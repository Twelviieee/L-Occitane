!function(e) {
    function t(t) {
        for (var n, r, o = t[0], l = t[1], c = t[2], h = 0, p = []; h < o.length; h++)
            r = o[h],
            s[r] && p.push(s[r][0]),
            s[r] = 0;
        for (n in l)
            Object.prototype.hasOwnProperty.call(l, n) && (e[n] = l[n]);
        for (u && u(t); p.length; )
            p.shift()();
        return a.push.apply(a, c || []),
        i()
    }
    function i() {
        for (var e, t = 0; t < a.length; t++) {
            for (var i = a[t], n = !0, r = 1; r < i.length; r++) {
                var l = i[r];
                0 !== s[l] && (n = !1)
            }
            n && (a.splice(t--, 1),
            e = o(o.s = i[0]))
        }
        return e
    }
    var n = {}
      , r = {
        0: 0
    }
      , s = {
        0: 0
    }
      , a = [];
    function o(t) {
        if (n[t])
            return n[t].exports;
        var i = n[t] = {
            i: t,
            l: !1,
            exports: {}
        };
        return e[t].call(i.exports, i, i.exports, o),
        i.l = !0,
        i.exports
    }
    o.e = function(e) {
        var t = [];
        r[e] ? t.push(r[e]) : 0 !== r[e] && {
            1: 1,
            2: 1,
            3: 1,
            4: 1,
            5: 1,
            6: 1
        }[e] && t.push(r[e] = new Promise(function(t, i) {
            for (var n = "css/" + ({
                1: "Choice",
                2: "Confirmation",
                3: "Debug",
                4: "Game",
                5: "Intro",
                6: "Seed"
            }[e] || e) + ".bundle.css", s = o.p + n, a = document.getElementsByTagName("link"), l = 0; l < a.length; l++) {
                var c = (u = a[l]).getAttribute("data-href") || u.getAttribute("href");
                if ("stylesheet" === u.rel && (c === n || c === s))
                    return t()
            }
            var h = document.getElementsByTagName("style");
            for (l = 0; l < h.length; l++) {
                var u;
                if ((c = (u = h[l]).getAttribute("data-href")) === n || c === s)
                    return t()
            }
            var p = document.createElement("link");
            p.rel = "stylesheet",
            p.type = "text/css",
            p.onload = t,
            p.onerror = function(t) {
                var n = t && t.target && t.target.src || s
                  , a = new Error("Loading CSS chunk " + e + " failed.\n(" + n + ")");
                a.code = "CSS_CHUNK_LOAD_FAILED",
                a.request = n,
                delete r[e],
                p.parentNode.removeChild(p),
                i(a)
            }
            ,
            p.href = s,
            document.getElementsByTagName("head")[0].appendChild(p)
        }
        ).then(function() {
            r[e] = 0
        }));
        var i = s[e];
        if (0 !== i)
            if (i)
                t.push(i[2]);
            else {
                var n = new Promise(function(t, n) {
                    i = s[e] = [t, n]
                }
                );
                t.push(i[2] = n);
                var a, l = document.createElement("script");
                l.charset = "utf-8",
                l.timeout = 120,
                o.nc && l.setAttribute("nonce", o.nc),
                l.src = function(e) {
                    return o.p + "js/" + ({
                        1: "Choice",
                        2: "Confirmation",
                        3: "Debug",
                        4: "Game",
                        5: "Intro",
                        6: "Seed"
                    }[e] || e) + ".bundle.js"
                }(e);
                var c = new Error;
                a = function(t) {
                    l.onerror = l.onload = null,
                    clearTimeout(h);
                    var i = s[e];
                    if (0 !== i) {
                        if (i) {
                            var n = t && ("load" === t.type ? "missing" : t.type)
                              , r = t && t.target && t.target.src;
                            c.message = "Loading chunk " + e + " failed.\n(" + n + ": " + r + ")",
                            c.name = "ChunkLoadError",
                            c.type = n,
                            c.request = r,
                            i[1](c)
                        }
                        s[e] = void 0
                    }
                }
                ;
                var h = setTimeout(function() {
                    a({
                        type: "timeout",
                        target: l
                    })
                }, 12e4);
                l.onerror = l.onload = a,
                document.head.appendChild(l)
            }
        return Promise.all(t)
    }
    ,
    o.m = e,
    o.c = n,
    o.d = function(e, t, i) {
        o.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: i
        })
    }
    ,
    o.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    o.t = function(e, t) {
        if (1 & t && (e = o(e)),
        8 & t)
            return e;
        if (4 & t && "object" == typeof e && e && e.__esModule)
            return e;
        var i = Object.create(null);
        if (o.r(i),
        Object.defineProperty(i, "default", {
            enumerable: !0,
            value: e
        }),
        2 & t && "string" != typeof e)
            for (var n in e)
                o.d(i, n, function(t) {
                    return e[t]
                }
                .bind(null, n));
        return i
    }
    ,
    o.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        }
        : function() {
            return e
        }
        ;
        return o.d(t, "a", t),
        t
    }
    ,
    o.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }
    ,
    o.p = "https://storage.googleapis.com/seeds-of-dreams-awards.appspot.com/assets/20200203_142321/",
    o.oe = function(e) {
        throw e
    }
    ;
    var l = window.webpackJsonp = window.webpackJsonp || []
      , c = l.push.bind(l);
    l.push = t,
    l = l.slice();
    for (var h = 0; h < l.length; h++)
        t(l[h]);
    var u = c;
    a.push([185, 7]),
    i()
}([function(e, t, i) {
    "use strict";
    function n() {}
    i.d(t, "W", function() {
        return Ht
    }),
    i.d(t, "X", function() {
        return cs
    }),
    i.d(t, "Q", function() {
        return ni
    }),
    i.d(t, "P", function() {
        return ps
    }),
    i.d(t, "x", function() {
        return fn
    }),
    i.d(t, "l", function() {
        return Cs
    }),
    i.d(t, "S", function() {
        return Wt
    }),
    i.d(t, "H", function() {
        return Jr
    }),
    i.d(t, "G", function() {
        return tl
    }),
    i.d(t, "d", function() {
        return Ol
    }),
    i.d(t, "c", function() {
        return Rl
    }),
    i.d(t, "p", function() {
        return sc
    }),
    i.d(t, "i", function() {
        return Vi
    }),
    i.d(t, "s", function() {
        return fs
    }),
    i.d(t, "q", function() {
        return ac
    }),
    i.d(t, "r", function() {
        return ds
    }),
    i.d(t, "o", function() {
        return oc
    }),
    i.d(t, "F", function() {
        return Mi
    }),
    i.d(t, "N", function() {
        return lc
    }),
    i.d(t, "w", function() {
        return ii
    }),
    i.d(t, "g", function() {
        return $t
    }),
    i.d(t, "f", function() {
        return uc
    }),
    i.d(t, "n", function() {
        return vi
    }),
    i.d(t, "V", function() {
        return qt
    }),
    i.d(t, "U", function() {
        return Ct
    }),
    i.d(t, "T", function() {
        return At
    }),
    i.d(t, "J", function() {
        return Pt
    }),
    i.d(t, "k", function() {
        return hi
    }),
    i.d(t, "I", function() {
        return Wi
    }),
    i.d(t, "M", function() {
        return Ya
    }),
    i.d(t, "R", function() {
        return hn
    }),
    i.d(t, "h", function() {
        return Li
    }),
    i.d(t, "e", function() {
        return h
    }),
    i.d(t, "m", function() {
        return m
    }),
    i.d(t, "D", function() {
        return b
    }),
    i.d(t, "E", function() {
        return x
    }),
    i.d(t, "a", function() {
        return w
    }),
    i.d(t, "z", function() {
        return T
    }),
    i.d(t, "O", function() {
        return ue
    }),
    i.d(t, "j", function() {
        return pe
    }),
    i.d(t, "y", function() {
        return de
    }),
    i.d(t, "A", function() {
        return fe
    }),
    i.d(t, "C", function() {
        return me
    }),
    i.d(t, "B", function() {
        return ge
    }),
    i.d(t, "t", function() {
        return ve
    }),
    i.d(t, "v", function() {
        return ye
    }),
    i.d(t, "u", function() {
        return be
    }),
    i.d(t, "b", function() {
        return Ie
    }),
    i.d(t, "L", function() {
        return Fe
    }),
    i.d(t, "K", function() {
        return Oe
    }),
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger && (Number.isInteger = function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }
    ),
    void 0 === Math.sign && (Math.sign = function(e) {
        return e < 0 ? -1 : e > 0 ? 1 : +e
    }
    ),
    "name"in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }),
    void 0 === Object.assign && (Object.assign = function(e) {
        if (null == e)
            throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), i = 1; i < arguments.length; i++) {
            var n = arguments[i];
            if (null != n)
                for (var r in n)
                    Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }
    ),
    Object.assign(n.prototype, {
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[e] && (i[e] = []),
            -1 === i[e].indexOf(t) && i[e].push(t)
        },
        hasEventListener: function(e, t) {
            if (void 0 === this._listeners)
                return !1;
            var i = this._listeners;
            return void 0 !== i[e] && -1 !== i[e].indexOf(t)
        },
        removeEventListener: function(e, t) {
            if (void 0 !== this._listeners) {
                var i = this._listeners[e];
                if (void 0 !== i) {
                    var n = i.indexOf(t);
                    -1 !== n && i.splice(n, 1)
                }
            }
        },
        dispatchEvent: function(e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var i = t.slice(0), n = 0, r = i.length; n < r; n++)
                        i[n].call(this, e)
                }
            }
        }
    });
    var r, s, a, o = 0, l = 1, c = 2, h = 0, u = 1, p = 2, d = 0, f = 1, m = 2, g = 0, v = 1, y = 2, b = 0, x = 1, w = 2, _ = 3, T = 4, M = 5, S = 100, A = 101, P = 102, C = 103, L = 104, k = 200, E = 201, I = 202, F = 203, O = 204, R = 205, z = 206, N = 207, D = 208, U = 209, B = 210, j = 0, V = 1, G = 2, X = 3, Y = 4, W = 5, q = 6, H = 7, Q = 0, J = 1, Z = 2, $ = 0, K = 1, ee = 2, te = 3, ie = 4, ne = 5, re = 301, se = 302, ae = 303, oe = 304, le = 305, ce = 306, he = 307, ue = 1e3, pe = 1001, de = 1002, fe = 1003, me = 1004, ge = 1005, ve = 1006, ye = 1007, be = 1008, xe = 1009, we = 1010, _e = 1011, Te = 1012, Me = 1013, Se = 1014, Ae = 1015, Pe = 1016, Ce = 1017, Le = 1018, ke = 1019, Ee = 1020, Ie = 1021, Fe = 1022, Oe = 1023, Re = 1024, ze = 1025, Ne = 1026, De = 1027, Ue = 1028, Be = 33776, je = 33777, Ve = 33778, Ge = 33779, Xe = 35840, Ye = 35841, We = 35842, qe = 35843, He = 36196, Qe = 37808, Je = 37809, Ze = 37810, $e = 37811, Ke = 37812, et = 37813, tt = 37814, it = 37815, nt = 37816, rt = 37817, st = 37818, at = 37819, ot = 37820, lt = 37821, ct = 2201, ht = 2400, ut = 0, pt = 1, dt = 2, ft = 3e3, mt = 3001, gt = 3007, vt = 3002, yt = 3004, bt = 3005, xt = 3006, wt = 3200, _t = 3201, Tt = 0, Mt = 1, St = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            for (var e = [], t = 0; t < 256; t++)
                e[t] = (t < 16 ? "0" : "") + t.toString(16);
            return function() {
                var t = 4294967295 * Math.random() | 0
                  , i = 4294967295 * Math.random() | 0
                  , n = 4294967295 * Math.random() | 0
                  , r = 4294967295 * Math.random() | 0;
                return (e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & i] + e[i >> 8 & 255] + "-" + e[i >> 16 & 15 | 64] + e[i >> 24 & 255] + "-" + e[63 & n | 128] + e[n >> 8 & 255] + "-" + e[n >> 16 & 255] + e[n >> 24 & 255] + e[255 & r] + e[r >> 8 & 255] + e[r >> 16 & 255] + e[r >> 24 & 255]).toUpperCase()
            }
        }(),
        clamp: function(e, t, i) {
            return Math.max(t, Math.min(i, e))
        },
        euclideanModulo: function(e, t) {
            return (e % t + t) % t
        },
        mapLinear: function(e, t, i, n, r) {
            return n + (e - t) * (r - n) / (i - t)
        },
        lerp: function(e, t, i) {
            return (1 - i) * e + i * t
        },
        smoothstep: function(e, t, i) {
            return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e)
        },
        smootherstep: function(e, t, i) {
            return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function(e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function(e) {
            return e * (.5 - Math.random())
        },
        degToRad: function(e) {
            return e * St.DEG2RAD
        },
        radToDeg: function(e) {
            return e * St.RAD2DEG
        },
        isPowerOfTwo: function(e) {
            return 0 == (e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function(e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
    };
    function At(e, t) {
        this.x = e || 0,
        this.y = t || 0
    }
    function Pt(e, t, i, n) {
        this._x = e || 0,
        this._y = t || 0,
        this._z = i || 0,
        this._w = void 0 !== n ? n : 1
    }
    function Ct(e, t, i) {
        this.x = e || 0,
        this.y = t || 0,
        this.z = i || 0
    }
    function Lt() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length
    }
    Object.defineProperties(At.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(e) {
                this.x = e
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(e) {
                this.y = e
            }
        }
    }),
    Object.assign(At.prototype, {
        isVector2: !0,
        set: function(e, t) {
            return this.x = e,
            this.y = t,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? this.addVectors(e, t) : (this.x += e.x,
            this.y += e.y,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? this.subVectors(e, t) : (this.x -= e.x,
            this.y -= e.y,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this
        },
        multiply: function(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this
        },
        divide: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        applyMatrix3: function(e) {
            var t = this.x
              , i = this.y
              , n = e.elements;
            return this.x = n[0] * t + n[3] * i + n[6],
            this.y = n[1] * t + n[4] * i + n[7],
            this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this
        },
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y
        },
        cross: function(e) {
            return this.x * e.y - this.y * e.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var e = Math.atan2(this.y, this.x);
            return e < 0 && (e += 2 * Math.PI),
            e
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x
              , i = this.y - e.y;
            return t * t + i * i
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e
        },
        fromBufferAttribute: function(e, t, i) {
            return this.x = e.getX(t),
            this.y = e.getY(t),
            this
        },
        rotateAround: function(e, t) {
            var i = Math.cos(t)
              , n = Math.sin(t)
              , r = this.x - e.x
              , s = this.y - e.y;
            return this.x = r * i - s * n + e.x,
            this.y = r * n + s * i + e.y,
            this
        }
    }),
    Object.assign(Pt, {
        slerp: function(e, t, i, n) {
            return i.copy(e).slerp(t, n)
        },
        slerpFlat: function(e, t, i, n, r, s, a) {
            var o = i[n + 0]
              , l = i[n + 1]
              , c = i[n + 2]
              , h = i[n + 3]
              , u = r[s + 0]
              , p = r[s + 1]
              , d = r[s + 2]
              , f = r[s + 3];
            if (h !== f || o !== u || l !== p || c !== d) {
                var m = 1 - a
                  , g = o * u + l * p + c * d + h * f
                  , v = g >= 0 ? 1 : -1
                  , y = 1 - g * g;
                if (y > Number.EPSILON) {
                    var b = Math.sqrt(y)
                      , x = Math.atan2(b, g * v);
                    m = Math.sin(m * x) / b,
                    a = Math.sin(a * x) / b
                }
                var w = a * v;
                if (o = o * m + u * w,
                l = l * m + p * w,
                c = c * m + d * w,
                h = h * m + f * w,
                m === 1 - a) {
                    var _ = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                    o *= _,
                    l *= _,
                    c *= _,
                    h *= _
                }
            }
            e[t] = o,
            e[t + 1] = l,
            e[t + 2] = c,
            e[t + 3] = h
        }
    }),
    Object.defineProperties(Pt.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e,
                this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(e) {
                this._w = e,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(Pt.prototype, {
        isQuaternion: !0,
        set: function(e, t, i, n) {
            return this._x = e,
            this._y = t,
            this._z = i,
            this._w = n,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        },
        copy: function(e) {
            return this._x = e.x,
            this._y = e.y,
            this._z = e.z,
            this._w = e.w,
            this.onChangeCallback(),
            this
        },
        setFromEuler: function(e, t) {
            if (!e || !e.isEuler)
                throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var i = e._x
              , n = e._y
              , r = e._z
              , s = e.order
              , a = Math.cos
              , o = Math.sin
              , l = a(i / 2)
              , c = a(n / 2)
              , h = a(r / 2)
              , u = o(i / 2)
              , p = o(n / 2)
              , d = o(r / 2);
            return "XYZ" === s ? (this._x = u * c * h + l * p * d,
            this._y = l * p * h - u * c * d,
            this._z = l * c * d + u * p * h,
            this._w = l * c * h - u * p * d) : "YXZ" === s ? (this._x = u * c * h + l * p * d,
            this._y = l * p * h - u * c * d,
            this._z = l * c * d - u * p * h,
            this._w = l * c * h + u * p * d) : "ZXY" === s ? (this._x = u * c * h - l * p * d,
            this._y = l * p * h + u * c * d,
            this._z = l * c * d + u * p * h,
            this._w = l * c * h - u * p * d) : "ZYX" === s ? (this._x = u * c * h - l * p * d,
            this._y = l * p * h + u * c * d,
            this._z = l * c * d - u * p * h,
            this._w = l * c * h + u * p * d) : "YZX" === s ? (this._x = u * c * h + l * p * d,
            this._y = l * p * h + u * c * d,
            this._z = l * c * d - u * p * h,
            this._w = l * c * h - u * p * d) : "XZY" === s && (this._x = u * c * h - l * p * d,
            this._y = l * p * h - u * c * d,
            this._z = l * c * d + u * p * h,
            this._w = l * c * h + u * p * d),
            !1 !== t && this.onChangeCallback(),
            this
        },
        setFromAxisAngle: function(e, t) {
            var i = t / 2
              , n = Math.sin(i);
            return this._x = e.x * n,
            this._y = e.y * n,
            this._z = e.z * n,
            this._w = Math.cos(i),
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(e) {
            var t, i = e.elements, n = i[0], r = i[4], s = i[8], a = i[1], o = i[5], l = i[9], c = i[2], h = i[6], u = i[10], p = n + o + u;
            return p > 0 ? (t = .5 / Math.sqrt(p + 1),
            this._w = .25 / t,
            this._x = (h - l) * t,
            this._y = (s - c) * t,
            this._z = (a - r) * t) : n > o && n > u ? (t = 2 * Math.sqrt(1 + n - o - u),
            this._w = (h - l) / t,
            this._x = .25 * t,
            this._y = (r + a) / t,
            this._z = (s + c) / t) : o > u ? (t = 2 * Math.sqrt(1 + o - n - u),
            this._w = (s - c) / t,
            this._x = (r + a) / t,
            this._y = .25 * t,
            this._z = (l + h) / t) : (t = 2 * Math.sqrt(1 + u - n - o),
            this._w = (a - r) / t,
            this._x = (s + c) / t,
            this._y = (l + h) / t,
            this._z = .25 * t),
            this.onChangeCallback(),
            this
        },
        setFromUnitVectors: function(e, t) {
            var i = e.dot(t) + 1;
            return i < 1e-6 ? (i = 0,
            Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
            this._y = e.x,
            this._z = 0,
            this._w = i) : (this._x = 0,
            this._y = -e.z,
            this._z = e.y,
            this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
            this._y = e.z * t.x - e.x * t.z,
            this._z = e.x * t.y - e.y * t.x,
            this._w = i),
            this.normalize()
        },
        angleTo: function(e) {
            return 2 * Math.acos(Math.abs(St.clamp(this.dot(e), -1, 1)))
        },
        rotateTowards: function(e, t) {
            var i = this.angleTo(e);
            if (0 === i)
                return this;
            var n = Math.min(1, t / i);
            return this.slerp(e, n),
            this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this.onChangeCallback(),
            this
        },
        dot: function(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var e = this.length();
            return 0 === e ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (e = 1 / e,
            this._x = this._x * e,
            this._y = this._y * e,
            this._z = this._z * e,
            this._w = this._w * e),
            this.onChangeCallback(),
            this
        },
        multiply: function(e, t) {
            return void 0 !== t ? this.multiplyQuaternions(e, t) : this.multiplyQuaternions(this, e)
        },
        premultiply: function(e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function(e, t) {
            var i = e._x
              , n = e._y
              , r = e._z
              , s = e._w
              , a = t._x
              , o = t._y
              , l = t._z
              , c = t._w;
            return this._x = i * c + s * a + n * l - r * o,
            this._y = n * c + s * o + r * a - i * l,
            this._z = r * c + s * l + i * o - n * a,
            this._w = s * c - i * a - n * o - r * l,
            this.onChangeCallback(),
            this
        },
        slerp: function(e, t) {
            if (0 === t)
                return this;
            if (1 === t)
                return this.copy(e);
            var i = this._x
              , n = this._y
              , r = this._z
              , s = this._w
              , a = s * e._w + i * e._x + n * e._y + r * e._z;
            if (a < 0 ? (this._w = -e._w,
            this._x = -e._x,
            this._y = -e._y,
            this._z = -e._z,
            a = -a) : this.copy(e),
            a >= 1)
                return this._w = s,
                this._x = i,
                this._y = n,
                this._z = r,
                this;
            var o = 1 - a * a;
            if (o <= Number.EPSILON) {
                var l = 1 - t;
                return this._w = l * s + t * this._w,
                this._x = l * i + t * this._x,
                this._y = l * n + t * this._y,
                this._z = l * r + t * this._z,
                this.normalize()
            }
            var c = Math.sqrt(o)
              , h = Math.atan2(c, a)
              , u = Math.sin((1 - t) * h) / c
              , p = Math.sin(t * h) / c;
            return this._w = s * u + this._w * p,
            this._x = i * u + this._x * p,
            this._y = n * u + this._y * p,
            this._z = r * u + this._z * p,
            this.onChangeCallback(),
            this
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this._x = e[t],
            this._y = e[t + 1],
            this._z = e[t + 2],
            this._w = e[t + 3],
            this.onChangeCallback(),
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._w,
            e
        },
        onChange: function(e) {
            return this.onChangeCallback = e,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(Ct.prototype, {
        isVector3: !0,
        set: function(e, t, i) {
            return this.x = e,
            this.y = t,
            this.z = i,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setZ: function(e) {
            return this.z = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? this.addVectors(e, t) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? this.subVectors(e, t) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this
        },
        multiply: function(e, t) {
            return void 0 !== t ? this.multiplyVectors(e, t) : (this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this)
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this
        },
        multiplyVectors: function(e, t) {
            return this.x = e.x * t.x,
            this.y = e.y * t.y,
            this.z = e.z * t.z,
            this
        },
        applyEuler: (s = new Pt,
        function(e) {
            return !e || e.isEuler,
            this.applyQuaternion(s.setFromEuler(e))
        }
        ),
        applyAxisAngle: function() {
            var e = new Pt;
            return function(t, i) {
                return this.applyQuaternion(e.setFromAxisAngle(t, i))
            }
        }(),
        applyMatrix3: function(e) {
            var t = this.x
              , i = this.y
              , n = this.z
              , r = e.elements;
            return this.x = r[0] * t + r[3] * i + r[6] * n,
            this.y = r[1] * t + r[4] * i + r[7] * n,
            this.z = r[2] * t + r[5] * i + r[8] * n,
            this
        },
        applyMatrix4: function(e) {
            var t = this.x
              , i = this.y
              , n = this.z
              , r = e.elements
              , s = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
            return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * s,
            this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * s,
            this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * s,
            this
        },
        applyQuaternion: function(e) {
            var t = this.x
              , i = this.y
              , n = this.z
              , r = e.x
              , s = e.y
              , a = e.z
              , o = e.w
              , l = o * t + s * n - a * i
              , c = o * i + a * t - r * n
              , h = o * n + r * i - s * t
              , u = -r * t - s * i - a * n;
            return this.x = l * o + u * -r + c * -a - h * -s,
            this.y = c * o + u * -s + h * -r - l * -a,
            this.z = h * o + u * -a + l * -s - c * -r,
            this
        },
        project: function(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        },
        unproject: function(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        },
        transformDirection: function(e) {
            var t = this.x
              , i = this.y
              , n = this.z
              , r = e.elements;
            return this.x = r[0] * t + r[4] * i + r[8] * n,
            this.y = r[1] * t + r[5] * i + r[9] * n,
            this.z = r[2] * t + r[6] * i + r[10] * n,
            this.normalize()
        },
        divide: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this.z /= e.z,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this
        },
        clampScalar: function(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this.z = Math.max(e, Math.min(t, this.z)),
            this
        },
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        cross: function(e, t) {
            return void 0 !== t ? this.crossVectors(e, t) : this.crossVectors(this, e)
        },
        crossVectors: function(e, t) {
            var i = e.x
              , n = e.y
              , r = e.z
              , s = t.x
              , a = t.y
              , o = t.z;
            return this.x = n * o - r * a,
            this.y = r * s - i * o,
            this.z = i * a - n * s,
            this
        },
        projectOnVector: function(e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t)
        },
        projectOnPlane: (r = new Ct,
        function(e) {
            return r.copy(this).projectOnVector(e),
            this.sub(r)
        }
        ),
        reflect: function() {
            var e = new Ct;
            return function(t) {
                return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
            }
        }(),
        angleTo: function(e) {
            var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
            return Math.acos(St.clamp(t, -1, 1))
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x
              , i = this.y - e.y
              , n = this.z - e.z;
            return t * t + i * i + n * n
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        },
        setFromSphericalCoords: function(e, t, i) {
            var n = Math.sin(t) * e;
            return this.x = n * Math.sin(i),
            this.y = Math.cos(t) * e,
            this.z = n * Math.cos(i),
            this
        },
        setFromCylindrical: function(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        },
        setFromCylindricalCoords: function(e, t, i) {
            return this.x = e * Math.sin(t),
            this.y = i,
            this.z = e * Math.cos(t),
            this
        },
        setFromMatrixPosition: function(e) {
            var t = e.elements;
            return this.x = t[12],
            this.y = t[13],
            this.z = t[14],
            this
        },
        setFromMatrixScale: function(e) {
            var t = this.setFromMatrixColumn(e, 0).length()
              , i = this.setFromMatrixColumn(e, 1).length()
              , n = this.setFromMatrixColumn(e, 2).length();
            return this.x = t,
            this.y = i,
            this.z = n,
            this
        },
        setFromMatrixColumn: function(e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e
        },
        fromBufferAttribute: function(e, t, i) {
            return this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this
        }
    }),
    Object.assign(Lt.prototype, {
        isMatrix3: !0,
        set: function(e, t, i, n, r, s, a, o, l) {
            var c = this.elements;
            return c[0] = e,
            c[1] = n,
            c[2] = a,
            c[3] = t,
            c[4] = r,
            c[5] = o,
            c[6] = i,
            c[7] = s,
            c[8] = l,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements
              , i = e.elements;
            return t[0] = i[0],
            t[1] = i[1],
            t[2] = i[2],
            t[3] = i[3],
            t[4] = i[4],
            t[5] = i[5],
            t[6] = i[6],
            t[7] = i[7],
            t[8] = i[8],
            this
        },
        setFromMatrix4: function(e) {
            var t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
        },
        applyToBufferAttribute: function() {
            var e = new Ct;
            return function(t) {
                for (var i = 0, n = t.count; i < n; i++)
                    e.x = t.getX(i),
                    e.y = t.getY(i),
                    e.z = t.getZ(i),
                    e.applyMatrix3(this),
                    t.setXYZ(i, e.x, e.y, e.z);
                return t
            }
        }(),
        multiply: function(e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var i = e.elements
              , n = t.elements
              , r = this.elements
              , s = i[0]
              , a = i[3]
              , o = i[6]
              , l = i[1]
              , c = i[4]
              , h = i[7]
              , u = i[2]
              , p = i[5]
              , d = i[8]
              , f = n[0]
              , m = n[3]
              , g = n[6]
              , v = n[1]
              , y = n[4]
              , b = n[7]
              , x = n[2]
              , w = n[5]
              , _ = n[8];
            return r[0] = s * f + a * v + o * x,
            r[3] = s * m + a * y + o * w,
            r[6] = s * g + a * b + o * _,
            r[1] = l * f + c * v + h * x,
            r[4] = l * m + c * y + h * w,
            r[7] = l * g + c * b + h * _,
            r[2] = u * f + p * v + d * x,
            r[5] = u * m + p * y + d * w,
            r[8] = u * g + p * b + d * _,
            this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[3] *= e,
            t[6] *= e,
            t[1] *= e,
            t[4] *= e,
            t[7] *= e,
            t[2] *= e,
            t[5] *= e,
            t[8] *= e,
            this
        },
        determinant: function() {
            var e = this.elements
              , t = e[0]
              , i = e[1]
              , n = e[2]
              , r = e[3]
              , s = e[4]
              , a = e[5]
              , o = e[6]
              , l = e[7]
              , c = e[8];
            return t * s * c - t * a * l - i * r * c + i * a * o + n * r * l - n * s * o
        },
        getInverse: function(e, t) {
            e && e.isMatrix4;
            var i = e.elements
              , n = this.elements
              , r = i[0]
              , s = i[1]
              , a = i[2]
              , o = i[3]
              , l = i[4]
              , c = i[5]
              , h = i[6]
              , u = i[7]
              , p = i[8]
              , d = p * l - c * u
              , f = c * h - p * o
              , m = u * o - l * h
              , g = r * d + s * f + a * m;
            if (0 === g) {
                if (!0 === t)
                    throw new Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return this.identity()
            }
            var v = 1 / g;
            return n[0] = d * v,
            n[1] = (a * u - p * s) * v,
            n[2] = (c * s - a * l) * v,
            n[3] = f * v,
            n[4] = (p * r - a * h) * v,
            n[5] = (a * o - c * r) * v,
            n[6] = m * v,
            n[7] = (s * h - u * r) * v,
            n[8] = (l * r - s * o) * v,
            this
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1],
            t[1] = t[3],
            t[3] = e,
            e = t[2],
            t[2] = t[6],
            t[6] = e,
            e = t[5],
            t[5] = t[7],
            t[7] = e,
            this
        },
        getNormalMatrix: function(e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function(e) {
            var t = this.elements;
            return e[0] = t[0],
            e[1] = t[3],
            e[2] = t[6],
            e[3] = t[1],
            e[4] = t[4],
            e[5] = t[7],
            e[6] = t[2],
            e[7] = t[5],
            e[8] = t[8],
            this
        },
        setUvTransform: function(e, t, i, n, r, s, a) {
            var o = Math.cos(r)
              , l = Math.sin(r);
            this.set(i * o, i * l, -i * (o * s + l * a) + s + e, -n * l, n * o, -n * (-l * s + o * a) + a + t, 0, 0, 1)
        },
        scale: function(e, t) {
            var i = this.elements;
            return i[0] *= e,
            i[3] *= e,
            i[6] *= e,
            i[1] *= t,
            i[4] *= t,
            i[7] *= t,
            this
        },
        rotate: function(e) {
            var t = Math.cos(e)
              , i = Math.sin(e)
              , n = this.elements
              , r = n[0]
              , s = n[3]
              , a = n[6]
              , o = n[1]
              , l = n[4]
              , c = n[7];
            return n[0] = t * r + i * o,
            n[3] = t * s + i * l,
            n[6] = t * a + i * c,
            n[1] = -i * r + t * o,
            n[4] = -i * s + t * l,
            n[7] = -i * a + t * c,
            this
        },
        translate: function(e, t) {
            var i = this.elements;
            return i[0] += e * i[2],
            i[3] += e * i[5],
            i[6] += e * i[8],
            i[1] += t * i[2],
            i[4] += t * i[5],
            i[7] += t * i[8],
            this
        },
        equals: function(e) {
            for (var t = this.elements, i = e.elements, n = 0; n < 9; n++)
                if (t[n] !== i[n])
                    return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; i < 9; i++)
                this.elements[i] = e[i + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []),
            void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0],
            e[t + 1] = i[1],
            e[t + 2] = i[2],
            e[t + 3] = i[3],
            e[t + 4] = i[4],
            e[t + 5] = i[5],
            e[t + 6] = i[6],
            e[t + 7] = i[7],
            e[t + 8] = i[8],
            e
        }
    });
    var kt, Et, It, Ft, Ot, Rt, zt, Nt, Dt, Ut, Bt, jt, Vt, Gt, Xt = {
        getDataURL: function(e) {
            var t;
            if ("undefined" == typeof HTMLCanvasElement)
                return e.src;
            if (e instanceof HTMLCanvasElement)
                t = e;
            else {
                void 0 === a && (a = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                a.width = e.width,
                a.height = e.height;
                var i = a.getContext("2d");
                e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
                t = a
            }
            return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
        }
    }, Yt = 0;
    function Wt(e, t, i, n, r, s, a, o, l, c) {
        Object.defineProperty(this, "id", {
            value: Yt++
        }),
        this.uuid = St.generateUUID(),
        this.name = "",
        this.image = void 0 !== e ? e : Wt.DEFAULT_IMAGE,
        this.mipmaps = [],
        this.mapping = void 0 !== t ? t : Wt.DEFAULT_MAPPING,
        this.wrapS = void 0 !== i ? i : pe,
        this.wrapT = void 0 !== n ? n : pe,
        this.magFilter = void 0 !== r ? r : ve,
        this.minFilter = void 0 !== s ? s : be,
        this.anisotropy = void 0 !== l ? l : 1,
        this.format = void 0 !== a ? a : Oe,
        this.type = void 0 !== o ? o : xe,
        this.offset = new At(0,0),
        this.repeat = new At(1,1),
        this.center = new At(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Lt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = void 0 !== c ? c : ft,
        this.version = 0,
        this.onUpdate = null
    }
    function qt(e, t, i, n) {
        this.x = e || 0,
        this.y = t || 0,
        this.z = i || 0,
        this.w = void 0 !== n ? n : 1
    }
    function Ht(e, t, i) {
        this.width = e,
        this.height = t,
        this.scissor = new qt(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new qt(0,0,e,t),
        i = i || {},
        this.texture = new Wt(void 0,void 0,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),
        this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps,
        this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : ve,
        this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer,
        this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer,
        this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
    }
    function Qt(e, t, i) {
        Ht.call(this, e, t, i),
        this.samples = 4
    }
    function Jt(e, t, i) {
        Ht.call(this, e, t, i)
    }
    function Zt(e, t, i, n, r, s, a, o, l, c, h, u) {
        Wt.call(this, null, s, a, o, l, c, n, r, h, u),
        this.image = {
            data: e,
            width: t,
            height: i
        },
        this.magFilter = void 0 !== l ? l : fe,
        this.minFilter = void 0 !== c ? c : fe,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
    function $t(e, t) {
        this.min = void 0 !== e ? e : new Ct(1 / 0,1 / 0,1 / 0),
        this.max = void 0 !== t ? t : new Ct(-1 / 0,-1 / 0,-1 / 0)
    }
    function Kt(e, t) {
        this.center = void 0 !== e ? e : new Ct,
        this.radius = void 0 !== t ? t : 0
    }
    function ei(e, t) {
        this.normal = void 0 !== e ? e : new Ct(1,0,0),
        this.constant = void 0 !== t ? t : 0
    }
    function ti(e, t, i, n, r, s) {
        this.planes = [void 0 !== e ? e : new ei, void 0 !== t ? t : new ei, void 0 !== i ? i : new ei, void 0 !== n ? n : new ei, void 0 !== r ? r : new ei, void 0 !== s ? s : new ei]
    }
    function ii() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length
    }
    Wt.DEFAULT_IMAGE = void 0,
    Wt.DEFAULT_MAPPING = 300,
    Wt.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Wt,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.name = e.name,
            this.image = e.image,
            this.mipmaps = e.mipmaps.slice(0),
            this.mapping = e.mapping,
            this.wrapS = e.wrapS,
            this.wrapT = e.wrapT,
            this.magFilter = e.magFilter,
            this.minFilter = e.minFilter,
            this.anisotropy = e.anisotropy,
            this.format = e.format,
            this.type = e.type,
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            this.rotation = e.rotation,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrix.copy(e.matrix),
            this.generateMipmaps = e.generateMipmaps,
            this.premultiplyAlpha = e.premultiplyAlpha,
            this.flipY = e.flipY,
            this.unpackAlignment = e.unpackAlignment,
            this.encoding = e.encoding,
            this
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid])
                return e.textures[this.uuid];
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var n = this.image;
                if (void 0 === n.uuid && (n.uuid = St.generateUUID()),
                !t && void 0 === e.images[n.uuid]) {
                    var r;
                    if (Array.isArray(n)) {
                        r = [];
                        for (var s = 0, a = n.length; s < a; s++)
                            r.push(Xt.getDataURL(n[s]))
                    } else
                        r = Xt.getDataURL(n);
                    e.images[n.uuid] = {
                        uuid: n.uuid,
                        url: r
                    }
                }
                i.image = n.uuid
            }
            return t || (e.textures[this.uuid] = i),
            i
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(e) {
            if (300 !== this.mapping)
                return e;
            if (e.applyMatrix3(this.matrix),
            e.x < 0 || e.x > 1)
                switch (this.wrapS) {
                case ue:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case pe:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case de:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
            if (e.y < 0 || e.y > 1)
                switch (this.wrapT) {
                case ue:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case pe:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case de:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
            return this.flipY && (e.y = 1 - e.y),
            e
        }
    }),
    Object.defineProperty(Wt.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(qt.prototype, {
        isVector4: !0,
        set: function(e, t, i, n) {
            return this.x = e,
            this.y = t,
            this.z = i,
            this.w = n,
            this
        },
        setScalar: function(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this.w = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setZ: function(e) {
            return this.z = e,
            this
        },
        setW: function(e) {
            return this.w = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this.w = void 0 !== e.w ? e.w : 1,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? this.addVectors(e, t) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this.w += e.w,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this.w += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this.w = e.w + t.w,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this.w += e.w * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? this.subVectors(e, t) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this.w -= e.w,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this.w -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this.w = e.w - t.w,
            this
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this.w *= e,
            this
        },
        applyMatrix4: function(e) {
            var t = this.x
              , i = this.y
              , n = this.z
              , r = this.w
              , s = e.elements;
            return this.x = s[0] * t + s[4] * i + s[8] * n + s[12] * r,
            this.y = s[1] * t + s[5] * i + s[9] * n + s[13] * r,
            this.z = s[2] * t + s[6] * i + s[10] * n + s[14] * r,
            this.w = s[3] * t + s[7] * i + s[11] * n + s[15] * r,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function(e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = e.x / t,
            this.y = e.y / t,
            this.z = e.z / t),
            this
        },
        setAxisAngleFromRotationMatrix: function(e) {
            var t, i, n, r, s = e.elements, a = s[0], o = s[4], l = s[8], c = s[1], h = s[5], u = s[9], p = s[2], d = s[6], f = s[10];
            if (Math.abs(o - c) < .01 && Math.abs(l - p) < .01 && Math.abs(u - d) < .01) {
                if (Math.abs(o + c) < .1 && Math.abs(l + p) < .1 && Math.abs(u + d) < .1 && Math.abs(a + h + f - 3) < .1)
                    return this.set(1, 0, 0, 0),
                    this;
                t = Math.PI;
                var m = (a + 1) / 2
                  , g = (h + 1) / 2
                  , v = (f + 1) / 2
                  , y = (o + c) / 4
                  , b = (l + p) / 4
                  , x = (u + d) / 4;
                return m > g && m > v ? m < .01 ? (i = 0,
                n = .707106781,
                r = .707106781) : (n = y / (i = Math.sqrt(m)),
                r = b / i) : g > v ? g < .01 ? (i = .707106781,
                n = 0,
                r = .707106781) : (i = y / (n = Math.sqrt(g)),
                r = x / n) : v < .01 ? (i = .707106781,
                n = .707106781,
                r = 0) : (i = b / (r = Math.sqrt(v)),
                n = x / r),
                this.set(i, n, r, t),
                this
            }
            var w = Math.sqrt((d - u) * (d - u) + (l - p) * (l - p) + (c - o) * (c - o));
            return Math.abs(w) < .001 && (w = 1),
            this.x = (d - u) / w,
            this.y = (l - p) / w,
            this.z = (c - o) / w,
            this.w = Math.acos((a + h + f - 1) / 2),
            this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this.w = Math.min(this.w, e.w),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this.w = Math.max(this.w, e.w),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this.w = Math.max(e.w, Math.min(t.w, this.w)),
            this
        },
        clampScalar: function(e, t) {
            return void 0 === kt && (kt = new qt,
            Et = new qt),
            kt.set(e, e, e, e),
            Et.set(t, t, t, t),
            this.clamp(kt, Et)
        },
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this.w += (e.w - this.w) * t,
            this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this.w = e[t + 3],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e[t + 3] = this.w,
            e
        },
        fromBufferAttribute: function(e, t, i) {
            return this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this.w = e.getW(t),
            this
        }
    }),
    Ht.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Ht,
        isWebGLRenderTarget: !0,
        setSize: function(e, t) {
            this.width === e && this.height === t || (this.width = e,
            this.height = t,
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.width = e.width,
            this.height = e.height,
            this.viewport.copy(e.viewport),
            this.texture = e.texture.clone(),
            this.depthBuffer = e.depthBuffer,
            this.stencilBuffer = e.stencilBuffer,
            this.depthTexture = e.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Qt.prototype = Object.assign(Object.create(Ht.prototype), {
        constructor: Qt,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(e) {
            return Ht.prototype.copy.call(this, e),
            this.samples = e.samples,
            this
        }
    }),
    Jt.prototype = Object.create(Ht.prototype),
    Jt.prototype.constructor = Jt,
    Jt.prototype.isWebGLRenderTargetCube = !0,
    Zt.prototype = Object.create(Wt.prototype),
    Zt.prototype.constructor = Zt,
    Zt.prototype.isDataTexture = !0,
    Object.assign($t.prototype, {
        isBox3: !0,
        set: function(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        },
        setFromArray: function(e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0, o = 0, l = e.length; o < l; o += 3) {
                var c = e[o]
                  , h = e[o + 1]
                  , u = e[o + 2];
                c < t && (t = c),
                h < i && (i = h),
                u < n && (n = u),
                c > r && (r = c),
                h > s && (s = h),
                u > a && (a = u)
            }
            return this.min.set(t, i, n),
            this.max.set(r, s, a),
            this
        },
        setFromBufferAttribute: function(e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0, o = 0, l = e.count; o < l; o++) {
                var c = e.getX(o)
                  , h = e.getY(o)
                  , u = e.getZ(o);
                c < t && (t = c),
                h < i && (i = h),
                u < n && (n = u),
                c > r && (r = c),
                h > s && (s = h),
                u > a && (a = u)
            }
            return this.min.set(t, i, n),
            this.max.set(r, s, a),
            this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++)
                this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new Ct;
            return function(t, i) {
                var n = e.copy(i).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                this.max.copy(t).add(n),
                this
            }
        }(),
        setFromObject: function(e) {
            return this.makeEmpty(),
            this.expandByObject(e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(e) {
            return void 0 === e && (e = new Ct),
            this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (e = new Ct),
            this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        },
        expandByVector: function(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        },
        expandByObject: function() {
            var e, t, i, n = new Ct;
            function r(r) {
                var s = r.geometry;
                if (void 0 !== s)
                    if (s.isGeometry) {
                        var a = s.vertices;
                        for (t = 0,
                        i = a.length; t < i; t++)
                            n.copy(a[t]),
                            n.applyMatrix4(r.matrixWorld),
                            e.expandByPoint(n)
                    } else if (s.isBufferGeometry) {
                        var o = s.attributes.position;
                        if (void 0 !== o)
                            for (t = 0,
                            i = o.count; t < i; t++)
                                n.fromBufferAttribute(o, t).applyMatrix4(r.matrixWorld),
                                e.expandByPoint(n)
                    }
            }
            return function(t) {
                return e = this,
                t.updateMatrixWorld(!0),
                t.traverse(r),
                this
            }
        }(),
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function(e, t) {
            return void 0 === t && (t = new Ct),
            t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        intersectsSphere: (Ft = new Ct,
        function(e) {
            return this.clampPoint(e.center, Ft),
            Ft.distanceToSquared(e.center) <= e.radius * e.radius
        }
        ),
        intersectsPlane: function(e) {
            var t, i;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
            i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
            i = e.normal.x * this.min.x),
            e.normal.y > 0 ? (t += e.normal.y * this.min.y,
            i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
            i += e.normal.y * this.min.y),
            e.normal.z > 0 ? (t += e.normal.z * this.min.z,
            i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
            i += e.normal.z * this.min.z),
            t <= -e.constant && i >= -e.constant
        },
        intersectsTriangle: function() {
            var e = new Ct
              , t = new Ct
              , i = new Ct
              , n = new Ct
              , r = new Ct
              , s = new Ct
              , a = new Ct
              , o = new Ct
              , l = new Ct
              , c = new Ct;
            function h(n) {
                var r, s;
                for (r = 0,
                s = n.length - 3; r <= s; r += 3) {
                    a.fromArray(n, r);
                    var o = l.x * Math.abs(a.x) + l.y * Math.abs(a.y) + l.z * Math.abs(a.z)
                      , c = e.dot(a)
                      , h = t.dot(a)
                      , u = i.dot(a);
                    if (Math.max(-Math.max(c, h, u), Math.min(c, h, u)) > o)
                        return !1
                }
                return !0
            }
            return function(a) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(o),
                l.subVectors(this.max, o),
                e.subVectors(a.a, o),
                t.subVectors(a.b, o),
                i.subVectors(a.c, o),
                n.subVectors(t, e),
                r.subVectors(i, t),
                s.subVectors(e, i);
                var u = [0, -n.z, n.y, 0, -r.z, r.y, 0, -s.z, s.y, n.z, 0, -n.x, r.z, 0, -r.x, s.z, 0, -s.x, -n.y, n.x, 0, -r.y, r.x, 0, -s.y, s.x, 0];
                return !!h(u) && (!!h(u = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (c.crossVectors(n, r),
                h(u = [c.x, c.y, c.z])))
            }
        }(),
        clampPoint: function(e, t) {
            return void 0 === t && (t = new Ct),
            t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new Ct;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        getBoundingSphere: function() {
            var e = new Ct;
            return function(t) {
                return this.getCenter(t.center),
                t.radius = .5 * this.getSize(e).length(),
                t
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
        },
        union: function(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        },
        applyMatrix4: (It = [new Ct, new Ct, new Ct, new Ct, new Ct, new Ct, new Ct, new Ct],
        function(e) {
            return this.isEmpty() ? this : (It[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            It[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            It[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            It[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            It[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            It[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            It[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            It[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints(It),
            this)
        }
        ),
        translate: function(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }),
    Object.assign(Kt.prototype, {
        set: function(e, t) {
            return this.center.copy(e),
            this.radius = t,
            this
        },
        setFromPoints: (Ot = new $t,
        function(e, t) {
            var i = this.center;
            void 0 !== t ? i.copy(t) : Ot.setFromPoints(e).getCenter(i);
            for (var n = 0, r = 0, s = e.length; r < s; r++)
                n = Math.max(n, i.distanceToSquared(e[r]));
            return this.radius = Math.sqrt(n),
            this
        }
        ),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.center.copy(e.center),
            this.radius = e.radius,
            this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function(e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(e, t) {
            var i = this.center.distanceToSquared(e);
            return void 0 === t && (t = new Ct),
            t.copy(e),
            i > this.radius * this.radius && (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
            t
        },
        getBoundingBox: function(e) {
            return void 0 === e && (e = new $t),
            e.set(this.center, this.center),
            e.expandByScalar(this.radius),
            e
        },
        applyMatrix4: function(e) {
            return this.center.applyMatrix4(e),
            this.radius = this.radius * e.getMaxScaleOnAxis(),
            this
        },
        translate: function(e) {
            return this.center.add(e),
            this
        },
        equals: function(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    }),
    Object.assign(ei.prototype, {
        set: function(e, t) {
            return this.normal.copy(e),
            this.constant = t,
            this
        },
        setComponents: function(e, t, i, n) {
            return this.normal.set(e, t, i),
            this.constant = n,
            this
        },
        setFromNormalAndCoplanarPoint: function(e, t) {
            return this.normal.copy(e),
            this.constant = -t.dot(this.normal),
            this
        },
        setFromCoplanarPoints: function() {
            var e = new Ct
              , t = new Ct;
            return function(i, n, r) {
                var s = e.subVectors(r, n).cross(t.subVectors(i, n)).normalize();
                return this.setFromNormalAndCoplanarPoint(s, i),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.normal.copy(e.normal),
            this.constant = e.constant,
            this
        },
        normalize: function() {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e),
            this.constant *= e,
            this
        },
        negate: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        },
        distanceToPoint: function(e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function(e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function(e, t) {
            return void 0 === t && (t = new Ct),
            t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        },
        intersectLine: function() {
            var e = new Ct;
            return function(t, i) {
                void 0 === i && (i = new Ct);
                var n = t.delta(e)
                  , r = this.normal.dot(n);
                if (0 === r)
                    return 0 === this.distanceToPoint(t.start) ? i.copy(t.start) : void 0;
                var s = -(t.start.dot(this.normal) + this.constant) / r;
                return s < 0 || s > 1 ? void 0 : i.copy(n).multiplyScalar(s).add(t.start)
            }
        }(),
        intersectsLine: function(e) {
            var t = this.distanceToPoint(e.start)
              , i = this.distanceToPoint(e.end);
            return t < 0 && i > 0 || i < 0 && t > 0
        },
        intersectsBox: function(e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function(e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function(e) {
            return void 0 === e && (e = new Ct),
            e.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var e = new Ct
              , t = new Lt;
            return function(i, n) {
                var r = n || t.getNormalMatrix(i)
                  , s = this.coplanarPoint(e).applyMatrix4(i)
                  , a = this.normal.applyMatrix3(r).normalize();
                return this.constant = -s.dot(a),
                this
            }
        }(),
        translate: function(e) {
            return this.constant -= e.dot(this.normal),
            this
        },
        equals: function(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    }),
    Object.assign(ti.prototype, {
        set: function(e, t, i, n, r, s) {
            var a = this.planes;
            return a[0].copy(e),
            a[1].copy(t),
            a[2].copy(i),
            a[3].copy(n),
            a[4].copy(r),
            a[5].copy(s),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            for (var t = this.planes, i = 0; i < 6; i++)
                t[i].copy(e.planes[i]);
            return this
        },
        setFromMatrix: function(e) {
            var t = this.planes
              , i = e.elements
              , n = i[0]
              , r = i[1]
              , s = i[2]
              , a = i[3]
              , o = i[4]
              , l = i[5]
              , c = i[6]
              , h = i[7]
              , u = i[8]
              , p = i[9]
              , d = i[10]
              , f = i[11]
              , m = i[12]
              , g = i[13]
              , v = i[14]
              , y = i[15];
            return t[0].setComponents(a - n, h - o, f - u, y - m).normalize(),
            t[1].setComponents(a + n, h + o, f + u, y + m).normalize(),
            t[2].setComponents(a + r, h + l, f + p, y + g).normalize(),
            t[3].setComponents(a - r, h - l, f - p, y - g).normalize(),
            t[4].setComponents(a - s, h - c, f - d, y - v).normalize(),
            t[5].setComponents(a + s, h + c, f + d, y + v).normalize(),
            this
        },
        intersectsObject: (zt = new Kt,
        function(e) {
            var t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(),
            zt.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(zt)
        }
        ),
        intersectsSprite: function() {
            var e = new Kt;
            return function(t) {
                return e.center.set(0, 0, 0),
                e.radius = .7071067811865476,
                e.applyMatrix4(t.matrixWorld),
                this.intersectsSphere(e)
            }
        }(),
        intersectsSphere: function(e) {
            for (var t = this.planes, i = e.center, n = -e.radius, r = 0; r < 6; r++) {
                if (t[r].distanceToPoint(i) < n)
                    return !1
            }
            return !0
        },
        intersectsBox: (Rt = new Ct,
        function(e) {
            for (var t = this.planes, i = 0; i < 6; i++) {
                var n = t[i];
                if (Rt.x = n.normal.x > 0 ? e.max.x : e.min.x,
                Rt.y = n.normal.y > 0 ? e.max.y : e.min.y,
                Rt.z = n.normal.z > 0 ? e.max.z : e.min.z,
                n.distanceToPoint(Rt) < 0)
                    return !1
            }
            return !0
        }
        ),
        containsPoint: function(e) {
            for (var t = this.planes, i = 0; i < 6; i++)
                if (t[i].distanceToPoint(e) < 0)
                    return !1;
            return !0
        }
    }),
    Object.assign(ii.prototype, {
        isMatrix4: !0,
        set: function(e, t, i, n, r, s, a, o, l, c, h, u, p, d, f, m) {
            var g = this.elements;
            return g[0] = e,
            g[4] = t,
            g[8] = i,
            g[12] = n,
            g[1] = r,
            g[5] = s,
            g[9] = a,
            g[13] = o,
            g[2] = l,
            g[6] = c,
            g[10] = h,
            g[14] = u,
            g[3] = p,
            g[7] = d,
            g[11] = f,
            g[15] = m,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new ii).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements
              , i = e.elements;
            return t[0] = i[0],
            t[1] = i[1],
            t[2] = i[2],
            t[3] = i[3],
            t[4] = i[4],
            t[5] = i[5],
            t[6] = i[6],
            t[7] = i[7],
            t[8] = i[8],
            t[9] = i[9],
            t[10] = i[10],
            t[11] = i[11],
            t[12] = i[12],
            t[13] = i[13],
            t[14] = i[14],
            t[15] = i[15],
            this
        },
        copyPosition: function(e) {
            var t = this.elements
              , i = e.elements;
            return t[12] = i[12],
            t[13] = i[13],
            t[14] = i[14],
            this
        },
        extractBasis: function(e, t, i) {
            return e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            i.setFromMatrixColumn(this, 2),
            this
        },
        makeBasis: function(e, t, i) {
            return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
            this
        },
        extractRotation: function() {
            var e = new Ct;
            return function(t) {
                var i = this.elements
                  , n = t.elements
                  , r = 1 / e.setFromMatrixColumn(t, 0).length()
                  , s = 1 / e.setFromMatrixColumn(t, 1).length()
                  , a = 1 / e.setFromMatrixColumn(t, 2).length();
                return i[0] = n[0] * r,
                i[1] = n[1] * r,
                i[2] = n[2] * r,
                i[3] = 0,
                i[4] = n[4] * s,
                i[5] = n[5] * s,
                i[6] = n[6] * s,
                i[7] = 0,
                i[8] = n[8] * a,
                i[9] = n[9] * a,
                i[10] = n[10] * a,
                i[11] = 0,
                i[12] = 0,
                i[13] = 0,
                i[14] = 0,
                i[15] = 1,
                this
            }
        }(),
        makeRotationFromEuler: function(e) {
            !e || e.isEuler;
            var t = this.elements
              , i = e.x
              , n = e.y
              , r = e.z
              , s = Math.cos(i)
              , a = Math.sin(i)
              , o = Math.cos(n)
              , l = Math.sin(n)
              , c = Math.cos(r)
              , h = Math.sin(r);
            if ("XYZ" === e.order) {
                var u = s * c
                  , p = s * h
                  , d = a * c
                  , f = a * h;
                t[0] = o * c,
                t[4] = -o * h,
                t[8] = l,
                t[1] = p + d * l,
                t[5] = u - f * l,
                t[9] = -a * o,
                t[2] = f - u * l,
                t[6] = d + p * l,
                t[10] = s * o
            } else if ("YXZ" === e.order) {
                var m = o * c
                  , g = o * h
                  , v = l * c
                  , y = l * h;
                t[0] = m + y * a,
                t[4] = v * a - g,
                t[8] = s * l,
                t[1] = s * h,
                t[5] = s * c,
                t[9] = -a,
                t[2] = g * a - v,
                t[6] = y + m * a,
                t[10] = s * o
            } else if ("ZXY" === e.order) {
                m = o * c,
                g = o * h,
                v = l * c,
                y = l * h;
                t[0] = m - y * a,
                t[4] = -s * h,
                t[8] = v + g * a,
                t[1] = g + v * a,
                t[5] = s * c,
                t[9] = y - m * a,
                t[2] = -s * l,
                t[6] = a,
                t[10] = s * o
            } else if ("ZYX" === e.order) {
                u = s * c,
                p = s * h,
                d = a * c,
                f = a * h;
                t[0] = o * c,
                t[4] = d * l - p,
                t[8] = u * l + f,
                t[1] = o * h,
                t[5] = f * l + u,
                t[9] = p * l - d,
                t[2] = -l,
                t[6] = a * o,
                t[10] = s * o
            } else if ("YZX" === e.order) {
                var b = s * o
                  , x = s * l
                  , w = a * o
                  , _ = a * l;
                t[0] = o * c,
                t[4] = _ - b * h,
                t[8] = w * h + x,
                t[1] = h,
                t[5] = s * c,
                t[9] = -a * c,
                t[2] = -l * c,
                t[6] = x * h + w,
                t[10] = b - _ * h
            } else if ("XZY" === e.order) {
                b = s * o,
                x = s * l,
                w = a * o,
                _ = a * l;
                t[0] = o * c,
                t[4] = -h,
                t[8] = l * c,
                t[1] = b * h + _,
                t[5] = s * c,
                t[9] = x * h - w,
                t[2] = w * h - x,
                t[6] = a * c,
                t[10] = _ * h + b
            }
            return t[3] = 0,
            t[7] = 0,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        },
        makeRotationFromQuaternion: (Vt = new Ct(0,0,0),
        Gt = new Ct(1,1,1),
        function(e) {
            return this.compose(Vt, e, Gt)
        }
        ),
        lookAt: (Ut = new Ct,
        Bt = new Ct,
        jt = new Ct,
        function(e, t, i) {
            var n = this.elements;
            return jt.subVectors(e, t),
            0 === jt.lengthSq() && (jt.z = 1),
            jt.normalize(),
            Ut.crossVectors(i, jt),
            0 === Ut.lengthSq() && (1 === Math.abs(i.z) ? jt.x += 1e-4 : jt.z += 1e-4,
            jt.normalize(),
            Ut.crossVectors(i, jt)),
            Ut.normalize(),
            Bt.crossVectors(jt, Ut),
            n[0] = Ut.x,
            n[4] = Bt.x,
            n[8] = jt.x,
            n[1] = Ut.y,
            n[5] = Bt.y,
            n[9] = jt.y,
            n[2] = Ut.z,
            n[6] = Bt.z,
            n[10] = jt.z,
            this
        }
        ),
        multiply: function(e, t) {
            return void 0 !== t ? this.multiplyMatrices(e, t) : this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var i = e.elements
              , n = t.elements
              , r = this.elements
              , s = i[0]
              , a = i[4]
              , o = i[8]
              , l = i[12]
              , c = i[1]
              , h = i[5]
              , u = i[9]
              , p = i[13]
              , d = i[2]
              , f = i[6]
              , m = i[10]
              , g = i[14]
              , v = i[3]
              , y = i[7]
              , b = i[11]
              , x = i[15]
              , w = n[0]
              , _ = n[4]
              , T = n[8]
              , M = n[12]
              , S = n[1]
              , A = n[5]
              , P = n[9]
              , C = n[13]
              , L = n[2]
              , k = n[6]
              , E = n[10]
              , I = n[14]
              , F = n[3]
              , O = n[7]
              , R = n[11]
              , z = n[15];
            return r[0] = s * w + a * S + o * L + l * F,
            r[4] = s * _ + a * A + o * k + l * O,
            r[8] = s * T + a * P + o * E + l * R,
            r[12] = s * M + a * C + o * I + l * z,
            r[1] = c * w + h * S + u * L + p * F,
            r[5] = c * _ + h * A + u * k + p * O,
            r[9] = c * T + h * P + u * E + p * R,
            r[13] = c * M + h * C + u * I + p * z,
            r[2] = d * w + f * S + m * L + g * F,
            r[6] = d * _ + f * A + m * k + g * O,
            r[10] = d * T + f * P + m * E + g * R,
            r[14] = d * M + f * C + m * I + g * z,
            r[3] = v * w + y * S + b * L + x * F,
            r[7] = v * _ + y * A + b * k + x * O,
            r[11] = v * T + y * P + b * E + x * R,
            r[15] = v * M + y * C + b * I + x * z,
            this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[4] *= e,
            t[8] *= e,
            t[12] *= e,
            t[1] *= e,
            t[5] *= e,
            t[9] *= e,
            t[13] *= e,
            t[2] *= e,
            t[6] *= e,
            t[10] *= e,
            t[14] *= e,
            t[3] *= e,
            t[7] *= e,
            t[11] *= e,
            t[15] *= e,
            this
        },
        applyToBufferAttribute: function() {
            var e = new Ct;
            return function(t) {
                for (var i = 0, n = t.count; i < n; i++)
                    e.x = t.getX(i),
                    e.y = t.getY(i),
                    e.z = t.getZ(i),
                    e.applyMatrix4(this),
                    t.setXYZ(i, e.x, e.y, e.z);
                return t
            }
        }(),
        determinant: function() {
            var e = this.elements
              , t = e[0]
              , i = e[4]
              , n = e[8]
              , r = e[12]
              , s = e[1]
              , a = e[5]
              , o = e[9]
              , l = e[13]
              , c = e[2]
              , h = e[6]
              , u = e[10]
              , p = e[14];
            return e[3] * (+r * o * h - n * l * h - r * a * u + i * l * u + n * a * p - i * o * p) + e[7] * (+t * o * p - t * l * u + r * s * u - n * s * p + n * l * c - r * o * c) + e[11] * (+t * l * h - t * a * p - r * s * h + i * s * p + r * a * c - i * l * c) + e[15] * (-n * a * c - t * o * h + t * a * u + n * s * h - i * s * u + i * o * c)
        },
        transpose: function() {
            var e, t = this.elements;
            return e = t[1],
            t[1] = t[4],
            t[4] = e,
            e = t[2],
            t[2] = t[8],
            t[8] = e,
            e = t[6],
            t[6] = t[9],
            t[9] = e,
            e = t[3],
            t[3] = t[12],
            t[12] = e,
            e = t[7],
            t[7] = t[13],
            t[13] = e,
            e = t[11],
            t[11] = t[14],
            t[14] = e,
            this
        },
        setPosition: function(e) {
            var t = this.elements;
            return t[12] = e.x,
            t[13] = e.y,
            t[14] = e.z,
            this
        },
        getInverse: function(e, t) {
            var i = this.elements
              , n = e.elements
              , r = n[0]
              , s = n[1]
              , a = n[2]
              , o = n[3]
              , l = n[4]
              , c = n[5]
              , h = n[6]
              , u = n[7]
              , p = n[8]
              , d = n[9]
              , f = n[10]
              , m = n[11]
              , g = n[12]
              , v = n[13]
              , y = n[14]
              , b = n[15]
              , x = d * y * u - v * f * u + v * h * m - c * y * m - d * h * b + c * f * b
              , w = g * f * u - p * y * u - g * h * m + l * y * m + p * h * b - l * f * b
              , _ = p * v * u - g * d * u + g * c * m - l * v * m - p * c * b + l * d * b
              , T = g * d * h - p * v * h - g * c * f + l * v * f + p * c * y - l * d * y
              , M = r * x + s * w + a * _ + o * T;
            if (0 === M) {
                if (!0 === t)
                    throw new Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return this.identity()
            }
            var S = 1 / M;
            return i[0] = x * S,
            i[1] = (v * f * o - d * y * o - v * a * m + s * y * m + d * a * b - s * f * b) * S,
            i[2] = (c * y * o - v * h * o + v * a * u - s * y * u - c * a * b + s * h * b) * S,
            i[3] = (d * h * o - c * f * o - d * a * u + s * f * u + c * a * m - s * h * m) * S,
            i[4] = w * S,
            i[5] = (p * y * o - g * f * o + g * a * m - r * y * m - p * a * b + r * f * b) * S,
            i[6] = (g * h * o - l * y * o - g * a * u + r * y * u + l * a * b - r * h * b) * S,
            i[7] = (l * f * o - p * h * o + p * a * u - r * f * u - l * a * m + r * h * m) * S,
            i[8] = _ * S,
            i[9] = (g * d * o - p * v * o - g * s * m + r * v * m + p * s * b - r * d * b) * S,
            i[10] = (l * v * o - g * c * o + g * s * u - r * v * u - l * s * b + r * c * b) * S,
            i[11] = (p * c * o - l * d * o - p * s * u + r * d * u + l * s * m - r * c * m) * S,
            i[12] = T * S,
            i[13] = (p * v * a - g * d * a + g * s * f - r * v * f - p * s * y + r * d * y) * S,
            i[14] = (g * c * a - l * v * a - g * s * h + r * v * h + l * s * y - r * c * y) * S,
            i[15] = (l * d * a - p * c * a + p * s * h - r * d * h - l * s * f + r * c * f) * S,
            this
        },
        scale: function(e) {
            var t = this.elements
              , i = e.x
              , n = e.y
              , r = e.z;
            return t[0] *= i,
            t[4] *= n,
            t[8] *= r,
            t[1] *= i,
            t[5] *= n,
            t[9] *= r,
            t[2] *= i,
            t[6] *= n,
            t[10] *= r,
            t[3] *= i,
            t[7] *= n,
            t[11] *= r,
            this
        },
        getMaxScaleOnAxis: function() {
            var e = this.elements
              , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
              , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
              , n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, i, n))
        },
        makeTranslation: function(e, t, i) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
            this
        },
        makeRotationX: function(e) {
            var t = Math.cos(e)
              , i = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
            this
        },
        makeRotationY: function(e) {
            var t = Math.cos(e)
              , i = Math.sin(e);
            return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
            this
        },
        makeRotationZ: function(e) {
            var t = Math.cos(e)
              , i = Math.sin(e);
            return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        makeRotationAxis: function(e, t) {
            var i = Math.cos(t)
              , n = Math.sin(t)
              , r = 1 - i
              , s = e.x
              , a = e.y
              , o = e.z
              , l = r * s
              , c = r * a;
            return this.set(l * s + i, l * a - n * o, l * o + n * a, 0, l * a + n * o, c * a + i, c * o - n * s, 0, l * o - n * a, c * o + n * s, r * o * o + i, 0, 0, 0, 0, 1),
            this
        },
        makeScale: function(e, t, i) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
            this
        },
        makeShear: function(e, t, i) {
            return this.set(1, t, i, 0, e, 1, i, 0, e, t, 1, 0, 0, 0, 0, 1),
            this
        },
        compose: function(e, t, i) {
            var n = this.elements
              , r = t._x
              , s = t._y
              , a = t._z
              , o = t._w
              , l = r + r
              , c = s + s
              , h = a + a
              , u = r * l
              , p = r * c
              , d = r * h
              , f = s * c
              , m = s * h
              , g = a * h
              , v = o * l
              , y = o * c
              , b = o * h
              , x = i.x
              , w = i.y
              , _ = i.z;
            return n[0] = (1 - (f + g)) * x,
            n[1] = (p + b) * x,
            n[2] = (d - y) * x,
            n[3] = 0,
            n[4] = (p - b) * w,
            n[5] = (1 - (u + g)) * w,
            n[6] = (m + v) * w,
            n[7] = 0,
            n[8] = (d + y) * _,
            n[9] = (m - v) * _,
            n[10] = (1 - (u + f)) * _,
            n[11] = 0,
            n[12] = e.x,
            n[13] = e.y,
            n[14] = e.z,
            n[15] = 1,
            this
        },
        decompose: (Nt = new Ct,
        Dt = new ii,
        function(e, t, i) {
            var n = this.elements
              , r = Nt.set(n[0], n[1], n[2]).length()
              , s = Nt.set(n[4], n[5], n[6]).length()
              , a = Nt.set(n[8], n[9], n[10]).length();
            this.determinant() < 0 && (r = -r),
            e.x = n[12],
            e.y = n[13],
            e.z = n[14],
            Dt.copy(this);
            var o = 1 / r
              , l = 1 / s
              , c = 1 / a;
            return Dt.elements[0] *= o,
            Dt.elements[1] *= o,
            Dt.elements[2] *= o,
            Dt.elements[4] *= l,
            Dt.elements[5] *= l,
            Dt.elements[6] *= l,
            Dt.elements[8] *= c,
            Dt.elements[9] *= c,
            Dt.elements[10] *= c,
            t.setFromRotationMatrix(Dt),
            i.x = r,
            i.y = s,
            i.z = a,
            this
        }
        ),
        makePerspective: function(e, t, i, n, r, s) {
            var a = this.elements
              , o = 2 * r / (t - e)
              , l = 2 * r / (i - n)
              , c = (t + e) / (t - e)
              , h = (i + n) / (i - n)
              , u = -(s + r) / (s - r)
              , p = -2 * s * r / (s - r);
            return a[0] = o,
            a[4] = 0,
            a[8] = c,
            a[12] = 0,
            a[1] = 0,
            a[5] = l,
            a[9] = h,
            a[13] = 0,
            a[2] = 0,
            a[6] = 0,
            a[10] = u,
            a[14] = p,
            a[3] = 0,
            a[7] = 0,
            a[11] = -1,
            a[15] = 0,
            this
        },
        makeOrthographic: function(e, t, i, n, r, s) {
            var a = this.elements
              , o = 1 / (t - e)
              , l = 1 / (i - n)
              , c = 1 / (s - r)
              , h = (t + e) * o
              , u = (i + n) * l
              , p = (s + r) * c;
            return a[0] = 2 * o,
            a[4] = 0,
            a[8] = 0,
            a[12] = -h,
            a[1] = 0,
            a[5] = 2 * l,
            a[9] = 0,
            a[13] = -u,
            a[2] = 0,
            a[6] = 0,
            a[10] = -2 * c,
            a[14] = -p,
            a[3] = 0,
            a[7] = 0,
            a[11] = 0,
            a[15] = 1,
            this
        },
        equals: function(e) {
            for (var t = this.elements, i = e.elements, n = 0; n < 16; n++)
                if (t[n] !== i[n])
                    return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; i < 16; i++)
                this.elements[i] = e[i + t];
            return this
        },
        toArray: function(e, t) {
            void 0 === e && (e = []),
            void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0],
            e[t + 1] = i[1],
            e[t + 2] = i[2],
            e[t + 3] = i[3],
            e[t + 4] = i[4],
            e[t + 5] = i[5],
            e[t + 6] = i[6],
            e[t + 7] = i[7],
            e[t + 8] = i[8],
            e[t + 9] = i[9],
            e[t + 10] = i[10],
            e[t + 11] = i[11],
            e[t + 12] = i[12],
            e[t + 13] = i[13],
            e[t + 14] = i[14],
            e[t + 15] = i[15],
            e
        }
    });
    var ni = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
        lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
        normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    };
    function ri(e) {
        var t = {};
        for (var i in e)
            for (var n in t[i] = {},
            e[i]) {
                var r = e[i][n];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? t[i][n] = r.clone() : Array.isArray(r) ? t[i][n] = r.slice() : t[i][n] = r
            }
        return t
    }
    function si(e) {
        for (var t = {}, i = 0; i < e.length; i++) {
            var n = ri(e[i]);
            for (var r in n)
                t[r] = n[r]
        }
        return t
    }
    var ai, oi, li, ci = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    function hi(e, t, i) {
        return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i)
    }
    Object.assign(hi.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e),
            this
        },
        setScalar: function(e) {
            return this.r = e,
            this.g = e,
            this.b = e,
            this
        },
        setHex: function(e) {
            return e = Math.floor(e),
            this.r = (e >> 16 & 255) / 255,
            this.g = (e >> 8 & 255) / 255,
            this.b = (255 & e) / 255,
            this
        },
        setRGB: function(e, t, i) {
            return this.r = e,
            this.g = t,
            this.b = i,
            this
        },
        setHSL: function() {
            function e(e, t, i) {
                return i < 0 && (i += 1),
                i > 1 && (i -= 1),
                i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
            }
            return function(t, i, n) {
                if (t = St.euclideanModulo(t, 1),
                i = St.clamp(i, 0, 1),
                n = St.clamp(n, 0, 1),
                0 === i)
                    this.r = this.g = this.b = n;
                else {
                    var r = n <= .5 ? n * (1 + i) : n + i - n * i
                      , s = 2 * n - r;
                    this.r = e(s, r, t + 1 / 3),
                    this.g = e(s, r, t),
                    this.b = e(s, r, t - 1 / 3)
                }
                return this
            }
        }(),
        setStyle: function(e) {
            function t(e) {
                void 0 !== e && parseFloat(e)
            }
            var i;
            if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                var n, r = i[1], s = i[2];
                switch (r) {
                case "rgb":
                case "rgba":
                    if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s))
                        return this.r = Math.min(255, parseInt(n[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(n[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(n[3], 10)) / 255,
                        t(n[5]),
                        this;
                    if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s))
                        return this.r = Math.min(100, parseInt(n[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(n[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(n[3], 10)) / 100,
                        t(n[5]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(s)) {
                        var a = parseFloat(n[1]) / 360
                          , o = parseInt(n[2], 10) / 100
                          , l = parseInt(n[3], 10) / 100;
                        return t(n[5]),
                        this.setHSL(a, o, l)
                    }
                }
            } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                var c, h = (c = i[1]).length;
                if (3 === h)
                    return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255,
                    this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255,
                    this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255,
                    this;
                if (6 === h)
                    return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255,
                    this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255,
                    this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255,
                    this
            }
            e && e.length > 0 && (void 0 !== (c = ci[e]) && this.setHex(c));
            return this
        },
        clone: function() {
            return new this.constructor(this.r,this.g,this.b)
        },
        copy: function(e) {
            return this.r = e.r,
            this.g = e.g,
            this.b = e.b,
            this
        },
        copyGammaToLinear: function(e, t) {
            return void 0 === t && (t = 2),
            this.r = Math.pow(e.r, t),
            this.g = Math.pow(e.g, t),
            this.b = Math.pow(e.b, t),
            this
        },
        copyLinearToGamma: function(e, t) {
            void 0 === t && (t = 2);
            var i = t > 0 ? 1 / t : 1;
            return this.r = Math.pow(e.r, i),
            this.g = Math.pow(e.g, i),
            this.b = Math.pow(e.b, i),
            this
        },
        convertGammaToLinear: function(e) {
            return this.copyGammaToLinear(this, e),
            this
        },
        convertLinearToGamma: function(e) {
            return this.copyLinearToGamma(this, e),
            this
        },
        copySRGBToLinear: function() {
            function e(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }
            return function(t) {
                return this.r = e(t.r),
                this.g = e(t.g),
                this.b = e(t.b),
                this
            }
        }(),
        copyLinearToSRGB: function() {
            function e(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            return function(t) {
                return this.r = e(t.r),
                this.g = e(t.g),
                this.b = e(t.b),
                this
            }
        }(),
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this),
            this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(e) {
            void 0 === e && (e = {
                h: 0,
                s: 0,
                l: 0
            });
            var t, i, n = this.r, r = this.g, s = this.b, a = Math.max(n, r, s), o = Math.min(n, r, s), l = (o + a) / 2;
            if (o === a)
                t = 0,
                i = 0;
            else {
                var c = a - o;
                switch (i = l <= .5 ? c / (a + o) : c / (2 - a - o),
                a) {
                case n:
                    t = (r - s) / c + (r < s ? 6 : 0);
                    break;
                case r:
                    t = (s - n) / c + 2;
                    break;
                case s:
                    t = (n - r) / c + 4
                }
                t /= 6
            }
            return e.h = t,
            e.s = i,
            e.l = l,
            e
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: (li = {},
        function(e, t, i) {
            return this.getHSL(li),
            li.h += e,
            li.s += t,
            li.l += i,
            this.setHSL(li.h, li.s, li.l),
            this
        }
        ),
        add: function(e) {
            return this.r += e.r,
            this.g += e.g,
            this.b += e.b,
            this
        },
        addColors: function(e, t) {
            return this.r = e.r + t.r,
            this.g = e.g + t.g,
            this.b = e.b + t.b,
            this
        },
        addScalar: function(e) {
            return this.r += e,
            this.g += e,
            this.b += e,
            this
        },
        sub: function(e) {
            return this.r = Math.max(0, this.r - e.r),
            this.g = Math.max(0, this.g - e.g),
            this.b = Math.max(0, this.b - e.b),
            this
        },
        multiply: function(e) {
            return this.r *= e.r,
            this.g *= e.g,
            this.b *= e.b,
            this
        },
        multiplyScalar: function(e) {
            return this.r *= e,
            this.g *= e,
            this.b *= e,
            this
        },
        lerp: function(e, t) {
            return this.r += (e.r - this.r) * t,
            this.g += (e.g - this.g) * t,
            this.b += (e.b - this.b) * t,
            this
        },
        lerpHSL: (ai = {
            h: 0,
            s: 0,
            l: 0
        },
        oi = {
            h: 0,
            s: 0,
            l: 0
        },
        function(e, t) {
            this.getHSL(ai),
            e.getHSL(oi);
            var i = St.lerp(ai.h, oi.h, t)
              , n = St.lerp(ai.s, oi.s, t)
              , r = St.lerp(ai.l, oi.l, t);
            return this.setHSL(i, n, r),
            this
        }
        ),
        equals: function(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function(e, t) {
            return void 0 === t && (t = 0),
            this.r = e[t],
            this.g = e[t + 1],
            this.b = e[t + 2],
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this.r,
            e[t + 1] = this.g,
            e[t + 2] = this.b,
            e
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var ui, pi = {
        common: {
            diffuse: {
                value: new hi(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Lt
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new At(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new hi(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new hi(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Lt
            }
        },
        sprite: {
            diffuse: {
                value: new hi(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new At(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Lt
            }
        }
    }, di = {
        basic: {
            uniforms: si([pi.common, pi.specularmap, pi.envmap, pi.aomap, pi.lightmap, pi.fog]),
            vertexShader: ni.meshbasic_vert,
            fragmentShader: ni.meshbasic_frag
        },
        lambert: {
            uniforms: si([pi.common, pi.specularmap, pi.envmap, pi.aomap, pi.lightmap, pi.emissivemap, pi.fog, pi.lights, {
                emissive: {
                    value: new hi(0)
                }
            }]),
            vertexShader: ni.meshlambert_vert,
            fragmentShader: ni.meshlambert_frag
        },
        phong: {
            uniforms: si([pi.common, pi.specularmap, pi.envmap, pi.aomap, pi.lightmap, pi.emissivemap, pi.bumpmap, pi.normalmap, pi.displacementmap, pi.gradientmap, pi.fog, pi.lights, {
                emissive: {
                    value: new hi(0)
                },
                specular: {
                    value: new hi(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: ni.meshphong_vert,
            fragmentShader: ni.meshphong_frag
        },
        standard: {
            uniforms: si([pi.common, pi.envmap, pi.aomap, pi.lightmap, pi.emissivemap, pi.bumpmap, pi.normalmap, pi.displacementmap, pi.roughnessmap, pi.metalnessmap, pi.fog, pi.lights, {
                emissive: {
                    value: new hi(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: ni.meshphysical_vert,
            fragmentShader: ni.meshphysical_frag
        },
        matcap: {
            uniforms: si([pi.common, pi.bumpmap, pi.normalmap, pi.displacementmap, pi.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: ni.meshmatcap_vert,
            fragmentShader: ni.meshmatcap_frag
        },
        points: {
            uniforms: si([pi.points, pi.fog]),
            vertexShader: ni.points_vert,
            fragmentShader: ni.points_frag
        },
        dashed: {
            uniforms: si([pi.common, pi.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: ni.linedashed_vert,
            fragmentShader: ni.linedashed_frag
        },
        depth: {
            uniforms: si([pi.common, pi.displacementmap]),
            vertexShader: ni.depth_vert,
            fragmentShader: ni.depth_frag
        },
        normal: {
            uniforms: si([pi.common, pi.bumpmap, pi.normalmap, pi.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: ni.normal_vert,
            fragmentShader: ni.normal_frag
        },
        sprite: {
            uniforms: si([pi.sprite, pi.fog]),
            vertexShader: ni.sprite_vert,
            fragmentShader: ni.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Lt
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: ni.background_vert,
            fragmentShader: ni.background_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: ni.cube_vert,
            fragmentShader: ni.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: ni.equirect_vert,
            fragmentShader: ni.equirect_frag
        },
        distanceRGBA: {
            uniforms: si([pi.common, pi.displacementmap, {
                referencePosition: {
                    value: new Ct
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: ni.distanceRGBA_vert,
            fragmentShader: ni.distanceRGBA_frag
        },
        shadow: {
            uniforms: si([pi.lights, pi.fog, {
                color: {
                    value: new hi(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: ni.shadow_vert,
            fragmentShader: ni.shadow_frag
        }
    };
    function fi() {
        var e = null
          , t = !1
          , i = null;
        function n(r, s) {
            !1 !== t && (i(r, s),
            e.requestAnimationFrame(n))
        }
        return {
            start: function() {
                !0 !== t && null !== i && (e.requestAnimationFrame(n),
                t = !0)
            },
            stop: function() {
                t = !1
            },
            setAnimationLoop: function(e) {
                i = e
            },
            setContext: function(t) {
                e = t
            }
        }
    }
    function mi(e) {
        var t = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data),
                t.get(e)
            },
            remove: function(i) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var n = t.get(i);
                n && (e.deleteBuffer(n.buffer),
                t.delete(i))
            },
            update: function(i, n) {
                i.isInterleavedBufferAttribute && (i = i.data);
                var r = t.get(i);
                void 0 === r ? t.set(i, function(t, i) {
                    var n = t.array
                      , r = t.dynamic ? 35048 : 35044
                      , s = e.createBuffer();
                    e.bindBuffer(i, s),
                    e.bufferData(i, n, r),
                    t.onUploadCallback();
                    var a = 5126;
                    return n instanceof Float32Array ? a = 5126 : n instanceof Float64Array || (n instanceof Uint16Array ? a = 5123 : n instanceof Int16Array ? a = 5122 : n instanceof Uint32Array ? a = 5125 : n instanceof Int32Array ? a = 5124 : n instanceof Int8Array ? a = 5120 : n instanceof Uint8Array && (a = 5121)),
                    {
                        buffer: s,
                        type: a,
                        bytesPerElement: n.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(i, n)) : r.version < i.version && (function(t, i, n) {
                    var r = i.array
                      , s = i.updateRange;
                    e.bindBuffer(n, t),
                    !1 === i.dynamic ? e.bufferData(n, r, 35044) : -1 === s.count ? e.bufferSubData(n, 0, r) : 0 === s.count || (e.bufferSubData(n, s.offset * r.BYTES_PER_ELEMENT, r.subarray(s.offset, s.offset + s.count)),
                    s.count = -1)
                }(r.buffer, i, n),
                r.version = i.version)
            }
        }
    }
    function gi(e, t, i, n, r, s) {
        this.a = e,
        this.b = t,
        this.c = i,
        this.normal = n && n.isVector3 ? n : new Ct,
        this.vertexNormals = Array.isArray(n) ? n : [],
        this.color = r && r.isColor ? r : new hi,
        this.vertexColors = Array.isArray(r) ? r : [],
        this.materialIndex = void 0 !== s ? s : 0
    }
    function vi(e, t, i, n) {
        this._x = e || 0,
        this._y = t || 0,
        this._z = i || 0,
        this._order = n || vi.DefaultOrder
    }
    function yi() {
        this.mask = 1
    }
    di.physical = {
        uniforms: si([di.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: ni.meshphysical_vert,
        fragmentShader: ni.meshphysical_frag
    },
    Object.assign(gi.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.a = e.a,
            this.b = e.b,
            this.c = e.c,
            this.normal.copy(e.normal),
            this.color.copy(e.color),
            this.materialIndex = e.materialIndex;
            for (var t = 0, i = e.vertexNormals.length; t < i; t++)
                this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0,
            i = e.vertexColors.length; t < i; t++)
                this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    }),
    vi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
    vi.DefaultOrder = "XYZ",
    Object.defineProperties(vi.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e,
                this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(e) {
                this._order = e,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(vi.prototype, {
        isEuler: !0,
        set: function(e, t, i, n) {
            return this._x = e,
            this._y = t,
            this._z = i,
            this._order = n || this._order,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        },
        copy: function(e) {
            return this._x = e._x,
            this._y = e._y,
            this._z = e._z,
            this._order = e._order,
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(e, t, i) {
            var n = St.clamp
              , r = e.elements
              , s = r[0]
              , a = r[4]
              , o = r[8]
              , l = r[1]
              , c = r[5]
              , h = r[9]
              , u = r[2]
              , p = r[6]
              , d = r[10];
            return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(n(o, -1, 1)),
            Math.abs(o) < .99999 ? (this._x = Math.atan2(-h, d),
            this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(p, c),
            this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(h, -1, 1)),
            Math.abs(h) < .99999 ? (this._y = Math.atan2(o, d),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, s),
            this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(p, -1, 1)),
            Math.abs(p) < .99999 ? (this._y = Math.atan2(-u, d),
            this._z = Math.atan2(-a, c)) : (this._y = 0,
            this._z = Math.atan2(l, s))) : "ZYX" === t ? (this._y = Math.asin(-n(u, -1, 1)),
            Math.abs(u) < .99999 ? (this._x = Math.atan2(p, d),
            this._z = Math.atan2(l, s)) : (this._x = 0,
            this._z = Math.atan2(-a, c))) : "YZX" === t ? (this._z = Math.asin(n(l, -1, 1)),
            Math.abs(l) < .99999 ? (this._x = Math.atan2(-h, c),
            this._y = Math.atan2(-u, s)) : (this._x = 0,
            this._y = Math.atan2(o, d))) : "XZY" === t && (this._z = Math.asin(-n(a, -1, 1)),
            Math.abs(a) < .99999 ? (this._x = Math.atan2(p, c),
            this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-h, d),
            this._y = 0)),
            this._order = t,
            !1 !== i && this.onChangeCallback(),
            this
        },
        setFromQuaternion: function() {
            var e = new ii;
            return function(t, i, n) {
                return e.makeRotationFromQuaternion(t),
                this.setFromRotationMatrix(e, i, n)
            }
        }(),
        setFromVector3: function(e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: (ui = new Pt,
        function(e) {
            return ui.setFromEuler(this),
            this.setFromQuaternion(ui, e)
        }
        ),
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function(e) {
            return this._x = e[0],
            this._y = e[1],
            this._z = e[2],
            void 0 !== e[3] && (this._order = e[3]),
            this.onChangeCallback(),
            this
        },
        toArray: function(e, t) {
            return void 0 === e && (e = []),
            void 0 === t && (t = 0),
            e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._order,
            e
        },
        toVector3: function(e) {
            return e ? e.set(this._x, this._y, this._z) : new Ct(this._x,this._y,this._z)
        },
        onChange: function(e) {
            return this.onChangeCallback = e,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(yi.prototype, {
        set: function(e) {
            this.mask = 1 << e | 0
        },
        enable: function(e) {
            this.mask |= 1 << e | 0
        },
        toggle: function(e) {
            this.mask ^= 1 << e | 0
        },
        disable: function(e) {
            this.mask &= ~(1 << e | 0)
        },
        test: function(e) {
            return 0 != (this.mask & e.mask)
        }
    });
    var bi, xi, wi, _i, Ti = 0;
    function Mi() {
        Object.defineProperty(this, "id", {
            value: Ti++
        }),
        this.uuid = St.generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Mi.DefaultUp.clone();
        var e = new Ct
          , t = new vi
          , i = new Pt
          , n = new Ct(1,1,1);
        t.onChange(function() {
            i.setFromEuler(t, !1)
        }),
        i.onChange(function() {
            t.setFromQuaternion(i, void 0, !1)
        }),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            modelViewMatrix: {
                value: new ii
            },
            normalMatrix: {
                value: new Lt
            }
        }),
        this.matrix = new ii,
        this.matrixWorld = new ii,
        this.matrixAutoUpdate = Mi.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new yi,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.userData = {}
    }
    Mi.DefaultUp = new Ct(0,1,0),
    Mi.DefaultMatrixAutoUpdate = !0,
    Mi.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Mi,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(e) {
            return this.quaternion.premultiply(e),
            this
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: (_i = new Pt,
        function(e, t) {
            return _i.setFromAxisAngle(e, t),
            this.quaternion.multiply(_i),
            this
        }
        ),
        rotateOnWorldAxis: function() {
            var e = new Pt;
            return function(t, i) {
                return e.setFromAxisAngle(t, i),
                this.quaternion.premultiply(e),
                this
            }
        }(),
        rotateX: function() {
            var e = new Ct(1,0,0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateY: function() {
            var e = new Ct(0,1,0);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        rotateZ: function() {
            var e = new Ct(0,0,1);
            return function(t) {
                return this.rotateOnAxis(e, t)
            }
        }(),
        translateOnAxis: function() {
            var e = new Ct;
            return function(t, i) {
                return e.copy(t).applyQuaternion(this.quaternion),
                this.position.add(e.multiplyScalar(i)),
                this
            }
        }(),
        translateX: function() {
            var e = new Ct(1,0,0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateY: function() {
            var e = new Ct(0,1,0);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        translateZ: function() {
            var e = new Ct(0,0,1);
            return function(t) {
                return this.translateOnAxis(e, t)
            }
        }(),
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: (wi = new ii,
        function(e) {
            return e.applyMatrix4(wi.getInverse(this.matrixWorld))
        }
        ),
        lookAt: function() {
            var e = new Pt
              , t = new ii
              , i = new Ct
              , n = new Ct;
            return function(r, s, a) {
                r.isVector3 ? i.copy(r) : i.set(r, s, a);
                var o = this.parent;
                this.updateWorldMatrix(!0, !1),
                n.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? t.lookAt(n, i, this.up) : t.lookAt(i, n, this.up),
                this.quaternion.setFromRotationMatrix(t),
                o && (t.extractRotation(o.matrixWorld),
                e.setFromRotationMatrix(t),
                this.quaternion.premultiply(e.inverse()))
            }
        }(),
        add: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++)
                    this.add(arguments[t]);
                return this
            }
            return e === this ? this : (e && e.isObject3D && (null !== e.parent && e.parent.remove(e),
            e.parent = this,
            e.dispatchEvent({
                type: "added"
            }),
            this.children.push(e)),
            this)
        },
        remove: function(e) {
            if (arguments.length > 1) {
                for (var t = 0; t < arguments.length; t++)
                    this.remove(arguments[t]);
                return this
            }
            var i = this.children.indexOf(e);
            return -1 !== i && (e.parent = null,
            e.dispatchEvent({
                type: "removed"
            }),
            this.children.splice(i, 1)),
            this
        },
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t)
                return this;
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i].getObjectByProperty(e, t);
                if (void 0 !== r)
                    return r
            }
        },
        getWorldPosition: function(e) {
            return void 0 === e && (e = new Ct),
            this.updateMatrixWorld(!0),
            e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: (bi = new Ct,
        xi = new Ct,
        function(e) {
            return void 0 === e && (e = new Pt),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(bi, e, xi),
            e
        }
        ),
        getWorldScale: function() {
            var e = new Ct
              , t = new Pt;
            return function(i) {
                return void 0 === i && (i = new Ct),
                this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(e, t, i),
                i
            }
        }(),
        getWorldDirection: function(e) {
            void 0 === e && (e = new Ct),
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        raycast: function() {},
        traverse: function(e) {
            e(this);
            for (var t = this.children, i = 0, n = t.length; i < n; i++)
                t[i].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, i = 0, n = t.length; i < n; i++)
                    t[i].traverseVisible(e)
            }
        },
        traverseAncestors: function(e) {
            var t = this.parent;
            null !== t && (e(t),
            t.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            e = !0);
            for (var t = this.children, i = 0, n = t.length; i < n; i++)
                t[i].updateMatrixWorld(e)
        },
        updateWorldMatrix: function(e, t) {
            var i = this.parent;
            if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === t)
                for (var n = this.children, r = 0, s = n.length; r < s; r++)
                    n[r].updateWorldMatrix(!1, !0)
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e
              , i = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            },
            i.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var n = {};
            function r(t, i) {
                return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)),
                i.uuid
            }
            if (n.uuid = this.uuid,
            n.type = this.type,
            "" !== this.name && (n.name = this.name),
            !0 === this.castShadow && (n.castShadow = !0),
            !0 === this.receiveShadow && (n.receiveShadow = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.frustumCulled && (n.frustumCulled = !1),
            0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
            n.layers = this.layers.mask,
            n.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
            this.isMesh && this.drawMode !== ut && (n.drawMode = this.drawMode),
            this.isMesh || this.isLine || this.isPoints) {
                n.geometry = r(e.geometries, this.geometry);
                var s = this.geometry.parameters;
                if (void 0 !== s && void 0 !== s.shapes) {
                    var a = s.shapes;
                    if (Array.isArray(a))
                        for (var o = 0, l = a.length; o < l; o++) {
                            var c = a[o];
                            r(e.shapes, c)
                        }
                    else
                        r(e.shapes, a)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var h = [];
                    for (o = 0,
                    l = this.material.length; o < l; o++)
                        h.push(r(e.materials, this.material[o]));
                    n.material = h
                } else
                    n.material = r(e.materials, this.material);
            if (this.children.length > 0) {
                n.children = [];
                for (o = 0; o < this.children.length; o++)
                    n.children.push(this.children[o].toJSON(e).object)
            }
            if (t) {
                var u = m(e.geometries)
                  , p = m(e.materials)
                  , d = m(e.textures)
                  , f = m(e.images);
                a = m(e.shapes);
                u.length > 0 && (i.geometries = u),
                p.length > 0 && (i.materials = p),
                d.length > 0 && (i.textures = d),
                f.length > 0 && (i.images = f),
                a.length > 0 && (i.shapes = a)
            }
            return i.object = n,
            i;
            function m(e) {
                var t = [];
                for (var i in e) {
                    var n = e[i];
                    delete n.metadata,
                    t.push(n)
                }
                return t
            }
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function(e, t) {
            if (void 0 === t && (t = !0),
            this.name = e.name,
            this.up.copy(e.up),
            this.position.copy(e.position),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
            this.layers.mask = e.layers.mask,
            this.visible = e.visible,
            this.castShadow = e.castShadow,
            this.receiveShadow = e.receiveShadow,
            this.frustumCulled = e.frustumCulled,
            this.renderOrder = e.renderOrder,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            !0 === t)
                for (var i = 0; i < e.children.length; i++) {
                    var n = e.children[i];
                    this.add(n.clone())
                }
            return this
        }
    });
    var Si, Ai, Pi = 0;
    function Ci() {
        Object.defineProperty(this, "id", {
            value: Pi += 2
        }),
        this.uuid = St.generateUUID(),
        this.name = "",
        this.type = "Geometry",
        this.vertices = [],
        this.colors = [],
        this.faces = [],
        this.faceVertexUvs = [[]],
        this.morphTargets = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.elementsNeedUpdate = !1,
        this.verticesNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.lineDistancesNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    function Li(e, t, i) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.normalized = !0 === i,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function ki(e, t, i) {
        Li.call(this, new Int8Array(e), t, i)
    }
    function Ei(e, t, i) {
        Li.call(this, new Uint8Array(e), t, i)
    }
    function Ii(e, t, i) {
        Li.call(this, new Uint8ClampedArray(e), t, i)
    }
    function Fi(e, t, i) {
        Li.call(this, new Int16Array(e), t, i)
    }
    function Oi(e, t, i) {
        Li.call(this, new Uint16Array(e), t, i)
    }
    function Ri(e, t, i) {
        Li.call(this, new Int32Array(e), t, i)
    }
    function zi(e, t, i) {
        Li.call(this, new Uint32Array(e), t, i)
    }
    function Ni(e, t, i) {
        Li.call(this, new Float32Array(e), t, i)
    }
    function Di(e, t, i) {
        Li.call(this, new Float64Array(e), t, i)
    }
    function Ui() {
        this.vertices = [],
        this.normals = [],
        this.colors = [],
        this.uvs = [],
        this.uvs2 = [],
        this.groups = [],
        this.morphTargets = {},
        this.skinWeights = [],
        this.skinIndices = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.verticesNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    function Bi(e) {
        if (0 === e.length)
            return -1 / 0;
        for (var t = e[0], i = 1, n = e.length; i < n; ++i)
            e[i] > t && (t = e[i]);
        return t
    }
    Ci.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Ci,
        isGeometry: !0,
        applyMatrix: function(e) {
            for (var t = (new Lt).getNormalMatrix(e), i = 0, n = this.vertices.length; i < n; i++) {
                this.vertices[i].applyMatrix4(e)
            }
            for (i = 0,
            n = this.faces.length; i < n; i++) {
                var r = this.faces[i];
                r.normal.applyMatrix3(t).normalize();
                for (var s = 0, a = r.vertexNormals.length; s < a; s++)
                    r.vertexNormals[s].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this.verticesNeedUpdate = !0,
            this.normalsNeedUpdate = !0,
            this
        },
        rotateX: function() {
            var e = new ii;
            return function(t) {
                return e.makeRotationX(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateY: function() {
            var e = new ii;
            return function(t) {
                return e.makeRotationY(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateZ: function() {
            var e = new ii;
            return function(t) {
                return e.makeRotationZ(t),
                this.applyMatrix(e),
                this
            }
        }(),
        translate: function() {
            var e = new ii;
            return function(t, i, n) {
                return e.makeTranslation(t, i, n),
                this.applyMatrix(e),
                this
            }
        }(),
        scale: function() {
            var e = new ii;
            return function(t, i, n) {
                return e.makeScale(t, i, n),
                this.applyMatrix(e),
                this
            }
        }(),
        lookAt: (Ai = new Mi,
        function(e) {
            Ai.lookAt(e),
            Ai.updateMatrix(),
            this.applyMatrix(Ai.matrix)
        }
        ),
        fromBufferGeometry: function(e) {
            var t = this
              , i = null !== e.index ? e.index.array : void 0
              , n = e.attributes
              , r = n.position.array
              , s = void 0 !== n.normal ? n.normal.array : void 0
              , a = void 0 !== n.color ? n.color.array : void 0
              , o = void 0 !== n.uv ? n.uv.array : void 0
              , l = void 0 !== n.uv2 ? n.uv2.array : void 0;
            void 0 !== l && (this.faceVertexUvs[1] = []);
            for (var c = 0, h = 0; c < r.length; c += 3,
            h += 2)
                t.vertices.push((new Ct).fromArray(r, c)),
                void 0 !== a && t.colors.push((new hi).fromArray(a, c));
            function u(e, i, n, r) {
                var c = void 0 === a ? [] : [t.colors[e].clone(), t.colors[i].clone(), t.colors[n].clone()]
                  , h = new gi(e,i,n,void 0 === s ? [] : [(new Ct).fromArray(s, 3 * e), (new Ct).fromArray(s, 3 * i), (new Ct).fromArray(s, 3 * n)],c,r);
                t.faces.push(h),
                void 0 !== o && t.faceVertexUvs[0].push([(new At).fromArray(o, 2 * e), (new At).fromArray(o, 2 * i), (new At).fromArray(o, 2 * n)]),
                void 0 !== l && t.faceVertexUvs[1].push([(new At).fromArray(l, 2 * e), (new At).fromArray(l, 2 * i), (new At).fromArray(l, 2 * n)])
            }
            var p = e.groups;
            if (p.length > 0)
                for (c = 0; c < p.length; c++)
                    for (var d = p[c], f = d.start, m = (h = f,
                    f + d.count); h < m; h += 3)
                        void 0 !== i ? u(i[h], i[h + 1], i[h + 2], d.materialIndex) : u(h, h + 1, h + 2, d.materialIndex);
            else if (void 0 !== i)
                for (c = 0; c < i.length; c += 3)
                    u(i[c], i[c + 1], i[c + 2]);
            else
                for (c = 0; c < r.length / 3; c += 3)
                    u(c, c + 1, c + 2);
            return this.computeFaceNormals(),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            this
        },
        center: (Si = new Ct,
        function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(Si).negate(),
            this.translate(Si.x, Si.y, Si.z),
            this
        }
        ),
        normalize: function() {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center
              , t = this.boundingSphere.radius
              , i = 0 === t ? 1 : 1 / t
              , n = new ii;
            return n.set(i, 0, 0, -i * e.x, 0, i, 0, -i * e.y, 0, 0, i, -i * e.z, 0, 0, 0, 1),
            this.applyMatrix(n),
            this
        },
        computeFaceNormals: function() {
            for (var e = new Ct, t = new Ct, i = 0, n = this.faces.length; i < n; i++) {
                var r = this.faces[i]
                  , s = this.vertices[r.a]
                  , a = this.vertices[r.b]
                  , o = this.vertices[r.c];
                e.subVectors(o, a),
                t.subVectors(s, a),
                e.cross(t),
                e.normalize(),
                r.normal.copy(e)
            }
        },
        computeVertexNormals: function(e) {
            var t, i, n, r, s, a;
            for (void 0 === e && (e = !0),
            a = new Array(this.vertices.length),
            t = 0,
            i = this.vertices.length; t < i; t++)
                a[t] = new Ct;
            if (e) {
                var o, l, c, h = new Ct, u = new Ct;
                for (n = 0,
                r = this.faces.length; n < r; n++)
                    s = this.faces[n],
                    o = this.vertices[s.a],
                    l = this.vertices[s.b],
                    c = this.vertices[s.c],
                    h.subVectors(c, l),
                    u.subVectors(o, l),
                    h.cross(u),
                    a[s.a].add(h),
                    a[s.b].add(h),
                    a[s.c].add(h)
            } else
                for (this.computeFaceNormals(),
                n = 0,
                r = this.faces.length; n < r; n++)
                    a[(s = this.faces[n]).a].add(s.normal),
                    a[s.b].add(s.normal),
                    a[s.c].add(s.normal);
            for (t = 0,
            i = this.vertices.length; t < i; t++)
                a[t].normalize();
            for (n = 0,
            r = this.faces.length; n < r; n++) {
                var p = (s = this.faces[n]).vertexNormals;
                3 === p.length ? (p[0].copy(a[s.a]),
                p[1].copy(a[s.b]),
                p[2].copy(a[s.c])) : (p[0] = a[s.a].clone(),
                p[1] = a[s.b].clone(),
                p[2] = a[s.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var e, t, i;
            for (this.computeFaceNormals(),
            e = 0,
            t = this.faces.length; e < t; e++) {
                var n = (i = this.faces[e]).vertexNormals;
                3 === n.length ? (n[0].copy(i.normal),
                n[1].copy(i.normal),
                n[2].copy(i.normal)) : (n[0] = i.normal.clone(),
                n[1] = i.normal.clone(),
                n[2] = i.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var e, t, i, n, r;
            for (i = 0,
            n = this.faces.length; i < n; i++)
                for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(),
                r.__originalVertexNormals || (r.__originalVertexNormals = []),
                e = 0,
                t = r.vertexNormals.length; e < t; e++)
                    r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone();
            var s = new Ci;
            for (s.faces = this.faces,
            e = 0,
            t = this.morphTargets.length; e < t; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {},
                    this.morphNormals[e].faceNormals = [],
                    this.morphNormals[e].vertexNormals = [];
                    var a = this.morphNormals[e].faceNormals
                      , o = this.morphNormals[e].vertexNormals;
                    for (i = 0,
                    n = this.faces.length; i < n; i++)
                        l = new Ct,
                        c = {
                            a: new Ct,
                            b: new Ct,
                            c: new Ct
                        },
                        a.push(l),
                        o.push(c)
                }
                var l, c, h = this.morphNormals[e];
                for (s.vertices = this.morphTargets[e].vertices,
                s.computeFaceNormals(),
                s.computeVertexNormals(),
                i = 0,
                n = this.faces.length; i < n; i++)
                    r = this.faces[i],
                    l = h.faceNormals[i],
                    c = h.vertexNormals[i],
                    l.copy(r.normal),
                    c.a.copy(r.vertexNormals[0]),
                    c.b.copy(r.vertexNormals[1]),
                    c.c.copy(r.vertexNormals[2])
            }
            for (i = 0,
            n = this.faces.length; i < n; i++)
                (r = this.faces[i]).normal = r.__originalFaceNormal,
                r.vertexNormals = r.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new $t),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Kt),
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(e, t, i) {
            if (e && e.isGeometry) {
                var n, r = this.vertices.length, s = this.vertices, a = e.vertices, o = this.faces, l = e.faces, c = this.faceVertexUvs[0], h = e.faceVertexUvs[0], u = this.colors, p = e.colors;
                void 0 === i && (i = 0),
                void 0 !== t && (n = (new Lt).getNormalMatrix(t));
                for (var d = 0, f = a.length; d < f; d++) {
                    var m = a[d].clone();
                    void 0 !== t && m.applyMatrix4(t),
                    s.push(m)
                }
                for (d = 0,
                f = p.length; d < f; d++)
                    u.push(p[d].clone());
                for (d = 0,
                f = l.length; d < f; d++) {
                    var g, v, y, b = l[d], x = b.vertexNormals, w = b.vertexColors;
                    (g = new gi(b.a + r,b.b + r,b.c + r)).normal.copy(b.normal),
                    void 0 !== n && g.normal.applyMatrix3(n).normalize();
                    for (var _ = 0, T = x.length; _ < T; _++)
                        v = x[_].clone(),
                        void 0 !== n && v.applyMatrix3(n).normalize(),
                        g.vertexNormals.push(v);
                    g.color.copy(b.color);
                    for (_ = 0,
                    T = w.length; _ < T; _++)
                        y = w[_],
                        g.vertexColors.push(y.clone());
                    g.materialIndex = b.materialIndex + i,
                    o.push(g)
                }
                for (d = 0,
                f = h.length; d < f; d++) {
                    var M = h[d]
                      , S = [];
                    if (void 0 !== M) {
                        for (_ = 0,
                        T = M.length; _ < T; _++)
                            S.push(M[_].clone());
                        c.push(S)
                    }
                }
            }
        },
        mergeMesh: function(e) {
            e && e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(),
            this.merge(e.geometry, e.matrix))
        },
        mergeVertices: function() {
            var e, t, i, n, r, s, a, o, l = {}, c = [], h = [], u = Math.pow(10, 4);
            for (i = 0,
            n = this.vertices.length; i < n; i++)
                e = this.vertices[i],
                void 0 === l[t = Math.round(e.x * u) + "_" + Math.round(e.y * u) + "_" + Math.round(e.z * u)] ? (l[t] = i,
                c.push(this.vertices[i]),
                h[i] = c.length - 1) : h[i] = h[l[t]];
            var p = [];
            for (i = 0,
            n = this.faces.length; i < n; i++) {
                (r = this.faces[i]).a = h[r.a],
                r.b = h[r.b],
                r.c = h[r.c],
                s = [r.a, r.b, r.c];
                for (var d = 0; d < 3; d++)
                    if (s[d] === s[(d + 1) % 3]) {
                        p.push(i);
                        break
                    }
            }
            for (i = p.length - 1; i >= 0; i--) {
                var f = p[i];
                for (this.faces.splice(f, 1),
                a = 0,
                o = this.faceVertexUvs.length; a < o; a++)
                    this.faceVertexUvs[a].splice(f, 1)
            }
            var m = this.vertices.length - c.length;
            return this.vertices = c,
            m
        },
        setFromPoints: function(e) {
            this.vertices = [];
            for (var t = 0, i = e.length; t < i; t++) {
                var n = e[t];
                this.vertices.push(new Ct(n.x,n.y,n.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var e = this.faces, t = e.length, i = 0; i < t; i++)
                e[i]._id = i;
            e.sort(function(e, t) {
                return e.materialIndex - t.materialIndex
            });
            var n, r, s = this.faceVertexUvs[0], a = this.faceVertexUvs[1];
            s && s.length === t && (n = []),
            a && a.length === t && (r = []);
            for (i = 0; i < t; i++) {
                var o = e[i]._id;
                n && n.push(s[o]),
                r && r.push(a[o])
            }
            n && (this.faceVertexUvs[0] = n),
            r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            void 0 !== this.parameters) {
                var t = this.parameters;
                for (var i in t)
                    void 0 !== t[i] && (e[i] = t[i]);
                return e
            }
            for (var n = [], r = 0; r < this.vertices.length; r++) {
                var s = this.vertices[r];
                n.push(s.x, s.y, s.z)
            }
            var a = []
              , o = []
              , l = {}
              , c = []
              , h = {}
              , u = []
              , p = {};
            for (r = 0; r < this.faces.length; r++) {
                var d = this.faces[r]
                  , f = void 0 !== this.faceVertexUvs[0][r]
                  , m = d.normal.length() > 0
                  , g = d.vertexNormals.length > 0
                  , v = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b
                  , y = d.vertexColors.length > 0
                  , b = 0;
                if (b = T(b, 0, 0),
                b = T(b, 1, !0),
                b = T(b, 2, !1),
                b = T(b, 3, f),
                b = T(b, 4, m),
                b = T(b, 5, g),
                b = T(b, 6, v),
                b = T(b, 7, y),
                a.push(b),
                a.push(d.a, d.b, d.c),
                a.push(d.materialIndex),
                f) {
                    var x = this.faceVertexUvs[0][r];
                    a.push(A(x[0]), A(x[1]), A(x[2]))
                }
                if (m && a.push(M(d.normal)),
                g) {
                    var w = d.vertexNormals;
                    a.push(M(w[0]), M(w[1]), M(w[2]))
                }
                if (v && a.push(S(d.color)),
                y) {
                    var _ = d.vertexColors;
                    a.push(S(_[0]), S(_[1]), S(_[2]))
                }
            }
            function T(e, t, i) {
                return i ? e | 1 << t : e & ~(1 << t)
            }
            function M(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== l[t] ? l[t] : (l[t] = o.length / 3,
                o.push(e.x, e.y, e.z),
                l[t])
            }
            function S(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== h[t] ? h[t] : (h[t] = c.length,
                c.push(e.getHex()),
                h[t])
            }
            function A(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== p[t] ? p[t] : (p[t] = u.length / 2,
                u.push(e.x, e.y),
                p[t])
            }
            return e.data = {},
            e.data.vertices = n,
            e.data.normals = o,
            c.length > 0 && (e.data.colors = c),
            u.length > 0 && (e.data.uvs = [u]),
            e.data.faces = a,
            e
        },
        clone: function() {
            return (new Ci).copy(this)
        },
        copy: function(e) {
            var t, i, n, r, s, a;
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = e.name;
            var o = e.vertices;
            for (t = 0,
            i = o.length; t < i; t++)
                this.vertices.push(o[t].clone());
            var l = e.colors;
            for (t = 0,
            i = l.length; t < i; t++)
                this.colors.push(l[t].clone());
            var c = e.faces;
            for (t = 0,
            i = c.length; t < i; t++)
                this.faces.push(c[t].clone());
            for (t = 0,
            i = e.faceVertexUvs.length; t < i; t++) {
                var h = e.faceVertexUvs[t];
                for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []),
                n = 0,
                r = h.length; n < r; n++) {
                    var u = h[n]
                      , p = [];
                    for (s = 0,
                    a = u.length; s < a; s++) {
                        var d = u[s];
                        p.push(d.clone())
                    }
                    this.faceVertexUvs[t].push(p)
                }
            }
            var f = e.morphTargets;
            for (t = 0,
            i = f.length; t < i; t++) {
                var m = {};
                if (m.name = f[t].name,
                void 0 !== f[t].vertices)
                    for (m.vertices = [],
                    n = 0,
                    r = f[t].vertices.length; n < r; n++)
                        m.vertices.push(f[t].vertices[n].clone());
                if (void 0 !== f[t].normals)
                    for (m.normals = [],
                    n = 0,
                    r = f[t].normals.length; n < r; n++)
                        m.normals.push(f[t].normals[n].clone());
                this.morphTargets.push(m)
            }
            var g = e.morphNormals;
            for (t = 0,
            i = g.length; t < i; t++) {
                var v = {};
                if (void 0 !== g[t].vertexNormals)
                    for (v.vertexNormals = [],
                    n = 0,
                    r = g[t].vertexNormals.length; n < r; n++) {
                        var y = g[t].vertexNormals[n]
                          , b = {};
                        b.a = y.a.clone(),
                        b.b = y.b.clone(),
                        b.c = y.c.clone(),
                        v.vertexNormals.push(b)
                    }
                if (void 0 !== g[t].faceNormals)
                    for (v.faceNormals = [],
                    n = 0,
                    r = g[t].faceNormals.length; n < r; n++)
                        v.faceNormals.push(g[t].faceNormals[n].clone());
                this.morphNormals.push(v)
            }
            var x = e.skinWeights;
            for (t = 0,
            i = x.length; t < i; t++)
                this.skinWeights.push(x[t].clone());
            var w = e.skinIndices;
            for (t = 0,
            i = w.length; t < i; t++)
                this.skinIndices.push(w[t].clone());
            var _ = e.lineDistances;
            for (t = 0,
            i = _.length; t < i; t++)
                this.lineDistances.push(_[t]);
            var T = e.boundingBox;
            null !== T && (this.boundingBox = T.clone());
            var M = e.boundingSphere;
            return null !== M && (this.boundingSphere = M.clone()),
            this.elementsNeedUpdate = e.elementsNeedUpdate,
            this.verticesNeedUpdate = e.verticesNeedUpdate,
            this.uvsNeedUpdate = e.uvsNeedUpdate,
            this.normalsNeedUpdate = e.normalsNeedUpdate,
            this.colorsNeedUpdate = e.colorsNeedUpdate,
            this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = e.groupsNeedUpdate,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(Li.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(Li.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.itemSize : 0,
            this.array = e,
            this
        },
        setDynamic: function(e) {
            return this.dynamic = e,
            this
        },
        copy: function(e) {
            return this.name = e.name,
            this.array = new e.array.constructor(e.array),
            this.itemSize = e.itemSize,
            this.count = e.count,
            this.normalized = e.normalized,
            this.dynamic = e.dynamic,
            this
        },
        copyAt: function(e, t, i) {
            e *= this.itemSize,
            i *= t.itemSize;
            for (var n = 0, r = this.itemSize; n < r; n++)
                this.array[e + n] = t.array[i + n];
            return this
        },
        copyArray: function(e) {
            return this.array.set(e),
            this
        },
        copyColorsArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var s = e[n];
                void 0 === s && (s = new hi),
                t[i++] = s.r,
                t[i++] = s.g,
                t[i++] = s.b
            }
            return this
        },
        copyVector2sArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var s = e[n];
                void 0 === s && (s = new At),
                t[i++] = s.x,
                t[i++] = s.y
            }
            return this
        },
        copyVector3sArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var s = e[n];
                void 0 === s && (s = new Ct),
                t[i++] = s.x,
                t[i++] = s.y,
                t[i++] = s.z
            }
            return this
        },
        copyVector4sArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var s = e[n];
                void 0 === s && (s = new qt),
                t[i++] = s.x,
                t[i++] = s.y,
                t[i++] = s.z,
                t[i++] = s.w
            }
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0),
            this.array.set(e, t),
            this
        },
        getX: function(e) {
            return this.array[e * this.itemSize]
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t,
            this
        },
        getY: function(e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t,
            this
        },
        getZ: function(e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t,
            this
        },
        getW: function(e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function(e, t) {
            return this.array[e * this.itemSize + 3] = t,
            this
        },
        setXY: function(e, t, i) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = i,
            this
        },
        setXYZ: function(e, t, i, n) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = i,
            this.array[e + 2] = n,
            this
        },
        setXYZW: function(e, t, i, n, r) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = i,
            this.array[e + 2] = n,
            this.array[e + 3] = r,
            this
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        }
    }),
    ki.prototype = Object.create(Li.prototype),
    ki.prototype.constructor = ki,
    Ei.prototype = Object.create(Li.prototype),
    Ei.prototype.constructor = Ei,
    Ii.prototype = Object.create(Li.prototype),
    Ii.prototype.constructor = Ii,
    Fi.prototype = Object.create(Li.prototype),
    Fi.prototype.constructor = Fi,
    Oi.prototype = Object.create(Li.prototype),
    Oi.prototype.constructor = Oi,
    Ri.prototype = Object.create(Li.prototype),
    Ri.prototype.constructor = Ri,
    zi.prototype = Object.create(Li.prototype),
    zi.prototype.constructor = zi,
    Ni.prototype = Object.create(Li.prototype),
    Ni.prototype.constructor = Ni,
    Di.prototype = Object.create(Li.prototype),
    Di.prototype.constructor = Di,
    Object.assign(Ui.prototype, {
        computeGroups: function(e) {
            for (var t, i = [], n = void 0, r = e.faces, s = 0; s < r.length; s++) {
                var a = r[s];
                a.materialIndex !== n && (n = a.materialIndex,
                void 0 !== t && (t.count = 3 * s - t.start,
                i.push(t)),
                t = {
                    start: 3 * s,
                    materialIndex: n
                })
            }
            void 0 !== t && (t.count = 3 * s - t.start,
            i.push(t)),
            this.groups = i
        },
        fromGeometry: function(e) {
            var t, i = e.faces, n = e.vertices, r = e.faceVertexUvs, s = r[0] && r[0].length > 0, a = r[1] && r[1].length > 0, o = e.morphTargets, l = o.length;
            if (l > 0) {
                t = [];
                for (var c = 0; c < l; c++)
                    t[c] = {
                        name: o[c].name,
                        data: []
                    };
                this.morphTargets.position = t
            }
            var h, u = e.morphNormals, p = u.length;
            if (p > 0) {
                h = [];
                for (c = 0; c < p; c++)
                    h[c] = {
                        name: u[c].name,
                        data: []
                    };
                this.morphTargets.normal = h
            }
            var d = e.skinIndices
              , f = e.skinWeights
              , m = d.length === n.length
              , g = f.length === n.length;
            n.length > 0 && i.length;
            for (c = 0; c < i.length; c++) {
                var v = i[c];
                this.vertices.push(n[v.a], n[v.b], n[v.c]);
                var y = v.vertexNormals;
                if (3 === y.length)
                    this.normals.push(y[0], y[1], y[2]);
                else {
                    var b = v.normal;
                    this.normals.push(b, b, b)
                }
                var x, w = v.vertexColors;
                if (3 === w.length)
                    this.colors.push(w[0], w[1], w[2]);
                else {
                    var _ = v.color;
                    this.colors.push(_, _, _)
                }
                if (!0 === s)
                    void 0 !== (x = r[0][c]) ? this.uvs.push(x[0], x[1], x[2]) : this.uvs.push(new At, new At, new At);
                if (!0 === a)
                    void 0 !== (x = r[1][c]) ? this.uvs2.push(x[0], x[1], x[2]) : this.uvs2.push(new At, new At, new At);
                for (var T = 0; T < l; T++) {
                    var M = o[T].vertices;
                    t[T].data.push(M[v.a], M[v.b], M[v.c])
                }
                for (T = 0; T < p; T++) {
                    var S = u[T].vertexNormals[c];
                    h[T].data.push(S.a, S.b, S.c)
                }
                m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]),
                g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
            }
            return this.computeGroups(e),
            this.verticesNeedUpdate = e.verticesNeedUpdate,
            this.normalsNeedUpdate = e.normalsNeedUpdate,
            this.colorsNeedUpdate = e.colorsNeedUpdate,
            this.uvsNeedUpdate = e.uvsNeedUpdate,
            this.groupsNeedUpdate = e.groupsNeedUpdate,
            this
        }
    });
    var ji = 1;
    function Vi() {
        Object.defineProperty(this, "id", {
            value: ji += 2
        }),
        this.uuid = St.generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    function Gi(e, t, i, n, r, s) {
        Ci.call(this),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: s
        },
        this.fromBufferGeometry(new Xi(e,t,i,n,r,s)),
        this.mergeVertices()
    }
    function Xi(e, t, i, n, r, s) {
        Vi.call(this),
        this.type = "BoxBufferGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: s
        };
        var a = this;
        e = e || 1,
        t = t || 1,
        i = i || 1,
        n = Math.floor(n) || 1,
        r = Math.floor(r) || 1,
        s = Math.floor(s) || 1;
        var o = []
          , l = []
          , c = []
          , h = []
          , u = 0
          , p = 0;
        function d(e, t, i, n, r, s, d, f, m, g, v) {
            var y, b, x = s / m, w = d / g, _ = s / 2, T = d / 2, M = f / 2, S = m + 1, A = g + 1, P = 0, C = 0, L = new Ct;
            for (b = 0; b < A; b++) {
                var k = b * w - T;
                for (y = 0; y < S; y++) {
                    var E = y * x - _;
                    L[e] = E * n,
                    L[t] = k * r,
                    L[i] = M,
                    l.push(L.x, L.y, L.z),
                    L[e] = 0,
                    L[t] = 0,
                    L[i] = f > 0 ? 1 : -1,
                    c.push(L.x, L.y, L.z),
                    h.push(y / m),
                    h.push(1 - b / g),
                    P += 1
                }
            }
            for (b = 0; b < g; b++)
                for (y = 0; y < m; y++) {
                    var I = u + y + S * b
                      , F = u + y + S * (b + 1)
                      , O = u + (y + 1) + S * (b + 1)
                      , R = u + (y + 1) + S * b;
                    o.push(I, F, R),
                    o.push(F, O, R),
                    C += 6
                }
            a.addGroup(p, C, v),
            p += C,
            u += P
        }
        d("z", "y", "x", -1, -1, i, t, e, s, r, 0),
        d("z", "y", "x", 1, -1, i, t, -e, s, r, 1),
        d("x", "z", "y", 1, 1, e, i, t, n, s, 2),
        d("x", "z", "y", 1, -1, e, i, -t, n, s, 3),
        d("x", "y", "z", 1, -1, e, t, i, n, r, 4),
        d("x", "y", "z", -1, -1, e, t, -i, n, r, 5),
        this.setIndex(o),
        this.addAttribute("position", new Ni(l,3)),
        this.addAttribute("normal", new Ni(c,3)),
        this.addAttribute("uv", new Ni(h,2))
    }
    function Yi(e, t, i, n) {
        Ci.call(this),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        },
        this.fromBufferGeometry(new Wi(e,t,i,n)),
        this.mergeVertices()
    }
    function Wi(e, t, i, n) {
        Vi.call(this),
        this.type = "PlaneBufferGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        };
        var r, s, a = (e = e || 1) / 2, o = (t = t || 1) / 2, l = Math.floor(i) || 1, c = Math.floor(n) || 1, h = l + 1, u = c + 1, p = e / l, d = t / c, f = [], m = [], g = [], v = [];
        for (s = 0; s < u; s++) {
            var y = s * d - o;
            for (r = 0; r < h; r++) {
                var b = r * p - a;
                m.push(b, -y, 0),
                g.push(0, 0, 1),
                v.push(r / l),
                v.push(1 - s / c)
            }
        }
        for (s = 0; s < c; s++)
            for (r = 0; r < l; r++) {
                var x = r + h * s
                  , w = r + h * (s + 1)
                  , _ = r + 1 + h * (s + 1)
                  , T = r + 1 + h * s;
                f.push(x, w, T),
                f.push(w, _, T)
            }
        this.setIndex(f),
        this.addAttribute("position", new Ni(m,3)),
        this.addAttribute("normal", new Ni(g,3)),
        this.addAttribute("uv", new Ni(v,2))
    }
    Vi.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Vi,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(e) {
            Array.isArray(e) ? this.index = new (Bi(e) > 65535 ? zi : Oi)(e,1) : this.index = e
        },
        addAttribute: function(e, t) {
            return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (this.setIndex(t),
            this) : (this.attributes[e] = t,
            this) : this.addAttribute(e, new Li(arguments[1],arguments[2]))
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        removeAttribute: function(e) {
            return delete this.attributes[e],
            this
        },
        addGroup: function(e, t, i) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== i ? i : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(e, t) {
            this.drawRange.start = e,
            this.drawRange.count = t
        },
        applyMatrix: function(e) {
            var t = this.attributes.position;
            void 0 !== t && (e.applyToBufferAttribute(t),
            t.needsUpdate = !0);
            var i = this.attributes.normal;
            void 0 !== i && ((new Lt).getNormalMatrix(e).applyToBufferAttribute(i),
            i.needsUpdate = !0);
            var n = this.attributes.tangent;
            void 0 !== n && ((new Lt).getNormalMatrix(e).applyToBufferAttribute(n),
            n.needsUpdate = !0);
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: function() {
            var e = new ii;
            return function(t) {
                return e.makeRotationX(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateY: function() {
            var e = new ii;
            return function(t) {
                return e.makeRotationY(t),
                this.applyMatrix(e),
                this
            }
        }(),
        rotateZ: function() {
            var e = new ii;
            return function(t) {
                return e.makeRotationZ(t),
                this.applyMatrix(e),
                this
            }
        }(),
        translate: function() {
            var e = new ii;
            return function(t, i, n) {
                return e.makeTranslation(t, i, n),
                this.applyMatrix(e),
                this
            }
        }(),
        scale: function() {
            var e = new ii;
            return function(t, i, n) {
                return e.makeScale(t, i, n),
                this.applyMatrix(e),
                this
            }
        }(),
        lookAt: function() {
            var e = new Mi;
            return function(t) {
                e.lookAt(t),
                e.updateMatrix(),
                this.applyMatrix(e.matrix)
            }
        }(),
        center: function() {
            var e = new Ct;
            return function() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(e).negate(),
                this.translate(e.x, e.y, e.z),
                this
            }
        }(),
        setFromObject: function(e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                var i = new Ni(3 * t.vertices.length,3)
                  , n = new Ni(3 * t.colors.length,3);
                if (this.addAttribute("position", i.copyVector3sArray(t.vertices)),
                this.addAttribute("color", n.copyColorsArray(t.colors)),
                t.lineDistances && t.lineDistances.length === t.vertices.length) {
                    var r = new Ni(t.lineDistances.length,1);
                    this.addAttribute("lineDistance", r.copyArray(t.lineDistances))
                }
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else
                e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        },
        setFromPoints: function(e) {
            for (var t = [], i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.push(r.x, r.y, r.z || 0)
            }
            return this.addAttribute("position", new Ni(t,3)),
            this
        },
        updateFromObject: function(e) {
            var t, i = e.geometry;
            if (e.isMesh) {
                var n = i.__directGeometry;
                if (!0 === i.elementsNeedUpdate && (n = void 0,
                i.elementsNeedUpdate = !1),
                void 0 === n)
                    return this.fromGeometry(i);
                n.verticesNeedUpdate = i.verticesNeedUpdate,
                n.normalsNeedUpdate = i.normalsNeedUpdate,
                n.colorsNeedUpdate = i.colorsNeedUpdate,
                n.uvsNeedUpdate = i.uvsNeedUpdate,
                n.groupsNeedUpdate = i.groupsNeedUpdate,
                i.verticesNeedUpdate = !1,
                i.normalsNeedUpdate = !1,
                i.colorsNeedUpdate = !1,
                i.uvsNeedUpdate = !1,
                i.groupsNeedUpdate = !1,
                i = n
            }
            return !0 === i.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(i.vertices),
            t.needsUpdate = !0),
            i.verticesNeedUpdate = !1),
            !0 === i.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(i.normals),
            t.needsUpdate = !0),
            i.normalsNeedUpdate = !1),
            !0 === i.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(i.colors),
            t.needsUpdate = !0),
            i.colorsNeedUpdate = !1),
            i.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(i.uvs),
            t.needsUpdate = !0),
            i.uvsNeedUpdate = !1),
            i.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(i.lineDistances),
            t.needsUpdate = !0),
            i.lineDistancesNeedUpdate = !1),
            i.groupsNeedUpdate && (i.computeGroups(e.geometry),
            this.groups = i.groups,
            i.groupsNeedUpdate = !1),
            this
        },
        fromGeometry: function(e) {
            return e.__directGeometry = (new Ui).fromGeometry(e),
            this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function(e) {
            var t = new Float32Array(3 * e.vertices.length);
            if (this.addAttribute("position", new Li(t,3).copyVector3sArray(e.vertices)),
            e.normals.length > 0) {
                var i = new Float32Array(3 * e.normals.length);
                this.addAttribute("normal", new Li(i,3).copyVector3sArray(e.normals))
            }
            if (e.colors.length > 0) {
                var n = new Float32Array(3 * e.colors.length);
                this.addAttribute("color", new Li(n,3).copyColorsArray(e.colors))
            }
            if (e.uvs.length > 0) {
                var r = new Float32Array(2 * e.uvs.length);
                this.addAttribute("uv", new Li(r,2).copyVector2sArray(e.uvs))
            }
            if (e.uvs2.length > 0) {
                var s = new Float32Array(2 * e.uvs2.length);
                this.addAttribute("uv2", new Li(s,2).copyVector2sArray(e.uvs2))
            }
            for (var a in this.groups = e.groups,
            e.morphTargets) {
                for (var o = [], l = e.morphTargets[a], c = 0, h = l.length; c < h; c++) {
                    var u = l[c]
                      , p = new Ni(3 * u.data.length,3);
                    p.name = u.name,
                    o.push(p.copyVector3sArray(u.data))
                }
                this.morphAttributes[a] = o
            }
            if (e.skinIndices.length > 0) {
                var d = new Ni(4 * e.skinIndices.length,4);
                this.addAttribute("skinIndex", d.copyVector4sArray(e.skinIndices))
            }
            if (e.skinWeights.length > 0) {
                var f = new Ni(4 * e.skinWeights.length,4);
                this.addAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
            }
            return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            this
        },
        computeBoundingBox: function() {
            var e = new $t;
            return function() {
                null === this.boundingBox && (this.boundingBox = new $t);
                var t = this.attributes.position
                  , i = this.morphAttributes.position;
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t),
                    i)
                        for (var n = 0, r = i.length; n < r; n++) {
                            var s = i[n];
                            e.setFromBufferAttribute(s),
                            this.boundingBox.expandByPoint(e.min),
                            this.boundingBox.expandByPoint(e.max)
                        }
                } else
                    this.boundingBox.makeEmpty();
                isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
            }
        }(),
        computeBoundingSphere: function() {
            var e = new $t
              , t = new $t
              , i = new Ct;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new Kt);
                var n = this.attributes.position
                  , r = this.morphAttributes.position;
                if (n) {
                    var s = this.boundingSphere.center;
                    if (e.setFromBufferAttribute(n),
                    r)
                        for (var a = 0, o = r.length; a < o; a++) {
                            var l = r[a];
                            t.setFromBufferAttribute(l),
                            e.expandByPoint(t.min),
                            e.expandByPoint(t.max)
                        }
                    e.getCenter(s);
                    var c = 0;
                    for (a = 0,
                    o = n.count; a < o; a++)
                        i.fromBufferAttribute(n, a),
                        c = Math.max(c, s.distanceToSquared(i));
                    if (r)
                        for (a = 0,
                        o = r.length; a < o; a++)
                            for (var h = 0, u = (l = r[a]).count; h < u; h++)
                                i.fromBufferAttribute(l, h),
                                c = Math.max(c, s.distanceToSquared(i));
                    this.boundingSphere.radius = Math.sqrt(c),
                    isNaN(this.boundingSphere.radius)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var e = this.index
              , t = this.attributes;
            if (t.position) {
                var i = t.position.array;
                if (void 0 === t.normal)
                    this.addAttribute("normal", new Li(new Float32Array(i.length),3));
                else
                    for (var n = t.normal.array, r = 0, s = n.length; r < s; r++)
                        n[r] = 0;
                var a, o, l, c = t.normal.array, h = new Ct, u = new Ct, p = new Ct, d = new Ct, f = new Ct;
                if (e) {
                    var m = e.array;
                    for (r = 0,
                    s = e.count; r < s; r += 3)
                        a = 3 * m[r + 0],
                        o = 3 * m[r + 1],
                        l = 3 * m[r + 2],
                        h.fromArray(i, a),
                        u.fromArray(i, o),
                        p.fromArray(i, l),
                        d.subVectors(p, u),
                        f.subVectors(h, u),
                        d.cross(f),
                        c[a] += d.x,
                        c[a + 1] += d.y,
                        c[a + 2] += d.z,
                        c[o] += d.x,
                        c[o + 1] += d.y,
                        c[o + 2] += d.z,
                        c[l] += d.x,
                        c[l + 1] += d.y,
                        c[l + 2] += d.z
                } else
                    for (r = 0,
                    s = i.length; r < s; r += 9)
                        h.fromArray(i, r),
                        u.fromArray(i, r + 3),
                        p.fromArray(i, r + 6),
                        d.subVectors(p, u),
                        f.subVectors(h, u),
                        d.cross(f),
                        c[r] = d.x,
                        c[r + 1] = d.y,
                        c[r + 2] = d.z,
                        c[r + 3] = d.x,
                        c[r + 4] = d.y,
                        c[r + 5] = d.z,
                        c[r + 6] = d.x,
                        c[r + 7] = d.y,
                        c[r + 8] = d.z;
                this.normalizeNormals(),
                t.normal.needsUpdate = !0
            }
        },
        merge: function(e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0);
                var i = this.attributes;
                for (var n in i)
                    if (void 0 !== e.attributes[n])
                        for (var r = i[n].array, s = e.attributes[n], a = s.array, o = s.itemSize * t, l = Math.min(a.length, r.length - o), c = 0, h = o; c < l; c++,
                        h++)
                            r[h] = a[c];
                return this
            }
        },
        normalizeNormals: function() {
            var e = new Ct;
            return function() {
                for (var t = this.attributes.normal, i = 0, n = t.count; i < n; i++)
                    e.x = t.getX(i),
                    e.y = t.getY(i),
                    e.z = t.getZ(i),
                    e.normalize(),
                    t.setXYZ(i, e.x, e.y, e.z)
            }
        }(),
        toNonIndexed: function() {
            function e(e, t) {
                for (var i = e.array, n = e.itemSize, r = new i.constructor(t.length * n), s = 0, a = 0, o = 0, l = t.length; o < l; o++) {
                    s = t[o] * n;
                    for (var c = 0; c < n; c++)
                        r[a++] = i[s++]
                }
                return new Li(r,n)
            }
            if (null === this.index)
                return this;
            var t = new Vi
              , i = this.index.array
              , n = this.attributes;
            for (var r in n) {
                var s = e(n[r], i);
                t.addAttribute(r, s)
            }
            var a = this.morphAttributes;
            for (r in a) {
                for (var o = [], l = a[r], c = 0, h = l.length; c < h; c++) {
                    s = e(l[c], i);
                    o.push(s)
                }
                t.morphAttributes[r] = o
            }
            for (var u = this.groups, p = (c = 0,
            u.length); c < p; c++) {
                var d = u[c];
                t.addGroup(d.start, d.count, d.materialIndex)
            }
            return t
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
            void 0 !== this.parameters) {
                var t = this.parameters;
                for (var i in t)
                    void 0 !== t[i] && (e[i] = t[i]);
                return e
            }
            e.data = {
                attributes: {}
            };
            var n = this.index;
            null !== n && (e.data.index = {
                type: n.array.constructor.name,
                array: Array.prototype.slice.call(n.array)
            });
            var r = this.attributes;
            for (var i in r) {
                var s = {
                    itemSize: (p = r[i]).itemSize,
                    type: p.array.constructor.name,
                    array: Array.prototype.slice.call(p.array),
                    normalized: p.normalized
                };
                "" !== p.name && (s.name = p.name),
                e.data.attributes[i] = s
            }
            var a = {}
              , o = !1;
            for (var i in this.morphAttributes) {
                for (var l = this.morphAttributes[i], c = [], h = 0, u = l.length; h < u; h++) {
                    var p;
                    s = {
                        itemSize: (p = l[h]).itemSize,
                        type: p.array.constructor.name,
                        array: Array.prototype.slice.call(p.array),
                        normalized: p.normalized
                    };
                    "" !== p.name && (s.name = p.name),
                    c.push(s)
                }
                c.length > 0 && (a[i] = c,
                o = !0)
            }
            o && (e.data.morphAttributes = a);
            var d = this.groups;
            d.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(d)));
            var f = this.boundingSphere;
            return null !== f && (e.data.boundingSphere = {
                center: f.center.toArray(),
                radius: f.radius
            }),
            e
        },
        clone: function() {
            return (new Vi).copy(this)
        },
        copy: function(e) {
            var t, i, n;
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = e.name;
            var r = e.index;
            null !== r && this.setIndex(r.clone());
            var s = e.attributes;
            for (t in s) {
                var a = s[t];
                this.addAttribute(t, a.clone())
            }
            var o = e.morphAttributes;
            for (t in o) {
                var l = []
                  , c = o[t];
                for (i = 0,
                n = c.length; i < n; i++)
                    l.push(c[i].clone());
                this.morphAttributes[t] = l
            }
            var h = e.groups;
            for (i = 0,
            n = h.length; i < n; i++) {
                var u = h[i];
                this.addGroup(u.start, u.count, u.materialIndex)
            }
            var p = e.boundingBox;
            null !== p && (this.boundingBox = p.clone());
            var d = e.boundingSphere;
            return null !== d && (this.boundingSphere = d.clone()),
            this.drawRange.start = e.drawRange.start,
            this.drawRange.count = e.drawRange.count,
            this.userData = e.userData,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Gi.prototype = Object.create(Ci.prototype),
    Gi.prototype.constructor = Gi,
    Xi.prototype = Object.create(Vi.prototype),
    Xi.prototype.constructor = Xi,
    Yi.prototype = Object.create(Ci.prototype),
    Yi.prototype.constructor = Yi,
    Wi.prototype = Object.create(Vi.prototype),
    Wi.prototype.constructor = Wi;
    var qi = 0;
    function Hi() {
        Object.defineProperty(this, "id", {
            value: qi++
        }),
        this.uuid = St.generateUUID(),
        this.name = "",
        this.type = "Material",
        this.fog = !0,
        this.lights = !0,
        this.blending = x,
        this.side = d,
        this.flatShading = !1,
        this.vertexTangents = !1,
        this.vertexColors = g,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = O,
        this.blendDst = R,
        this.blendEquation = S,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = X,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.userData = {},
        this.needsUpdate = !0
    }
    Hi.prototype = Object.assign(Object.create(n.prototype), {
        constructor: Hi,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var i = e[t];
                    if (void 0 !== i)
                        if ("shading" !== t) {
                            var n = this[t];
                            void 0 !== n && (n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i)
                        } else
                            this.flatShading = 1 === i
                }
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            function n(e) {
                var t = [];
                for (var i in e) {
                    var n = e[i];
                    delete n.metadata,
                    t.push(n)
                }
                return t
            }
            if (i.uuid = this.uuid,
            i.type = this.type,
            "" !== this.name && (i.name = this.name),
            this.color && this.color.isColor && (i.color = this.color.getHex()),
            void 0 !== this.roughness && (i.roughness = this.roughness),
            void 0 !== this.metalness && (i.metalness = this.metalness),
            this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
            1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
            void 0 !== this.shininess && (i.shininess = this.shininess),
            void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat),
            void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness),
            this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
            this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid),
            this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
            i.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
            i.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
            i.normalMapType = this.normalMapType,
            i.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
            i.displacementScale = this.displacementScale,
            i.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
            i.reflectivity = this.reflectivity,
            void 0 !== this.combine && (i.combine = this.combine),
            void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)),
            this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.size && (i.size = this.size),
            void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
            this.blending !== x && (i.blending = this.blending),
            !0 === this.flatShading && (i.flatShading = this.flatShading),
            this.side !== d && (i.side = this.side),
            this.vertexColors !== g && (i.vertexColors = this.vertexColors),
            this.opacity < 1 && (i.opacity = this.opacity),
            !0 === this.transparent && (i.transparent = this.transparent),
            i.depthFunc = this.depthFunc,
            i.depthTest = this.depthTest,
            i.depthWrite = this.depthWrite,
            0 !== this.rotation && (i.rotation = this.rotation),
            !0 === this.polygonOffset && (i.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits),
            1 !== this.linewidth && (i.linewidth = this.linewidth),
            void 0 !== this.dashSize && (i.dashSize = this.dashSize),
            void 0 !== this.gapSize && (i.gapSize = this.gapSize),
            void 0 !== this.scale && (i.scale = this.scale),
            !0 === this.dithering && (i.dithering = !0),
            this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (i.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (i.morphTargets = !0),
            !0 === this.skinning && (i.skinning = !0),
            !1 === this.visible && (i.visible = !1),
            "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
            t) {
                var r = n(e.textures)
                  , s = n(e.images);
                r.length > 0 && (i.textures = r),
                s.length > 0 && (i.images = s)
            }
            return i
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.name = e.name,
            this.fog = e.fog,
            this.lights = e.lights,
            this.blending = e.blending,
            this.side = e.side,
            this.flatShading = e.flatShading,
            this.vertexColors = e.vertexColors,
            this.opacity = e.opacity,
            this.transparent = e.transparent,
            this.blendSrc = e.blendSrc,
            this.blendDst = e.blendDst,
            this.blendEquation = e.blendEquation,
            this.blendSrcAlpha = e.blendSrcAlpha,
            this.blendDstAlpha = e.blendDstAlpha,
            this.blendEquationAlpha = e.blendEquationAlpha,
            this.depthFunc = e.depthFunc,
            this.depthTest = e.depthTest,
            this.depthWrite = e.depthWrite,
            this.colorWrite = e.colorWrite,
            this.precision = e.precision,
            this.polygonOffset = e.polygonOffset,
            this.polygonOffsetFactor = e.polygonOffsetFactor,
            this.polygonOffsetUnits = e.polygonOffsetUnits,
            this.dithering = e.dithering,
            this.alphaTest = e.alphaTest,
            this.premultipliedAlpha = e.premultipliedAlpha,
            this.visible = e.visible,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            this.clipShadows = e.clipShadows,
            this.clipIntersection = e.clipIntersection;
            var t = e.clippingPlanes
              , i = null;
            if (null !== t) {
                var n = t.length;
                i = new Array(n);
                for (var r = 0; r !== n; ++r)
                    i[r] = t[r].clone()
            }
            return this.clippingPlanes = i,
            this.shadowSide = e.shadowSide,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    var Qi, Ji, Zi, $i, Ki, en, tn, nn, rn, sn, an, on, ln = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", cn = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    function hn(e) {
        Hi.call(this),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = ln,
        this.fragmentShader = cn,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        void 0 !== e && (e.attributes,
        this.setValues(e))
    }
    function un(e, t) {
        this.origin = void 0 !== e ? e : new Ct,
        this.direction = void 0 !== t ? t : new Ct
    }
    function pn(e, t, i) {
        this.a = void 0 !== e ? e : new Ct,
        this.b = void 0 !== t ? t : new Ct,
        this.c = void 0 !== i ? i : new Ct
    }
    function dn(e) {
        Hi.call(this),
        this.type = "MeshBasicMaterial",
        this.color = new hi(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Q,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function fn(e, t) {
        Mi.call(this),
        this.type = "Mesh",
        this.geometry = void 0 !== e ? e : new Vi,
        this.material = void 0 !== t ? t : new dn({
            color: 16777215 * Math.random()
        }),
        this.drawMode = ut,
        this.updateMorphTargets()
    }
    function mn(e, t, i, n) {
        var r, s, a = new hi(0), o = 0, l = null, c = 0;
        function h(e, i) {
            t.buffers.color.setClear(e.r, e.g, e.b, i, n)
        }
        return {
            getClearColor: function() {
                return a
            },
            setClearColor: function(e, t) {
                a.set(e),
                h(a, o = void 0 !== t ? t : 1)
            },
            getClearAlpha: function() {
                return o
            },
            setClearAlpha: function(e) {
                h(a, o = e)
            },
            render: function(t, n, u, p) {
                var m = n.background
                  , g = e.vr
                  , v = g.getSession && g.getSession();
                if (v && "additive" === v.environmentBlendMode && (m = null),
                null === m ? (h(a, o),
                l = null,
                c = 0) : m && m.isColor && (h(m, 1),
                p = !0,
                l = null,
                c = 0),
                (e.autoClear || p) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                m && (m.isCubeTexture || m.isWebGLRenderTargetCube)) {
                    void 0 === s && ((s = new fn(new Xi(1,1,1),new hn({
                        type: "BackgroundCubeMaterial",
                        uniforms: ri(di.cube.uniforms),
                        vertexShader: di.cube.vertexShader,
                        fragmentShader: di.cube.fragmentShader,
                        side: f,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.removeAttribute("normal"),
                    s.geometry.removeAttribute("uv"),
                    s.onBeforeRender = function(e, t, i) {
                        this.matrixWorld.copyPosition(i.matrixWorld)
                    }
                    ,
                    Object.defineProperty(s.material, "map", {
                        get: function() {
                            return this.uniforms.tCube.value
                        }
                    }),
                    i.update(s));
                    var y = m.isWebGLRenderTargetCube ? m.texture : m;
                    s.material.uniforms.tCube.value = y,
                    s.material.uniforms.tFlip.value = m.isWebGLRenderTargetCube ? 1 : -1,
                    l === m && c === y.version || (s.material.needsUpdate = !0,
                    l = m,
                    c = y.version),
                    t.unshift(s, s.geometry, s.material, 0, 0, null)
                } else
                    m && m.isTexture && (void 0 === r && ((r = new fn(new Wi(2,2),new hn({
                        type: "BackgroundMaterial",
                        uniforms: ri(di.background.uniforms),
                        vertexShader: di.background.vertexShader,
                        fragmentShader: di.background.fragmentShader,
                        side: d,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.removeAttribute("normal"),
                    Object.defineProperty(r.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    i.update(r)),
                    r.material.uniforms.t2D.value = m,
                    !0 === m.matrixAutoUpdate && m.updateMatrix(),
                    r.material.uniforms.uvTransform.value.copy(m.matrix),
                    l === m && c === m.version || (r.material.needsUpdate = !0,
                    l = m,
                    c = m.version),
                    t.unshift(r, r.geometry, r.material, 0, 0, null))
            }
        }
    }
    function gn(e, t, i, n) {
        var r;
        this.setMode = function(e) {
            r = e
        }
        ,
        this.render = function(t, n) {
            e.drawArrays(r, t, n),
            i.update(n, r)
        }
        ,
        this.renderInstances = function(s, a, o) {
            var l;
            if (n.isWebGL2)
                l = e;
            else if (null === (l = t.get("ANGLE_instanced_arrays")))
                return;
            l[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, a, o, s.maxInstancedCount),
            i.update(o, r, s.maxInstancedCount)
        }
    }
    function vn(e, t, i) {
        var n;
        function r(t) {
            if ("highp" === t) {
                if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0)
                    return "highp";
                t = "mediump"
            }
            return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
        }
        var s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext
          , a = void 0 !== i.precision ? i.precision : "highp"
          , o = r(a);
        o !== a && (a = o);
        var l = !0 === i.logarithmicDepthBuffer
          , c = e.getParameter(34930)
          , h = e.getParameter(35660)
          , u = e.getParameter(3379)
          , p = e.getParameter(34076)
          , d = e.getParameter(34921)
          , f = e.getParameter(36347)
          , m = e.getParameter(36348)
          , g = e.getParameter(36349)
          , v = h > 0
          , y = s || !!t.get("OES_texture_float");
        return {
            isWebGL2: s,
            getMaxAnisotropy: function() {
                if (void 0 !== n)
                    return n;
                var i = t.get("EXT_texture_filter_anisotropic");
                return n = null !== i ? e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: r,
            precision: a,
            logarithmicDepthBuffer: l,
            maxTextures: c,
            maxVertexTextures: h,
            maxTextureSize: u,
            maxCubemapSize: p,
            maxAttributes: d,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: s ? e.getParameter(36183) : 0
        }
    }
    function yn() {
        var e = this
          , t = null
          , i = 0
          , n = !1
          , r = !1
          , s = new ei
          , a = new Lt
          , o = {
            value: null,
            needsUpdate: !1
        };
        function l() {
            o.value !== t && (o.value = t,
            o.needsUpdate = i > 0),
            e.numPlanes = i,
            e.numIntersection = 0
        }
        function c(t, i, n, r) {
            var l = null !== t ? t.length : 0
              , c = null;
            if (0 !== l) {
                if (c = o.value,
                !0 !== r || null === c) {
                    var h = n + 4 * l
                      , u = i.matrixWorldInverse;
                    a.getNormalMatrix(u),
                    (null === c || c.length < h) && (c = new Float32Array(h));
                    for (var p = 0, d = n; p !== l; ++p,
                    d += 4)
                        s.copy(t[p]).applyMatrix4(u, a),
                        s.normal.toArray(c, d),
                        c[d + 3] = s.constant
                }
                o.value = c,
                o.needsUpdate = !0
            }
            return e.numPlanes = l,
            c
        }
        this.uniform = o,
        this.numPlanes = 0,
        this.numIntersection = 0,
        this.init = function(e, r, s) {
            var a = 0 !== e.length || r || 0 !== i || n;
            return n = r,
            t = c(e, s, 0),
            i = e.length,
            a
        }
        ,
        this.beginShadows = function() {
            r = !0,
            c(null)
        }
        ,
        this.endShadows = function() {
            r = !1,
            l()
        }
        ,
        this.setState = function(e, s, a, h, u, p) {
            if (!n || null === e || 0 === e.length || r && !a)
                r ? c(null) : l();
            else {
                var d = r ? 0 : i
                  , f = 4 * d
                  , m = u.clippingState || null;
                o.value = m,
                m = c(e, h, f, p);
                for (var g = 0; g !== f; ++g)
                    m[g] = t[g];
                u.clippingState = m,
                this.numIntersection = s ? this.numPlanes : 0,
                this.numPlanes += d
            }
        }
    }
    function bn(e) {
        var t = {};
        return {
            get: function(i) {
                if (void 0 !== t[i])
                    return t[i];
                var n;
                switch (i) {
                case "WEBGL_depth_texture":
                    n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    n = e.getExtension(i)
                }
                return t[i] = n,
                n
            }
        }
    }
    function xn(e, t, i) {
        var n = {}
          , r = {};
        function s(e) {
            var a = e.target
              , o = n[a.id];
            for (var l in null !== o.index && t.remove(o.index),
            o.attributes)
                t.remove(o.attributes[l]);
            a.removeEventListener("dispose", s),
            delete n[a.id];
            var c = r[o.id];
            c && (t.remove(c),
            delete r[o.id]),
            i.memory.geometries--
        }
        return {
            get: function(e, t) {
                var r = n[t.id];
                return r || (t.addEventListener("dispose", s),
                t.isBufferGeometry ? r = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new Vi).setFromObject(e)),
                r = t._bufferGeometry),
                n[t.id] = r,
                i.memory.geometries++,
                r)
            },
            update: function(e) {
                var i = e.index
                  , n = e.attributes;
                for (var r in null !== i && t.update(i, 34963),
                n)
                    t.update(n[r], 34962);
                var s = e.morphAttributes;
                for (var r in s)
                    for (var a = s[r], o = 0, l = a.length; o < l; o++)
                        t.update(a[o], 34962)
            },
            getWireframeAttribute: function(e) {
                var i = r[e.id];
                if (i)
                    return i;
                var n, s = [], a = e.index, o = e.attributes;
                if (null !== a)
                    for (var l = 0, c = (n = a.array).length; l < c; l += 3) {
                        var h = n[l + 0]
                          , u = n[l + 1]
                          , p = n[l + 2];
                        s.push(h, u, u, p, p, h)
                    }
                else
                    for (l = 0,
                    c = (n = o.position.array).length / 3 - 1; l < c; l += 3)
                        h = l + 0,
                        u = l + 1,
                        p = l + 2,
                        s.push(h, u, u, p, p, h);
                return i = new (Bi(s) > 65535 ? zi : Oi)(s,1),
                t.update(i, 34963),
                r[e.id] = i,
                i
            }
        }
    }
    function wn(e, t, i, n) {
        var r, s, a;
        this.setMode = function(e) {
            r = e
        }
        ,
        this.setIndex = function(e) {
            s = e.type,
            a = e.bytesPerElement
        }
        ,
        this.render = function(t, n) {
            e.drawElements(r, n, s, t * a),
            i.update(n, r)
        }
        ,
        this.renderInstances = function(o, l, c) {
            var h;
            if (n.isWebGL2)
                h = e;
            else if (null === (h = t.get("ANGLE_instanced_arrays")))
                return;
            h[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, c, s, l * a, o.maxInstancedCount),
            i.update(c, r, o.maxInstancedCount)
        }
    }
    function _n(e) {
        var t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: t,
            programs: null,
            autoReset: !0,
            reset: function() {
                t.frame++,
                t.calls = 0,
                t.triangles = 0,
                t.points = 0,
                t.lines = 0
            },
            update: function(e, i, n) {
                switch (n = n || 1,
                t.calls++,
                i) {
                case 4:
                    t.triangles += n * (e / 3);
                    break;
                case 5:
                case 6:
                    t.triangles += n * (e - 2);
                    break;
                case 1:
                    t.lines += n * (e / 2);
                    break;
                case 3:
                    t.lines += n * (e - 1);
                    break;
                case 2:
                    t.lines += n * e;
                    break;
                case 0:
                    t.points += n * e
                }
            }
        }
    }
    function Tn(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }
    function Mn(e) {
        var t = {}
          , i = new Float32Array(8);
        return {
            update: function(n, r, s, a) {
                var o = n.morphTargetInfluences
                  , l = o.length
                  , c = t[r.id];
                if (void 0 === c) {
                    c = [];
                    for (var h = 0; h < l; h++)
                        c[h] = [h, 0];
                    t[r.id] = c
                }
                var u = s.morphTargets && r.morphAttributes.position
                  , p = s.morphNormals && r.morphAttributes.normal;
                for (h = 0; h < l; h++)
                    0 !== (d = c[h])[1] && (u && r.removeAttribute("morphTarget" + h),
                    p && r.removeAttribute("morphNormal" + h));
                for (h = 0; h < l; h++)
                    (d = c[h])[0] = h,
                    d[1] = o[h];
                for (c.sort(Tn),
                h = 0; h < 8; h++) {
                    var d;
                    if (d = c[h]) {
                        var f = d[0]
                          , m = d[1];
                        if (m) {
                            u && r.addAttribute("morphTarget" + h, u[f]),
                            p && r.addAttribute("morphNormal" + h, p[f]),
                            i[h] = m;
                            continue
                        }
                    }
                    i[h] = 0
                }
                a.getUniforms().setValue(e, "morphTargetInfluences", i)
            }
        }
    }
    function Sn(e, t) {
        var i = {};
        return {
            update: function(n) {
                var r = t.render.frame
                  , s = n.geometry
                  , a = e.get(n, s);
                return i[a.id] !== r && (s.isGeometry && a.updateFromObject(n),
                e.update(a),
                i[a.id] = r),
                a
            },
            dispose: function() {
                i = {}
            }
        }
    }
    function An(e, t, i, n, r, s, a, o, l, c) {
        e = void 0 !== e ? e : [],
        t = void 0 !== t ? t : re,
        a = void 0 !== a ? a : Fe,
        Wt.call(this, e, t, i, n, r, s, a, o, l, c),
        this.flipY = !1
    }
    function Pn(e, t, i, n) {
        Wt.call(this, null),
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
        },
        this.magFilter = fe,
        this.minFilter = fe,
        this.wrapR = pe,
        this.generateMipmaps = !1,
        this.flipY = !1
    }
    function Cn(e, t, i, n) {
        Wt.call(this, null),
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
        },
        this.magFilter = fe,
        this.minFilter = fe,
        this.wrapR = pe,
        this.generateMipmaps = !1,
        this.flipY = !1
    }
    hn.prototype = Object.create(Hi.prototype),
    hn.prototype.constructor = hn,
    hn.prototype.isShaderMaterial = !0,
    hn.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = ri(e.uniforms),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this.extensions = e.extensions,
        this
    }
    ,
    hn.prototype.toJSON = function(e) {
        var t = Hi.prototype.toJSON.call(this, e);
        for (var i in t.uniforms = {},
        this.uniforms) {
            var n = this.uniforms[i].value;
            n && n.isTexture ? t.uniforms[i] = {
                type: "t",
                value: n.toJSON(e).uuid
            } : n && n.isColor ? t.uniforms[i] = {
                type: "c",
                value: n.getHex()
            } : n && n.isVector2 ? t.uniforms[i] = {
                type: "v2",
                value: n.toArray()
            } : n && n.isVector3 ? t.uniforms[i] = {
                type: "v3",
                value: n.toArray()
            } : n && n.isVector4 ? t.uniforms[i] = {
                type: "v4",
                value: n.toArray()
            } : n && n.isMatrix3 ? t.uniforms[i] = {
                type: "m3",
                value: n.toArray()
            } : n && n.isMatrix4 ? t.uniforms[i] = {
                type: "m4",
                value: n.toArray()
            } : t.uniforms[i] = {
                value: n
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        var r = {};
        for (var s in this.extensions)
            !0 === this.extensions[s] && (r[s] = !0);
        return Object.keys(r).length > 0 && (t.extensions = r),
        t
    }
    ,
    Object.assign(un.prototype, {
        set: function(e, t) {
            return this.origin.copy(e),
            this.direction.copy(t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.origin.copy(e.origin),
            this.direction.copy(e.direction),
            this
        },
        at: function(e, t) {
            return void 0 === t && (t = new Ct),
            t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function(e) {
            return this.direction.copy(e).sub(this.origin).normalize(),
            this
        },
        recast: function() {
            var e = new Ct;
            return function(t) {
                return this.origin.copy(this.at(t, e)),
                this
            }
        }(),
        closestPointToPoint: function(e, t) {
            void 0 === t && (t = new Ct),
            t.subVectors(e, this.origin);
            var i = t.dot(this.direction);
            return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin)
        },
        distanceToPoint: function(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: function() {
            var e = new Ct;
            return function(t) {
                var i = e.subVectors(t, this.origin).dot(this.direction);
                return i < 0 ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(i).add(this.origin),
                e.distanceToSquared(t))
            }
        }(),
        distanceSqToSegment: (Ji = new Ct,
        Zi = new Ct,
        $i = new Ct,
        function(e, t, i, n) {
            Ji.copy(e).add(t).multiplyScalar(.5),
            Zi.copy(t).sub(e).normalize(),
            $i.copy(this.origin).sub(Ji);
            var r, s, a, o, l = .5 * e.distanceTo(t), c = -this.direction.dot(Zi), h = $i.dot(this.direction), u = -$i.dot(Zi), p = $i.lengthSq(), d = Math.abs(1 - c * c);
            if (d > 0)
                if (s = c * h - u,
                o = l * d,
                (r = c * u - h) >= 0)
                    if (s >= -o)
                        if (s <= o) {
                            var f = 1 / d;
                            a = (r *= f) * (r + c * (s *= f) + 2 * h) + s * (c * r + s + 2 * u) + p
                        } else
                            s = l,
                            a = -(r = Math.max(0, -(c * s + h))) * r + s * (s + 2 * u) + p;
                    else
                        s = -l,
                        a = -(r = Math.max(0, -(c * s + h))) * r + s * (s + 2 * u) + p;
                else
                    s <= -o ? a = -(r = Math.max(0, -(-c * l + h))) * r + (s = r > 0 ? -l : Math.min(Math.max(-l, -u), l)) * (s + 2 * u) + p : s <= o ? (r = 0,
                    a = (s = Math.min(Math.max(-l, -u), l)) * (s + 2 * u) + p) : a = -(r = Math.max(0, -(c * l + h))) * r + (s = r > 0 ? l : Math.min(Math.max(-l, -u), l)) * (s + 2 * u) + p;
            else
                s = c > 0 ? -l : l,
                a = -(r = Math.max(0, -(c * s + h))) * r + s * (s + 2 * u) + p;
            return i && i.copy(this.direction).multiplyScalar(r).add(this.origin),
            n && n.copy(Zi).multiplyScalar(s).add(Ji),
            a
        }
        ),
        intersectSphere: function() {
            var e = new Ct;
            return function(t, i) {
                e.subVectors(t.center, this.origin);
                var n = e.dot(this.direction)
                  , r = e.dot(e) - n * n
                  , s = t.radius * t.radius;
                if (r > s)
                    return null;
                var a = Math.sqrt(s - r)
                  , o = n - a
                  , l = n + a;
                return o < 0 && l < 0 ? null : o < 0 ? this.at(l, i) : this.at(o, i)
            }
        }(),
        intersectsSphere: function(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        },
        distanceToPlane: function(e) {
            var t = e.normal.dot(this.direction);
            if (0 === t)
                return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            var i = -(this.origin.dot(e.normal) + e.constant) / t;
            return i >= 0 ? i : null
        },
        intersectPlane: function(e, t) {
            var i = this.distanceToPlane(e);
            return null === i ? null : this.at(i, t)
        },
        intersectsPlane: function(e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        },
        intersectBox: function(e, t) {
            var i, n, r, s, a, o, l = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin;
            return l >= 0 ? (i = (e.min.x - u.x) * l,
            n = (e.max.x - u.x) * l) : (i = (e.max.x - u.x) * l,
            n = (e.min.x - u.x) * l),
            c >= 0 ? (r = (e.min.y - u.y) * c,
            s = (e.max.y - u.y) * c) : (r = (e.max.y - u.y) * c,
            s = (e.min.y - u.y) * c),
            i > s || r > n ? null : ((r > i || i != i) && (i = r),
            (s < n || n != n) && (n = s),
            h >= 0 ? (a = (e.min.z - u.z) * h,
            o = (e.max.z - u.z) * h) : (a = (e.max.z - u.z) * h,
            o = (e.min.z - u.z) * h),
            i > o || a > n ? null : ((a > i || i != i) && (i = a),
            (o < n || n != n) && (n = o),
            n < 0 ? null : this.at(i >= 0 ? i : n, t)))
        },
        intersectsBox: (Qi = new Ct,
        function(e) {
            return null !== this.intersectBox(e, Qi)
        }
        ),
        intersectTriangle: function() {
            var e = new Ct
              , t = new Ct
              , i = new Ct
              , n = new Ct;
            return function(r, s, a, o, l) {
                t.subVectors(s, r),
                i.subVectors(a, r),
                n.crossVectors(t, i);
                var c, h = this.direction.dot(n);
                if (h > 0) {
                    if (o)
                        return null;
                    c = 1
                } else {
                    if (!(h < 0))
                        return null;
                    c = -1,
                    h = -h
                }
                e.subVectors(this.origin, r);
                var u = c * this.direction.dot(i.crossVectors(e, i));
                if (u < 0)
                    return null;
                var p = c * this.direction.dot(t.cross(e));
                if (p < 0)
                    return null;
                if (u + p > h)
                    return null;
                var d = -c * e.dot(n);
                return d < 0 ? null : this.at(d / h, l)
            }
        }(),
        applyMatrix4: function(e) {
            return this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
        },
        equals: function(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    }),
    Object.assign(pn, {
        getNormal: (en = new Ct,
        function(e, t, i, n) {
            void 0 === n && (n = new Ct),
            n.subVectors(i, t),
            en.subVectors(e, t),
            n.cross(en);
            var r = n.lengthSq();
            return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
        }
        ),
        getBarycoord: function() {
            var e = new Ct
              , t = new Ct
              , i = new Ct;
            return function(n, r, s, a, o) {
                e.subVectors(a, r),
                t.subVectors(s, r),
                i.subVectors(n, r);
                var l = e.dot(e)
                  , c = e.dot(t)
                  , h = e.dot(i)
                  , u = t.dot(t)
                  , p = t.dot(i)
                  , d = l * u - c * c;
                if (void 0 === o && (o = new Ct),
                0 === d)
                    return o.set(-2, -1, -1);
                var f = 1 / d
                  , m = (u * h - c * p) * f
                  , g = (l * p - c * h) * f;
                return o.set(1 - m - g, g, m)
            }
        }(),
        containsPoint: function() {
            var e = new Ct;
            return function(t, i, n, r) {
                return pn.getBarycoord(t, i, n, r, e),
                e.x >= 0 && e.y >= 0 && e.x + e.y <= 1
            }
        }(),
        getUV: (Ki = new Ct,
        function(e, t, i, n, r, s, a, o) {
            return this.getBarycoord(e, t, i, n, Ki),
            o.set(0, 0),
            o.addScaledVector(r, Ki.x),
            o.addScaledVector(s, Ki.y),
            o.addScaledVector(a, Ki.z),
            o
        }
        )
    }),
    Object.assign(pn.prototype, {
        set: function(e, t, i) {
            return this.a.copy(e),
            this.b.copy(t),
            this.c.copy(i),
            this
        },
        setFromPointsAndIndices: function(e, t, i, n) {
            return this.a.copy(e[t]),
            this.b.copy(e[i]),
            this.c.copy(e[n]),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.a.copy(e.a),
            this.b.copy(e.b),
            this.c.copy(e.c),
            this
        },
        getArea: function() {
            var e = new Ct
              , t = new Ct;
            return function() {
                return e.subVectors(this.c, this.b),
                t.subVectors(this.a, this.b),
                .5 * e.cross(t).length()
            }
        }(),
        getMidpoint: function(e) {
            return void 0 === e && (e = new Ct),
            e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(e) {
            return pn.getNormal(this.a, this.b, this.c, e)
        },
        getPlane: function(e) {
            return void 0 === e && (e = new Ct),
            e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(e, t) {
            return pn.getBarycoord(e, this.a, this.b, this.c, t)
        },
        containsPoint: function(e) {
            return pn.containsPoint(e, this.a, this.b, this.c)
        },
        getUV: function(e, t, i, n, r) {
            return pn.getUV(e, this.a, this.b, this.c, t, i, n, r)
        },
        intersectsBox: function(e) {
            return e.intersectsTriangle(this)
        },
        closestPointToPoint: (tn = new Ct,
        nn = new Ct,
        rn = new Ct,
        sn = new Ct,
        an = new Ct,
        on = new Ct,
        function(e, t) {
            void 0 === t && (t = new Ct);
            var i, n, r = this.a, s = this.b, a = this.c;
            tn.subVectors(s, r),
            nn.subVectors(a, r),
            sn.subVectors(e, r);
            var o = tn.dot(sn)
              , l = nn.dot(sn);
            if (o <= 0 && l <= 0)
                return t.copy(r);
            an.subVectors(e, s);
            var c = tn.dot(an)
              , h = nn.dot(an);
            if (c >= 0 && h <= c)
                return t.copy(s);
            var u = o * h - c * l;
            if (u <= 0 && o >= 0 && c <= 0)
                return i = o / (o - c),
                t.copy(r).addScaledVector(tn, i);
            on.subVectors(e, a);
            var p = tn.dot(on)
              , d = nn.dot(on);
            if (d >= 0 && p <= d)
                return t.copy(a);
            var f = p * l - o * d;
            if (f <= 0 && l >= 0 && d <= 0)
                return n = l / (l - d),
                t.copy(r).addScaledVector(nn, n);
            var m = c * d - p * h;
            if (m <= 0 && h - c >= 0 && p - d >= 0)
                return rn.subVectors(a, s),
                n = (h - c) / (h - c + (p - d)),
                t.copy(s).addScaledVector(rn, n);
            var g = 1 / (m + f + u);
            return i = f * g,
            n = u * g,
            t.copy(r).addScaledVector(tn, i).addScaledVector(nn, n)
        }
        ),
        equals: function(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }),
    dn.prototype = Object.create(Hi.prototype),
    dn.prototype.constructor = dn,
    dn.prototype.isMeshBasicMaterial = !0,
    dn.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this
    }
    ,
    fn.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: fn,
        isMesh: !0,
        setDrawMode: function(e) {
            this.drawMode = e
        },
        copy: function(e) {
            return Mi.prototype.copy.call(this, e),
            this.drawMode = e.drawMode,
            void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
            this
        },
        updateMorphTargets: function() {
            var e, t, i, n = this.geometry;
            if (n.isBufferGeometry) {
                var r = n.morphAttributes
                  , s = Object.keys(r);
                if (s.length > 0) {
                    var a = r[s[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        e = 0,
                        t = a.length; e < t; e++)
                            i = a[e].name || String(e),
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[i] = e
                }
            } else {
                var o = n.morphTargets;
                void 0 !== o && o.length
            }
        },
        raycast: function() {
            var e = new ii
              , t = new un
              , i = new Kt
              , n = new Ct
              , r = new Ct
              , s = new Ct
              , a = new Ct
              , o = new Ct
              , l = new Ct
              , c = new Ct
              , h = new Ct
              , u = new Ct
              , p = new At
              , d = new At
              , g = new At
              , v = new Ct
              , y = new Ct;
            function b(e, t, i, n, r, s, a, o) {
                if (null === (t.side === f ? n.intersectTriangle(a, s, r, !0, o) : n.intersectTriangle(r, s, a, t.side !== m, o)))
                    return null;
                y.copy(o),
                y.applyMatrix4(e.matrixWorld);
                var l = i.ray.origin.distanceTo(y);
                return l < i.near || l > i.far ? null : {
                    distance: l,
                    point: y.clone(),
                    object: e
                }
            }
            function x(e, t, i, f, m, y, x, w, _, T) {
                n.fromBufferAttribute(m, w),
                r.fromBufferAttribute(m, _),
                s.fromBufferAttribute(m, T);
                var M = e.morphTargetInfluences;
                if (t.morphTargets && y && M) {
                    c.set(0, 0, 0),
                    h.set(0, 0, 0),
                    u.set(0, 0, 0);
                    for (var S = 0, A = y.length; S < A; S++) {
                        var P = M[S]
                          , C = y[S];
                        0 !== P && (a.fromBufferAttribute(C, w),
                        o.fromBufferAttribute(C, _),
                        l.fromBufferAttribute(C, T),
                        c.addScaledVector(a.sub(n), P),
                        h.addScaledVector(o.sub(r), P),
                        u.addScaledVector(l.sub(s), P))
                    }
                    n.add(c),
                    r.add(h),
                    s.add(u)
                }
                var L = b(e, t, i, f, n, r, s, v);
                if (L) {
                    x && (p.fromBufferAttribute(x, w),
                    d.fromBufferAttribute(x, _),
                    g.fromBufferAttribute(x, T),
                    L.uv = pn.getUV(v, n, r, s, p, d, g, new At));
                    var k = new gi(w,_,T);
                    pn.getNormal(n, r, s, k.normal),
                    L.face = k
                }
                return L
            }
            return function(n, r) {
                var s, a = this.geometry, o = this.material, l = this.matrixWorld;
                if (void 0 !== o && (null === a.boundingSphere && a.computeBoundingSphere(),
                i.copy(a.boundingSphere),
                i.applyMatrix4(l),
                !1 !== n.ray.intersectsSphere(i) && (e.getInverse(l),
                t.copy(n.ray).applyMatrix4(e),
                null === a.boundingBox || !1 !== t.intersectsBox(a.boundingBox))))
                    if (a.isBufferGeometry) {
                        var c, h, u, f, m, y, w, _, T, M = a.index, S = a.attributes.position, A = a.morphAttributes.position, P = a.attributes.uv, C = a.groups, L = a.drawRange;
                        if (null !== M)
                            if (Array.isArray(o))
                                for (f = 0,
                                y = C.length; f < y; f++)
                                    for (T = o[(_ = C[f]).materialIndex],
                                    m = Math.max(_.start, L.start),
                                    w = Math.min(_.start + _.count, L.start + L.count); m < w; m += 3)
                                        c = M.getX(m),
                                        h = M.getX(m + 1),
                                        u = M.getX(m + 2),
                                        (s = x(this, T, n, t, S, A, P, c, h, u)) && (s.faceIndex = Math.floor(m / 3),
                                        s.face.materialIndex = _.materialIndex,
                                        r.push(s));
                            else
                                for (f = Math.max(0, L.start),
                                y = Math.min(M.count, L.start + L.count); f < y; f += 3)
                                    c = M.getX(f),
                                    h = M.getX(f + 1),
                                    u = M.getX(f + 2),
                                    (s = x(this, o, n, t, S, A, P, c, h, u)) && (s.faceIndex = Math.floor(f / 3),
                                    r.push(s));
                        else if (void 0 !== S)
                            if (Array.isArray(o))
                                for (f = 0,
                                y = C.length; f < y; f++)
                                    for (T = o[(_ = C[f]).materialIndex],
                                    m = Math.max(_.start, L.start),
                                    w = Math.min(_.start + _.count, L.start + L.count); m < w; m += 3)
                                        (s = x(this, T, n, t, S, A, P, c = m, h = m + 1, u = m + 2)) && (s.faceIndex = Math.floor(m / 3),
                                        s.face.materialIndex = _.materialIndex,
                                        r.push(s));
                            else
                                for (f = Math.max(0, L.start),
                                y = Math.min(S.count, L.start + L.count); f < y; f += 3)
                                    (s = x(this, o, n, t, S, A, P, c = f, h = f + 1, u = f + 2)) && (s.faceIndex = Math.floor(f / 3),
                                    r.push(s))
                    } else if (a.isGeometry) {
                        var k, E, I, F, O = Array.isArray(o), R = a.vertices, z = a.faces, N = a.faceVertexUvs[0];
                        N.length > 0 && (F = N);
                        for (var D = 0, U = z.length; D < U; D++) {
                            var B = z[D]
                              , j = O ? o[B.materialIndex] : o;
                            if (void 0 !== j && (k = R[B.a],
                            E = R[B.b],
                            I = R[B.c],
                            s = b(this, j, n, t, k, E, I, v))) {
                                if (F && F[D]) {
                                    var V = F[D];
                                    p.copy(V[0]),
                                    d.copy(V[1]),
                                    g.copy(V[2]),
                                    s.uv = pn.getUV(v, k, E, I, p, d, g, new At)
                                }
                                s.face = B,
                                s.faceIndex = D,
                                r.push(s)
                            }
                        }
                    }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    An.prototype = Object.create(Wt.prototype),
    An.prototype.constructor = An,
    An.prototype.isCubeTexture = !0,
    Object.defineProperty(An.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(e) {
            this.image = e
        }
    }),
    Pn.prototype = Object.create(Wt.prototype),
    Pn.prototype.constructor = Pn,
    Pn.prototype.isDataTexture2DArray = !0,
    Cn.prototype = Object.create(Wt.prototype),
    Cn.prototype.constructor = Cn,
    Cn.prototype.isDataTexture3D = !0;
    var Ln = new Wt
      , kn = new Pn
      , En = new Cn
      , In = new An
      , Fn = []
      , On = []
      , Rn = new Float32Array(16)
      , zn = new Float32Array(9)
      , Nn = new Float32Array(4);
    function Dn(e, t, i) {
        var n = e[0];
        if (n <= 0 || n > 0)
            return e;
        var r = t * i
          , s = Fn[r];
        if (void 0 === s && (s = new Float32Array(r),
        Fn[r] = s),
        0 !== t) {
            n.toArray(s, 0);
            for (var a = 1, o = 0; a !== t; ++a)
                o += i,
                e[a].toArray(s, o)
        }
        return s
    }
    function Un(e, t) {
        if (e.length !== t.length)
            return !1;
        for (var i = 0, n = e.length; i < n; i++)
            if (e[i] !== t[i])
                return !1;
        return !0
    }
    function Bn(e, t) {
        for (var i = 0, n = t.length; i < n; i++)
            e[i] = t[i]
    }
    function jn(e, t) {
        var i = On[t];
        void 0 === i && (i = new Int32Array(t),
        On[t] = i);
        for (var n = 0; n !== t; ++n)
            i[n] = e.allocateTextureUnit();
        return i
    }
    function Vn(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1f(this.addr, t),
        i[0] = t)
    }
    function Gn(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1i(this.addr, t),
        i[0] = t)
    }
    function Xn(e, t) {
        var i = this.cache;
        if (void 0 !== t.x)
            i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
            i[0] = t.x,
            i[1] = t.y);
        else {
            if (Un(i, t))
                return;
            e.uniform2fv(this.addr, t),
            Bn(i, t)
        }
    }
    function Yn(e, t) {
        var i = this.cache;
        if (void 0 !== t.x)
            i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
            i[0] = t.x,
            i[1] = t.y,
            i[2] = t.z);
        else if (void 0 !== t.r)
            i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
            i[0] = t.r,
            i[1] = t.g,
            i[2] = t.b);
        else {
            if (Un(i, t))
                return;
            e.uniform3fv(this.addr, t),
            Bn(i, t)
        }
    }
    function Wn(e, t) {
        var i = this.cache;
        if (void 0 !== t.x)
            i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            i[0] = t.x,
            i[1] = t.y,
            i[2] = t.z,
            i[3] = t.w);
        else {
            if (Un(i, t))
                return;
            e.uniform4fv(this.addr, t),
            Bn(i, t)
        }
    }
    function qn(e, t) {
        var i = this.cache
          , n = t.elements;
        if (void 0 === n) {
            if (Un(i, t))
                return;
            e.uniformMatrix2fv(this.addr, !1, t),
            Bn(i, t)
        } else {
            if (Un(i, n))
                return;
            Nn.set(n),
            e.uniformMatrix2fv(this.addr, !1, Nn),
            Bn(i, n)
        }
    }
    function Hn(e, t) {
        var i = this.cache
          , n = t.elements;
        if (void 0 === n) {
            if (Un(i, t))
                return;
            e.uniformMatrix3fv(this.addr, !1, t),
            Bn(i, t)
        } else {
            if (Un(i, n))
                return;
            zn.set(n),
            e.uniformMatrix3fv(this.addr, !1, zn),
            Bn(i, n)
        }
    }
    function Qn(e, t) {
        var i = this.cache
          , n = t.elements;
        if (void 0 === n) {
            if (Un(i, t))
                return;
            e.uniformMatrix4fv(this.addr, !1, t),
            Bn(i, t)
        } else {
            if (Un(i, n))
                return;
            Rn.set(n),
            e.uniformMatrix4fv(this.addr, !1, Rn),
            Bn(i, n)
        }
    }
    function Jn(e, t, i) {
        var n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r),
        n[0] = r),
        i.safeSetTexture2D(t || Ln, r)
    }
    function Zn(e, t, i) {
        var n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r),
        n[0] = r),
        i.setTexture2DArray(t || kn, r)
    }
    function $n(e, t, i) {
        var n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r),
        n[0] = r),
        i.setTexture3D(t || En, r)
    }
    function Kn(e, t, i) {
        var n = this.cache
          , r = i.allocateTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r),
        n[0] = r),
        i.safeSetTextureCube(t || In, r)
    }
    function er(e, t) {
        var i = this.cache;
        Un(i, t) || (e.uniform2iv(this.addr, t),
        Bn(i, t))
    }
    function tr(e, t) {
        var i = this.cache;
        Un(i, t) || (e.uniform3iv(this.addr, t),
        Bn(i, t))
    }
    function ir(e, t) {
        var i = this.cache;
        Un(i, t) || (e.uniform4iv(this.addr, t),
        Bn(i, t))
    }
    function nr(e, t) {
        var i = this.cache;
        Un(i, t) || (e.uniform1fv(this.addr, t),
        Bn(i, t))
    }
    function rr(e, t) {
        var i = this.cache;
        Un(i, t) || (e.uniform1iv(this.addr, t),
        Bn(i, t))
    }
    function sr(e, t) {
        var i = this.cache
          , n = Dn(t, this.size, 2);
        Un(i, n) || (e.uniform2fv(this.addr, n),
        this.updateCache(n))
    }
    function ar(e, t) {
        var i = this.cache
          , n = Dn(t, this.size, 3);
        Un(i, n) || (e.uniform3fv(this.addr, n),
        this.updateCache(n))
    }
    function or(e, t) {
        var i = this.cache
          , n = Dn(t, this.size, 4);
        Un(i, n) || (e.uniform4fv(this.addr, n),
        this.updateCache(n))
    }
    function lr(e, t) {
        var i = this.cache
          , n = Dn(t, this.size, 4);
        Un(i, n) || (e.uniformMatrix2fv(this.addr, !1, n),
        this.updateCache(n))
    }
    function cr(e, t) {
        var i = this.cache
          , n = Dn(t, this.size, 9);
        Un(i, n) || (e.uniformMatrix3fv(this.addr, !1, n),
        this.updateCache(n))
    }
    function hr(e, t) {
        var i = this.cache
          , n = Dn(t, this.size, 16);
        Un(i, n) || (e.uniformMatrix4fv(this.addr, !1, n),
        this.updateCache(n))
    }
    function ur(e, t, i) {
        var n = this.cache
          , r = t.length
          , s = jn(i, r);
        !1 === Un(n, s) && (e.uniform1iv(this.addr, s),
        Bn(n, s));
        for (var a = 0; a !== r; ++a)
            i.safeSetTexture2D(t[a] || Ln, s[a])
    }
    function pr(e, t, i) {
        var n = this.cache
          , r = t.length
          , s = jn(i, r);
        !1 === Un(n, s) && (e.uniform1iv(this.addr, s),
        Bn(n, s));
        for (var a = 0; a !== r; ++a)
            i.safeSetTextureCube(t[a] || In, s[a])
    }
    function dr(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return Vn;
            case 35664:
                return Xn;
            case 35665:
                return Yn;
            case 35666:
                return Wn;
            case 35674:
                return qn;
            case 35675:
                return Hn;
            case 35676:
                return Qn;
            case 35678:
            case 36198:
                return Jn;
            case 35679:
                return $n;
            case 35680:
                return Kn;
            case 36289:
                return Zn;
            case 5124:
            case 35670:
                return Gn;
            case 35667:
            case 35671:
                return er;
            case 35668:
            case 35672:
                return tr;
            case 35669:
            case 35673:
                return ir
            }
        }(t.type)
    }
    function fr(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.size = t.size,
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return nr;
            case 35664:
                return sr;
            case 35665:
                return ar;
            case 35666:
                return or;
            case 35674:
                return lr;
            case 35675:
                return cr;
            case 35676:
                return hr;
            case 35678:
                return ur;
            case 35680:
                return pr;
            case 5124:
            case 35670:
                return rr;
            case 35667:
            case 35671:
                return er;
            case 35668:
            case 35672:
                return tr;
            case 35669:
            case 35673:
                return ir
            }
        }(t.type)
    }
    function mr(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    fr.prototype.updateCache = function(e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)),
        Bn(t, e)
    }
    ,
    mr.prototype.setValue = function(e, t, i) {
        for (var n = this.seq, r = 0, s = n.length; r !== s; ++r) {
            var a = n[r];
            a.setValue(e, t[a.id], i)
        }
    }
    ;
    var gr = /([\w\d_]+)(\])?(\[|\.)?/g;
    function vr(e, t) {
        e.seq.push(t),
        e.map[t.id] = t
    }
    function yr(e, t, i) {
        var n = e.name
          , r = n.length;
        for (gr.lastIndex = 0; ; ) {
            var s = gr.exec(n)
              , a = gr.lastIndex
              , o = s[1]
              , l = "]" === s[2]
              , c = s[3];
            if (l && (o |= 0),
            void 0 === c || "[" === c && a + 2 === r) {
                vr(i, void 0 === c ? new dr(o,e,t) : new fr(o,e,t));
                break
            }
            var h = i.map[o];
            void 0 === h && vr(i, h = new mr(o)),
            i = h
        }
    }
    function br(e, t) {
        this.seq = [],
        this.map = {};
        for (var i = e.getProgramParameter(t, 35718), n = 0; n < i; ++n) {
            var r = e.getActiveUniform(t, n);
            yr(r, e.getUniformLocation(t, r.name), this)
        }
    }
    function xr(e, t, i, n) {
        var r = e.createShader(t);
        return e.shaderSource(r, i),
        e.compileShader(r),
        !0 === n && (e.getShaderParameter(r, 35713),
        e.getShaderInfoLog(r)),
        r
    }
    br.prototype.setValue = function(e, t, i, n) {
        var r = this.map[t];
        void 0 !== r && r.setValue(e, i, n)
    }
    ,
    br.prototype.setOptional = function(e, t, i) {
        var n = t[i];
        void 0 !== n && this.setValue(e, i, n)
    }
    ,
    br.upload = function(e, t, i, n) {
        for (var r = 0, s = t.length; r !== s; ++r) {
            var a = t[r]
              , o = i[a.id];
            !1 !== o.needsUpdate && a.setValue(e, o.value, n)
        }
    }
    ,
    br.seqWithValue = function(e, t) {
        for (var i = [], n = 0, r = e.length; n !== r; ++n) {
            var s = e[n];
            s.id in t && i.push(s)
        }
        return i
    }
    ;
    var wr = 0;
    function _r(e) {
        switch (e) {
        case ft:
            return ["Linear", "( value )"];
        case mt:
            return ["sRGB", "( value )"];
        case vt:
            return ["RGBE", "( value )"];
        case yt:
            return ["RGBM", "( value, 7.0 )"];
        case bt:
            return ["RGBM", "( value, 16.0 )"];
        case xt:
            return ["RGBD", "( value, 256.0 )"];
        case gt:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
            throw new Error("unsupported encoding: " + e)
        }
    }
    function Tr(e, t) {
        var i = _r(t);
        return "vec4 " + e + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
    }
    function Mr(e, t) {
        var i;
        switch (t) {
        case K:
            i = "Linear";
            break;
        case ee:
            i = "Reinhard";
            break;
        case te:
            i = "Uncharted2";
            break;
        case ie:
            i = "OptimizedCineon";
            break;
        case ne:
            i = "ACESFilmic";
            break;
        default:
            throw new Error("unsupported toneMapping: " + t)
        }
        return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
    }
    function Sr(e) {
        return "" !== e
    }
    function Ar(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    }
    function Pr(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }
    function Cr(e) {
        return e.replace(/^[ \t]*#include +<([\w\d.\/]+)>/gm, function(e, t) {
            var i = ni[t];
            if (void 0 === i)
                throw new Error("Can not resolve #include <" + t + ">");
            return Cr(i)
        })
    }
    function Lr(e) {
        return e.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(e, t, i, n) {
            for (var r = "", s = parseInt(t); s < parseInt(i); s++)
                r += n.replace(/\[ i \]/g, "[ " + s + " ]");
            return r
        })
    }
    function kr(e, t, i, n, r, s, a, o) {
        var l = e.context
          , c = n.defines
          , h = r.vertexShader
          , d = r.fragmentShader
          , f = "SHADOWMAP_TYPE_BASIC";
        s.shadowMapType === u ? f = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === p && (f = "SHADOWMAP_TYPE_PCF_SOFT");
        var m = "ENVMAP_TYPE_CUBE"
          , g = "ENVMAP_MODE_REFLECTION"
          , v = "ENVMAP_BLENDING_MULTIPLY";
        if (s.envMap) {
            switch (n.envMap.mapping) {
            case re:
            case se:
                m = "ENVMAP_TYPE_CUBE";
                break;
            case ce:
            case he:
                m = "ENVMAP_TYPE_CUBE_UV";
                break;
            case ae:
            case oe:
                m = "ENVMAP_TYPE_EQUIREC";
                break;
            case le:
                m = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
            case se:
            case oe:
                g = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
            case Q:
                v = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case J:
                v = "ENVMAP_BLENDING_MIX";
                break;
            case Z:
                v = "ENVMAP_BLENDING_ADD"
            }
        }
        var y, b, x, w, _, T = e.gammaFactor > 0 ? e.gammaFactor : 1, M = a.isWebGL2 ? "" : function(e, t, i) {
            return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap && !t.objectSpaceNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Sr).join("\n")
        }(n.extensions, s, t), S = function(e) {
            var t = [];
            for (var i in e) {
                var n = e[i];
                !1 !== n && t.push("#define " + i + " " + n)
            }
            return t.join("\n")
        }(c), A = l.createProgram();
        if (n.isRawShaderMaterial ? ((y = [S].filter(Sr).join("\n")).length > 0 && (y += "\n"),
        (b = [M, S].filter(Sr).join("\n")).length > 0 && (b += "\n")) : (y = ["precision " + s.precision + " float;", "precision " + s.precision + " int;", "#define SHADER_NAME " + r.name, S, s.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + T, "#define MAX_BONES " + s.maxBones, s.useFog && s.fog ? "#define USE_FOG" : "", s.useFog && s.fogExp ? "#define FOG_EXP2" : "", s.map ? "#define USE_MAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.envMap ? "#define " + g : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.aoMap ? "#define USE_AOMAP" : "", s.emissiveMap ? "#define USE_EMISSIVEMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.normalMap && s.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", s.displacementMap && s.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", s.metalnessMap ? "#define USE_METALNESSMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexTangents ? "#define USE_TANGENT" : "", s.vertexColors ? "#define USE_COLOR" : "", s.flatShading ? "#define FLAT_SHADED" : "", s.skinning ? "#define USE_SKINNING" : "", s.useVertexTexture ? "#define BONE_TEXTURE" : "", s.morphTargets ? "#define USE_MORPHTARGETS" : "", s.morphNormals && !1 === s.flatShading ? "#define USE_MORPHNORMALS" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + f : "", s.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", s.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Sr).join("\n"),
        b = [M, "precision " + s.precision + " float;", "precision " + s.precision + " int;", "#define SHADER_NAME " + r.name, S, s.alphaTest ? "#define ALPHATEST " + s.alphaTest + (s.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + T, s.useFog && s.fog ? "#define USE_FOG" : "", s.useFog && s.fogExp ? "#define FOG_EXP2" : "", s.map ? "#define USE_MAP" : "", s.matcap ? "#define USE_MATCAP" : "", s.envMap ? "#define USE_ENVMAP" : "", s.envMap ? "#define " + m : "", s.envMap ? "#define " + g : "", s.envMap ? "#define " + v : "", s.lightMap ? "#define USE_LIGHTMAP" : "", s.aoMap ? "#define USE_AOMAP" : "", s.emissiveMap ? "#define USE_EMISSIVEMAP" : "", s.bumpMap ? "#define USE_BUMPMAP" : "", s.normalMap ? "#define USE_NORMALMAP" : "", s.normalMap && s.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", s.specularMap ? "#define USE_SPECULARMAP" : "", s.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", s.metalnessMap ? "#define USE_METALNESSMAP" : "", s.alphaMap ? "#define USE_ALPHAMAP" : "", s.vertexTangents ? "#define USE_TANGENT" : "", s.vertexColors ? "#define USE_COLOR" : "", s.gradientMap ? "#define USE_GRADIENTMAP" : "", s.flatShading ? "#define FLAT_SHADED" : "", s.doubleSided ? "#define DOUBLE_SIDED" : "", s.flipSided ? "#define FLIP_SIDED" : "", s.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", s.shadowMapEnabled ? "#define " + f : "", s.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", s.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", s.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", s.logarithmicDepthBuffer && (a.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", s.envMap && (a.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", s.toneMapping !== $ ? "#define TONE_MAPPING" : "", s.toneMapping !== $ ? ni.tonemapping_pars_fragment : "", s.toneMapping !== $ ? Mr("toneMapping", s.toneMapping) : "", s.dithering ? "#define DITHERING" : "", s.outputEncoding || s.mapEncoding || s.matcapEncoding || s.envMapEncoding || s.emissiveMapEncoding ? ni.encodings_pars_fragment : "", s.mapEncoding ? Tr("mapTexelToLinear", s.mapEncoding) : "", s.matcapEncoding ? Tr("matcapTexelToLinear", s.matcapEncoding) : "", s.envMapEncoding ? Tr("envMapTexelToLinear", s.envMapEncoding) : "", s.emissiveMapEncoding ? Tr("emissiveMapTexelToLinear", s.emissiveMapEncoding) : "", s.outputEncoding ? (x = "linearToOutputTexel",
        w = s.outputEncoding,
        _ = _r(w),
        "vec4 " + x + "( vec4 value ) { return LinearTo" + _[0] + _[1] + "; }") : "", s.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Sr).join("\n")),
        h = Pr(h = Ar(h = Cr(h), s), s),
        d = Pr(d = Ar(d = Cr(d), s), s),
        h = Lr(h),
        d = Lr(d),
        a.isWebGL2 && !n.isRawShaderMaterial) {
            var P = !1
              , C = /^\s*#version\s+300\s+es\s*\n/;
            n.isShaderMaterial && null !== h.match(C) && null !== d.match(C) && (P = !0,
            h = h.replace(C, ""),
            d = d.replace(C, "")),
            y = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y,
            b = ["#version 300 es\n", "#define varying in", P ? "" : "out highp vec4 pc_fragColor;", P ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b
        }
        var L, k, E = b + d, I = xr(l, 35633, y + h, e.debug.checkShaderErrors), F = xr(l, 35632, E, e.debug.checkShaderErrors);
        if (l.attachShader(A, I),
        l.attachShader(A, F),
        void 0 !== n.index0AttributeName ? l.bindAttribLocation(A, 0, n.index0AttributeName) : !0 === s.morphTargets && l.bindAttribLocation(A, 0, "position"),
        l.linkProgram(A),
        e.debug.checkShaderErrors) {
            var O = l.getProgramInfoLog(A).trim()
              , R = l.getShaderInfoLog(I).trim()
              , z = l.getShaderInfoLog(F).trim()
              , N = !0
              , D = !0;
            !1 === l.getProgramParameter(A, 35714) ? N = !1 : "" !== O || "" !== R && "" !== z || (D = !1),
            D && (this.diagnostics = {
                runnable: N,
                material: n,
                programLog: O,
                vertexShader: {
                    log: R,
                    prefix: y
                },
                fragmentShader: {
                    log: z,
                    prefix: b
                }
            })
        }
        return l.deleteShader(I),
        l.deleteShader(F),
        this.getUniforms = function() {
            return void 0 === L && (L = new br(l,A,o)),
            L
        }
        ,
        this.getAttributes = function() {
            return void 0 === k && (k = function(e, t) {
                for (var i = {}, n = e.getProgramParameter(t, 35721), r = 0; r < n; r++) {
                    var s = e.getActiveAttrib(t, r).name;
                    i[s] = e.getAttribLocation(t, s)
                }
                return i
            }(l, A)),
            k
        }
        ,
        this.destroy = function() {
            l.deleteProgram(A),
            this.program = void 0
        }
        ,
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return this.getAttributes()
                }
            }
        }),
        this.name = r.name,
        this.id = wr++,
        this.code = i,
        this.usedTimes = 1,
        this.program = A,
        this.vertexShader = I,
        this.fragmentShader = F,
        this
    }
    function Er(e, t, i, n) {
        var r = []
          , s = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        }
          , a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
        function o(e, t) {
            var i;
            return e ? e.isTexture ? i = e.encoding : e.isWebGLRenderTarget && (i = e.texture.encoding) : i = ft,
            i === ft && t && (i = gt),
            i
        }
        this.getParameters = function(t, n, r, a, l, c, h) {
            var u = s[t.type]
              , p = h.isSkinnedMesh ? function(e) {
                var t = e.skeleton.bones;
                if (i.floatVertexTextures)
                    return 1024;
                var n = i.maxVertexUniforms
                  , r = Math.floor((n - 20) / 4)
                  , s = Math.min(r, t.length);
                return s < t.length ? 0 : s
            }(h) : 0
              , d = i.precision;
            null !== t.precision && (d = i.getMaxPrecision(t.precision),
            t.precision);
            var g = e.getRenderTarget();
            return {
                shaderID: u,
                precision: d,
                supportsVertexTextures: i.vertexTextures,
                outputEncoding: o(g ? g.texture : null, e.gammaOutput),
                map: !!t.map,
                mapEncoding: o(t.map, e.gammaInput),
                matcap: !!t.matcap,
                matcapEncoding: o(t.matcap, e.gammaInput),
                envMap: !!t.envMap,
                envMapMode: t.envMap && t.envMap.mapping,
                envMapEncoding: o(t.envMap, e.gammaInput),
                envMapCubeUV: !!t.envMap && (t.envMap.mapping === ce || t.envMap.mapping === he),
                lightMap: !!t.lightMap,
                aoMap: !!t.aoMap,
                emissiveMap: !!t.emissiveMap,
                emissiveMapEncoding: o(t.emissiveMap, e.gammaInput),
                bumpMap: !!t.bumpMap,
                normalMap: !!t.normalMap,
                objectSpaceNormalMap: t.normalMapType === Mt,
                displacementMap: !!t.displacementMap,
                roughnessMap: !!t.roughnessMap,
                metalnessMap: !!t.metalnessMap,
                specularMap: !!t.specularMap,
                alphaMap: !!t.alphaMap,
                gradientMap: !!t.gradientMap,
                combine: t.combine,
                vertexTangents: t.normalMap && t.vertexTangents,
                vertexColors: t.vertexColors,
                fog: !!a,
                useFog: t.fog,
                fogExp: a && a.isFogExp2,
                flatShading: t.flatShading,
                sizeAttenuation: t.sizeAttenuation,
                logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                skinning: t.skinning && p > 0,
                maxBones: p,
                useVertexTexture: i.floatVertexTextures,
                morphTargets: t.morphTargets,
                morphNormals: t.morphNormals,
                maxMorphTargets: e.maxMorphTargets,
                maxMorphNormals: e.maxMorphNormals,
                numDirLights: n.directional.length,
                numPointLights: n.point.length,
                numSpotLights: n.spot.length,
                numRectAreaLights: n.rectArea.length,
                numHemiLights: n.hemi.length,
                numClippingPlanes: l,
                numClipIntersection: c,
                dithering: t.dithering,
                shadowMapEnabled: e.shadowMap.enabled && h.receiveShadow && r.length > 0,
                shadowMapType: e.shadowMap.type,
                toneMapping: e.toneMapping,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: t.premultipliedAlpha,
                alphaTest: t.alphaTest,
                doubleSided: t.side === m,
                flipSided: t.side === f,
                depthPacking: void 0 !== t.depthPacking && t.depthPacking
            }
        }
        ,
        this.getProgramCode = function(t, i) {
            var n = [];
            if (i.shaderID ? n.push(i.shaderID) : (n.push(t.fragmentShader),
            n.push(t.vertexShader)),
            void 0 !== t.defines)
                for (var r in t.defines)
                    n.push(r),
                    n.push(t.defines[r]);
            for (var s = 0; s < a.length; s++)
                n.push(i[a[s]]);
            return n.push(t.onBeforeCompile.toString()),
            n.push(e.gammaOutput),
            n.push(e.gammaFactor),
            n.join()
        }
        ,
        this.acquireProgram = function(s, a, o, l) {
            for (var c, h = 0, u = r.length; h < u; h++) {
                var p = r[h];
                if (p.code === l) {
                    ++(c = p).usedTimes;
                    break
                }
            }
            return void 0 === c && (c = new kr(e,t,l,s,a,o,i,n),
            r.push(c)),
            c
        }
        ,
        this.releaseProgram = function(e) {
            if (0 == --e.usedTimes) {
                var t = r.indexOf(e);
                r[t] = r[r.length - 1],
                r.pop(),
                e.destroy()
            }
        }
        ,
        this.programs = r
    }
    function Ir() {
        var e = new WeakMap;
        return {
            get: function(t) {
                var i = e.get(t);
                return void 0 === i && (i = {},
                e.set(t, i)),
                i
            },
            remove: function(t) {
                e.delete(t)
            },
            update: function(t, i, n) {
                e.get(t)[i] = n
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    function Fr(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }
    function Or(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }
    function Rr() {
        var e = []
          , t = 0
          , i = []
          , n = []
          , r = {
            id: -1
        };
        function s(i, n, s, a, o, l) {
            var c = e[t];
            return void 0 === c ? (c = {
                id: i.id,
                object: i,
                geometry: n,
                material: s,
                program: s.program || r,
                groupOrder: a,
                renderOrder: i.renderOrder,
                z: o,
                group: l
            },
            e[t] = c) : (c.id = i.id,
            c.object = i,
            c.geometry = n,
            c.material = s,
            c.program = s.program || r,
            c.groupOrder = a,
            c.renderOrder = i.renderOrder,
            c.z = o,
            c.group = l),
            t++,
            c
        }
        return {
            opaque: i,
            transparent: n,
            init: function() {
                t = 0,
                i.length = 0,
                n.length = 0
            },
            push: function(e, t, r, a, o, l) {
                var c = s(e, t, r, a, o, l);
                (!0 === r.transparent ? n : i).push(c)
            },
            unshift: function(e, t, r, a, o, l) {
                var c = s(e, t, r, a, o, l);
                (!0 === r.transparent ? n : i).unshift(c)
            },
            sort: function() {
                i.length > 1 && i.sort(Fr),
                n.length > 1 && n.sort(Or)
            }
        }
    }
    function zr() {
        var e = {};
        function t(i) {
            var n = i.target;
            n.removeEventListener("dispose", t),
            delete e[n.id]
        }
        return {
            get: function(i, n) {
                var r, s = e[i.id];
                return void 0 === s ? (r = new Rr,
                e[i.id] = {},
                e[i.id][n.id] = r,
                i.addEventListener("dispose", t)) : void 0 === (r = s[n.id]) && (r = new Rr,
                s[n.id] = r),
                r
            },
            dispose: function() {
                e = {}
            },
            disposeScene: function(t) {
                delete e[t.id]
            }
        }
    }
    function Nr() {
        var e = {};
        return {
            get: function(t) {
                if (void 0 !== e[t.id])
                    return e[t.id];
                var i;
                switch (t.type) {
                case "DirectionalLight":
                    i = {
                        direction: new Ct,
                        color: new hi,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new At
                    };
                    break;
                case "SpotLight":
                    i = {
                        position: new Ct,
                        direction: new Ct,
                        color: new hi,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new At
                    };
                    break;
                case "PointLight":
                    i = {
                        position: new Ct,
                        color: new hi,
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new At,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break;
                case "HemisphereLight":
                    i = {
                        direction: new Ct,
                        skyColor: new hi,
                        groundColor: new hi
                    };
                    break;
                case "RectAreaLight":
                    i = {
                        color: new hi,
                        position: new Ct,
                        halfWidth: new Ct,
                        halfHeight: new Ct
                    }
                }
                return e[t.id] = i,
                i
            }
        }
    }
    var Dr = 0;
    function Ur() {
        for (var e = new Nr, t = {
            id: Dr++,
            hash: {
                stateID: -1,
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                shadowsLength: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }, i = 0; i < 9; i++)
            t.probe.push(new Ct);
        var n = new Ct
          , r = new ii
          , s = new ii;
        return {
            setup: function(i, a, o) {
                for (var l = 0, c = 0, h = 0, u = 0; u < 9; u++)
                    t.probe[u].set(0, 0, 0);
                for (var p = 0, d = 0, f = 0, m = 0, g = 0, v = o.matrixWorldInverse, y = (u = 0,
                i.length); u < y; u++) {
                    var b = i[u]
                      , x = b.color
                      , w = b.intensity
                      , _ = b.distance
                      , T = b.shadow && b.shadow.map ? b.shadow.map.texture : null;
                    if (b.isAmbientLight)
                        l += x.r * w,
                        c += x.g * w,
                        h += x.b * w;
                    else if (b.isLightProbe)
                        for (var M = 0; M < 9; M++)
                            t.probe[M].addScaledVector(b.sh.coefficients[M], w);
                    else if (b.isDirectionalLight) {
                        if ((A = e.get(b)).color.copy(b.color).multiplyScalar(b.intensity),
                        A.direction.setFromMatrixPosition(b.matrixWorld),
                        n.setFromMatrixPosition(b.target.matrixWorld),
                        A.direction.sub(n),
                        A.direction.transformDirection(v),
                        A.shadow = b.castShadow,
                        b.castShadow) {
                            var S = b.shadow;
                            A.shadowBias = S.bias,
                            A.shadowRadius = S.radius,
                            A.shadowMapSize = S.mapSize
                        }
                        t.directionalShadowMap[p] = T,
                        t.directionalShadowMatrix[p] = b.shadow.matrix,
                        t.directional[p] = A,
                        p++
                    } else if (b.isSpotLight)
                        (A = e.get(b)).position.setFromMatrixPosition(b.matrixWorld),
                        A.position.applyMatrix4(v),
                        A.color.copy(x).multiplyScalar(w),
                        A.distance = _,
                        A.direction.setFromMatrixPosition(b.matrixWorld),
                        n.setFromMatrixPosition(b.target.matrixWorld),
                        A.direction.sub(n),
                        A.direction.transformDirection(v),
                        A.coneCos = Math.cos(b.angle),
                        A.penumbraCos = Math.cos(b.angle * (1 - b.penumbra)),
                        A.decay = b.decay,
                        A.shadow = b.castShadow,
                        b.castShadow && (S = b.shadow,
                        A.shadowBias = S.bias,
                        A.shadowRadius = S.radius,
                        A.shadowMapSize = S.mapSize),
                        t.spotShadowMap[f] = T,
                        t.spotShadowMatrix[f] = b.shadow.matrix,
                        t.spot[f] = A,
                        f++;
                    else if (b.isRectAreaLight)
                        (A = e.get(b)).color.copy(x).multiplyScalar(w),
                        A.position.setFromMatrixPosition(b.matrixWorld),
                        A.position.applyMatrix4(v),
                        s.identity(),
                        r.copy(b.matrixWorld),
                        r.premultiply(v),
                        s.extractRotation(r),
                        A.halfWidth.set(.5 * b.width, 0, 0),
                        A.halfHeight.set(0, .5 * b.height, 0),
                        A.halfWidth.applyMatrix4(s),
                        A.halfHeight.applyMatrix4(s),
                        t.rectArea[m] = A,
                        m++;
                    else if (b.isPointLight)
                        (A = e.get(b)).position.setFromMatrixPosition(b.matrixWorld),
                        A.position.applyMatrix4(v),
                        A.color.copy(b.color).multiplyScalar(b.intensity),
                        A.distance = b.distance,
                        A.decay = b.decay,
                        A.shadow = b.castShadow,
                        b.castShadow && (S = b.shadow,
                        A.shadowBias = S.bias,
                        A.shadowRadius = S.radius,
                        A.shadowMapSize = S.mapSize,
                        A.shadowCameraNear = S.camera.near,
                        A.shadowCameraFar = S.camera.far),
                        t.pointShadowMap[d] = T,
                        t.pointShadowMatrix[d] = b.shadow.matrix,
                        t.point[d] = A,
                        d++;
                    else if (b.isHemisphereLight) {
                        var A;
                        (A = e.get(b)).direction.setFromMatrixPosition(b.matrixWorld),
                        A.direction.transformDirection(v),
                        A.direction.normalize(),
                        A.skyColor.copy(b.color).multiplyScalar(w),
                        A.groundColor.copy(b.groundColor).multiplyScalar(w),
                        t.hemi[g] = A,
                        g++
                    }
                }
                t.ambient[0] = l,
                t.ambient[1] = c,
                t.ambient[2] = h,
                t.directional.length = p,
                t.spot.length = f,
                t.rectArea.length = m,
                t.point.length = d,
                t.hemi.length = g,
                t.hash.stateID = t.id,
                t.hash.directionalLength = p,
                t.hash.pointLength = d,
                t.hash.spotLength = f,
                t.hash.rectAreaLength = m,
                t.hash.hemiLength = g,
                t.hash.shadowsLength = a.length
            },
            state: t
        }
    }
    function Br() {
        var e = new Ur
          , t = []
          , i = [];
        return {
            init: function() {
                t.length = 0,
                i.length = 0
            },
            state: {
                lightsArray: t,
                shadowsArray: i,
                lights: e
            },
            setupLights: function(n) {
                e.setup(t, i, n)
            },
            pushLight: function(e) {
                t.push(e)
            },
            pushShadow: function(e) {
                i.push(e)
            }
        }
    }
    function jr() {
        var e = {};
        function t(i) {
            var n = i.target;
            n.removeEventListener("dispose", t),
            delete e[n.id]
        }
        return {
            get: function(i, n) {
                var r;
                return void 0 === e[i.id] ? (r = new Br,
                e[i.id] = {},
                e[i.id][n.id] = r,
                i.addEventListener("dispose", t)) : void 0 === e[i.id][n.id] ? (r = new Br,
                e[i.id][n.id] = r) : r = e[i.id][n.id],
                r
            },
            dispose: function() {
                e = {}
            }
        }
    }
    function Vr(e) {
        Hi.call(this),
        this.type = "MeshDepthMaterial",
        this.depthPacking = wt,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function Gr(e) {
        Hi.call(this),
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new Ct,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.fog = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function Xr(e, t, i) {
        for (var n = new ti, r = new ii, s = new At, a = new At(i,i), o = new Ct, l = new Ct, c = 1, h = 2, p = 1 + (c | h), g = new Array(p), v = new Array(p), y = {}, x = {
            0: f,
            1: d,
            2: m
        }, w = [new Ct(1,0,0), new Ct(-1,0,0), new Ct(0,0,1), new Ct(0,0,-1), new Ct(0,1,0), new Ct(0,-1,0)], _ = [new Ct(0,1,0), new Ct(0,1,0), new Ct(0,1,0), new Ct(0,1,0), new Ct(0,0,1), new Ct(0,0,-1)], T = [new qt, new qt, new qt, new qt, new qt, new qt], M = 0; M !== p; ++M) {
            var S = 0 != (M & c)
              , A = 0 != (M & h)
              , P = new Vr({
                depthPacking: _t,
                morphTargets: S,
                skinning: A
            });
            g[M] = P;
            var C = new Gr({
                morphTargets: S,
                skinning: A
            });
            v[M] = C
        }
        var L = this;
        function k(t, i, n, r, s, a) {
            var o = t.geometry
              , l = null
              , u = g
              , p = t.customDepthMaterial;
            if (n && (u = v,
            p = t.customDistanceMaterial),
            p)
                l = p;
            else {
                var d = !1;
                i.morphTargets && (o && o.isBufferGeometry ? d = o.morphAttributes && o.morphAttributes.position && o.morphAttributes.position.length > 0 : o && o.isGeometry && (d = o.morphTargets && o.morphTargets.length > 0)),
                t.isSkinnedMesh && i.skinning;
                var f = t.isSkinnedMesh && i.skinning
                  , m = 0;
                d && (m |= c),
                f && (m |= h),
                l = u[m]
            }
            if (e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                var b = l.uuid
                  , w = i.uuid
                  , _ = y[b];
                void 0 === _ && (_ = {},
                y[b] = _);
                var T = _[w];
                void 0 === T && (T = l.clone(),
                _[w] = T),
                l = T
            }
            return l.visible = i.visible,
            l.wireframe = i.wireframe,
            l.side = null != i.shadowSide ? i.shadowSide : x[i.side],
            l.clipShadows = i.clipShadows,
            l.clippingPlanes = i.clippingPlanes,
            l.clipIntersection = i.clipIntersection,
            l.wireframeLinewidth = i.wireframeLinewidth,
            l.linewidth = i.linewidth,
            n && l.isMeshDistanceMaterial && (l.referencePosition.copy(r),
            l.nearDistance = s,
            l.farDistance = a),
            l
        }
        function E(i, r, s, a) {
            if (!1 !== i.visible) {
                if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || n.intersectsObject(i))) {
                    i.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, i.matrixWorld);
                    var o = t.update(i)
                      , c = i.material;
                    if (Array.isArray(c))
                        for (var h = o.groups, u = 0, p = h.length; u < p; u++) {
                            var d = h[u]
                              , f = c[d.materialIndex];
                            if (f && f.visible) {
                                var m = k(i, f, a, l, s.near, s.far);
                                e.renderBufferDirect(s, null, o, m, i, d)
                            }
                        }
                    else if (c.visible) {
                        m = k(i, c, a, l, s.near, s.far);
                        e.renderBufferDirect(s, null, o, m, i, null)
                    }
                }
                for (var g = i.children, v = 0, y = g.length; v < y; v++)
                    E(g[v], r, s, a)
            }
        }
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = u,
        this.render = function(t, i, c) {
            if (!1 !== L.enabled && (!1 !== L.autoUpdate || !1 !== L.needsUpdate) && 0 !== t.length) {
                var h, u = e.getRenderTarget(), p = e.state;
                p.setBlending(b),
                p.buffers.color.setClear(1, 1, 1, 1),
                p.buffers.depth.setTest(!0),
                p.setScissorTest(!1);
                for (var d = 0, f = t.length; d < f; d++) {
                    var m = t[d]
                      , g = m.shadow
                      , v = m && m.isPointLight;
                    if (void 0 !== g) {
                        var y = g.camera;
                        if (s.copy(g.mapSize),
                        s.min(a),
                        v) {
                            var x = s.x
                              , M = s.y;
                            T[0].set(2 * x, M, x, M),
                            T[1].set(0, M, x, M),
                            T[2].set(3 * x, M, x, M),
                            T[3].set(x, M, x, M),
                            T[4].set(3 * x, 0, x, M),
                            T[5].set(x, 0, x, M),
                            s.x *= 4,
                            s.y *= 2
                        }
                        if (null === g.map) {
                            var S = {
                                minFilter: fe,
                                magFilter: fe,
                                format: Oe
                            };
                            g.map = new Ht(s.x,s.y,S),
                            g.map.texture.name = m.name + ".shadowMap",
                            y.updateProjectionMatrix()
                        }
                        g.isSpotLightShadow && g.update(m);
                        var A = g.map
                          , P = g.matrix;
                        l.setFromMatrixPosition(m.matrixWorld),
                        y.position.copy(l),
                        v ? (h = 6,
                        P.makeTranslation(-l.x, -l.y, -l.z)) : (h = 1,
                        o.setFromMatrixPosition(m.target.matrixWorld),
                        y.lookAt(o),
                        y.updateMatrixWorld(),
                        P.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        P.multiply(y.projectionMatrix),
                        P.multiply(y.matrixWorldInverse)),
                        e.setRenderTarget(A),
                        e.clear();
                        for (var C = 0; C < h; C++) {
                            if (v) {
                                o.copy(y.position),
                                o.add(w[C]),
                                y.up.copy(_[C]),
                                y.lookAt(o),
                                y.updateMatrixWorld();
                                var k = T[C];
                                p.viewport(k)
                            }
                            r.multiplyMatrices(y.projectionMatrix, y.matrixWorldInverse),
                            n.setFromMatrix(r),
                            E(i, c, y, v)
                        }
                    }
                }
                L.needsUpdate = !1,
                e.setRenderTarget(u)
            }
        }
    }
    function Yr(e, t, i, n) {
        var r = new function() {
            var t = !1
              , i = new qt
              , n = null
              , r = new qt(0,0,0,0);
            return {
                setMask: function(i) {
                    n === i || t || (e.colorMask(i, i, i, i),
                    n = i)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t, n, s, a, o) {
                    !0 === o && (t *= a,
                    n *= a,
                    s *= a),
                    i.set(t, n, s, a),
                    !1 === r.equals(i) && (e.clearColor(t, n, s, a),
                    r.copy(i))
                },
                reset: function() {
                    t = !1,
                    n = null,
                    r.set(-1, 0, 0, 0)
                }
            }
        }
          , s = new function() {
            var t = !1
              , i = null
              , n = null
              , r = null;
            return {
                setTest: function(e) {
                    e ? se(2929) : ae(2929)
                },
                setMask: function(n) {
                    i === n || t || (e.depthMask(n),
                    i = n)
                },
                setFunc: function(t) {
                    if (n !== t) {
                        if (t)
                            switch (t) {
                            case j:
                                e.depthFunc(512);
                                break;
                            case V:
                                e.depthFunc(519);
                                break;
                            case G:
                                e.depthFunc(513);
                                break;
                            case X:
                                e.depthFunc(515);
                                break;
                            case Y:
                                e.depthFunc(514);
                                break;
                            case W:
                                e.depthFunc(518);
                                break;
                            case q:
                                e.depthFunc(516);
                                break;
                            case H:
                                e.depthFunc(517);
                                break;
                            default:
                                e.depthFunc(515)
                            }
                        else
                            e.depthFunc(515);
                        n = t
                    }
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t) {
                    r !== t && (e.clearDepth(t),
                    r = t)
                },
                reset: function() {
                    t = !1,
                    i = null,
                    n = null,
                    r = null
                }
            }
        }
          , a = new function() {
            var t = !1
              , i = null
              , n = null
              , r = null
              , s = null
              , a = null
              , o = null
              , l = null
              , c = null;
            return {
                setTest: function(e) {
                    e ? se(2960) : ae(2960)
                },
                setMask: function(n) {
                    i === n || t || (e.stencilMask(n),
                    i = n)
                },
                setFunc: function(t, i, a) {
                    n === t && r === i && s === a || (e.stencilFunc(t, i, a),
                    n = t,
                    r = i,
                    s = a)
                },
                setOp: function(t, i, n) {
                    a === t && o === i && l === n || (e.stencilOp(t, i, n),
                    a = t,
                    o = i,
                    l = n)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t) {
                    c !== t && (e.clearStencil(t),
                    c = t)
                },
                reset: function() {
                    t = !1,
                    i = null,
                    n = null,
                    r = null,
                    s = null,
                    a = null,
                    o = null,
                    l = null,
                    c = null
                }
            }
        }
          , h = e.getParameter(34921)
          , u = new Uint8Array(h)
          , p = new Uint8Array(h)
          , d = new Uint8Array(h)
          , g = {}
          , v = null
          , y = null
          , A = null
          , P = null
          , C = null
          , L = null
          , k = null
          , E = null
          , I = null
          , F = null
          , O = !1
          , R = null
          , z = null
          , N = null
          , D = null
          , U = null
          , B = e.getParameter(35661)
          , Q = !1
          , J = 0
          , Z = e.getParameter(7938);
        -1 !== Z.indexOf("WebGL") ? (J = parseFloat(/^WebGL\ ([0-9])/.exec(Z)[1]),
        Q = J >= 1) : -1 !== Z.indexOf("OpenGL ES") && (J = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(Z)[1]),
        Q = J >= 2);
        var $ = null
          , K = {}
          , ee = new qt
          , te = new qt;
        function ie(t, i, n) {
            var r = new Uint8Array(4)
              , s = e.createTexture();
            e.bindTexture(t, s),
            e.texParameteri(t, 10241, 9728),
            e.texParameteri(t, 10240, 9728);
            for (var a = 0; a < n; a++)
                e.texImage2D(i + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return s
        }
        var ne = {};
        function re(i, r) {
            (u[i] = 1,
            0 === p[i] && (e.enableVertexAttribArray(i),
            p[i] = 1),
            d[i] !== r) && ((n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r),
            d[i] = r)
        }
        function se(t) {
            !0 !== g[t] && (e.enable(t),
            g[t] = !0)
        }
        function ae(t) {
            !1 !== g[t] && (e.disable(t),
            g[t] = !1)
        }
        function oe(t, n, r, s, a, o, l, c) {
            if (t !== b) {
                if (A || (se(3042),
                A = !0),
                t === M)
                    a = a || n,
                    o = o || r,
                    l = l || s,
                    n === C && a === E || (e.blendEquationSeparate(i.convert(n), i.convert(a)),
                    C = n,
                    E = a),
                    r === L && s === k && o === I && l === F || (e.blendFuncSeparate(i.convert(r), i.convert(s), i.convert(o), i.convert(l)),
                    L = r,
                    k = s,
                    I = o,
                    F = l),
                    P = t,
                    O = null;
                else if (t !== P || c !== O) {
                    if (C === S && E === S || (e.blendEquation(32774),
                    C = S,
                    E = S),
                    c)
                        switch (t) {
                        case x:
                            e.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case w:
                            e.blendFunc(1, 1);
                            break;
                        case _:
                            e.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case T:
                            e.blendFuncSeparate(0, 768, 0, 770)
                        }
                    else
                        switch (t) {
                        case x:
                            e.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case w:
                            e.blendFunc(770, 1);
                            break;
                        case _:
                            e.blendFunc(0, 769);
                            break;
                        case T:
                            e.blendFunc(0, 768)
                        }
                    L = null,
                    k = null,
                    I = null,
                    F = null,
                    P = t,
                    O = c
                }
            } else
                A && (ae(3042),
                A = !1)
        }
        function le(t) {
            R !== t && (t ? e.frontFace(2304) : e.frontFace(2305),
            R = t)
        }
        function ce(t) {
            t !== o ? (se(2884),
            t !== z && (t === l ? e.cullFace(1029) : t === c ? e.cullFace(1028) : e.cullFace(1032))) : ae(2884),
            z = t
        }
        function he(t, i, n) {
            t ? (se(32823),
            D === i && U === n || (e.polygonOffset(i, n),
            D = i,
            U = n)) : ae(32823)
        }
        function ue(t) {
            void 0 === t && (t = 33984 + B - 1),
            $ !== t && (e.activeTexture(t),
            $ = t)
        }
        return ne[3553] = ie(3553, 3553, 1),
        ne[34067] = ie(34067, 34069, 6),
        r.setClear(0, 0, 0, 1),
        s.setClear(1),
        a.setClear(0),
        se(2929),
        s.setFunc(X),
        le(!1),
        ce(l),
        se(2884),
        oe(b),
        {
            buffers: {
                color: r,
                depth: s,
                stencil: a
            },
            initAttributes: function() {
                for (var e = 0, t = u.length; e < t; e++)
                    u[e] = 0
            },
            enableAttribute: function(e) {
                re(e, 0)
            },
            enableAttributeAndDivisor: re,
            disableUnusedAttributes: function() {
                for (var t = 0, i = p.length; t !== i; ++t)
                    p[t] !== u[t] && (e.disableVertexAttribArray(t),
                    p[t] = 0)
            },
            enable: se,
            disable: ae,
            getCompressedTextureFormats: function() {
                if (null === v && (v = [],
                t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
                    for (var i = e.getParameter(34467), n = 0; n < i.length; n++)
                        v.push(i[n]);
                return v
            },
            useProgram: function(t) {
                return y !== t && (e.useProgram(t),
                y = t,
                !0)
            },
            setBlending: oe,
            setMaterial: function(e, t) {
                e.side === m ? ae(2884) : se(2884);
                var i = e.side === f;
                t && (i = !i),
                le(i),
                e.blending === x && !1 === e.transparent ? oe(b) : oe(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
                s.setFunc(e.depthFunc),
                s.setTest(e.depthTest),
                s.setMask(e.depthWrite),
                r.setMask(e.colorWrite),
                he(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            },
            setFlipSided: le,
            setCullFace: ce,
            setLineWidth: function(t) {
                t !== N && (Q && e.lineWidth(t),
                N = t)
            },
            setPolygonOffset: he,
            setScissorTest: function(e) {
                e ? se(3089) : ae(3089)
            },
            activeTexture: ue,
            bindTexture: function(t, i) {
                null === $ && ue();
                var n = K[$];
                void 0 === n && (n = {
                    type: void 0,
                    texture: void 0
                },
                K[$] = n),
                n.type === t && n.texture === i || (e.bindTexture(t, i || ne[t]),
                n.type = t,
                n.texture = i)
            },
            compressedTexImage2D: function() {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (e) {}
            },
            texImage2D: function() {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (e) {}
            },
            texImage3D: function() {
                try {
                    e.texImage3D.apply(e, arguments)
                } catch (e) {}
            },
            scissor: function(t) {
                !1 === ee.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                ee.copy(t))
            },
            viewport: function(t) {
                !1 === te.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                te.copy(t))
            },
            reset: function() {
                for (var t = 0; t < p.length; t++)
                    1 === p[t] && (e.disableVertexAttribArray(t),
                    p[t] = 0);
                g = {},
                v = null,
                $ = null,
                K = {},
                y = null,
                P = null,
                R = null,
                z = null,
                r.reset(),
                s.reset(),
                a.reset()
            }
        }
    }
    function Wr(e, t, i, n, r, s, a) {
        var o, l = {}, c = "undefined" != typeof OffscreenCanvas;
        function h(e, t) {
            return c ? new OffscreenCanvas(e,t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }
        function u(e, t, i, n) {
            var r = 1;
            if ((e.width > n || e.height > n) && (r = n / Math.max(e.width, e.height)),
            r < 1 || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    var s = t ? St.floorPowerOfTwo : Math.floor
                      , a = s(r * e.width)
                      , l = s(r * e.height);
                    void 0 === o && (o = h(a, l));
                    var c = i ? h(a, l) : o;
                    return c.width = a,
                    c.height = l,
                    c.getContext("2d").drawImage(e, 0, 0, a, l),
                    c
                }
                return e
            }
            return e
        }
        function p(e) {
            return St.isPowerOfTwo(e.width) && St.isPowerOfTwo(e.height)
        }
        function d(e, t) {
            return e.generateMipmaps && t && e.minFilter !== fe && e.minFilter !== ve
        }
        function f(t, i, r, s) {
            e.generateMipmap(t),
            n.get(i).__maxMipLevel = Math.log(Math.max(r, s)) * Math.LOG2E
        }
        function m(e, i) {
            if (!r.isWebGL2)
                return e;
            var n = e;
            return 6403 === e && (5126 === i && (n = 33326),
            5131 === i && (n = 33325),
            5121 === i && (n = 33321)),
            6407 === e && (5126 === i && (n = 34837),
            5131 === i && (n = 34843),
            5121 === i && (n = 32849)),
            6408 === e && (5126 === i && (n = 34836),
            5131 === i && (n = 34842),
            5121 === i && (n = 32856)),
            33325 !== n && 33326 !== n && 34842 !== n && 34836 !== n || t.get("EXT_color_buffer_float"),
            n
        }
        function g(e) {
            return e === fe || e === me || e === ge ? 9728 : 9729
        }
        function v(t) {
            var i = t.target;
            i.removeEventListener("dispose", v),
            function(t) {
                var i = n.get(t);
                if (void 0 === i.__webglInit)
                    return;
                e.deleteTexture(i.__webglTexture),
                n.remove(t)
            }(i),
            i.isVideoTexture && delete l[i.id],
            a.memory.textures--
        }
        function y(t) {
            var i = t.target;
            i.removeEventListener("dispose", y),
            function(t) {
                var i = n.get(t)
                  , r = n.get(t.texture);
                if (!t)
                    return;
                void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture);
                t.depthTexture && t.depthTexture.dispose();
                if (t.isWebGLRenderTargetCube)
                    for (var s = 0; s < 6; s++)
                        e.deleteFramebuffer(i.__webglFramebuffer[s]),
                        i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[s]);
                else
                    e.deleteFramebuffer(i.__webglFramebuffer),
                    i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer);
                n.remove(t.texture),
                n.remove(t)
            }(i),
            a.memory.textures--
        }
        var b = 0;
        function x(e, t) {
            var r = n.get(e);
            if (e.isVideoTexture && function(e) {
                var t = e.id
                  , i = a.render.frame;
                l[t] !== i && (l[t] = i,
                e.update())
            }(e),
            e.version > 0 && r.__version !== e.version) {
                var s = e.image;
                if (void 0 === s)
                    ;
                else if (!1 !== s.complete)
                    return void S(r, e, t)
            }
            i.activeTexture(33984 + t),
            i.bindTexture(3553, r.__webglTexture)
        }
        function w(t, a) {
            var o = n.get(t);
            if (6 === t.image.length)
                if (t.version > 0 && o.__version !== t.version) {
                    M(o, t),
                    i.activeTexture(33984 + a),
                    i.bindTexture(34067, o.__webglTexture),
                    e.pixelStorei(37440, t.flipY);
                    for (var l = t && t.isCompressedTexture, c = t.image[0] && t.image[0].isDataTexture, h = [], g = 0; g < 6; g++)
                        h[g] = l || c ? c ? t.image[g].image : t.image[g] : u(t.image[g], !1, !0, r.maxCubemapSize);
                    var v = h[0]
                      , y = p(v) || r.isWebGL2
                      , b = s.convert(t.format)
                      , x = s.convert(t.type)
                      , w = m(b, x);
                    T(34067, t, y);
                    for (g = 0; g < 6; g++)
                        if (l)
                            for (var _, S = h[g].mipmaps, A = 0, P = S.length; A < P; A++)
                                _ = S[A],
                                t.format !== Oe && t.format !== Fe ? i.getCompressedTextureFormats().indexOf(b) > -1 && i.compressedTexImage2D(34069 + g, A, w, _.width, _.height, 0, _.data) : i.texImage2D(34069 + g, A, w, _.width, _.height, 0, b, x, _.data);
                        else
                            c ? i.texImage2D(34069 + g, 0, w, h[g].width, h[g].height, 0, b, x, h[g].data) : i.texImage2D(34069 + g, 0, w, b, x, h[g]);
                    o.__maxMipLevel = l ? S.length - 1 : 0,
                    d(t, y) && f(34067, t, v.width, v.height),
                    o.__version = t.version,
                    t.onUpdate && t.onUpdate(t)
                } else
                    i.activeTexture(33984 + a),
                    i.bindTexture(34067, o.__webglTexture)
        }
        function _(e, t) {
            i.activeTexture(33984 + t),
            i.bindTexture(34067, n.get(e).__webglTexture)
        }
        function T(i, a, o) {
            var l;
            if (o ? (e.texParameteri(i, 10242, s.convert(a.wrapS)),
            e.texParameteri(i, 10243, s.convert(a.wrapT)),
            32879 !== i && 35866 !== i || e.texParameteri(i, 32882, s.convert(a.wrapR)),
            e.texParameteri(i, 10240, s.convert(a.magFilter)),
            e.texParameteri(i, 10241, s.convert(a.minFilter))) : (e.texParameteri(i, 10242, 33071),
            e.texParameteri(i, 10243, 33071),
            32879 !== i && 35866 !== i || e.texParameteri(i, 32882, 33071),
            a.wrapS !== pe || a.wrapT,
            e.texParameteri(i, 10240, g(a.magFilter)),
            e.texParameteri(i, 10241, g(a.minFilter)),
            a.minFilter !== fe && a.minFilter),
            l = t.get("EXT_texture_filter_anisotropic")) {
                if (a.type === Ae && null === t.get("OES_texture_float_linear"))
                    return;
                if (a.type === Pe && null === (r.isWebGL2 || t.get("OES_texture_half_float_linear")))
                    return;
                (a.anisotropy > 1 || n.get(a).__currentAnisotropy) && (e.texParameterf(i, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())),
                n.get(a).__currentAnisotropy = a.anisotropy)
            }
        }
        function M(t, i) {
            void 0 === t.__webglInit && (t.__webglInit = !0,
            i.addEventListener("dispose", v),
            t.__webglTexture = e.createTexture(),
            a.memory.textures++)
        }
        function S(t, n, a) {
            var o = 3553;
            n.isDataTexture2DArray && (o = 35866),
            n.isDataTexture3D && (o = 32879),
            M(t, n),
            i.activeTexture(33984 + a),
            i.bindTexture(o, t.__webglTexture),
            e.pixelStorei(37440, n.flipY),
            e.pixelStorei(37441, n.premultiplyAlpha),
            e.pixelStorei(3317, n.unpackAlignment);
            var l = function(e) {
                return !r.isWebGL2 && (e.wrapS !== pe || e.wrapT !== pe || e.minFilter !== fe && e.minFilter !== ve)
            }(n) && !1 === p(n.image)
              , c = u(n.image, l, !1, r.maxTextureSize)
              , h = p(c) || r.isWebGL2
              , g = s.convert(n.format)
              , v = s.convert(n.type)
              , y = m(g, v);
            T(o, n, h);
            var b, x = n.mipmaps;
            if (n.isDepthTexture) {
                if (y = 6402,
                n.type === Ae) {
                    if (!r.isWebGL2)
                        throw new Error("Float Depth Texture only supported in WebGL2.0");
                    y = 36012
                } else
                    r.isWebGL2 && (y = 33189);
                n.format === Ne && 6402 === y && n.type !== Te && n.type !== Se && (n.type = Te,
                v = s.convert(n.type)),
                n.format === De && (y = 34041,
                n.type !== Ee && (n.type = Ee,
                v = s.convert(n.type))),
                i.texImage2D(3553, 0, y, c.width, c.height, 0, g, v, null)
            } else if (n.isDataTexture)
                if (x.length > 0 && h) {
                    for (var w = 0, _ = x.length; w < _; w++)
                        b = x[w],
                        i.texImage2D(3553, w, y, b.width, b.height, 0, g, v, b.data);
                    n.generateMipmaps = !1,
                    t.__maxMipLevel = x.length - 1
                } else
                    i.texImage2D(3553, 0, y, c.width, c.height, 0, g, v, c.data),
                    t.__maxMipLevel = 0;
            else if (n.isCompressedTexture) {
                for (w = 0,
                _ = x.length; w < _; w++)
                    b = x[w],
                    n.format !== Oe && n.format !== Fe ? i.getCompressedTextureFormats().indexOf(g) > -1 && i.compressedTexImage2D(3553, w, y, b.width, b.height, 0, b.data) : i.texImage2D(3553, w, y, b.width, b.height, 0, g, v, b.data);
                t.__maxMipLevel = x.length - 1
            } else if (n.isDataTexture2DArray)
                i.texImage3D(35866, 0, y, c.width, c.height, c.depth, 0, g, v, c.data),
                t.__maxMipLevel = 0;
            else if (n.isDataTexture3D)
                i.texImage3D(32879, 0, y, c.width, c.height, c.depth, 0, g, v, c.data),
                t.__maxMipLevel = 0;
            else if (x.length > 0 && h) {
                for (w = 0,
                _ = x.length; w < _; w++)
                    b = x[w],
                    i.texImage2D(3553, w, y, g, v, b);
                n.generateMipmaps = !1,
                t.__maxMipLevel = x.length - 1
            } else
                i.texImage2D(3553, 0, y, g, v, c),
                t.__maxMipLevel = 0;
            d(n, h) && f(3553, n, c.width, c.height),
            t.__version = n.version,
            n.onUpdate && n.onUpdate(n)
        }
        function A(t, r, a, o) {
            var l = s.convert(r.texture.format)
              , c = s.convert(r.texture.type)
              , h = m(l, c);
            i.texImage2D(o, 0, h, r.width, r.height, 0, l, c, null),
            e.bindFramebuffer(36160, t),
            e.framebufferTexture2D(36160, a, o, n.get(r.texture).__webglTexture, 0),
            e.bindFramebuffer(36160, null)
        }
        function P(t, i, n) {
            if (e.bindRenderbuffer(36161, t),
            i.depthBuffer && !i.stencilBuffer) {
                if (n) {
                    var r = L(i);
                    e.renderbufferStorageMultisample(36161, r, 33189, i.width, i.height)
                } else
                    e.renderbufferStorage(36161, 33189, i.width, i.height);
                e.framebufferRenderbuffer(36160, 36096, 36161, t)
            } else if (i.depthBuffer && i.stencilBuffer) {
                if (n) {
                    r = L(i);
                    e.renderbufferStorageMultisample(36161, r, 34041, i.width, i.height)
                } else
                    e.renderbufferStorage(36161, 34041, i.width, i.height);
                e.framebufferRenderbuffer(36160, 33306, 36161, t)
            } else {
                var a = m(s.convert(i.texture.format), s.convert(i.texture.type));
                if (n) {
                    r = L(i);
                    e.renderbufferStorageMultisample(36161, r, a, i.width, i.height)
                } else
                    e.renderbufferStorage(36161, a, i.width, i.height)
            }
            e.bindRenderbuffer(36161, null)
        }
        function C(t) {
            var i = n.get(t)
              , r = !0 === t.isWebGLRenderTargetCube;
            if (t.depthTexture) {
                if (r)
                    throw new Error("target.depthTexture not supported in Cube render targets");
                !function(t, i) {
                    if (i && i.isWebGLRenderTargetCube)
                        throw new Error("Depth Texture with cube render targets is not supported");
                    if (e.bindFramebuffer(36160, t),
                    !i.depthTexture || !i.depthTexture.isDepthTexture)
                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    n.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width,
                    i.depthTexture.image.height = i.height,
                    i.depthTexture.needsUpdate = !0),
                    x(i.depthTexture, 0);
                    var r = n.get(i.depthTexture).__webglTexture;
                    if (i.depthTexture.format === Ne)
                        e.framebufferTexture2D(36160, 36096, 3553, r, 0);
                    else {
                        if (i.depthTexture.format !== De)
                            throw new Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, r, 0)
                    }
                }(i.__webglFramebuffer, t)
            } else if (r) {
                i.__webglDepthbuffer = [];
                for (var s = 0; s < 6; s++)
                    e.bindFramebuffer(36160, i.__webglFramebuffer[s]),
                    i.__webglDepthbuffer[s] = e.createRenderbuffer(),
                    P(i.__webglDepthbuffer[s], t)
            } else
                e.bindFramebuffer(36160, i.__webglFramebuffer),
                i.__webglDepthbuffer = e.createRenderbuffer(),
                P(i.__webglDepthbuffer, t);
            e.bindFramebuffer(36160, null)
        }
        function L(e) {
            return r.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, e.samples) : 0
        }
        var k = !1
          , E = !1;
        this.allocateTextureUnit = function() {
            var e = b;
            return r.maxTextures,
            b += 1,
            e
        }
        ,
        this.resetTextureUnits = function() {
            b = 0
        }
        ,
        this.setTexture2D = x,
        this.setTexture2DArray = function(e, t) {
            var r = n.get(e);
            e.version > 0 && r.__version !== e.version ? S(r, e, t) : (i.activeTexture(33984 + t),
            i.bindTexture(35866, r.__webglTexture))
        }
        ,
        this.setTexture3D = function(e, t) {
            var r = n.get(e);
            e.version > 0 && r.__version !== e.version ? S(r, e, t) : (i.activeTexture(33984 + t),
            i.bindTexture(32879, r.__webglTexture))
        }
        ,
        this.setTextureCube = w,
        this.setTextureCubeDynamic = _,
        this.setupRenderTarget = function(t) {
            var o = n.get(t)
              , l = n.get(t.texture);
            t.addEventListener("dispose", y),
            l.__webglTexture = e.createTexture(),
            a.memory.textures++;
            var c = !0 === t.isWebGLRenderTargetCube
              , h = !0 === t.isWebGLMultisampleRenderTarget
              , u = p(t) || r.isWebGL2;
            if (c) {
                o.__webglFramebuffer = [];
                for (var g = 0; g < 6; g++)
                    o.__webglFramebuffer[g] = e.createFramebuffer()
            } else if (o.__webglFramebuffer = e.createFramebuffer(),
            h && r.isWebGL2) {
                o.__webglMultisampledFramebuffer = e.createFramebuffer(),
                o.__webglColorRenderbuffer = e.createRenderbuffer(),
                e.bindRenderbuffer(36161, o.__webglColorRenderbuffer);
                var v = m(s.convert(t.texture.format), s.convert(t.texture.type))
                  , b = L(t);
                e.renderbufferStorageMultisample(36161, b, v, t.width, t.height),
                e.bindFramebuffer(36160, o.__webglMultisampledFramebuffer),
                e.framebufferRenderbuffer(36160, 36064, 36161, o.__webglColorRenderbuffer),
                e.bindRenderbuffer(36161, null),
                t.depthBuffer && (o.__webglDepthRenderbuffer = e.createRenderbuffer(),
                P(o.__webglDepthRenderbuffer, t, !0)),
                e.bindFramebuffer(36160, null)
            }
            if (c) {
                for (i.bindTexture(34067, l.__webglTexture),
                T(34067, t.texture, u),
                g = 0; g < 6; g++)
                    A(o.__webglFramebuffer[g], t, 36064, 34069 + g);
                d(t.texture, u) && f(34067, t.texture, t.width, t.height),
                i.bindTexture(34067, null)
            } else
                i.bindTexture(3553, l.__webglTexture),
                T(3553, t.texture, u),
                A(o.__webglFramebuffer, t, 36064, 3553),
                d(t.texture, u) && f(3553, t.texture, t.width, t.height),
                i.bindTexture(3553, null);
            t.depthBuffer && C(t)
        }
        ,
        this.updateRenderTargetMipmap = function(e) {
            var t = e.texture;
            if (d(t, p(e) || r.isWebGL2)) {
                var s = e.isWebGLRenderTargetCube ? 34067 : 3553
                  , a = n.get(t).__webglTexture;
                i.bindTexture(s, a),
                f(s, t, e.width, e.height),
                i.bindTexture(s, null)
            }
        }
        ,
        this.updateMultisampleRenderTarget = function(t) {
            if (t.isWebGLMultisampleRenderTarget && r.isWebGL2) {
                var i = n.get(t);
                e.bindFramebuffer(36008, i.__webglMultisampledFramebuffer),
                e.bindFramebuffer(36009, i.__webglFramebuffer);
                var s = t.width
                  , a = t.height
                  , o = 16384;
                t.depthBuffer && (o |= 256),
                t.stencilBuffer && (o |= 1024),
                e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, 9728)
            }
        }
        ,
        this.safeSetTexture2D = function(e, t) {
            e && e.isWebGLRenderTarget && (!1 === k && (k = !0),
            e = e.texture),
            x(e, t)
        }
        ,
        this.safeSetTextureCube = function(e, t) {
            e && e.isWebGLRenderTargetCube && (!1 === E && (E = !0),
            e = e.texture),
            e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? w(e, t) : _(e, t)
        }
    }
    function qr(e, t, i) {
        return {
            convert: function(e) {
                var n;
                if (e === ue)
                    return 10497;
                if (e === pe)
                    return 33071;
                if (e === de)
                    return 33648;
                if (e === fe)
                    return 9728;
                if (e === me)
                    return 9984;
                if (e === ge)
                    return 9986;
                if (e === ve)
                    return 9729;
                if (e === ye)
                    return 9985;
                if (e === be)
                    return 9987;
                if (e === xe)
                    return 5121;
                if (e === Ce)
                    return 32819;
                if (e === Le)
                    return 32820;
                if (e === ke)
                    return 33635;
                if (e === we)
                    return 5120;
                if (e === _e)
                    return 5122;
                if (e === Te)
                    return 5123;
                if (e === Me)
                    return 5124;
                if (e === Se)
                    return 5125;
                if (e === Ae)
                    return 5126;
                if (e === Pe) {
                    if (i.isWebGL2)
                        return 5131;
                    if (null !== (n = t.get("OES_texture_half_float")))
                        return n.HALF_FLOAT_OES
                }
                if (e === Ie)
                    return 6406;
                if (e === Fe)
                    return 6407;
                if (e === Oe)
                    return 6408;
                if (e === Re)
                    return 6409;
                if (e === ze)
                    return 6410;
                if (e === Ne)
                    return 6402;
                if (e === De)
                    return 34041;
                if (e === Ue)
                    return 6403;
                if (e === S)
                    return 32774;
                if (e === A)
                    return 32778;
                if (e === P)
                    return 32779;
                if (e === k)
                    return 0;
                if (e === E)
                    return 1;
                if (e === I)
                    return 768;
                if (e === F)
                    return 769;
                if (e === O)
                    return 770;
                if (e === R)
                    return 771;
                if (e === z)
                    return 772;
                if (e === N)
                    return 773;
                if (e === D)
                    return 774;
                if (e === U)
                    return 775;
                if (e === B)
                    return 776;
                if ((e === Be || e === je || e === Ve || e === Ge) && null !== (n = t.get("WEBGL_compressed_texture_s3tc"))) {
                    if (e === Be)
                        return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (e === je)
                        return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (e === Ve)
                        return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (e === Ge)
                        return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((e === Xe || e === Ye || e === We || e === qe) && null !== (n = t.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (e === Xe)
                        return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (e === Ye)
                        return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (e === We)
                        return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (e === qe)
                        return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (e === He && null !== (n = t.get("WEBGL_compressed_texture_etc1")))
                    return n.COMPRESSED_RGB_ETC1_WEBGL;
                if ((e === Qe || e === Je || e === Ze || e === $e || e === Ke || e === et || e === tt || e === it || e === nt || e === rt || e === st || e === at || e === ot || e === lt) && null !== (n = t.get("WEBGL_compressed_texture_astc")))
                    return e;
                if (e === C || e === L) {
                    if (i.isWebGL2) {
                        if (e === C)
                            return 32775;
                        if (e === L)
                            return 32776
                    }
                    if (null !== (n = t.get("EXT_blend_minmax"))) {
                        if (e === C)
                            return n.MIN_EXT;
                        if (e === L)
                            return n.MAX_EXT
                    }
                }
                if (e === Ee) {
                    if (i.isWebGL2)
                        return 34042;
                    if (null !== (n = t.get("WEBGL_depth_texture")))
                        return n.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }
    function Hr() {
        Mi.call(this),
        this.type = "Group"
    }
    function Qr() {
        Mi.call(this),
        this.type = "Camera",
        this.matrixWorldInverse = new ii,
        this.projectionMatrix = new ii,
        this.projectionMatrixInverse = new ii
    }
    function Jr(e, t, i, n) {
        Qr.call(this),
        this.type = "PerspectiveCamera",
        this.fov = void 0 !== e ? e : 50,
        this.zoom = 1,
        this.near = void 0 !== i ? i : .1,
        this.far = void 0 !== n ? n : 2e3,
        this.focus = 10,
        this.aspect = void 0 !== t ? t : 1,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    function Zr(e) {
        Jr.call(this),
        this.cameras = e || []
    }
    Vr.prototype = Object.create(Hi.prototype),
    Vr.prototype.constructor = Vr,
    Vr.prototype.isMeshDepthMaterial = !0,
    Vr.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.depthPacking = e.depthPacking,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
    ,
    Gr.prototype = Object.create(Hi.prototype),
    Gr.prototype.constructor = Gr,
    Gr.prototype.isMeshDistanceMaterial = !0,
    Gr.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
    ,
    Hr.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: Hr,
        isGroup: !0
    }),
    Qr.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: Qr,
        isCamera: !0,
        copy: function(e, t) {
            return Mi.prototype.copy.call(this, e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
        },
        getWorldDirection: function(e) {
            void 0 === e && (e = new Ct),
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function(e) {
            Mi.prototype.updateMatrixWorld.call(this, e),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    Jr.prototype = Object.assign(Object.create(Qr.prototype), {
        constructor: Jr,
        isPerspectiveCamera: !0,
        copy: function(e, t) {
            return Qr.prototype.copy.call(this, e, t),
            this.fov = e.fov,
            this.zoom = e.zoom,
            this.near = e.near,
            this.far = e.far,
            this.focus = e.focus,
            this.aspect = e.aspect,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this.filmGauge = e.filmGauge,
            this.filmOffset = e.filmOffset,
            this
        },
        setFocalLength: function(e) {
            var t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * St.RAD2DEG * Math.atan(t),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var e = Math.tan(.5 * St.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function() {
            return 2 * St.RAD2DEG * Math.atan(Math.tan(.5 * St.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(e, t, i, n, r, s) {
            this.aspect = e / t,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = i,
            this.view.offsetY = n,
            this.view.width = r,
            this.view.height = s,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = this.near
              , t = e * Math.tan(.5 * St.DEG2RAD * this.fov) / this.zoom
              , i = 2 * t
              , n = this.aspect * i
              , r = -.5 * n
              , s = this.view;
            if (null !== this.view && this.view.enabled) {
                var a = s.fullWidth
                  , o = s.fullHeight;
                r += s.offsetX * n / a,
                t -= s.offsetY * i / o,
                n *= s.width / a,
                i *= s.height / o
            }
            var l = this.filmOffset;
            0 !== l && (r += e * l / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            var t = Mi.prototype.toJSON.call(this, e);
            return t.object.fov = this.fov,
            t.object.zoom = this.zoom,
            t.object.near = this.near,
            t.object.far = this.far,
            t.object.focus = this.focus,
            t.object.aspect = this.aspect,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t.object.filmGauge = this.filmGauge,
            t.object.filmOffset = this.filmOffset,
            t
        }
    }),
    Zr.prototype = Object.assign(Object.create(Jr.prototype), {
        constructor: Zr,
        isArrayCamera: !0
    });
    var $r, Kr, es, ts, is, ns, rs = new Ct, ss = new Ct;
    function as(e, t, i) {
        rs.setFromMatrixPosition(t.matrixWorld),
        ss.setFromMatrixPosition(i.matrixWorld);
        var n = rs.distanceTo(ss)
          , r = t.projectionMatrix.elements
          , s = i.projectionMatrix.elements
          , a = r[14] / (r[10] - 1)
          , o = r[14] / (r[10] + 1)
          , l = (r[9] + 1) / r[5]
          , c = (r[9] - 1) / r[5]
          , h = (r[8] - 1) / r[0]
          , u = (s[8] + 1) / s[0]
          , p = a * h
          , d = a * u
          , f = n / (-h + u)
          , m = f * -h;
        t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
        e.translateX(m),
        e.translateZ(f),
        e.matrixWorld.compose(e.position, e.quaternion, e.scale),
        e.matrixWorldInverse.getInverse(e.matrixWorld);
        var g = a + f
          , v = o + f
          , y = p - m
          , b = d + (n - m)
          , x = l * o / v * g
          , w = c * o / v * g;
        e.projectionMatrix.makePerspective(y, b, x, w, g, v)
    }
    function os(e) {
        var t = this
          , i = null
          , n = null
          , r = null
          , s = []
          , a = new ii
          , o = new ii
          , l = 1
          , c = "stage";
        "undefined" != typeof window && "VRFrameData"in window && (n = new window.VRFrameData,
        window.addEventListener("vrdisplaypresentchange", b, !1));
        var h = new ii
          , u = new Pt
          , p = new Ct
          , d = new Jr;
        d.bounds = new qt(0,0,.5,1),
        d.layers.enable(1);
        var f = new Jr;
        f.bounds = new qt(.5,0,.5,1),
        f.layers.enable(2);
        var m = new Zr([d, f]);
        function g() {
            return null !== i && !0 === i.isPresenting
        }
        m.layers.enable(1),
        m.layers.enable(2);
        var v, y = new At;
        function b() {
            if (g()) {
                var n = i.getEyeParameters("left")
                  , r = n.renderWidth * l
                  , s = n.renderHeight * l;
                v = e.getPixelRatio(),
                e.getSize(y),
                e.setDrawingBufferSize(2 * r, s, 1),
                _.start()
            } else
                t.enabled && e.setDrawingBufferSize(y.width, y.height, v),
                _.stop()
        }
        var x = [];
        function w(e) {
            for (var t = navigator.getGamepads && navigator.getGamepads(), i = 0, n = 0, r = t.length; i < r; i++) {
                var s = t[i];
                if (s && ("Daydream Controller" === s.id || "Gear VR Controller" === s.id || "Oculus Go Controller" === s.id || "OpenVR Gamepad" === s.id || s.id.startsWith("Oculus Touch") || s.id.startsWith("Spatial Controller"))) {
                    if (n === e)
                        return s;
                    n++
                }
            }
        }
        this.enabled = !1,
        this.getController = function(e) {
            var t = s[e];
            return void 0 === t && ((t = new Hr).matrixAutoUpdate = !1,
            t.visible = !1,
            s[e] = t),
            t
        }
        ,
        this.getDevice = function() {
            return i
        }
        ,
        this.setDevice = function(e) {
            void 0 !== e && (i = e),
            _.setContext(e)
        }
        ,
        this.setFramebufferScaleFactor = function(e) {
            l = e
        }
        ,
        this.setFrameOfReferenceType = function(e) {
            c = e
        }
        ,
        this.setPoseTarget = function(e) {
            void 0 !== e && (r = e)
        }
        ,
        this.getCamera = function(e) {
            var t = "stage" === c ? 1.6 : 0;
            if (!1 === g())
                return e.position.set(0, t, 0),
                e.rotation.set(0, 0, 0),
                e;
            if (i.depthNear = e.near,
            i.depthFar = e.far,
            i.getFrameData(n),
            "stage" === c) {
                var l = i.stageParameters;
                l ? a.fromArray(l.sittingToStandingTransform) : a.makeTranslation(0, t, 0)
            }
            var v = n.pose
              , y = null !== r ? r : e;
            y.matrix.copy(a),
            y.matrix.decompose(y.position, y.quaternion, y.scale),
            null !== v.orientation && (u.fromArray(v.orientation),
            y.quaternion.multiply(u)),
            null !== v.position && (u.setFromRotationMatrix(a),
            p.fromArray(v.position),
            p.applyQuaternion(u),
            y.position.add(p)),
            y.updateMatrixWorld(),
            d.near = e.near,
            f.near = e.near,
            d.far = e.far,
            f.far = e.far,
            d.matrixWorldInverse.fromArray(n.leftViewMatrix),
            f.matrixWorldInverse.fromArray(n.rightViewMatrix),
            o.getInverse(a),
            "stage" === c && (d.matrixWorldInverse.multiply(o),
            f.matrixWorldInverse.multiply(o));
            var b = y.parent;
            null !== b && (h.getInverse(b.matrixWorld),
            d.matrixWorldInverse.multiply(h),
            f.matrixWorldInverse.multiply(h)),
            d.matrixWorld.getInverse(d.matrixWorldInverse),
            f.matrixWorld.getInverse(f.matrixWorldInverse),
            d.projectionMatrix.fromArray(n.leftProjectionMatrix),
            f.projectionMatrix.fromArray(n.rightProjectionMatrix),
            as(m, d, f);
            var _ = i.getLayers();
            if (_.length) {
                var T = _[0];
                null !== T.leftBounds && 4 === T.leftBounds.length && d.bounds.fromArray(T.leftBounds),
                null !== T.rightBounds && 4 === T.rightBounds.length && f.bounds.fromArray(T.rightBounds)
            }
            return function() {
                for (var e = 0; e < s.length; e++) {
                    var t = s[e]
                      , i = w(e);
                    if (void 0 !== i && void 0 !== i.pose) {
                        if (null === i.pose)
                            return;
                        var n = i.pose;
                        !1 === n.hasPosition && t.position.set(.2, -.6, -.05),
                        null !== n.position && t.position.fromArray(n.position),
                        null !== n.orientation && t.quaternion.fromArray(n.orientation),
                        t.matrix.compose(t.position, t.quaternion, t.scale),
                        t.matrix.premultiply(a),
                        t.matrix.decompose(t.position, t.quaternion, t.scale),
                        t.matrixWorldNeedsUpdate = !0,
                        t.visible = !0;
                        var r = "Daydream Controller" === i.id ? 0 : 1;
                        x[e] !== i.buttons[r].pressed && (x[e] = i.buttons[r].pressed,
                        !0 === x[e] ? t.dispatchEvent({
                            type: "selectstart"
                        }) : (t.dispatchEvent({
                            type: "selectend"
                        }),
                        t.dispatchEvent({
                            type: "select"
                        })))
                    } else
                        t.visible = !1
                }
            }(),
            m
        }
        ,
        this.getStandingMatrix = function() {
            return a
        }
        ,
        this.isPresenting = g;
        var _ = new fi;
        this.setAnimationLoop = function(e) {
            _.setAnimationLoop(e),
            g() && _.start()
        }
        ,
        this.submitFrame = function() {
            g() && i.submitFrame()
        }
        ,
        this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", b)
        }
    }
    function ls(e) {
        var t = e.context
          , i = null
          , n = null
          , r = 1
          , s = null
          , a = "stage"
          , o = null
          , l = []
          , c = [];
        function h() {
            return null !== n && null !== s
        }
        var u = new Jr;
        u.layers.enable(1),
        u.viewport = new qt;
        var p = new Jr;
        p.layers.enable(2),
        p.viewport = new qt;
        var d = new Zr([u, p]);
        function f(e) {
            var t = l[c.indexOf(e.inputSource)];
            t && t.dispatchEvent({
                type: e.type
            })
        }
        function m() {
            e.setFramebuffer(null),
            e.setRenderTarget(e.getRenderTarget()),
            y.stop()
        }
        function g(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.getInverse(e.matrixWorld)
        }
        d.layers.enable(1),
        d.layers.enable(2),
        this.enabled = !1,
        this.getController = function(e) {
            var t = l[e];
            return void 0 === t && ((t = new Hr).matrixAutoUpdate = !1,
            t.visible = !1,
            l[e] = t),
            t
        }
        ,
        this.getDevice = function() {
            return i
        }
        ,
        this.setDevice = function(e) {
            void 0 !== e && (i = e),
            e instanceof XRDevice && t.setCompatibleXRDevice(e)
        }
        ,
        this.setFramebufferScaleFactor = function(e) {
            r = e
        }
        ,
        this.setFrameOfReferenceType = function(e) {
            a = e
        }
        ,
        this.setSession = function(i) {
            null !== (n = i) && (n.addEventListener("select", f),
            n.addEventListener("selectstart", f),
            n.addEventListener("selectend", f),
            n.addEventListener("end", m),
            n.baseLayer = new XRWebGLLayer(n,t,{
                framebufferScaleFactor: r
            }),
            n.requestFrameOfReference(a).then(function(t) {
                s = t,
                e.setFramebuffer(n.baseLayer.framebuffer),
                y.setContext(n),
                y.start()
            }),
            c = n.getInputSources(),
            n.addEventListener("inputsourceschange", function() {
                c = n.getInputSources();
                for (var e = 0; e < l.length; e++) {
                    l[e].userData.inputSource = c[e]
                }
            }))
        }
        ,
        this.getCamera = function(e) {
            if (h()) {
                var t = e.parent
                  , i = d.cameras;
                g(d, t);
                for (var n = 0; n < i.length; n++)
                    g(i[n], t);
                e.matrixWorld.copy(d.matrixWorld);
                for (var r = e.children, s = (n = 0,
                r.length); n < s; n++)
                    r[n].updateMatrixWorld(!0);
                return as(d, u, p),
                d
            }
            return e
        }
        ,
        this.isPresenting = h;
        var v = null;
        var y = new fi;
        y.setAnimationLoop(function(e, t) {
            if (null !== (o = t.getDevicePose(s)))
                for (var i = n.baseLayer, r = t.views, a = 0; a < r.length; a++) {
                    var h = r[a]
                      , u = i.getViewport(h)
                      , p = o.getViewMatrix(h)
                      , f = d.cameras[a];
                    f.matrix.fromArray(p).getInverse(f.matrix),
                    f.projectionMatrix.fromArray(h.projectionMatrix),
                    f.viewport.set(u.x, u.y, u.width, u.height),
                    0 === a && d.matrix.copy(f.matrix)
                }
            for (a = 0; a < l.length; a++) {
                var m = l[a]
                  , g = c[a];
                if (g) {
                    var y = t.getInputPose(g, s);
                    if (null !== y) {
                        "targetRay"in y ? m.matrix.elements = y.targetRay.transformMatrix : "pointerMatrix"in y && (m.matrix.elements = y.pointerMatrix),
                        m.matrix.decompose(m.position, m.rotation, m.scale),
                        m.visible = !0;
                        continue
                    }
                }
                m.visible = !1
            }
            v && v(e)
        }),
        this.setAnimationLoop = function(e) {
            v = e
        }
        ,
        this.dispose = function() {}
        ,
        this.getStandingMatrix = function() {
            return new ii
        }
        ,
        this.submitFrame = function() {}
    }
    function cs(e) {
        var t = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
          , i = void 0 !== e.context ? e.context : null
          , n = void 0 !== e.alpha && e.alpha
          , r = void 0 === e.depth || e.depth
          , s = void 0 === e.stencil || e.stencil
          , a = void 0 !== e.antialias && e.antialias
          , o = void 0 === e.premultipliedAlpha || e.premultipliedAlpha
          , l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer
          , c = void 0 !== e.powerPreference ? e.powerPreference : "default"
          , h = null
          , u = null;
        this.domElement = t,
        this.context = null,
        this.debug = {
            checkShaderErrors: !1
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.gammaInput = !1,
        this.gammaOutput = !1,
        this.physicallyCorrectLights = !1,
        this.toneMapping = K,
        this.toneMappingExposure = 1,
        this.toneMappingWhitePoint = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4;
        var p, d, m, g, v, y, b, x, w, _, T, M, S, A, P, C, L, k, E = this, I = !1, F = null, O = null, R = null, z = -1, N = {
            geometry: null,
            program: null,
            wireframe: !1
        }, D = null, U = null, B = new qt, j = new qt, V = null, G = t.width, X = t.height, Y = 1, W = new qt(0,0,G,X), q = new qt(0,0,G,X), H = !1, Q = new ti, J = new yn, Z = !1, $ = !1, ee = new ii, te = new Ct;
        function ie() {
            return null === O ? Y : 1
        }
        try {
            var ne = {
                alpha: n,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: o,
                preserveDrawingBuffer: l,
                powerPreference: c
            };
            if (t.addEventListener("webglcontextlost", oe, !1),
            t.addEventListener("webglcontextrestored", le, !1),
            null === (p = i || t.getContext("webgl", ne) || t.getContext("experimental-webgl", ne)))
                throw null !== t.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === p.getShaderPrecisionFormat && (p.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (e) {
            throw e
        }
        function re() {
            d = new bn(p),
            (m = new vn(p,d,e)).isWebGL2 || (d.get("WEBGL_depth_texture"),
            d.get("OES_texture_float"),
            d.get("OES_texture_half_float"),
            d.get("OES_texture_half_float_linear"),
            d.get("OES_standard_derivatives"),
            d.get("OES_element_index_uint"),
            d.get("ANGLE_instanced_arrays")),
            d.get("OES_texture_float_linear"),
            k = new qr(p,d,m),
            (g = new Yr(p,d,k,m)).scissor(j.copy(q).multiplyScalar(Y)),
            g.viewport(B.copy(W).multiplyScalar(Y)),
            v = new _n(p),
            y = new Ir,
            b = new Wr(p,d,g,y,m,k,v),
            x = new mi(p),
            w = new xn(p,x,v),
            _ = new Sn(w,v),
            P = new Mn(p),
            T = new Er(E,d,m,b),
            M = new zr,
            S = new jr,
            A = new mn(E,g,_,o),
            C = new gn(p,d,v,m),
            L = new wn(p,d,v,m),
            v.programs = T.programs,
            E.context = p,
            E.capabilities = m,
            E.extensions = d,
            E.properties = y,
            E.renderLists = M,
            E.state = g,
            E.info = v
        }
        re();
        var se = "undefined" != typeof navigator && "xr"in navigator ? new ls(E) : new os(E);
        this.vr = se;
        var ae = new Xr(E,_,m.maxTextureSize);
        function oe(e) {
            e.preventDefault(),
            I = !0
        }
        function le() {
            I = !1,
            re()
        }
        function ce(e) {
            var t = e.target;
            t.removeEventListener("dispose", ce),
            function(e) {
                he(e),
                y.remove(e)
            }(t)
        }
        function he(e) {
            var t = y.get(e).program;
            e.program = void 0,
            void 0 !== t && T.releaseProgram(t)
        }
        this.shadowMap = ae,
        this.getContext = function() {
            return p
        }
        ,
        this.getContextAttributes = function() {
            return p.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            var e = d.get("WEBGL_lose_context");
            e && e.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            var e = d.get("WEBGL_lose_context");
            e && e.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return Y
        }
        ,
        this.setPixelRatio = function(e) {
            void 0 !== e && (Y = e,
            this.setSize(G, X, !1))
        }
        ,
        this.getSize = function(e) {
            return void 0 === e && (e = new At),
            e.set(G, X)
        }
        ,
        this.setSize = function(e, i, n) {
            se.isPresenting() || (G = e,
            X = i,
            t.width = e * Y,
            t.height = i * Y,
            !1 !== n && (t.style.width = e + "px",
            t.style.height = i + "px"),
            this.setViewport(0, 0, e, i))
        }
        ,
        this.getDrawingBufferSize = function(e) {
            return void 0 === e && (e = new At),
            e.set(G * Y, X * Y)
        }
        ,
        this.setDrawingBufferSize = function(e, i, n) {
            G = e,
            X = i,
            Y = n,
            t.width = e * n,
            t.height = i * n,
            this.setViewport(0, 0, e, i)
        }
        ,
        this.getCurrentViewport = function(e) {
            return void 0 === e && (e = new qt),
            e.copy(B)
        }
        ,
        this.getViewport = function(e) {
            return e.copy(W)
        }
        ,
        this.setViewport = function(e, t, i, n) {
            e.isVector4 ? W.set(e.x, e.y, e.z, e.w) : W.set(e, t, i, n),
            g.viewport(B.copy(W).multiplyScalar(Y))
        }
        ,
        this.getScissor = function(e) {
            return e.copy(q)
        }
        ,
        this.setScissor = function(e, t, i, n) {
            e.isVector4 ? q.set(e.x, e.y, e.z, e.w) : q.set(e, t, i, n),
            g.scissor(j.copy(q).multiplyScalar(Y))
        }
        ,
        this.getScissorTest = function() {
            return H
        }
        ,
        this.setScissorTest = function(e) {
            g.setScissorTest(H = e)
        }
        ,
        this.getClearColor = function() {
            return A.getClearColor()
        }
        ,
        this.setClearColor = function() {
            A.setClearColor.apply(A, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return A.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            A.setClearAlpha.apply(A, arguments)
        }
        ,
        this.clear = function(e, t, i) {
            var n = 0;
            (void 0 === e || e) && (n |= 16384),
            (void 0 === t || t) && (n |= 256),
            (void 0 === i || i) && (n |= 1024),
            p.clear(n)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", oe, !1),
            t.removeEventListener("webglcontextrestored", le, !1),
            M.dispose(),
            S.dispose(),
            y.dispose(),
            _.dispose(),
            se.dispose(),
            pe.stop()
        }
        ,
        this.renderBufferImmediate = function(e, t) {
            g.initAttributes();
            var i = y.get(e);
            e.hasPositions && !i.position && (i.position = p.createBuffer()),
            e.hasNormals && !i.normal && (i.normal = p.createBuffer()),
            e.hasUvs && !i.uv && (i.uv = p.createBuffer()),
            e.hasColors && !i.color && (i.color = p.createBuffer());
            var n = t.getAttributes();
            e.hasPositions && (p.bindBuffer(34962, i.position),
            p.bufferData(34962, e.positionArray, 35048),
            g.enableAttribute(n.position),
            p.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)),
            e.hasNormals && (p.bindBuffer(34962, i.normal),
            p.bufferData(34962, e.normalArray, 35048),
            g.enableAttribute(n.normal),
            p.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)),
            e.hasUvs && (p.bindBuffer(34962, i.uv),
            p.bufferData(34962, e.uvArray, 35048),
            g.enableAttribute(n.uv),
            p.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)),
            e.hasColors && (p.bindBuffer(34962, i.color),
            p.bufferData(34962, e.colorArray, 35048),
            g.enableAttribute(n.color),
            p.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)),
            g.disableUnusedAttributes(),
            p.drawArrays(4, 0, e.count),
            e.count = 0
        }
        ,
        this.renderBufferDirect = function(e, t, i, n, r, s) {
            var a = r.isMesh && r.matrixWorld.determinant() < 0;
            g.setMaterial(n, a);
            var o = ve(e, t, n, r)
              , l = !1;
            N.geometry === i.id && N.program === o.id && N.wireframe === (!0 === n.wireframe) || (N.geometry = i.id,
            N.program = o.id,
            N.wireframe = !0 === n.wireframe,
            l = !0),
            r.morphTargetInfluences && (P.update(r, i, n, o),
            l = !0);
            var c, h = i.index, u = i.attributes.position, f = 1;
            !0 === n.wireframe && (h = w.getWireframeAttribute(i),
            f = 2);
            var v = C;
            null !== h && (c = x.get(h),
            (v = L).setIndex(c)),
            l && (!function(e, t, i) {
                if (i && i.isInstancedBufferGeometry && !m.isWebGL2 && null === d.get("ANGLE_instanced_arrays"))
                    return;
                g.initAttributes();
                var n = i.attributes
                  , r = t.getAttributes()
                  , s = e.defaultAttributeValues;
                for (var a in r) {
                    var o = r[a];
                    if (o >= 0) {
                        var l = n[a];
                        if (void 0 !== l) {
                            var c = l.normalized
                              , h = l.itemSize
                              , u = x.get(l);
                            if (void 0 === u)
                                continue;
                            var f = u.buffer
                              , v = u.type
                              , y = u.bytesPerElement;
                            if (l.isInterleavedBufferAttribute) {
                                var b = l.data
                                  , w = b.stride
                                  , _ = l.offset;
                                b && b.isInstancedInterleavedBuffer ? (g.enableAttributeAndDivisor(o, b.meshPerAttribute),
                                void 0 === i.maxInstancedCount && (i.maxInstancedCount = b.meshPerAttribute * b.count)) : g.enableAttribute(o),
                                p.bindBuffer(34962, f),
                                p.vertexAttribPointer(o, h, v, c, w * y, _ * y)
                            } else
                                l.isInstancedBufferAttribute ? (g.enableAttributeAndDivisor(o, l.meshPerAttribute),
                                void 0 === i.maxInstancedCount && (i.maxInstancedCount = l.meshPerAttribute * l.count)) : g.enableAttribute(o),
                                p.bindBuffer(34962, f),
                                p.vertexAttribPointer(o, h, v, c, 0, 0)
                        } else if (void 0 !== s) {
                            var T = s[a];
                            if (void 0 !== T)
                                switch (T.length) {
                                case 2:
                                    p.vertexAttrib2fv(o, T);
                                    break;
                                case 3:
                                    p.vertexAttrib3fv(o, T);
                                    break;
                                case 4:
                                    p.vertexAttrib4fv(o, T);
                                    break;
                                default:
                                    p.vertexAttrib1fv(o, T)
                                }
                        }
                    }
                }
                g.disableUnusedAttributes()
            }(n, o, i),
            null !== h && p.bindBuffer(34963, c.buffer));
            var y = 1 / 0;
            null !== h ? y = h.count : void 0 !== u && (y = u.count);
            var b = i.drawRange.start * f
              , _ = i.drawRange.count * f
              , T = null !== s ? s.start * f : 0
              , M = null !== s ? s.count * f : 1 / 0
              , S = Math.max(b, T)
              , A = Math.min(y, b + _, T + M) - 1
              , k = Math.max(0, A - S + 1);
            if (0 !== k) {
                if (r.isMesh)
                    if (!0 === n.wireframe)
                        g.setLineWidth(n.wireframeLinewidth * ie()),
                        v.setMode(1);
                    else
                        switch (r.drawMode) {
                        case ut:
                            v.setMode(4);
                            break;
                        case pt:
                            v.setMode(5);
                            break;
                        case dt:
                            v.setMode(6)
                        }
                else if (r.isLine) {
                    var E = n.linewidth;
                    void 0 === E && (E = 1),
                    g.setLineWidth(E * ie()),
                    r.isLineSegments ? v.setMode(1) : r.isLineLoop ? v.setMode(2) : v.setMode(3)
                } else
                    r.isPoints ? v.setMode(0) : r.isSprite && v.setMode(4);
                i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && v.renderInstances(i, S, k) : v.render(S, k)
            }
        }
        ,
        this.compile = function(e, t) {
            (u = S.get(e, t)).init(),
            e.traverse(function(e) {
                e.isLight && (u.pushLight(e),
                e.castShadow && u.pushShadow(e))
            }),
            u.setupLights(t),
            e.traverse(function(t) {
                if (t.material)
                    if (Array.isArray(t.material))
                        for (var i = 0; i < t.material.length; i++)
                            ge(t.material[i], e.fog, t);
                    else
                        ge(t.material, e.fog, t)
            })
        }
        ;
        var ue = null;
        var pe = new fi;
        function de(e, t, i, n) {
            if (!1 !== e.visible) {
                if (e.layers.test(t.layers))
                    if (e.isGroup)
                        i = e.renderOrder;
                    else if (e.isLight)
                        u.pushLight(e),
                        e.castShadow && u.pushShadow(e);
                    else if (e.isSprite) {
                        if (!e.frustumCulled || Q.intersectsSprite(e)) {
                            n && te.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ee);
                            var r = _.update(e);
                            (s = e.material).visible && h.push(e, r, s, i, te.z, null)
                        }
                    } else if (e.isImmediateRenderObject)
                        n && te.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ee),
                        h.push(e, null, e.material, i, te.z, null);
                    else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(),
                    !e.frustumCulled || Q.intersectsObject(e))) {
                        n && te.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ee);
                        r = _.update(e);
                        var s = e.material;
                        if (Array.isArray(s))
                            for (var a = r.groups, o = 0, l = a.length; o < l; o++) {
                                var c = a[o]
                                  , p = s[c.materialIndex];
                                p && p.visible && h.push(e, r, p, i, te.z, c)
                            }
                        else
                            s.visible && h.push(e, r, s, i, te.z, null)
                    }
                var d = e.children;
                for (o = 0,
                l = d.length; o < l; o++)
                    de(d[o], t, i, n)
            }
        }
        function fe(e, t, i, n) {
            for (var r = 0, s = e.length; r < s; r++) {
                var a = e[r]
                  , o = a.object
                  , l = a.geometry
                  , c = void 0 === n ? a.material : n
                  , h = a.group;
                if (i.isArrayCamera) {
                    U = i;
                    for (var p = i.cameras, d = 0, f = p.length; d < f; d++) {
                        var m = p[d];
                        if (o.layers.test(m.layers)) {
                            if ("viewport"in m)
                                g.viewport(B.copy(m.viewport));
                            else {
                                var v = m.bounds
                                  , y = v.x * G
                                  , b = v.y * X
                                  , x = v.z * G
                                  , w = v.w * X;
                                g.viewport(B.set(y, b, x, w).multiplyScalar(Y))
                            }
                            u.setupLights(m),
                            me(o, t, m, l, c, h)
                        }
                    }
                } else
                    U = null,
                    me(o, t, i, l, c, h)
            }
        }
        function me(e, t, i, n, r, s) {
            if (e.onBeforeRender(E, t, i, n, r, s),
            u = S.get(t, U || i),
            e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            e.isImmediateRenderObject) {
                g.setMaterial(r);
                var a = ve(i, t.fog, r, e);
                N.geometry = null,
                N.program = null,
                N.wireframe = !1,
                function(e, t) {
                    e.render(function(e) {
                        E.renderBufferImmediate(e, t)
                    })
                }(e, a)
            } else
                E.renderBufferDirect(i, t.fog, n, r, e, s);
            e.onAfterRender(E, t, i, n, r, s),
            u = S.get(t, U || i)
        }
        function ge(e, t, i) {
            var n = y.get(e)
              , r = u.state.lights
              , s = u.state.shadowsArray
              , a = n.lightsHash
              , o = r.state.hash
              , l = T.getParameters(e, r.state, s, t, J.numPlanes, J.numIntersection, i)
              , c = T.getProgramCode(e, l)
              , h = n.program
              , p = !0;
            if (void 0 === h)
                e.addEventListener("dispose", ce);
            else if (h.code !== c)
                he(e);
            else if (a.stateID !== o.stateID || a.directionalLength !== o.directionalLength || a.pointLength !== o.pointLength || a.spotLength !== o.spotLength || a.rectAreaLength !== o.rectAreaLength || a.hemiLength !== o.hemiLength || a.shadowsLength !== o.shadowsLength)
                a.stateID = o.stateID,
                a.directionalLength = o.directionalLength,
                a.pointLength = o.pointLength,
                a.spotLength = o.spotLength,
                a.rectAreaLength = o.rectAreaLength,
                a.hemiLength = o.hemiLength,
                a.shadowsLength = o.shadowsLength,
                p = !1;
            else {
                if (void 0 !== l.shaderID)
                    return;
                p = !1
            }
            if (p) {
                if (l.shaderID) {
                    var d = di[l.shaderID];
                    n.shader = {
                        name: e.type,
                        uniforms: ri(d.uniforms),
                        vertexShader: d.vertexShader,
                        fragmentShader: d.fragmentShader
                    }
                } else
                    n.shader = {
                        name: e.type,
                        uniforms: e.uniforms,
                        vertexShader: e.vertexShader,
                        fragmentShader: e.fragmentShader
                    };
                e.onBeforeCompile(n.shader, E),
                c = T.getProgramCode(e, l),
                h = T.acquireProgram(e, n.shader, l, c),
                n.program = h,
                e.program = h
            }
            var f = h.getAttributes();
            if (e.morphTargets) {
                e.numSupportedMorphTargets = 0;
                for (var m = 0; m < E.maxMorphTargets; m++)
                    f["morphTarget" + m] >= 0 && e.numSupportedMorphTargets++
            }
            if (e.morphNormals) {
                e.numSupportedMorphNormals = 0;
                for (m = 0; m < E.maxMorphNormals; m++)
                    f["morphNormal" + m] >= 0 && e.numSupportedMorphNormals++
            }
            var g = n.shader.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (n.numClippingPlanes = J.numPlanes,
            n.numIntersection = J.numIntersection,
            g.clippingPlanes = J.uniform),
            n.fog = t,
            void 0 === a && (n.lightsHash = a = {}),
            a.stateID = o.stateID,
            a.directionalLength = o.directionalLength,
            a.pointLength = o.pointLength,
            a.spotLength = o.spotLength,
            a.rectAreaLength = o.rectAreaLength,
            a.hemiLength = o.hemiLength,
            a.shadowsLength = o.shadowsLength,
            e.lights && (g.ambientLightColor.value = r.state.ambient,
            g.lightProbe.value = r.state.probe,
            g.directionalLights.value = r.state.directional,
            g.spotLights.value = r.state.spot,
            g.rectAreaLights.value = r.state.rectArea,
            g.pointLights.value = r.state.point,
            g.hemisphereLights.value = r.state.hemi,
            g.directionalShadowMap.value = r.state.directionalShadowMap,
            g.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
            g.spotShadowMap.value = r.state.spotShadowMap,
            g.spotShadowMatrix.value = r.state.spotShadowMatrix,
            g.pointShadowMap.value = r.state.pointShadowMap,
            g.pointShadowMatrix.value = r.state.pointShadowMatrix);
            var v = n.program.getUniforms()
              , b = br.seqWithValue(v.seq, g);
            n.uniformsList = b
        }
        function ve(e, t, i, n) {
            b.resetTextureUnits();
            var r = y.get(i)
              , s = u.state.lights
              , a = r.lightsHash
              , o = s.state.hash;
            if (Z && ($ || e !== D)) {
                var l = e === D && i.id === z;
                J.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, e, r, l)
            }
            !1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== t ? i.needsUpdate = !0 : (!i.lights || a.stateID === o.stateID && a.directionalLength === o.directionalLength && a.pointLength === o.pointLength && a.spotLength === o.spotLength && a.rectAreaLength === o.rectAreaLength && a.hemiLength === o.hemiLength && a.shadowsLength === o.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === J.numPlanes && r.numIntersection === J.numIntersection) || (i.needsUpdate = !0)),
            i.needsUpdate && (ge(i, t, n),
            i.needsUpdate = !1);
            var c = !1
              , h = !1
              , d = !1
              , v = r.program
              , x = v.getUniforms()
              , w = r.shader.uniforms;
            if (g.useProgram(v.program) && (c = !0,
            h = !0,
            d = !0),
            i.id !== z && (z = i.id,
            h = !0),
            c || D !== e) {
                if (x.setValue(p, "projectionMatrix", e.projectionMatrix),
                m.logarithmicDepthBuffer && x.setValue(p, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                D !== e && (D = e,
                h = !0,
                d = !0),
                i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) {
                    var _ = x.map.cameraPosition;
                    void 0 !== _ && _.setValue(p, te.setFromMatrixPosition(e.matrixWorld))
                }
                (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && x.setValue(p, "viewMatrix", e.matrixWorldInverse)
            }
            if (i.skinning) {
                x.setOptional(p, n, "bindMatrix"),
                x.setOptional(p, n, "bindMatrixInverse");
                var T = n.skeleton;
                if (T) {
                    var M = T.bones;
                    if (m.floatVertexTextures) {
                        if (void 0 === T.boneTexture) {
                            var S = Math.sqrt(4 * M.length);
                            S = St.ceilPowerOfTwo(S),
                            S = Math.max(S, 4);
                            var A = new Float32Array(S * S * 4);
                            A.set(T.boneMatrices);
                            var P = new Zt(A,S,S,Oe,Ae);
                            P.needsUpdate = !0,
                            T.boneMatrices = A,
                            T.boneTexture = P,
                            T.boneTextureSize = S
                        }
                        x.setValue(p, "boneTexture", T.boneTexture, b),
                        x.setValue(p, "boneTextureSize", T.boneTextureSize)
                    } else
                        x.setOptional(p, T, "boneMatrices")
                }
            }
            return h && (x.setValue(p, "toneMappingExposure", E.toneMappingExposure),
            x.setValue(p, "toneMappingWhitePoint", E.toneMappingWhitePoint),
            i.lights && function(e, t) {
                e.ambientLightColor.needsUpdate = t,
                e.lightProbe.needsUpdate = t,
                e.directionalLights.needsUpdate = t,
                e.pointLights.needsUpdate = t,
                e.spotLights.needsUpdate = t,
                e.rectAreaLights.needsUpdate = t,
                e.hemisphereLights.needsUpdate = t
            }(w, d),
            t && i.fog && function(e, t) {
                e.fogColor.value.copy(t.color),
                t.isFog ? (e.fogNear.value = t.near,
                e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
            }(w, t),
            i.isMeshBasicMaterial ? ye(w, i) : i.isMeshLambertMaterial ? (ye(w, i),
            function(e, t) {
                t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
            }(w, i)) : i.isMeshPhongMaterial ? (ye(w, i),
            i.isMeshToonMaterial ? function(e, t) {
                be(e, t),
                t.gradientMap && (e.gradientMap.value = t.gradientMap)
            }(w, i) : be(w, i)) : i.isMeshStandardMaterial ? (ye(w, i),
            i.isMeshPhysicalMaterial ? function(e, t) {
                we(e, t),
                e.reflectivity.value = t.reflectivity,
                e.clearCoat.value = t.clearCoat,
                e.clearCoatRoughness.value = t.clearCoatRoughness
            }(w, i) : we(w, i)) : i.isMeshMatcapMaterial ? (ye(w, i),
            function(e, t) {
                t.matcap && (e.matcap.value = t.matcap);
                t.bumpMap && (e.bumpMap.value = t.bumpMap,
                e.bumpScale.value = t.bumpScale,
                t.side === f && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap,
                e.normalScale.value.copy(t.normalScale),
                t.side === f && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias)
            }(w, i)) : i.isMeshDepthMaterial ? (ye(w, i),
            function(e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias)
            }(w, i)) : i.isMeshDistanceMaterial ? (ye(w, i),
            function(e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias);
                e.referencePosition.value.copy(t.referencePosition),
                e.nearDistance.value = t.nearDistance,
                e.farDistance.value = t.farDistance
            }(w, i)) : i.isMeshNormalMaterial ? (ye(w, i),
            function(e, t) {
                t.bumpMap && (e.bumpMap.value = t.bumpMap,
                e.bumpScale.value = t.bumpScale,
                t.side === f && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap,
                e.normalScale.value.copy(t.normalScale),
                t.side === f && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap,
                e.displacementScale.value = t.displacementScale,
                e.displacementBias.value = t.displacementBias)
            }(w, i)) : i.isLineBasicMaterial ? (function(e, t) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity
            }(w, i),
            i.isLineDashedMaterial && function(e, t) {
                e.dashSize.value = t.dashSize,
                e.totalSize.value = t.dashSize + t.gapSize,
                e.scale.value = t.scale
            }(w, i)) : i.isPointsMaterial ? function(e, t) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity,
                e.size.value = t.size * Y,
                e.scale.value = .5 * X,
                e.map.value = t.map,
                null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(),
                e.uvTransform.value.copy(t.map.matrix))
            }(w, i) : i.isSpriteMaterial ? function(e, t) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity,
                e.rotation.value = t.rotation,
                e.map.value = t.map,
                null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(),
                e.uvTransform.value.copy(t.map.matrix))
            }(w, i) : i.isShadowMaterial && (w.color.value.copy(i.color),
            w.opacity.value = i.opacity),
            void 0 !== w.ltc_1 && (w.ltc_1.value = pi.LTC_1),
            void 0 !== w.ltc_2 && (w.ltc_2.value = pi.LTC_2),
            br.upload(p, r.uniformsList, w, b)),
            i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (br.upload(p, r.uniformsList, w, b),
            i.uniformsNeedUpdate = !1),
            i.isSpriteMaterial && x.setValue(p, "center", n.center),
            i.useObjectUniforms && function(e, t, i, n) {
                i.isCustomSpriteMaterial ? n.setValue(e, "texCoords", t.texCoords) : i.isPropsMaterial ? i.uniforms.propType.value !== t.propType && (i.uniforms.propType.value = t.propType,
                n.setValue(e, "propType", t.propType)) : i.isBubbleMaterial ? i.uniforms.bubbleScale.value !== t.bubbleScale && (i.uniforms.bubbleScale.value = t.bubbleScale,
                n.setValue(e, "bubbleScale", t.bubbleScale)) : i.isSkeletonMeshMaterial && i.uniforms.flash.value !== t.flash && (i.uniforms.flash.value = t.flash,
                n.setValue(e, "flash", t.flash))
            }(p, n, i, x),
            x.setValue(p, "modelViewMatrix", n.modelViewMatrix),
            x.setValue(p, "normalMatrix", n.normalMatrix),
            x.setValue(p, "modelMatrix", n.matrixWorld),
            v
        }
        function ye(e, t) {
            var i;
            e.opacity.value = t.opacity,
            t.color && e.diffuse.value.copy(t.color),
            t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity),
            t.map && (e.map.value = t.map),
            t.alphaMap && (e.alphaMap.value = t.alphaMap),
            t.specularMap && (e.specularMap.value = t.specularMap),
            t.envMap && (e.envMap.value = t.envMap,
            e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1,
            e.reflectivity.value = t.reflectivity,
            e.refractionRatio.value = t.refractionRatio,
            e.maxMipLevel.value = y.get(t.envMap).__maxMipLevel),
            t.lightMap && (e.lightMap.value = t.lightMap,
            e.lightMapIntensity.value = t.lightMapIntensity),
            t.aoMap && (e.aoMap.value = t.aoMap,
            e.aoMapIntensity.value = t.aoMapIntensity),
            t.map ? i = t.map : t.specularMap ? i = t.specularMap : t.displacementMap ? i = t.displacementMap : t.normalMap ? i = t.normalMap : t.bumpMap ? i = t.bumpMap : t.roughnessMap ? i = t.roughnessMap : t.metalnessMap ? i = t.metalnessMap : t.alphaMap ? i = t.alphaMap : t.emissiveMap && (i = t.emissiveMap),
            void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture),
            !0 === i.matrixAutoUpdate && i.updateMatrix(),
            e.uvTransform.value.copy(i.matrix))
        }
        function be(e, t) {
            e.specular.value.copy(t.specular),
            e.shininess.value = Math.max(t.shininess, 1e-4),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap && (e.bumpMap.value = t.bumpMap,
            e.bumpScale.value = t.bumpScale,
            t.side === f && (e.bumpScale.value *= -1)),
            t.normalMap && (e.normalMap.value = t.normalMap,
            e.normalScale.value.copy(t.normalScale),
            t.side === f && e.normalScale.value.negate()),
            t.displacementMap && (e.displacementMap.value = t.displacementMap,
            e.displacementScale.value = t.displacementScale,
            e.displacementBias.value = t.displacementBias)
        }
        function we(e, t) {
            e.roughness.value = t.roughness,
            e.metalness.value = t.metalness,
            t.roughnessMap && (e.roughnessMap.value = t.roughnessMap),
            t.metalnessMap && (e.metalnessMap.value = t.metalnessMap),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap && (e.bumpMap.value = t.bumpMap,
            e.bumpScale.value = t.bumpScale,
            t.side === f && (e.bumpScale.value *= -1)),
            t.normalMap && (e.normalMap.value = t.normalMap,
            e.normalScale.value.copy(t.normalScale),
            t.side === f && e.normalScale.value.negate()),
            t.displacementMap && (e.displacementMap.value = t.displacementMap,
            e.displacementScale.value = t.displacementScale,
            e.displacementBias.value = t.displacementBias),
            t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }
        pe.setAnimationLoop(function(e) {
            se.isPresenting() || ue && ue(e)
        }),
        "undefined" != typeof window && pe.setContext(window),
        this.setAnimationLoop = function(e) {
            ue = e,
            se.setAnimationLoop(e),
            pe.start()
        }
        ,
        this.render = function(e, t) {
            var i, n;
            if (void 0 !== arguments[2] && (i = arguments[2]),
            void 0 !== arguments[3] && (n = arguments[3]),
            t && t.isCamera && !I) {
                N.geometry = null,
                N.program = null,
                N.wireframe = !1,
                z = -1,
                D = null,
                !0 === e.autoUpdate && e.updateMatrixWorld(),
                null === t.parent && t.updateMatrixWorld(),
                se.enabled && (t = se.getCamera(t)),
                (u = S.get(e, t)).init(),
                e.onBeforeRender(E, e, t, i || O),
                ee.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                Q.setFromMatrix(ee),
                $ = this.localClippingEnabled,
                Z = J.init(this.clippingPlanes, $, t),
                (h = M.get(e, t)).init(),
                de(e, t, 0, E.sortObjects),
                !0 === E.sortObjects && h.sort(),
                Z && J.beginShadows();
                var r = u.state.shadowsArray;
                ae.render(r, e, t),
                u.setupLights(t),
                Z && J.endShadows(),
                this.info.autoReset && this.info.reset(),
                void 0 !== i && this.setRenderTarget(i),
                A.render(h, e, t, n);
                var s = h.opaque
                  , a = h.transparent;
                if (e.overrideMaterial) {
                    var o = e.overrideMaterial;
                    s.length && fe(s, e, t, o),
                    a.length && fe(a, e, t, o)
                } else
                    s.length && fe(s, e, t),
                    a.length && fe(a, e, t);
                e.onAfterRender(E, e, t),
                null !== O && (b.updateRenderTargetMipmap(O),
                b.updateMultisampleRenderTarget(O)),
                g.buffers.depth.setTest(!0),
                g.buffers.depth.setMask(!0),
                g.buffers.color.setMask(!0),
                g.setPolygonOffset(!1),
                se.enabled && se.submitFrame(),
                h = null,
                u = null
            }
        }
        ,
        this.setFramebuffer = function(e) {
            F = e
        }
        ,
        this.getRenderTarget = function() {
            return O
        }
        ,
        this.setRenderTarget = function(e, t, i) {
            O = e,
            e && void 0 === y.get(e).__webglFramebuffer && b.setupRenderTarget(e);
            var n = F
              , r = !1;
            if (e) {
                var s = y.get(e).__webglFramebuffer;
                e.isWebGLRenderTargetCube ? (n = s[t || 0],
                r = !0) : n = e.isWebGLMultisampleRenderTarget ? y.get(e).__webglMultisampledFramebuffer : s,
                B.copy(e.viewport),
                j.copy(e.scissor),
                V = e.scissorTest
            } else
                B.copy(W).multiplyScalar(Y),
                j.copy(q).multiplyScalar(Y),
                V = H;
            if (R !== n && (p.bindFramebuffer(36160, n),
            R = n),
            g.viewport(B),
            g.scissor(j),
            g.setScissorTest(V),
            r) {
                var a = y.get(e.texture);
                p.framebufferTexture2D(36160, 36064, 34069 + (t || 0), a.__webglTexture, i || 0)
            }
        }
        ,
        this.readRenderTargetPixels = function(e, t, i, n, r, s) {
            if (e && e.isWebGLRenderTarget) {
                var a = y.get(e).__webglFramebuffer;
                if (a) {
                    var o = !1;
                    a !== R && (p.bindFramebuffer(36160, a),
                    o = !0);
                    try {
                        var l = e.texture
                          , c = l.format
                          , h = l.type;
                        if (c !== Oe && k.convert(c) !== p.getParameter(35739))
                            return;
                        if (!(h === xe || k.convert(h) === p.getParameter(35738) || h === Ae && (m.isWebGL2 || d.get("OES_texture_float") || d.get("WEBGL_color_buffer_float")) || h === Pe && (m.isWebGL2 ? d.get("EXT_color_buffer_float") : d.get("EXT_color_buffer_half_float"))))
                            return;
                        36053 === p.checkFramebufferStatus(36160) && t >= 0 && t <= e.width - n && i >= 0 && i <= e.height - r && p.readPixels(t, i, n, r, k.convert(c), k.convert(h), s)
                    } finally {
                        o && p.bindFramebuffer(36160, R)
                    }
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(e, t, i) {
            var n = t.image.width
              , r = t.image.height
              , s = k.convert(t.format);
            b.setTexture2D(t, 0),
            p.copyTexImage2D(3553, i || 0, s, e.x, e.y, n, r, 0)
        }
        ,
        this.copyTextureToTexture = function(e, t, i, n) {
            var r = t.image.width
              , s = t.image.height
              , a = k.convert(i.format)
              , o = k.convert(i.type);
            b.setTexture2D(i, 0),
            t.isDataTexture ? p.texSubImage2D(3553, n || 0, e.x, e.y, r, s, a, o, t.image.data) : p.texSubImage2D(3553, n || 0, e.x, e.y, a, o, t.image)
        }
    }
    function hs(e, t) {
        this.name = "",
        this.color = new hi(e),
        this.density = void 0 !== t ? t : 25e-5
    }
    function us(e, t, i) {
        this.name = "",
        this.color = new hi(e),
        this.near = void 0 !== t ? t : 1,
        this.far = void 0 !== i ? i : 1e3
    }
    function ps() {
        Mi.call(this),
        this.type = "Scene",
        this.background = null,
        this.fog = null,
        this.overrideMaterial = null,
        this.autoUpdate = !0
    }
    function ds(e, t) {
        this.array = e,
        this.stride = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function fs(e, t, i, n) {
        this.data = e,
        this.itemSize = t,
        this.offset = i,
        this.normalized = !0 === n
    }
    function ms(e) {
        Hi.call(this),
        this.type = "SpriteMaterial",
        this.color = new hi(16777215),
        this.map = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.lights = !1,
        this.transparent = !0,
        this.setValues(e)
    }
    function gs(e) {
        if (Mi.call(this),
        this.type = "Sprite",
        void 0 === $r) {
            $r = new Vi;
            var t = new ds(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),5);
            $r.setIndex([0, 1, 2, 0, 2, 3]),
            $r.addAttribute("position", new fs(t,3,0,!1)),
            $r.addAttribute("uv", new fs(t,2,3,!1))
        }
        this.geometry = $r,
        this.material = void 0 !== e ? e : new ms,
        this.center = new At(.5,.5)
    }
    function vs() {
        Mi.call(this),
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }
    function ys(e, t) {
        e && e.isGeometry,
        fn.call(this, e, t),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new ii,
        this.bindMatrixInverse = new ii
    }
    function bs(e, t) {
        if (e = e || [],
        this.bones = e.slice(0),
        this.boneMatrices = new Float32Array(16 * this.bones.length),
        void 0 === t)
            this.calculateInverses();
        else if (this.bones.length === t.length)
            this.boneInverses = t.slice(0);
        else {
            this.boneInverses = [];
            for (var i = 0, n = this.bones.length; i < n; i++)
                this.boneInverses.push(new ii)
        }
    }
    function xs() {
        Mi.call(this),
        this.type = "Bone"
    }
    function ws(e) {
        Hi.call(this),
        this.type = "LineBasicMaterial",
        this.color = new hi(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.lights = !1,
        this.setValues(e)
    }
    function _s(e, t, i) {
        Mi.call(this),
        this.type = "Line",
        this.geometry = void 0 !== e ? e : new Vi,
        this.material = void 0 !== t ? t : new ws({
            color: 16777215 * Math.random()
        })
    }
    function Ts(e, t) {
        _s.call(this, e, t),
        this.type = "LineSegments"
    }
    function Ms(e, t) {
        _s.call(this, e, t),
        this.type = "LineLoop"
    }
    function Ss(e) {
        Hi.call(this),
        this.type = "PointsMaterial",
        this.color = new hi(16777215),
        this.map = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.morphTargets = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function As(e, t) {
        Mi.call(this),
        this.type = "Points",
        this.geometry = void 0 !== e ? e : new Vi,
        this.material = void 0 !== t ? t : new Ss({
            color: 16777215 * Math.random()
        })
    }
    function Ps(e, t, i, n, r, s, a, o, l) {
        Wt.call(this, e, t, i, n, r, s, a, o, l),
        this.format = void 0 !== a ? a : Fe,
        this.minFilter = void 0 !== s ? s : ve,
        this.magFilter = void 0 !== r ? r : ve,
        this.generateMipmaps = !1
    }
    function Cs(e, t, i, n, r, s, a, o, l, c, h, u) {
        Wt.call(this, null, s, a, o, l, c, n, r, h, u),
        this.image = {
            width: t,
            height: i
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function Ls(e, t, i, n, r, s, a, o, l) {
        Wt.call(this, e, t, i, n, r, s, a, o, l),
        this.needsUpdate = !0
    }
    function ks(e, t, i, n, r, s, a, o, l, c) {
        if ((c = void 0 !== c ? c : Ne) !== Ne && c !== De)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && c === Ne && (i = Te),
        void 0 === i && c === De && (i = Ee),
        Wt.call(this, null, n, r, s, a, o, c, i, l),
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = void 0 !== a ? a : fe,
        this.minFilter = void 0 !== o ? o : fe,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function Es(e) {
        Vi.call(this),
        this.type = "WireframeGeometry";
        var t, i, n, r, s, a, o, l, c, h, u = [], p = [0, 0], d = {}, f = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var m = e.faces;
            for (t = 0,
            n = m.length; t < n; t++) {
                var g = m[t];
                for (i = 0; i < 3; i++)
                    o = g[f[i]],
                    l = g[f[(i + 1) % 3]],
                    p[0] = Math.min(o, l),
                    p[1] = Math.max(o, l),
                    void 0 === d[c = p[0] + "," + p[1]] && (d[c] = {
                        index1: p[0],
                        index2: p[1]
                    })
            }
            for (c in d)
                a = d[c],
                h = e.vertices[a.index1],
                u.push(h.x, h.y, h.z),
                h = e.vertices[a.index2],
                u.push(h.x, h.y, h.z)
        } else if (e && e.isBufferGeometry) {
            var v, y, b, x, w, _, T;
            if (h = new Ct,
            null !== e.index) {
                for (v = e.attributes.position,
                y = e.index,
                0 === (b = e.groups).length && (b = [{
                    start: 0,
                    count: y.count,
                    materialIndex: 0
                }]),
                r = 0,
                s = b.length; r < s; ++r)
                    for (t = w = (x = b[r]).start,
                    n = w + x.count; t < n; t += 3)
                        for (i = 0; i < 3; i++)
                            o = y.getX(t + i),
                            l = y.getX(t + (i + 1) % 3),
                            p[0] = Math.min(o, l),
                            p[1] = Math.max(o, l),
                            void 0 === d[c = p[0] + "," + p[1]] && (d[c] = {
                                index1: p[0],
                                index2: p[1]
                            });
                for (c in d)
                    a = d[c],
                    h.fromBufferAttribute(v, a.index1),
                    u.push(h.x, h.y, h.z),
                    h.fromBufferAttribute(v, a.index2),
                    u.push(h.x, h.y, h.z)
            } else
                for (t = 0,
                n = (v = e.attributes.position).count / 3; t < n; t++)
                    for (i = 0; i < 3; i++)
                        _ = 3 * t + i,
                        h.fromBufferAttribute(v, _),
                        u.push(h.x, h.y, h.z),
                        T = 3 * t + (i + 1) % 3,
                        h.fromBufferAttribute(v, T),
                        u.push(h.x, h.y, h.z)
        }
        this.addAttribute("position", new Ni(u,3))
    }
    function Is(e, t, i) {
        Ci.call(this),
        this.type = "ParametricGeometry",
        this.parameters = {
            func: e,
            slices: t,
            stacks: i
        },
        this.fromBufferGeometry(new Fs(e,t,i)),
        this.mergeVertices()
    }
    function Fs(e, t, i) {
        Vi.call(this),
        this.type = "ParametricBufferGeometry",
        this.parameters = {
            func: e,
            slices: t,
            stacks: i
        };
        var n, r, s = [], a = [], o = [], l = [], c = new Ct, h = new Ct, u = new Ct, p = new Ct, d = new Ct;
        e.length;
        var f = t + 1;
        for (n = 0; n <= i; n++) {
            var m = n / i;
            for (r = 0; r <= t; r++) {
                var g = r / t;
                e(g, m, h),
                a.push(h.x, h.y, h.z),
                g - 1e-5 >= 0 ? (e(g - 1e-5, m, u),
                p.subVectors(h, u)) : (e(g + 1e-5, m, u),
                p.subVectors(u, h)),
                m - 1e-5 >= 0 ? (e(g, m - 1e-5, u),
                d.subVectors(h, u)) : (e(g, m + 1e-5, u),
                d.subVectors(u, h)),
                c.crossVectors(p, d).normalize(),
                o.push(c.x, c.y, c.z),
                l.push(g, m)
            }
        }
        for (n = 0; n < i; n++)
            for (r = 0; r < t; r++) {
                var v = n * f + r
                  , y = n * f + r + 1
                  , b = (n + 1) * f + r + 1
                  , x = (n + 1) * f + r;
                s.push(v, y, x),
                s.push(y, b, x)
            }
        this.setIndex(s),
        this.addAttribute("position", new Ni(a,3)),
        this.addAttribute("normal", new Ni(o,3)),
        this.addAttribute("uv", new Ni(l,2))
    }
    function Os(e, t, i, n) {
        Ci.call(this),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: n
        },
        this.fromBufferGeometry(new Rs(e,t,i,n)),
        this.mergeVertices()
    }
    function Rs(e, t, i, n) {
        Vi.call(this),
        this.type = "PolyhedronBufferGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: n
        },
        i = i || 1;
        var r = []
          , s = [];
        function a(e, t, i, n) {
            var r, s, a = Math.pow(2, n), l = [];
            for (r = 0; r <= a; r++) {
                l[r] = [];
                var c = e.clone().lerp(i, r / a)
                  , h = t.clone().lerp(i, r / a)
                  , u = a - r;
                for (s = 0; s <= u; s++)
                    l[r][s] = 0 === s && r === a ? c : c.clone().lerp(h, s / u)
            }
            for (r = 0; r < a; r++)
                for (s = 0; s < 2 * (a - r) - 1; s++) {
                    var p = Math.floor(s / 2);
                    s % 2 == 0 ? (o(l[r][p + 1]),
                    o(l[r + 1][p]),
                    o(l[r][p])) : (o(l[r][p + 1]),
                    o(l[r + 1][p + 1]),
                    o(l[r + 1][p]))
                }
        }
        function o(e) {
            r.push(e.x, e.y, e.z)
        }
        function l(t, i) {
            var n = 3 * t;
            i.x = e[n + 0],
            i.y = e[n + 1],
            i.z = e[n + 2]
        }
        function c(e, t, i, n) {
            n < 0 && 1 === e.x && (s[t] = e.x - 1),
            0 === i.x && 0 === i.z && (s[t] = n / 2 / Math.PI + .5)
        }
        function h(e) {
            return Math.atan2(e.z, -e.x)
        }
        function u(e) {
            return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z))
        }
        !function(e) {
            for (var i = new Ct, n = new Ct, r = new Ct, s = 0; s < t.length; s += 3)
                l(t[s + 0], i),
                l(t[s + 1], n),
                l(t[s + 2], r),
                a(i, n, r, e)
        }(n = n || 0),
        function(e) {
            for (var t = new Ct, i = 0; i < r.length; i += 3)
                t.x = r[i + 0],
                t.y = r[i + 1],
                t.z = r[i + 2],
                t.normalize().multiplyScalar(e),
                r[i + 0] = t.x,
                r[i + 1] = t.y,
                r[i + 2] = t.z
        }(i),
        function() {
            for (var e = new Ct, t = 0; t < r.length; t += 3) {
                e.x = r[t + 0],
                e.y = r[t + 1],
                e.z = r[t + 2];
                var i = h(e) / 2 / Math.PI + .5
                  , n = u(e) / Math.PI + .5;
                s.push(i, 1 - n)
            }
            (function() {
                for (var e = new Ct, t = new Ct, i = new Ct, n = new Ct, a = new At, o = new At, l = new At, u = 0, p = 0; u < r.length; u += 9,
                p += 6) {
                    e.set(r[u + 0], r[u + 1], r[u + 2]),
                    t.set(r[u + 3], r[u + 4], r[u + 5]),
                    i.set(r[u + 6], r[u + 7], r[u + 8]),
                    a.set(s[p + 0], s[p + 1]),
                    o.set(s[p + 2], s[p + 3]),
                    l.set(s[p + 4], s[p + 5]),
                    n.copy(e).add(t).add(i).divideScalar(3);
                    var d = h(n);
                    c(a, p + 0, e, d),
                    c(o, p + 2, t, d),
                    c(l, p + 4, i, d)
                }
            }
            )(),
            function() {
                for (var e = 0; e < s.length; e += 6) {
                    var t = s[e + 0]
                      , i = s[e + 2]
                      , n = s[e + 4]
                      , r = Math.max(t, i, n)
                      , a = Math.min(t, i, n);
                    r > .9 && a < .1 && (t < .2 && (s[e + 0] += 1),
                    i < .2 && (s[e + 2] += 1),
                    n < .2 && (s[e + 4] += 1))
                }
            }()
        }(),
        this.addAttribute("position", new Ni(r,3)),
        this.addAttribute("normal", new Ni(r.slice(),3)),
        this.addAttribute("uv", new Ni(s,2)),
        0 === n ? this.computeVertexNormals() : this.normalizeNormals()
    }
    function zs(e, t) {
        Ci.call(this),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new Ns(e,t)),
        this.mergeVertices()
    }
    function Ns(e, t) {
        Rs.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t),
        this.type = "TetrahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function Ds(e, t) {
        Ci.call(this),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new Us(e,t)),
        this.mergeVertices()
    }
    function Us(e, t) {
        Rs.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t),
        this.type = "OctahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function Bs(e, t) {
        Ci.call(this),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new js(e,t)),
        this.mergeVertices()
    }
    function js(e, t) {
        var i = (1 + Math.sqrt(5)) / 2
          , n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1];
        Rs.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t),
        this.type = "IcosahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function Vs(e, t) {
        Ci.call(this),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new Gs(e,t)),
        this.mergeVertices()
    }
    function Gs(e, t) {
        var i = (1 + Math.sqrt(5)) / 2
          , n = 1 / i
          , r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n];
        Rs.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t),
        this.type = "DodecahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function Xs(e, t, i, n, r, s) {
        Ci.call(this),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: n,
            closed: r
        };
        var a = new Ys(e,t,i,n,r);
        this.tangents = a.tangents,
        this.normals = a.normals,
        this.binormals = a.binormals,
        this.fromBufferGeometry(a),
        this.mergeVertices()
    }
    function Ys(e, t, i, n, r) {
        Vi.call(this),
        this.type = "TubeBufferGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: n,
            closed: r
        },
        t = t || 64,
        i = i || 1,
        n = n || 8,
        r = r || !1;
        var s = e.computeFrenetFrames(t, r);
        this.tangents = s.tangents,
        this.normals = s.normals,
        this.binormals = s.binormals;
        var a, o, l = new Ct, c = new Ct, h = new At, u = new Ct, p = [], d = [], f = [], m = [];
        function g(r) {
            u = e.getPointAt(r / t, u);
            var a = s.normals[r]
              , h = s.binormals[r];
            for (o = 0; o <= n; o++) {
                var f = o / n * Math.PI * 2
                  , m = Math.sin(f)
                  , g = -Math.cos(f);
                c.x = g * a.x + m * h.x,
                c.y = g * a.y + m * h.y,
                c.z = g * a.z + m * h.z,
                c.normalize(),
                d.push(c.x, c.y, c.z),
                l.x = u.x + i * c.x,
                l.y = u.y + i * c.y,
                l.z = u.z + i * c.z,
                p.push(l.x, l.y, l.z)
            }
        }
        !function() {
            for (a = 0; a < t; a++)
                g(a);
            g(!1 === r ? t : 0),
            function() {
                for (a = 0; a <= t; a++)
                    for (o = 0; o <= n; o++)
                        h.x = a / t,
                        h.y = o / n,
                        f.push(h.x, h.y)
            }(),
            function() {
                for (o = 1; o <= t; o++)
                    for (a = 1; a <= n; a++) {
                        var e = (n + 1) * (o - 1) + (a - 1)
                          , i = (n + 1) * o + (a - 1)
                          , r = (n + 1) * o + a
                          , s = (n + 1) * (o - 1) + a;
                        m.push(e, i, s),
                        m.push(i, r, s)
                    }
            }()
        }(),
        this.setIndex(m),
        this.addAttribute("position", new Ni(p,3)),
        this.addAttribute("normal", new Ni(d,3)),
        this.addAttribute("uv", new Ni(f,2))
    }
    function Ws(e, t, i, n, r, s, a) {
        Ci.call(this),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: s
        },
        this.fromBufferGeometry(new qs(e,t,i,n,r,s)),
        this.mergeVertices()
    }
    function qs(e, t, i, n, r, s) {
        Vi.call(this),
        this.type = "TorusKnotBufferGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: s
        },
        e = e || 1,
        t = t || .4,
        i = Math.floor(i) || 64,
        n = Math.floor(n) || 8,
        r = r || 2,
        s = s || 3;
        var a, o, l = [], c = [], h = [], u = [], p = new Ct, d = new Ct, f = new Ct, m = new Ct, g = new Ct, v = new Ct, y = new Ct;
        for (a = 0; a <= i; ++a) {
            var b = a / i * r * Math.PI * 2;
            for (P(b, r, s, e, f),
            P(b + .01, r, s, e, m),
            v.subVectors(m, f),
            y.addVectors(m, f),
            g.crossVectors(v, y),
            y.crossVectors(g, v),
            g.normalize(),
            y.normalize(),
            o = 0; o <= n; ++o) {
                var x = o / n * Math.PI * 2
                  , w = -t * Math.cos(x)
                  , _ = t * Math.sin(x);
                p.x = f.x + (w * y.x + _ * g.x),
                p.y = f.y + (w * y.y + _ * g.y),
                p.z = f.z + (w * y.z + _ * g.z),
                c.push(p.x, p.y, p.z),
                d.subVectors(p, f).normalize(),
                h.push(d.x, d.y, d.z),
                u.push(a / i),
                u.push(o / n)
            }
        }
        for (o = 1; o <= i; o++)
            for (a = 1; a <= n; a++) {
                var T = (n + 1) * (o - 1) + (a - 1)
                  , M = (n + 1) * o + (a - 1)
                  , S = (n + 1) * o + a
                  , A = (n + 1) * (o - 1) + a;
                l.push(T, M, A),
                l.push(M, S, A)
            }
        function P(e, t, i, n, r) {
            var s = Math.cos(e)
              , a = Math.sin(e)
              , o = i / t * e
              , l = Math.cos(o);
            r.x = n * (2 + l) * .5 * s,
            r.y = n * (2 + l) * a * .5,
            r.z = n * Math.sin(o) * .5
        }
        this.setIndex(l),
        this.addAttribute("position", new Ni(c,3)),
        this.addAttribute("normal", new Ni(h,3)),
        this.addAttribute("uv", new Ni(u,2))
    }
    function Hs(e, t, i, n, r) {
        Ci.call(this),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        },
        this.fromBufferGeometry(new Qs(e,t,i,n,r)),
        this.mergeVertices()
    }
    function Qs(e, t, i, n, r) {
        Vi.call(this),
        this.type = "TorusBufferGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        },
        e = e || 1,
        t = t || .4,
        i = Math.floor(i) || 8,
        n = Math.floor(n) || 6,
        r = r || 2 * Math.PI;
        var s, a, o = [], l = [], c = [], h = [], u = new Ct, p = new Ct, d = new Ct;
        for (s = 0; s <= i; s++)
            for (a = 0; a <= n; a++) {
                var f = a / n * r
                  , m = s / i * Math.PI * 2;
                p.x = (e + t * Math.cos(m)) * Math.cos(f),
                p.y = (e + t * Math.cos(m)) * Math.sin(f),
                p.z = t * Math.sin(m),
                l.push(p.x, p.y, p.z),
                u.x = e * Math.cos(f),
                u.y = e * Math.sin(f),
                d.subVectors(p, u).normalize(),
                c.push(d.x, d.y, d.z),
                h.push(a / n),
                h.push(s / i)
            }
        for (s = 1; s <= i; s++)
            for (a = 1; a <= n; a++) {
                var g = (n + 1) * s + a - 1
                  , v = (n + 1) * (s - 1) + a - 1
                  , y = (n + 1) * (s - 1) + a
                  , b = (n + 1) * s + a;
                o.push(g, v, b),
                o.push(v, y, b)
            }
        this.setIndex(o),
        this.addAttribute("position", new Ni(l,3)),
        this.addAttribute("normal", new Ni(c,3)),
        this.addAttribute("uv", new Ni(h,2))
    }
    Object.assign(hs.prototype, {
        isFogExp2: !0,
        clone: function() {
            return new hs(this.color,this.density)
        },
        toJSON: function() {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }
    }),
    Object.assign(us.prototype, {
        isFog: !0,
        clone: function() {
            return new us(this.color,this.near,this.far)
        },
        toJSON: function() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }),
    ps.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: ps,
        isScene: !0,
        copy: function(e, t) {
            return Mi.prototype.copy.call(this, e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
            this.autoUpdate = e.autoUpdate,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this
        },
        toJSON: function(e) {
            var t = Mi.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)),
            null !== this.fog && (t.object.fog = this.fog.toJSON()),
            t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(ds.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(ds.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.stride : 0,
            this.array = e,
            this
        },
        setDynamic: function(e) {
            return this.dynamic = e,
            this
        },
        copy: function(e) {
            return this.array = new e.array.constructor(e.array),
            this.count = e.count,
            this.stride = e.stride,
            this.dynamic = e.dynamic,
            this
        },
        copyAt: function(e, t, i) {
            e *= this.stride,
            i *= t.stride;
            for (var n = 0, r = this.stride; n < r; n++)
                this.array[e + n] = t.array[i + n];
            return this
        },
        set: function(e, t) {
            return void 0 === t && (t = 0),
            this.array.set(e, t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        }
    }),
    Object.defineProperties(fs.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }),
    Object.assign(fs.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t,
            this
        },
        setY: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t,
            this
        },
        setZ: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t,
            this
        },
        setW: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t,
            this
        },
        getX: function(e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function(e, t, i) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = i,
            this
        },
        setXYZ: function(e, t, i, n) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = i,
            this.data.array[e + 2] = n,
            this
        },
        setXYZW: function(e, t, i, n, r) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = i,
            this.data.array[e + 2] = n,
            this.data.array[e + 3] = r,
            this
        }
    }),
    ms.prototype = Object.create(Hi.prototype),
    ms.prototype.constructor = ms,
    ms.prototype.isSpriteMaterial = !0,
    ms.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this
    }
    ,
    gs.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: gs,
        isSprite: !0,
        raycast: function() {
            var e = new Ct
              , t = new Ct
              , i = new Ct
              , n = new At
              , r = new At
              , s = new ii
              , a = new Ct
              , o = new Ct
              , l = new Ct
              , c = new At
              , h = new At
              , u = new At;
            function p(e, t, i, a, o, l) {
                n.subVectors(e, i).addScalar(.5).multiply(a),
                void 0 !== o ? (r.x = l * n.x - o * n.y,
                r.y = o * n.x + l * n.y) : r.copy(n),
                e.copy(t),
                e.x += r.x,
                e.y += r.y,
                e.applyMatrix4(s)
            }
            return function(n, r) {
                t.setFromMatrixScale(this.matrixWorld),
                s.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld),
                i.setFromMatrixPosition(this.modelViewMatrix);
                var d, f, m = this.material.rotation;
                0 !== m && (f = Math.cos(m),
                d = Math.sin(m));
                var g = this.center;
                p(a.set(-.5, -.5, 0), i, g, t, d, f),
                p(o.set(.5, -.5, 0), i, g, t, d, f),
                p(l.set(.5, .5, 0), i, g, t, d, f),
                c.set(0, 0),
                h.set(1, 0),
                u.set(1, 1);
                var v = n.ray.intersectTriangle(a, o, l, !1, e);
                if (null !== v || (p(o.set(-.5, .5, 0), i, g, t, d, f),
                h.set(0, 1),
                null !== (v = n.ray.intersectTriangle(a, l, o, !1, e)))) {
                    var y = n.ray.origin.distanceTo(e);
                    y < n.near || y > n.far || r.push({
                        distance: y,
                        point: e.clone(),
                        uv: pn.getUV(e, a, o, l, c, h, u, new At),
                        face: null,
                        object: this
                    })
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(e) {
            return Mi.prototype.copy.call(this, e),
            void 0 !== e.center && this.center.copy(e.center),
            this
        }
    }),
    vs.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: vs,
        isLOD: !0,
        copy: function(e) {
            Mi.prototype.copy.call(this, e, !1);
            for (var t = e.levels, i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                this.addLevel(r.object.clone(), r.distance)
            }
            return this
        },
        addLevel: function(e, t) {
            void 0 === t && (t = 0),
            t = Math.abs(t);
            for (var i = this.levels, n = 0; n < i.length && !(t < i[n].distance); n++)
                ;
            return i.splice(n, 0, {
                distance: t,
                object: e
            }),
            this.add(e),
            this
        },
        getObjectForDistance: function(e) {
            for (var t = this.levels, i = 1, n = t.length; i < n && !(e < t[i].distance); i++)
                ;
            return t[i - 1].object
        },
        raycast: (Kr = new Ct,
        function(e, t) {
            Kr.setFromMatrixPosition(this.matrixWorld);
            var i = e.ray.origin.distanceTo(Kr);
            this.getObjectForDistance(i).raycast(e, t)
        }
        ),
        update: function() {
            var e = new Ct
              , t = new Ct;
            return function(i) {
                var n = this.levels;
                if (n.length > 1) {
                    e.setFromMatrixPosition(i.matrixWorld),
                    t.setFromMatrixPosition(this.matrixWorld);
                    var r = e.distanceTo(t);
                    n[0].object.visible = !0;
                    for (var s = 1, a = n.length; s < a && r >= n[s].distance; s++)
                        n[s - 1].object.visible = !1,
                        n[s].object.visible = !0;
                    for (; s < a; s++)
                        n[s].object.visible = !1
                }
            }
        }(),
        toJSON: function(e) {
            var t = Mi.prototype.toJSON.call(this, e);
            t.object.levels = [];
            for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
                var s = i[n];
                t.object.levels.push({
                    object: s.object.uuid,
                    distance: s.distance
                })
            }
            return t
        }
    }),
    ys.prototype = Object.assign(Object.create(fn.prototype), {
        constructor: ys,
        isSkinnedMesh: !0,
        bind: function(e, t) {
            this.skeleton = e,
            void 0 === t && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            t = this.matrixWorld),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.getInverse(t)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var e = new qt, t = this.geometry.attributes.skinWeight, i = 0, n = t.count; i < n; i++) {
                e.x = t.getX(i),
                e.y = t.getY(i),
                e.z = t.getZ(i),
                e.w = t.getW(i);
                var r = 1 / e.manhattanLength();
                r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
                t.setXYZW(i, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function(e) {
            fn.prototype.updateMatrixWorld.call(this, e),
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode && this.bindMatrixInverse.getInverse(this.bindMatrix)
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Object.assign(bs.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var i = new ii;
                this.bones[e] && i.getInverse(this.bones[e].matrixWorld),
                this.boneInverses.push(i)
            }
        },
        pose: function() {
            var e, t, i;
            for (t = 0,
            i = this.bones.length; t < i; t++)
                (e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
            for (t = 0,
            i = this.bones.length; t < i; t++)
                (e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld),
                e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: (es = new ii,
        ts = new ii,
        function() {
            for (var e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture, r = 0, s = e.length; r < s; r++) {
                var a = e[r] ? e[r].matrixWorld : ts;
                es.multiplyMatrices(a, t[r]),
                es.toArray(i, 16 * r)
            }
            void 0 !== n && (n.needsUpdate = !0)
        }
        ),
        clone: function() {
            return new bs(this.bones,this.boneInverses)
        },
        getBoneByName: function(e) {
            for (var t = 0, i = this.bones.length; t < i; t++) {
                var n = this.bones[t];
                if (n.name === e)
                    return n
            }
        }
    }),
    xs.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: xs,
        isBone: !0
    }),
    ws.prototype = Object.create(Hi.prototype),
    ws.prototype.constructor = ws,
    ws.prototype.isLineBasicMaterial = !0,
    ws.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this
    }
    ,
    _s.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: _s,
        isLine: !0,
        computeLineDistances: (is = new Ct,
        ns = new Ct,
        function() {
            var e = this.geometry;
            if (e.isBufferGeometry) {
                if (null === e.index) {
                    for (var t = e.attributes.position, i = [0], n = 1, r = t.count; n < r; n++)
                        is.fromBufferAttribute(t, n - 1),
                        ns.fromBufferAttribute(t, n),
                        i[n] = i[n - 1],
                        i[n] += is.distanceTo(ns);
                    e.addAttribute("lineDistance", new Ni(i,1))
                }
            } else if (e.isGeometry) {
                var s = e.vertices;
                for ((i = e.lineDistances)[0] = 0,
                n = 1,
                r = s.length; n < r; n++)
                    i[n] = i[n - 1],
                    i[n] += s[n - 1].distanceTo(s[n])
            }
            return this
        }
        ),
        raycast: function() {
            var e = new ii
              , t = new un
              , i = new Kt;
            return function(n, r) {
                var s = n.linePrecision
                  , a = this.geometry
                  , o = this.matrixWorld;
                if (null === a.boundingSphere && a.computeBoundingSphere(),
                i.copy(a.boundingSphere),
                i.applyMatrix4(o),
                i.radius += s,
                !1 !== n.ray.intersectsSphere(i)) {
                    e.getInverse(o),
                    t.copy(n.ray).applyMatrix4(e);
                    var l = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                      , c = l * l
                      , h = new Ct
                      , u = new Ct
                      , p = new Ct
                      , d = new Ct
                      , f = this && this.isLineSegments ? 2 : 1;
                    if (a.isBufferGeometry) {
                        var m = a.index
                          , g = a.attributes.position.array;
                        if (null !== m)
                            for (var v = m.array, y = 0, b = v.length - 1; y < b; y += f) {
                                var x = v[y]
                                  , w = v[y + 1];
                                if (h.fromArray(g, 3 * x),
                                u.fromArray(g, 3 * w),
                                !(t.distanceSqToSegment(h, u, d, p) > c))
                                    d.applyMatrix4(this.matrixWorld),
                                    (M = n.ray.origin.distanceTo(d)) < n.near || M > n.far || r.push({
                                        distance: M,
                                        point: p.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                            }
                        else
                            for (y = 0,
                            b = g.length / 3 - 1; y < b; y += f) {
                                if (h.fromArray(g, 3 * y),
                                u.fromArray(g, 3 * y + 3),
                                !(t.distanceSqToSegment(h, u, d, p) > c))
                                    d.applyMatrix4(this.matrixWorld),
                                    (M = n.ray.origin.distanceTo(d)) < n.near || M > n.far || r.push({
                                        distance: M,
                                        point: p.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                            }
                    } else if (a.isGeometry) {
                        var _ = a.vertices
                          , T = _.length;
                        for (y = 0; y < T - 1; y += f) {
                            var M;
                            if (!(t.distanceSqToSegment(_[y], _[y + 1], d, p) > c))
                                d.applyMatrix4(this.matrixWorld),
                                (M = n.ray.origin.distanceTo(d)) < n.near || M > n.far || r.push({
                                    distance: M,
                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                    index: y,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                        }
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Ts.prototype = Object.assign(Object.create(_s.prototype), {
        constructor: Ts,
        isLineSegments: !0,
        computeLineDistances: function() {
            var e = new Ct
              , t = new Ct;
            return function() {
                var i = this.geometry;
                if (i.isBufferGeometry) {
                    if (null === i.index) {
                        for (var n = i.attributes.position, r = [], s = 0, a = n.count; s < a; s += 2)
                            e.fromBufferAttribute(n, s),
                            t.fromBufferAttribute(n, s + 1),
                            r[s] = 0 === s ? 0 : r[s - 1],
                            r[s + 1] = r[s] + e.distanceTo(t);
                        i.addAttribute("lineDistance", new Ni(r,1))
                    }
                } else if (i.isGeometry) {
                    var o = i.vertices;
                    for (r = i.lineDistances,
                    s = 0,
                    a = o.length; s < a; s += 2)
                        e.copy(o[s]),
                        t.copy(o[s + 1]),
                        r[s] = 0 === s ? 0 : r[s - 1],
                        r[s + 1] = r[s] + e.distanceTo(t)
                }
                return this
            }
        }()
    }),
    Ms.prototype = Object.assign(Object.create(_s.prototype), {
        constructor: Ms,
        isLineLoop: !0
    }),
    Ss.prototype = Object.create(Hi.prototype),
    Ss.prototype.constructor = Ss,
    Ss.prototype.isPointsMaterial = !0,
    Ss.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.morphTargets = e.morphTargets,
        this
    }
    ,
    As.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: As,
        isPoints: !0,
        raycast: function() {
            var e = new ii
              , t = new un
              , i = new Kt;
            return function(n, r) {
                var s = this
                  , a = this.geometry
                  , o = this.matrixWorld
                  , l = n.params.Points.threshold;
                if (null === a.boundingSphere && a.computeBoundingSphere(),
                i.copy(a.boundingSphere),
                i.applyMatrix4(o),
                i.radius += l,
                !1 !== n.ray.intersectsSphere(i)) {
                    e.getInverse(o),
                    t.copy(n.ray).applyMatrix4(e);
                    var c = l / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                      , h = c * c
                      , u = new Ct
                      , p = new Ct;
                    if (a.isBufferGeometry) {
                        var d = a.index
                          , f = a.attributes.position.array;
                        if (null !== d)
                            for (var m = d.array, g = 0, v = m.length; g < v; g++) {
                                var y = m[g];
                                u.fromArray(f, 3 * y),
                                w(u, y)
                            }
                        else {
                            g = 0;
                            for (var b = f.length / 3; g < b; g++)
                                u.fromArray(f, 3 * g),
                                w(u, g)
                        }
                    } else {
                        var x = a.vertices;
                        for (g = 0,
                        b = x.length; g < b; g++)
                            w(x[g], g)
                    }
                }
                function w(e, i) {
                    var a = t.distanceSqToPoint(e);
                    if (a < h) {
                        t.closestPointToPoint(e, p),
                        p.applyMatrix4(o);
                        var l = n.ray.origin.distanceTo(p);
                        if (l < n.near || l > n.far)
                            return;
                        r.push({
                            distance: l,
                            distanceToRay: Math.sqrt(a),
                            point: p.clone(),
                            index: i,
                            face: null,
                            object: s
                        })
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Ps.prototype = Object.assign(Object.create(Wt.prototype), {
        constructor: Ps,
        isVideoTexture: !0,
        update: function() {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }),
    Cs.prototype = Object.create(Wt.prototype),
    Cs.prototype.constructor = Cs,
    Cs.prototype.isCompressedTexture = !0,
    Ls.prototype = Object.create(Wt.prototype),
    Ls.prototype.constructor = Ls,
    Ls.prototype.isCanvasTexture = !0,
    ks.prototype = Object.create(Wt.prototype),
    ks.prototype.constructor = ks,
    ks.prototype.isDepthTexture = !0,
    Es.prototype = Object.create(Vi.prototype),
    Es.prototype.constructor = Es,
    Is.prototype = Object.create(Ci.prototype),
    Is.prototype.constructor = Is,
    Fs.prototype = Object.create(Vi.prototype),
    Fs.prototype.constructor = Fs,
    Os.prototype = Object.create(Ci.prototype),
    Os.prototype.constructor = Os,
    Rs.prototype = Object.create(Vi.prototype),
    Rs.prototype.constructor = Rs,
    zs.prototype = Object.create(Ci.prototype),
    zs.prototype.constructor = zs,
    Ns.prototype = Object.create(Rs.prototype),
    Ns.prototype.constructor = Ns,
    Ds.prototype = Object.create(Ci.prototype),
    Ds.prototype.constructor = Ds,
    Us.prototype = Object.create(Rs.prototype),
    Us.prototype.constructor = Us,
    Bs.prototype = Object.create(Ci.prototype),
    Bs.prototype.constructor = Bs,
    js.prototype = Object.create(Rs.prototype),
    js.prototype.constructor = js,
    Vs.prototype = Object.create(Ci.prototype),
    Vs.prototype.constructor = Vs,
    Gs.prototype = Object.create(Rs.prototype),
    Gs.prototype.constructor = Gs,
    Xs.prototype = Object.create(Ci.prototype),
    Xs.prototype.constructor = Xs,
    Ys.prototype = Object.create(Vi.prototype),
    Ys.prototype.constructor = Ys,
    Ys.prototype.toJSON = function() {
        var e = Vi.prototype.toJSON.call(this);
        return e.path = this.parameters.path.toJSON(),
        e
    }
    ,
    Ws.prototype = Object.create(Ci.prototype),
    Ws.prototype.constructor = Ws,
    qs.prototype = Object.create(Vi.prototype),
    qs.prototype.constructor = qs,
    Hs.prototype = Object.create(Ci.prototype),
    Hs.prototype.constructor = Hs,
    Qs.prototype = Object.create(Vi.prototype),
    Qs.prototype.constructor = Qs;
    var Js = function(e, t, i) {
        i = i || 2;
        var n, r, s, a, o, l, c, h = t && t.length, u = h ? t[0] * i : e.length, p = Zs(e, 0, u, i, !0), d = [];
        if (!p)
            return d;
        if (h && (p = function(e, t, i, n) {
            var r, s, a, o, l, c = [];
            for (r = 0,
            s = t.length; r < s; r++)
                a = t[r] * n,
                o = r < s - 1 ? t[r + 1] * n : e.length,
                (l = Zs(e, a, o, n, !1)) === l.next && (l.steiner = !0),
                c.push(oa(l));
            for (c.sort(ra),
            r = 0; r < c.length; r++)
                sa(c[r], i),
                i = $s(i, i.next);
            return i
        }(e, t, p, i)),
        e.length > 80 * i) {
            n = s = e[0],
            r = a = e[1];
            for (var f = i; f < u; f += i)
                (o = e[f]) < n && (n = o),
                (l = e[f + 1]) < r && (r = l),
                o > s && (s = o),
                l > a && (a = l);
            c = 0 !== (c = Math.max(s - n, a - r)) ? 1 / c : 0
        }
        return Ks(p, d, i, n, r, c),
        d
    };
    function Zs(e, t, i, n, r) {
        var s, a;
        if (r === function(e, t, i, n) {
            for (var r = 0, s = t, a = i - n; s < i; s += n)
                r += (e[a] - e[s]) * (e[s + 1] + e[a + 1]),
                a = s;
            return r
        }(e, t, i, n) > 0)
            for (s = t; s < i; s += n)
                a = ma(s, e[s], e[s + 1], a);
        else
            for (s = i - n; s >= t; s -= n)
                a = ma(s, e[s], e[s + 1], a);
        return a && ua(a, a.next) && (ga(a),
        a = a.next),
        a
    }
    function $s(e, t) {
        if (!e)
            return e;
        t || (t = e);
        var i, n = e;
        do {
            if (i = !1,
            n.steiner || !ua(n, n.next) && 0 !== ha(n.prev, n, n.next))
                n = n.next;
            else {
                if (ga(n),
                (n = t = n.prev) === n.next)
                    break;
                i = !0
            }
        } while (i || n !== t);
        return t
    }
    function Ks(e, t, i, n, r, s, a) {
        if (e) {
            !a && s && function(e, t, i, n) {
                var r = e;
                do {
                    null === r.z && (r.z = aa(r.x, r.y, t, i, n)),
                    r.prevZ = r.prev,
                    r.nextZ = r.next,
                    r = r.next
                } while (r !== e);
                r.prevZ.nextZ = null,
                r.prevZ = null,
                function(e) {
                    var t, i, n, r, s, a, o, l, c = 1;
                    do {
                        for (i = e,
                        e = null,
                        s = null,
                        a = 0; i; ) {
                            for (a++,
                            n = i,
                            o = 0,
                            t = 0; t < c && (o++,
                            n = n.nextZ); t++)
                                ;
                            for (l = c; o > 0 || l > 0 && n; )
                                0 !== o && (0 === l || !n || i.z <= n.z) ? (r = i,
                                i = i.nextZ,
                                o--) : (r = n,
                                n = n.nextZ,
                                l--),
                                s ? s.nextZ = r : e = r,
                                r.prevZ = s,
                                s = r;
                            i = n
                        }
                        s.nextZ = null,
                        c *= 2
                    } while (a > 1)
                }(r)
            }(e, n, r, s);
            for (var o, l, c = e; e.prev !== e.next; )
                if (o = e.prev,
                l = e.next,
                s ? ta(e, n, r, s) : ea(e))
                    t.push(o.i / i),
                    t.push(e.i / i),
                    t.push(l.i / i),
                    ga(e),
                    e = l.next,
                    c = l.next;
                else if ((e = l) === c) {
                    a ? 1 === a ? Ks(e = ia(e, t, i), t, i, n, r, s, 2) : 2 === a && na(e, t, i, n, r, s) : Ks($s(e), t, i, n, r, s, 1);
                    break
                }
        }
    }
    function ea(e) {
        var t = e.prev
          , i = e
          , n = e.next;
        if (ha(t, i, n) >= 0)
            return !1;
        for (var r = e.next.next; r !== e.prev; ) {
            if (la(t.x, t.y, i.x, i.y, n.x, n.y, r.x, r.y) && ha(r.prev, r, r.next) >= 0)
                return !1;
            r = r.next
        }
        return !0
    }
    function ta(e, t, i, n) {
        var r = e.prev
          , s = e
          , a = e.next;
        if (ha(r, s, a) >= 0)
            return !1;
        for (var o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x, l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y, c = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x, h = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y, u = aa(o, l, t, i, n), p = aa(c, h, t, i, n), d = e.nextZ; d && d.z <= p; ) {
            if (d !== e.prev && d !== e.next && la(r.x, r.y, s.x, s.y, a.x, a.y, d.x, d.y) && ha(d.prev, d, d.next) >= 0)
                return !1;
            d = d.nextZ
        }
        for (d = e.prevZ; d && d.z >= u; ) {
            if (d !== e.prev && d !== e.next && la(r.x, r.y, s.x, s.y, a.x, a.y, d.x, d.y) && ha(d.prev, d, d.next) >= 0)
                return !1;
            d = d.prevZ
        }
        return !0
    }
    function ia(e, t, i) {
        var n = e;
        do {
            var r = n.prev
              , s = n.next.next;
            !ua(r, s) && pa(r, n, n.next, s) && da(r, s) && da(s, r) && (t.push(r.i / i),
            t.push(n.i / i),
            t.push(s.i / i),
            ga(n),
            ga(n.next),
            n = e = s),
            n = n.next
        } while (n !== e);
        return n
    }
    function na(e, t, i, n, r, s) {
        var a = e;
        do {
            for (var o = a.next.next; o !== a.prev; ) {
                if (a.i !== o.i && ca(a, o)) {
                    var l = fa(a, o);
                    return a = $s(a, a.next),
                    l = $s(l, l.next),
                    Ks(a, t, i, n, r, s),
                    void Ks(l, t, i, n, r, s)
                }
                o = o.next
            }
            a = a.next
        } while (a !== e)
    }
    function ra(e, t) {
        return e.x - t.x
    }
    function sa(e, t) {
        if (t = function(e, t) {
            var i, n = t, r = e.x, s = e.y, a = -1 / 0;
            do {
                if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
                    var o = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                    if (o <= r && o > a) {
                        if (a = o,
                        o === r) {
                            if (s === n.y)
                                return n;
                            if (s === n.next.y)
                                return n.next
                        }
                        i = n.x < n.next.x ? n : n.next
                    }
                }
                n = n.next
            } while (n !== t);
            if (!i)
                return null;
            if (r === a)
                return i.prev;
            var l, c = i, h = i.x, u = i.y, p = 1 / 0;
            n = i.next;
            for (; n !== c; )
                r >= n.x && n.x >= h && r !== n.x && la(s < u ? r : a, s, h, u, s < u ? a : r, s, n.x, n.y) && ((l = Math.abs(s - n.y) / (r - n.x)) < p || l === p && n.x > i.x) && da(n, e) && (i = n,
                p = l),
                n = n.next;
            return i
        }(e, t)) {
            var i = fa(t, e);
            $s(i, i.next)
        }
    }
    function aa(e, t, i, n, r) {
        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }
    function oa(e) {
        var t = e
          , i = e;
        do {
            t.x < i.x && (i = t),
            t = t.next
        } while (t !== e);
        return i
    }
    function la(e, t, i, n, r, s, a, o) {
        return (r - a) * (t - o) - (e - a) * (s - o) >= 0 && (e - a) * (n - o) - (i - a) * (t - o) >= 0 && (i - a) * (s - o) - (r - a) * (n - o) >= 0
    }
    function ca(e, t) {
        return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
            var i = e;
            do {
                if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && pa(i, i.next, e, t))
                    return !0;
                i = i.next
            } while (i !== e);
            return !1
        }(e, t) && da(e, t) && da(t, e) && function(e, t) {
            var i = e
              , n = !1
              , r = (e.x + t.x) / 2
              , s = (e.y + t.y) / 2;
            do {
                i.y > s != i.next.y > s && i.next.y !== i.y && r < (i.next.x - i.x) * (s - i.y) / (i.next.y - i.y) + i.x && (n = !n),
                i = i.next
            } while (i !== e);
            return n
        }(e, t)
    }
    function ha(e, t, i) {
        return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
    }
    function ua(e, t) {
        return e.x === t.x && e.y === t.y
    }
    function pa(e, t, i, n) {
        return !!(ua(e, t) && ua(i, n) || ua(e, n) && ua(i, t)) || ha(e, t, i) > 0 != ha(e, t, n) > 0 && ha(i, n, e) > 0 != ha(i, n, t) > 0
    }
    function da(e, t) {
        return ha(e.prev, e, e.next) < 0 ? ha(e, t, e.next) >= 0 && ha(e, e.prev, t) >= 0 : ha(e, t, e.prev) < 0 || ha(e, e.next, t) < 0
    }
    function fa(e, t) {
        var i = new va(e.i,e.x,e.y)
          , n = new va(t.i,t.x,t.y)
          , r = e.next
          , s = t.prev;
        return e.next = t,
        t.prev = e,
        i.next = r,
        r.prev = i,
        n.next = i,
        i.prev = n,
        s.next = n,
        n.prev = s,
        n
    }
    function ma(e, t, i, n) {
        var r = new va(e,t,i);
        return n ? (r.next = n.next,
        r.prev = n,
        n.next.prev = r,
        n.next = r) : (r.prev = r,
        r.next = r),
        r
    }
    function ga(e) {
        e.next.prev = e.prev,
        e.prev.next = e.next,
        e.prevZ && (e.prevZ.nextZ = e.nextZ),
        e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }
    function va(e, t, i) {
        this.i = e,
        this.x = t,
        this.y = i,
        this.prev = null,
        this.next = null,
        this.z = null,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    }
    var ya = {
        area: function(e) {
            for (var t = e.length, i = 0, n = t - 1, r = 0; r < t; n = r++)
                i += e[n].x * e[r].y - e[r].x * e[n].y;
            return .5 * i
        },
        isClockWise: function(e) {
            return ya.area(e) < 0
        },
        triangulateShape: function(e, t) {
            var i = []
              , n = []
              , r = [];
            ba(e),
            xa(i, e);
            var s = e.length;
            t.forEach(ba);
            for (var a = 0; a < t.length; a++)
                n.push(s),
                s += t[a].length,
                xa(i, t[a]);
            var o = Js(i, n);
            for (a = 0; a < o.length; a += 3)
                r.push(o.slice(a, a + 3));
            return r
        }
    };
    function ba(e) {
        var t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop()
    }
    function xa(e, t) {
        for (var i = 0; i < t.length; i++)
            e.push(t[i].x),
            e.push(t[i].y)
    }
    function wa(e, t) {
        Ci.call(this),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        this.fromBufferGeometry(new _a(e,t)),
        this.mergeVertices()
    }
    function _a(e, t) {
        Vi.call(this),
        this.type = "ExtrudeBufferGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        for (var i = this, n = [], r = [], s = 0, a = e.length; s < a; s++) {
            o(e[s])
        }
        function o(e) {
            var s = []
              , a = void 0 !== t.curveSegments ? t.curveSegments : 12
              , o = void 0 !== t.steps ? t.steps : 1
              , l = void 0 !== t.depth ? t.depth : 100
              , c = void 0 === t.bevelEnabled || t.bevelEnabled
              , h = void 0 !== t.bevelThickness ? t.bevelThickness : 6
              , u = void 0 !== t.bevelSize ? t.bevelSize : h - 2
              , p = void 0 !== t.bevelOffset ? t.bevelOffset : 0
              , d = void 0 !== t.bevelSegments ? t.bevelSegments : 3
              , f = t.extrudePath
              , m = void 0 !== t.UVGenerator ? t.UVGenerator : Ta;
            void 0 !== t.amount && (l = t.amount);
            var g, v, y, b, x, w, _, T, M = !1;
            f && (g = f.getSpacedPoints(o),
            M = !0,
            c = !1,
            v = f.computeFrenetFrames(o, !1),
            y = new Ct,
            b = new Ct,
            x = new Ct),
            c || (d = 0,
            h = 0,
            u = 0,
            p = 0);
            var S = e.extractPoints(a)
              , A = S.shape
              , P = S.holes;
            if (!ya.isClockWise(A))
                for (A = A.reverse(),
                _ = 0,
                T = P.length; _ < T; _++)
                    w = P[_],
                    ya.isClockWise(w) && (P[_] = w.reverse());
            var C = ya.triangulateShape(A, P)
              , L = A;
            for (_ = 0,
            T = P.length; _ < T; _++)
                w = P[_],
                A = A.concat(w);
            function k(e, t, i) {
                return t.clone().multiplyScalar(i).add(e)
            }
            var E, I, F, O, R, z, N = A.length, D = C.length;
            function U(e, t, i) {
                var n, r, s, a = e.x - t.x, o = e.y - t.y, l = i.x - e.x, c = i.y - e.y, h = a * a + o * o, u = a * c - o * l;
                if (Math.abs(u) > Number.EPSILON) {
                    var p = Math.sqrt(h)
                      , d = Math.sqrt(l * l + c * c)
                      , f = t.x - o / p
                      , m = t.y + a / p
                      , g = ((i.x - c / d - f) * c - (i.y + l / d - m) * l) / (a * c - o * l)
                      , v = (n = f + a * g - e.x) * n + (r = m + o * g - e.y) * r;
                    if (v <= 2)
                        return new At(n,r);
                    s = Math.sqrt(v / 2)
                } else {
                    var y = !1;
                    a > Number.EPSILON ? l > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (y = !0) : Math.sign(o) === Math.sign(c) && (y = !0),
                    y ? (n = -o,
                    r = a,
                    s = Math.sqrt(h)) : (n = a,
                    r = o,
                    s = Math.sqrt(h / 2))
                }
                return new At(n / s,r / s)
            }
            for (var B = [], j = 0, V = L.length, G = V - 1, X = j + 1; j < V; j++,
            G++,
            X++)
                G === V && (G = 0),
                X === V && (X = 0),
                B[j] = U(L[j], L[G], L[X]);
            var Y, W, q = [], H = B.concat();
            for (_ = 0,
            T = P.length; _ < T; _++) {
                for (w = P[_],
                Y = [],
                j = 0,
                G = (V = w.length) - 1,
                X = j + 1; j < V; j++,
                G++,
                X++)
                    G === V && (G = 0),
                    X === V && (X = 0),
                    Y[j] = U(w[j], w[G], w[X]);
                q.push(Y),
                H = H.concat(Y)
            }
            for (E = 0; E < d; E++) {
                for (F = E / d,
                O = h * Math.cos(F * Math.PI / 2),
                I = u * Math.sin(F * Math.PI / 2) + p,
                j = 0,
                V = L.length; j < V; j++)
                    J((R = k(L[j], B[j], I)).x, R.y, -O);
                for (_ = 0,
                T = P.length; _ < T; _++)
                    for (w = P[_],
                    Y = q[_],
                    j = 0,
                    V = w.length; j < V; j++)
                        J((R = k(w[j], Y[j], I)).x, R.y, -O)
            }
            for (I = u + p,
            j = 0; j < N; j++)
                R = c ? k(A[j], H[j], I) : A[j],
                M ? (b.copy(v.normals[0]).multiplyScalar(R.x),
                y.copy(v.binormals[0]).multiplyScalar(R.y),
                x.copy(g[0]).add(b).add(y),
                J(x.x, x.y, x.z)) : J(R.x, R.y, 0);
            for (W = 1; W <= o; W++)
                for (j = 0; j < N; j++)
                    R = c ? k(A[j], H[j], I) : A[j],
                    M ? (b.copy(v.normals[W]).multiplyScalar(R.x),
                    y.copy(v.binormals[W]).multiplyScalar(R.y),
                    x.copy(g[W]).add(b).add(y),
                    J(x.x, x.y, x.z)) : J(R.x, R.y, l / o * W);
            for (E = d - 1; E >= 0; E--) {
                for (F = E / d,
                O = h * Math.cos(F * Math.PI / 2),
                I = u * Math.sin(F * Math.PI / 2) + p,
                j = 0,
                V = L.length; j < V; j++)
                    J((R = k(L[j], B[j], I)).x, R.y, l + O);
                for (_ = 0,
                T = P.length; _ < T; _++)
                    for (w = P[_],
                    Y = q[_],
                    j = 0,
                    V = w.length; j < V; j++)
                        R = k(w[j], Y[j], I),
                        M ? J(R.x, R.y + g[o - 1].y, g[o - 1].x + O) : J(R.x, R.y, l + O)
            }
            function Q(e, t) {
                var i, n;
                for (j = e.length; --j >= 0; ) {
                    i = j,
                    (n = j - 1) < 0 && (n = e.length - 1);
                    var r = 0
                      , s = o + 2 * d;
                    for (r = 0; r < s; r++) {
                        var a = N * r
                          , l = N * (r + 1);
                        $(t + i + a, t + n + a, t + n + l, t + i + l)
                    }
                }
            }
            function J(e, t, i) {
                s.push(e),
                s.push(t),
                s.push(i)
            }
            function Z(e, t, r) {
                K(e),
                K(t),
                K(r);
                var s = n.length / 3
                  , a = m.generateTopUV(i, n, s - 3, s - 2, s - 1);
                ee(a[0]),
                ee(a[1]),
                ee(a[2])
            }
            function $(e, t, r, s) {
                K(e),
                K(t),
                K(s),
                K(t),
                K(r),
                K(s);
                var a = n.length / 3
                  , o = m.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
                ee(o[0]),
                ee(o[1]),
                ee(o[3]),
                ee(o[1]),
                ee(o[2]),
                ee(o[3])
            }
            function K(e) {
                n.push(s[3 * e + 0]),
                n.push(s[3 * e + 1]),
                n.push(s[3 * e + 2])
            }
            function ee(e) {
                r.push(e.x),
                r.push(e.y)
            }
            !function() {
                var e = n.length / 3;
                if (c) {
                    var t = 0
                      , r = N * t;
                    for (j = 0; j < D; j++)
                        Z((z = C[j])[2] + r, z[1] + r, z[0] + r);
                    for (r = N * (t = o + 2 * d),
                    j = 0; j < D; j++)
                        Z((z = C[j])[0] + r, z[1] + r, z[2] + r)
                } else {
                    for (j = 0; j < D; j++)
                        Z((z = C[j])[2], z[1], z[0]);
                    for (j = 0; j < D; j++)
                        Z((z = C[j])[0] + N * o, z[1] + N * o, z[2] + N * o)
                }
                i.addGroup(e, n.length / 3 - e, 0)
            }(),
            function() {
                var e = n.length / 3
                  , t = 0;
                for (Q(L, t),
                t += L.length,
                _ = 0,
                T = P.length; _ < T; _++)
                    Q(w = P[_], t),
                    t += w.length;
                i.addGroup(e, n.length / 3 - e, 1)
            }()
        }
        this.addAttribute("position", new Ni(n,3)),
        this.addAttribute("uv", new Ni(r,2)),
        this.computeVertexNormals()
    }
    wa.prototype = Object.create(Ci.prototype),
    wa.prototype.constructor = wa,
    wa.prototype.toJSON = function() {
        var e = Ci.prototype.toJSON.call(this);
        return Ma(this.parameters.shapes, this.parameters.options, e)
    }
    ,
    _a.prototype = Object.create(Vi.prototype),
    _a.prototype.constructor = _a,
    _a.prototype.toJSON = function() {
        var e = Vi.prototype.toJSON.call(this);
        return Ma(this.parameters.shapes, this.parameters.options, e)
    }
    ;
    var Ta = {
        generateTopUV: function(e, t, i, n, r) {
            var s = t[3 * i]
              , a = t[3 * i + 1]
              , o = t[3 * n]
              , l = t[3 * n + 1]
              , c = t[3 * r]
              , h = t[3 * r + 1];
            return [new At(s,a), new At(o,l), new At(c,h)]
        },
        generateSideWallUV: function(e, t, i, n, r, s) {
            var a = t[3 * i]
              , o = t[3 * i + 1]
              , l = t[3 * i + 2]
              , c = t[3 * n]
              , h = t[3 * n + 1]
              , u = t[3 * n + 2]
              , p = t[3 * r]
              , d = t[3 * r + 1]
              , f = t[3 * r + 2]
              , m = t[3 * s]
              , g = t[3 * s + 1]
              , v = t[3 * s + 2];
            return Math.abs(o - h) < .01 ? [new At(a,1 - l), new At(c,1 - u), new At(p,1 - f), new At(m,1 - v)] : [new At(o,1 - l), new At(h,1 - u), new At(d,1 - f), new At(g,1 - v)]
        }
    };
    function Ma(e, t, i) {
        if (i.shapes = [],
        Array.isArray(e))
            for (var n = 0, r = e.length; n < r; n++) {
                var s = e[n];
                i.shapes.push(s.uuid)
            }
        else
            i.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()),
        i
    }
    function Sa(e, t) {
        Ci.call(this),
        this.type = "TextGeometry",
        this.parameters = {
            text: e,
            parameters: t
        },
        this.fromBufferGeometry(new Aa(e,t)),
        this.mergeVertices()
    }
    function Aa(e, t) {
        var i = (t = t || {}).font;
        if (!i || !i.isFont)
            return new Ci;
        var n = i.generateShapes(e, t.size);
        t.depth = void 0 !== t.height ? t.height : 50,
        void 0 === t.bevelThickness && (t.bevelThickness = 10),
        void 0 === t.bevelSize && (t.bevelSize = 8),
        void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
        _a.call(this, n, t),
        this.type = "TextBufferGeometry"
    }
    function Pa(e, t, i, n, r, s, a) {
        Ci.call(this),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: s,
            thetaLength: a
        },
        this.fromBufferGeometry(new Ca(e,t,i,n,r,s,a)),
        this.mergeVertices()
    }
    function Ca(e, t, i, n, r, s, a) {
        Vi.call(this),
        this.type = "SphereBufferGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: s,
            thetaLength: a
        },
        e = e || 1,
        t = Math.max(3, Math.floor(t) || 8),
        i = Math.max(2, Math.floor(i) || 6),
        n = void 0 !== n ? n : 0,
        r = void 0 !== r ? r : 2 * Math.PI;
        var o, l, c = (s = void 0 !== s ? s : 0) + (a = void 0 !== a ? a : Math.PI), h = 0, u = [], p = new Ct, d = new Ct, f = [], m = [], g = [], v = [];
        for (l = 0; l <= i; l++) {
            var y = []
              , b = l / i
              , x = 0 == l ? .5 / t : l == i ? -.5 / t : 0;
            for (o = 0; o <= t; o++) {
                var w = o / t;
                p.x = -e * Math.cos(n + w * r) * Math.sin(s + b * a),
                p.y = e * Math.cos(s + b * a),
                p.z = e * Math.sin(n + w * r) * Math.sin(s + b * a),
                m.push(p.x, p.y, p.z),
                d.copy(p).normalize(),
                g.push(d.x, d.y, d.z),
                v.push(w + x, 1 - b),
                y.push(h++)
            }
            u.push(y)
        }
        for (l = 0; l < i; l++)
            for (o = 0; o < t; o++) {
                var _ = u[l][o + 1]
                  , T = u[l][o]
                  , M = u[l + 1][o]
                  , S = u[l + 1][o + 1];
                (0 !== l || s > 0) && f.push(_, T, S),
                (l !== i - 1 || c < Math.PI) && f.push(T, M, S)
            }
        this.setIndex(f),
        this.addAttribute("position", new Ni(m,3)),
        this.addAttribute("normal", new Ni(g,3)),
        this.addAttribute("uv", new Ni(v,2))
    }
    function La(e, t, i, n, r, s) {
        Ci.call(this),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: s
        },
        this.fromBufferGeometry(new ka(e,t,i,n,r,s)),
        this.mergeVertices()
    }
    function ka(e, t, i, n, r, s) {
        Vi.call(this),
        this.type = "RingBufferGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: s
        },
        e = e || .5,
        t = t || 1,
        r = void 0 !== r ? r : 0,
        s = void 0 !== s ? s : 2 * Math.PI,
        i = void 0 !== i ? Math.max(3, i) : 8;
        var a, o, l, c = [], h = [], u = [], p = [], d = e, f = (t - e) / (n = void 0 !== n ? Math.max(1, n) : 1), m = new Ct, g = new At;
        for (o = 0; o <= n; o++) {
            for (l = 0; l <= i; l++)
                a = r + l / i * s,
                m.x = d * Math.cos(a),
                m.y = d * Math.sin(a),
                h.push(m.x, m.y, m.z),
                u.push(0, 0, 1),
                g.x = (m.x / t + 1) / 2,
                g.y = (m.y / t + 1) / 2,
                p.push(g.x, g.y);
            d += f
        }
        for (o = 0; o < n; o++) {
            var v = o * (i + 1);
            for (l = 0; l < i; l++) {
                var y = a = l + v
                  , b = a + i + 1
                  , x = a + i + 2
                  , w = a + 1;
                c.push(y, b, w),
                c.push(b, x, w)
            }
        }
        this.setIndex(c),
        this.addAttribute("position", new Ni(h,3)),
        this.addAttribute("normal", new Ni(u,3)),
        this.addAttribute("uv", new Ni(p,2))
    }
    function Ea(e, t, i, n) {
        Ci.call(this),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: n
        },
        this.fromBufferGeometry(new Ia(e,t,i,n)),
        this.mergeVertices()
    }
    function Ia(e, t, i, n) {
        Vi.call(this),
        this.type = "LatheBufferGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: n
        },
        t = Math.floor(t) || 12,
        i = i || 0,
        n = n || 2 * Math.PI,
        n = St.clamp(n, 0, 2 * Math.PI);
        var r, s, a, o = [], l = [], c = [], h = 1 / t, u = new Ct, p = new At;
        for (s = 0; s <= t; s++) {
            var d = i + s * h * n
              , f = Math.sin(d)
              , m = Math.cos(d);
            for (a = 0; a <= e.length - 1; a++)
                u.x = e[a].x * f,
                u.y = e[a].y,
                u.z = e[a].x * m,
                l.push(u.x, u.y, u.z),
                p.x = s / t,
                p.y = a / (e.length - 1),
                c.push(p.x, p.y)
        }
        for (s = 0; s < t; s++)
            for (a = 0; a < e.length - 1; a++) {
                var g = r = a + s * e.length
                  , v = r + e.length
                  , y = r + e.length + 1
                  , b = r + 1;
                o.push(g, v, b),
                o.push(v, y, b)
            }
        if (this.setIndex(o),
        this.addAttribute("position", new Ni(l,3)),
        this.addAttribute("uv", new Ni(c,2)),
        this.computeVertexNormals(),
        n === 2 * Math.PI) {
            var x = this.attributes.normal.array
              , w = new Ct
              , _ = new Ct
              , T = new Ct;
            for (r = t * e.length * 3,
            s = 0,
            a = 0; s < e.length; s++,
            a += 3)
                w.x = x[a + 0],
                w.y = x[a + 1],
                w.z = x[a + 2],
                _.x = x[r + a + 0],
                _.y = x[r + a + 1],
                _.z = x[r + a + 2],
                T.addVectors(w, _).normalize(),
                x[a + 0] = x[r + a + 0] = T.x,
                x[a + 1] = x[r + a + 1] = T.y,
                x[a + 2] = x[r + a + 2] = T.z
        }
    }
    function Fa(e, t) {
        Ci.call(this),
        this.type = "ShapeGeometry",
        "object" == typeof t && (t = t.curveSegments),
        this.parameters = {
            shapes: e,
            curveSegments: t
        },
        this.fromBufferGeometry(new Oa(e,t)),
        this.mergeVertices()
    }
    function Oa(e, t) {
        Vi.call(this),
        this.type = "ShapeBufferGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        },
        t = t || 12;
        var i = []
          , n = []
          , r = []
          , s = []
          , a = 0
          , o = 0;
        if (!1 === Array.isArray(e))
            c(e);
        else
            for (var l = 0; l < e.length; l++)
                c(e[l]),
                this.addGroup(a, o, l),
                a += o,
                o = 0;
        function c(e) {
            var a, l, c, h = n.length / 3, u = e.extractPoints(t), p = u.shape, d = u.holes;
            for (!1 === ya.isClockWise(p) && (p = p.reverse()),
            a = 0,
            l = d.length; a < l; a++)
                c = d[a],
                !0 === ya.isClockWise(c) && (d[a] = c.reverse());
            var f = ya.triangulateShape(p, d);
            for (a = 0,
            l = d.length; a < l; a++)
                c = d[a],
                p = p.concat(c);
            for (a = 0,
            l = p.length; a < l; a++) {
                var m = p[a];
                n.push(m.x, m.y, 0),
                r.push(0, 0, 1),
                s.push(m.x, m.y)
            }
            for (a = 0,
            l = f.length; a < l; a++) {
                var g = f[a]
                  , v = g[0] + h
                  , y = g[1] + h
                  , b = g[2] + h;
                i.push(v, y, b),
                o += 3
            }
        }
        this.setIndex(i),
        this.addAttribute("position", new Ni(n,3)),
        this.addAttribute("normal", new Ni(r,3)),
        this.addAttribute("uv", new Ni(s,2))
    }
    function Ra(e, t) {
        if (t.shapes = [],
        Array.isArray(e))
            for (var i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.shapes.push(r.uuid)
            }
        else
            t.shapes.push(e.uuid);
        return t
    }
    function za(e, t) {
        Vi.call(this),
        this.type = "EdgesGeometry",
        this.parameters = {
            thresholdAngle: t
        },
        t = void 0 !== t ? t : 1;
        var i, n, r, s, a = [], o = Math.cos(St.DEG2RAD * t), l = [0, 0], c = {}, h = ["a", "b", "c"];
        e.isBufferGeometry ? (s = new Ci).fromBufferGeometry(e) : s = e.clone(),
        s.mergeVertices(),
        s.computeFaceNormals();
        for (var u = s.vertices, p = s.faces, d = 0, f = p.length; d < f; d++)
            for (var m = p[d], g = 0; g < 3; g++)
                i = m[h[g]],
                n = m[h[(g + 1) % 3]],
                l[0] = Math.min(i, n),
                l[1] = Math.max(i, n),
                void 0 === c[r = l[0] + "," + l[1]] ? c[r] = {
                    index1: l[0],
                    index2: l[1],
                    face1: d,
                    face2: void 0
                } : c[r].face2 = d;
        for (r in c) {
            var v = c[r];
            if (void 0 === v.face2 || p[v.face1].normal.dot(p[v.face2].normal) <= o) {
                var y = u[v.index1];
                a.push(y.x, y.y, y.z),
                y = u[v.index2],
                a.push(y.x, y.y, y.z)
            }
        }
        this.addAttribute("position", new Ni(a,3))
    }
    function Na(e, t, i, n, r, s, a, o) {
        Ci.call(this),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: s,
            thetaStart: a,
            thetaLength: o
        },
        this.fromBufferGeometry(new Da(e,t,i,n,r,s,a,o)),
        this.mergeVertices()
    }
    function Da(e, t, i, n, r, s, a, o) {
        Vi.call(this),
        this.type = "CylinderBufferGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: s,
            thetaStart: a,
            thetaLength: o
        };
        var l = this;
        e = void 0 !== e ? e : 1,
        t = void 0 !== t ? t : 1,
        i = i || 1,
        n = Math.floor(n) || 8,
        r = Math.floor(r) || 1,
        s = void 0 !== s && s,
        a = void 0 !== a ? a : 0,
        o = void 0 !== o ? o : 2 * Math.PI;
        var c = []
          , h = []
          , u = []
          , p = []
          , d = 0
          , f = []
          , m = i / 2
          , g = 0;
        function v(i) {
            var r, s, f, v = new At, y = new Ct, b = 0, x = !0 === i ? e : t, w = !0 === i ? 1 : -1;
            for (s = d,
            r = 1; r <= n; r++)
                h.push(0, m * w, 0),
                u.push(0, w, 0),
                p.push(.5, .5),
                d++;
            for (f = d,
            r = 0; r <= n; r++) {
                var _ = r / n * o + a
                  , T = Math.cos(_)
                  , M = Math.sin(_);
                y.x = x * M,
                y.y = m * w,
                y.z = x * T,
                h.push(y.x, y.y, y.z),
                u.push(0, w, 0),
                v.x = .5 * T + .5,
                v.y = .5 * M * w + .5,
                p.push(v.x, v.y),
                d++
            }
            for (r = 0; r < n; r++) {
                var S = s + r
                  , A = f + r;
                !0 === i ? c.push(A, A + 1, S) : c.push(A + 1, A, S),
                b += 3
            }
            l.addGroup(g, b, !0 === i ? 1 : 2),
            g += b
        }
        !function() {
            var s, v, y = new Ct, b = new Ct, x = 0, w = (t - e) / i;
            for (v = 0; v <= r; v++) {
                var _ = []
                  , T = v / r
                  , M = T * (t - e) + e;
                for (s = 0; s <= n; s++) {
                    var S = s / n
                      , A = S * o + a
                      , P = Math.sin(A)
                      , C = Math.cos(A);
                    b.x = M * P,
                    b.y = -T * i + m,
                    b.z = M * C,
                    h.push(b.x, b.y, b.z),
                    y.set(P, w, C).normalize(),
                    u.push(y.x, y.y, y.z),
                    p.push(S, 1 - T),
                    _.push(d++)
                }
                f.push(_)
            }
            for (s = 0; s < n; s++)
                for (v = 0; v < r; v++) {
                    var L = f[v][s]
                      , k = f[v + 1][s]
                      , E = f[v + 1][s + 1]
                      , I = f[v][s + 1];
                    c.push(L, k, I),
                    c.push(k, E, I),
                    x += 6
                }
            l.addGroup(g, x, 0),
            g += x
        }(),
        !1 === s && (e > 0 && v(!0),
        t > 0 && v(!1)),
        this.setIndex(c),
        this.addAttribute("position", new Ni(h,3)),
        this.addAttribute("normal", new Ni(u,3)),
        this.addAttribute("uv", new Ni(p,2))
    }
    function Ua(e, t, i, n, r, s, a) {
        Na.call(this, 0, e, t, i, n, r, s, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: s,
            thetaLength: a
        }
    }
    function Ba(e, t, i, n, r, s, a) {
        Da.call(this, 0, e, t, i, n, r, s, a),
        this.type = "ConeBufferGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: s,
            thetaLength: a
        }
    }
    function ja(e, t, i, n) {
        Ci.call(this),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: n
        },
        this.fromBufferGeometry(new Va(e,t,i,n)),
        this.mergeVertices()
    }
    function Va(e, t, i, n) {
        Vi.call(this),
        this.type = "CircleBufferGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: n
        },
        e = e || 1,
        t = void 0 !== t ? Math.max(3, t) : 8,
        i = void 0 !== i ? i : 0,
        n = void 0 !== n ? n : 2 * Math.PI;
        var r, s, a = [], o = [], l = [], c = [], h = new Ct, u = new At;
        for (o.push(0, 0, 0),
        l.push(0, 0, 1),
        c.push(.5, .5),
        s = 0,
        r = 3; s <= t; s++,
        r += 3) {
            var p = i + s / t * n;
            h.x = e * Math.cos(p),
            h.y = e * Math.sin(p),
            o.push(h.x, h.y, h.z),
            l.push(0, 0, 1),
            u.x = (o[r] / e + 1) / 2,
            u.y = (o[r + 1] / e + 1) / 2,
            c.push(u.x, u.y)
        }
        for (r = 1; r <= t; r++)
            a.push(r, r + 1, 0);
        this.setIndex(a),
        this.addAttribute("position", new Ni(o,3)),
        this.addAttribute("normal", new Ni(l,3)),
        this.addAttribute("uv", new Ni(c,2))
    }
    Sa.prototype = Object.create(Ci.prototype),
    Sa.prototype.constructor = Sa,
    Aa.prototype = Object.create(_a.prototype),
    Aa.prototype.constructor = Aa,
    Pa.prototype = Object.create(Ci.prototype),
    Pa.prototype.constructor = Pa,
    Ca.prototype = Object.create(Vi.prototype),
    Ca.prototype.constructor = Ca,
    La.prototype = Object.create(Ci.prototype),
    La.prototype.constructor = La,
    ka.prototype = Object.create(Vi.prototype),
    ka.prototype.constructor = ka,
    Ea.prototype = Object.create(Ci.prototype),
    Ea.prototype.constructor = Ea,
    Ia.prototype = Object.create(Vi.prototype),
    Ia.prototype.constructor = Ia,
    Fa.prototype = Object.create(Ci.prototype),
    Fa.prototype.constructor = Fa,
    Fa.prototype.toJSON = function() {
        var e = Ci.prototype.toJSON.call(this);
        return Ra(this.parameters.shapes, e)
    }
    ,
    Oa.prototype = Object.create(Vi.prototype),
    Oa.prototype.constructor = Oa,
    Oa.prototype.toJSON = function() {
        var e = Vi.prototype.toJSON.call(this);
        return Ra(this.parameters.shapes, e)
    }
    ,
    za.prototype = Object.create(Vi.prototype),
    za.prototype.constructor = za,
    Na.prototype = Object.create(Ci.prototype),
    Na.prototype.constructor = Na,
    Da.prototype = Object.create(Vi.prototype),
    Da.prototype.constructor = Da,
    Ua.prototype = Object.create(Na.prototype),
    Ua.prototype.constructor = Ua,
    Ba.prototype = Object.create(Da.prototype),
    Ba.prototype.constructor = Ba,
    ja.prototype = Object.create(Ci.prototype),
    ja.prototype.constructor = ja,
    Va.prototype = Object.create(Vi.prototype),
    Va.prototype.constructor = Va;
    var Ga = Object.freeze({
        WireframeGeometry: Es,
        ParametricGeometry: Is,
        ParametricBufferGeometry: Fs,
        TetrahedronGeometry: zs,
        TetrahedronBufferGeometry: Ns,
        OctahedronGeometry: Ds,
        OctahedronBufferGeometry: Us,
        IcosahedronGeometry: Bs,
        IcosahedronBufferGeometry: js,
        DodecahedronGeometry: Vs,
        DodecahedronBufferGeometry: Gs,
        PolyhedronGeometry: Os,
        PolyhedronBufferGeometry: Rs,
        TubeGeometry: Xs,
        TubeBufferGeometry: Ys,
        TorusKnotGeometry: Ws,
        TorusKnotBufferGeometry: qs,
        TorusGeometry: Hs,
        TorusBufferGeometry: Qs,
        TextGeometry: Sa,
        TextBufferGeometry: Aa,
        SphereGeometry: Pa,
        SphereBufferGeometry: Ca,
        RingGeometry: La,
        RingBufferGeometry: ka,
        PlaneGeometry: Yi,
        PlaneBufferGeometry: Wi,
        LatheGeometry: Ea,
        LatheBufferGeometry: Ia,
        ShapeGeometry: Fa,
        ShapeBufferGeometry: Oa,
        ExtrudeGeometry: wa,
        ExtrudeBufferGeometry: _a,
        EdgesGeometry: za,
        ConeGeometry: Ua,
        ConeBufferGeometry: Ba,
        CylinderGeometry: Na,
        CylinderBufferGeometry: Da,
        CircleGeometry: ja,
        CircleBufferGeometry: Va,
        BoxGeometry: Gi,
        BoxBufferGeometry: Xi
    });
    function Xa(e) {
        Hi.call(this),
        this.type = "ShadowMaterial",
        this.color = new hi(0),
        this.transparent = !0,
        this.setValues(e)
    }
    function Ya(e) {
        hn.call(this, e),
        this.type = "RawShaderMaterial"
    }
    function Wa(e) {
        Hi.call(this),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new hi(16777215),
        this.roughness = .5,
        this.metalness = .5,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new hi(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Tt,
        this.normalScale = new At(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function qa(e) {
        Wa.call(this),
        this.defines = {
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.reflectivity = .5,
        this.clearCoat = 0,
        this.clearCoatRoughness = 0,
        this.setValues(e)
    }
    function Ha(e) {
        Hi.call(this),
        this.type = "MeshPhongMaterial",
        this.color = new hi(16777215),
        this.specular = new hi(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new hi(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Tt,
        this.normalScale = new At(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Q,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function Qa(e) {
        Ha.call(this),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.gradientMap = null,
        this.setValues(e)
    }
    function Ja(e) {
        Hi.call(this),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Tt,
        this.normalScale = new At(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function Za(e) {
        Hi.call(this),
        this.type = "MeshLambertMaterial",
        this.color = new hi(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new hi(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = Q,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(e)
    }
    function $a(e) {
        Hi.call(this),
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new hi(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Tt,
        this.normalScale = new At(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.lights = !1,
        this.setValues(e)
    }
    function Ka(e) {
        ws.call(this),
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    Xa.prototype = Object.create(Hi.prototype),
    Xa.prototype.constructor = Xa,
    Xa.prototype.isShadowMaterial = !0,
    Xa.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this
    }
    ,
    Ya.prototype = Object.create(hn.prototype),
    Ya.prototype.constructor = Ya,
    Ya.prototype.isRawShaderMaterial = !0,
    Wa.prototype = Object.create(Hi.prototype),
    Wa.prototype.constructor = Wa,
    Wa.prototype.isMeshStandardMaterial = !0,
    Wa.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    qa.prototype = Object.create(Wa.prototype),
    qa.prototype.constructor = qa,
    qa.prototype.isMeshPhysicalMaterial = !0,
    qa.prototype.copy = function(e) {
        return Wa.prototype.copy.call(this, e),
        this.defines = {
            PHYSICAL: ""
        },
        this.reflectivity = e.reflectivity,
        this.clearCoat = e.clearCoat,
        this.clearCoatRoughness = e.clearCoatRoughness,
        this
    }
    ,
    Ha.prototype = Object.create(Hi.prototype),
    Ha.prototype.constructor = Ha,
    Ha.prototype.isMeshPhongMaterial = !0,
    Ha.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Qa.prototype = Object.create(Ha.prototype),
    Qa.prototype.constructor = Qa,
    Qa.prototype.isMeshToonMaterial = !0,
    Qa.prototype.copy = function(e) {
        return Ha.prototype.copy.call(this, e),
        this.gradientMap = e.gradientMap,
        this
    }
    ,
    Ja.prototype = Object.create(Hi.prototype),
    Ja.prototype.constructor = Ja,
    Ja.prototype.isMeshNormalMaterial = !0,
    Ja.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Za.prototype = Object.create(Hi.prototype),
    Za.prototype.constructor = Za,
    Za.prototype.isMeshLambertMaterial = !0,
    Za.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    $a.prototype = Object.create(Hi.prototype),
    $a.prototype.constructor = $a,
    $a.prototype.isMeshMatcapMaterial = !0,
    $a.prototype.copy = function(e) {
        return Hi.prototype.copy.call(this, e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    Ka.prototype = Object.create(ws.prototype),
    Ka.prototype.constructor = Ka,
    Ka.prototype.isLineDashedMaterial = !0,
    Ka.prototype.copy = function(e) {
        return ws.prototype.copy.call(this, e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
    ;
    var eo = Object.freeze({
        ShadowMaterial: Xa,
        SpriteMaterial: ms,
        RawShaderMaterial: Ya,
        ShaderMaterial: hn,
        PointsMaterial: Ss,
        MeshPhysicalMaterial: qa,
        MeshStandardMaterial: Wa,
        MeshPhongMaterial: Ha,
        MeshToonMaterial: Qa,
        MeshNormalMaterial: Ja,
        MeshLambertMaterial: Za,
        MeshDepthMaterial: Vr,
        MeshDistanceMaterial: Gr,
        MeshBasicMaterial: dn,
        MeshMatcapMaterial: $a,
        LineDashedMaterial: Ka,
        LineBasicMaterial: ws,
        Material: Hi
    })
      , to = {
        arraySlice: function(e, t, i) {
            return to.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i)
        },
        convertArray: function(e, t, i) {
            return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        },
        isTypedArray: function(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        },
        getKeyframeOrder: function(e) {
            for (var t = e.length, i = new Array(t), n = 0; n !== t; ++n)
                i[n] = n;
            return i.sort(function(t, i) {
                return e[t] - e[i]
            }),
            i
        },
        sortedArray: function(e, t, i) {
            for (var n = e.length, r = new e.constructor(n), s = 0, a = 0; a !== n; ++s)
                for (var o = i[s] * t, l = 0; l !== t; ++l)
                    r[a++] = e[o + l];
            return r
        },
        flattenJSON: function(e, t, i, n) {
            for (var r = 1, s = e[0]; void 0 !== s && void 0 === s[n]; )
                s = e[r++];
            if (void 0 !== s) {
                var a = s[n];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            void 0 !== (a = s[n]) && (t.push(s.time),
                            i.push.apply(i, a)),
                            s = e[r++]
                        } while (void 0 !== s);
                    else if (void 0 !== a.toArray)
                        do {
                            void 0 !== (a = s[n]) && (t.push(s.time),
                            a.toArray(i, i.length)),
                            s = e[r++]
                        } while (void 0 !== s);
                    else
                        do {
                            void 0 !== (a = s[n]) && (t.push(s.time),
                            i.push(a)),
                            s = e[r++]
                        } while (void 0 !== s)
            }
        }
    };
    function io(e, t, i, n) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== n ? n : new t.constructor(i),
        this.sampleValues = t,
        this.valueSize = i
    }
    function no(e, t, i, n) {
        io.call(this, e, t, i, n),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0
    }
    function ro(e, t, i, n) {
        io.call(this, e, t, i, n)
    }
    function so(e, t, i, n) {
        io.call(this, e, t, i, n)
    }
    function ao(e, t, i, n) {
        if (void 0 === e)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = to.convertArray(t, this.TimeBufferType),
        this.values = to.convertArray(i, this.ValueBufferType),
        this.setInterpolation(n || this.DefaultInterpolation)
    }
    function oo(e, t, i) {
        ao.call(this, e, t, i)
    }
    function lo(e, t, i, n) {
        ao.call(this, e, t, i, n)
    }
    function co(e, t, i, n) {
        ao.call(this, e, t, i, n)
    }
    function ho(e, t, i, n) {
        io.call(this, e, t, i, n)
    }
    function uo(e, t, i, n) {
        ao.call(this, e, t, i, n)
    }
    function po(e, t, i, n) {
        ao.call(this, e, t, i, n)
    }
    function fo(e, t, i, n) {
        ao.call(this, e, t, i, n)
    }
    function mo(e, t, i) {
        this.name = e,
        this.tracks = i,
        this.duration = void 0 !== t ? t : -1,
        this.uuid = St.generateUUID(),
        this.duration < 0 && this.resetDuration()
    }
    function go(e) {
        if (void 0 === e.type)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var t = function(e) {
            switch (e.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return co;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return fo;
            case "color":
                return lo;
            case "quaternion":
                return uo;
            case "bool":
            case "boolean":
                return oo;
            case "string":
                return po
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            var i = []
              , n = [];
            to.flattenJSON(e.keys, i, n, "value"),
            e.times = i,
            e.values = n
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
    }
    Object.assign(io.prototype, {
        evaluate: function(e) {
            var t = this.parameterPositions
              , i = this._cachedIndex
              , n = t[i]
              , r = t[i - 1];
            e: {
                t: {
                    var s;
                    i: {
                        n: if (!(e < n)) {
                            for (var a = i + 2; ; ) {
                                if (void 0 === n) {
                                    if (e < r)
                                        break n;
                                    return i = t.length,
                                    this._cachedIndex = i,
                                    this.afterEnd_(i - 1, e, r)
                                }
                                if (i === a)
                                    break;
                                if (r = n,
                                e < (n = t[++i]))
                                    break t
                            }
                            s = t.length;
                            break i
                        }
                        if (e >= r)
                            break e;
                        var o = t[1];
                        e < o && (i = 2,
                        r = o);
                        for (a = i - 2; ; ) {
                            if (void 0 === r)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, e, n);
                            if (i === a)
                                break;
                            if (n = r,
                            e >= (r = t[--i - 1]))
                                break t
                        }
                        s = i,
                        i = 0
                    }
                    for (; i < s; ) {
                        var l = i + s >>> 1;
                        e < t[l] ? s = l : i = l + 1
                    }
                    if (n = t[i],
                    void 0 === (r = t[i - 1]))
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, e, n);
                    if (void 0 === n)
                        return i = t.length,
                        this._cachedIndex = i,
                        this.afterEnd_(i - 1, r, e)
                }
                this._cachedIndex = i,
                this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, e, n)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(e) {
            for (var t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n, s = 0; s !== n; ++s)
                t[s] = i[r + s];
            return t
        },
        interpolate_: function() {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }),
    Object.assign(io.prototype, {
        beforeStart_: io.prototype.copySampleValue_,
        afterEnd_: io.prototype.copySampleValue_
    }),
    no.prototype = Object.assign(Object.create(io.prototype), {
        constructor: no,
        DefaultSettings_: {
            endingStart: ht,
            endingEnd: ht
        },
        intervalChanged_: function(e, t, i) {
            var n = this.parameterPositions
              , r = e - 2
              , s = e + 1
              , a = n[r]
              , o = n[s];
            if (void 0 === a)
                switch (this.getSettings_().endingStart) {
                case 2401:
                    r = e,
                    a = 2 * t - i;
                    break;
                case 2402:
                    a = t + n[r = n.length - 2] - n[r + 1];
                    break;
                default:
                    r = e,
                    a = i
                }
            if (void 0 === o)
                switch (this.getSettings_().endingEnd) {
                case 2401:
                    s = e,
                    o = 2 * i - t;
                    break;
                case 2402:
                    s = 1,
                    o = i + n[1] - n[0];
                    break;
                default:
                    s = e - 1,
                    o = t
                }
            var l = .5 * (i - t)
              , c = this.valueSize;
            this._weightPrev = l / (t - a),
            this._weightNext = l / (o - i),
            this._offsetPrev = r * c,
            this._offsetNext = s * c
        },
        interpolate_: function(e, t, i, n) {
            for (var r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (i - t) / (n - t), f = d * d, m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, b = p * m - p * f, x = 0; x !== a; ++x)
                r[x] = g * s[c + x] + v * s[l + x] + y * s[o + x] + b * s[h + x];
            return r
        }
    }),
    ro.prototype = Object.assign(Object.create(io.prototype), {
        constructor: ro,
        interpolate_: function(e, t, i, n) {
            for (var r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a, c = (i - t) / (n - t), h = 1 - c, u = 0; u !== a; ++u)
                r[u] = s[l + u] * h + s[o + u] * c;
            return r
        }
    }),
    so.prototype = Object.assign(Object.create(io.prototype), {
        constructor: so,
        interpolate_: function(e) {
            return this.copySampleValue_(e - 1)
        }
    }),
    Object.assign(ao, {
        toJSON: function(e) {
            var t, i = e.constructor;
            if (void 0 !== i.toJSON)
                t = i.toJSON(e);
            else {
                t = {
                    name: e.name,
                    times: to.convertArray(e.times, Array),
                    values: to.convertArray(e.values, Array)
                };
                var n = e.getInterpolation();
                n !== e.DefaultInterpolation && (t.interpolation = n)
            }
            return t.type = e.ValueTypeName,
            t
        }
    }),
    Object.assign(ao.prototype, {
        constructor: ao,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(e) {
            return new so(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodLinear: function(e) {
            return new ro(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodSmooth: function(e) {
            return new no(this.times,this.values,this.getValueSize(),e)
        },
        setInterpolation: function(e) {
            var t;
            switch (e) {
            case 2300:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case 2301:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case 2302:
                t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation)
                        throw new Error(i);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return this
            }
            return this.createInterpolant = t,
            this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return 2300;
            case this.InterpolantFactoryMethodLinear:
                return 2301;
            case this.InterpolantFactoryMethodSmooth:
                return 2302
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(e) {
            if (0 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i)
                    t[i] += e;
            return this
        },
        scale: function(e) {
            if (1 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i)
                    t[i] *= e;
            return this
        },
        trim: function(e, t) {
            for (var i = this.times, n = i.length, r = 0, s = n - 1; r !== n && i[r] < e; )
                ++r;
            for (; -1 !== s && i[s] > t; )
                --s;
            if (++s,
            0 !== r || s !== n) {
                r >= s && (r = (s = Math.max(s, 1)) - 1);
                var a = this.getValueSize();
                this.times = to.arraySlice(i, r, s),
                this.values = to.arraySlice(this.values, r * a, s * a)
            }
            return this
        },
        validate: function() {
            var e = !0
              , t = this.getValueSize();
            t - Math.floor(t) != 0 && (e = !1);
            var i = this.times
              , n = this.values
              , r = i.length;
            0 === r && (e = !1);
            for (var s = null, a = 0; a !== r; a++) {
                var o = i[a];
                if ("number" == typeof o && isNaN(o)) {
                    e = !1;
                    break
                }
                if (null !== s && s > o) {
                    e = !1;
                    break
                }
                s = o
            }
            if (void 0 !== n && to.isTypedArray(n)) {
                a = 0;
                for (var l = n.length; a !== l; ++a) {
                    var c = n[a];
                    if (isNaN(c)) {
                        e = !1;
                        break
                    }
                }
            }
            return e
        },
        optimize: function() {
            for (var e = this.times, t = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, s = e.length - 1, a = 1; a < s; ++a) {
                var o = !1
                  , l = e[a];
                if (l !== e[a + 1] && (1 !== a || l !== l[0]))
                    if (n)
                        o = !0;
                    else
                        for (var c = a * i, h = c - i, u = c + i, p = 0; p !== i; ++p) {
                            var d = t[c + p];
                            if (d !== t[h + p] || d !== t[u + p]) {
                                o = !0;
                                break
                            }
                        }
                if (o) {
                    if (a !== r) {
                        e[r] = e[a];
                        var f = a * i
                          , m = r * i;
                        for (p = 0; p !== i; ++p)
                            t[m + p] = t[f + p]
                    }
                    ++r
                }
            }
            if (s > 0) {
                e[r] = e[s];
                for (f = s * i,
                m = r * i,
                p = 0; p !== i; ++p)
                    t[m + p] = t[f + p];
                ++r
            }
            return r !== e.length && (this.times = to.arraySlice(e, 0, r),
            this.values = to.arraySlice(t, 0, r * i)),
            this
        },
        clone: function() {
            var e = to.arraySlice(this.times, 0)
              , t = to.arraySlice(this.values, 0)
              , i = new (0,
            this.constructor)(this.name,e,t);
            return i.createInterpolant = this.createInterpolant,
            i
        }
    }),
    oo.prototype = Object.assign(Object.create(ao.prototype), {
        constructor: oo,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    lo.prototype = Object.assign(Object.create(ao.prototype), {
        constructor: lo,
        ValueTypeName: "color"
    }),
    co.prototype = Object.assign(Object.create(ao.prototype), {
        constructor: co,
        ValueTypeName: "number"
    }),
    ho.prototype = Object.assign(Object.create(io.prototype), {
        constructor: ho,
        interpolate_: function(e, t, i, n) {
            for (var r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = (i - t) / (n - t), c = o + a; o !== c; o += 4)
                Pt.slerpFlat(r, 0, s, o - a, s, o, l);
            return r
        }
    }),
    uo.prototype = Object.assign(Object.create(ao.prototype), {
        constructor: uo,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(e) {
            return new ho(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    po.prototype = Object.assign(Object.create(ao.prototype), {
        constructor: po,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    fo.prototype = Object.assign(Object.create(ao.prototype), {
        constructor: fo,
        ValueTypeName: "vector"
    }),
    Object.assign(mo, {
        parse: function(e) {
            for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), r = 0, s = i.length; r !== s; ++r)
                t.push(go(i[r]).scale(n));
            return new mo(e.name,e.duration,t)
        },
        toJSON: function(e) {
            for (var t = [], i = e.tracks, n = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid
            }, r = 0, s = i.length; r !== s; ++r)
                t.push(ao.toJSON(i[r]));
            return n
        },
        CreateFromMorphTargetSequence: function(e, t, i, n) {
            for (var r = t.length, s = [], a = 0; a < r; a++) {
                var o = []
                  , l = [];
                o.push((a + r - 1) % r, a, (a + 1) % r),
                l.push(0, 1, 0);
                var c = to.getKeyframeOrder(o);
                o = to.sortedArray(o, 1, c),
                l = to.sortedArray(l, 1, c),
                n || 0 !== o[0] || (o.push(r),
                l.push(l[0])),
                s.push(new co(".morphTargetInfluences[" + t[a].name + "]",o,l).scale(1 / i))
            }
            return new mo(e,-1,s)
        },
        findByName: function(e, t) {
            var i = e;
            if (!Array.isArray(e)) {
                var n = e;
                i = n.geometry && n.geometry.animations || n.animations
            }
            for (var r = 0; r < i.length; r++)
                if (i[r].name === t)
                    return i[r];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(e, t, i) {
            for (var n = {}, r = /^([\w-]*?)([\d]+)$/, s = 0, a = e.length; s < a; s++) {
                var o = e[s]
                  , l = o.name.match(r);
                if (l && l.length > 1) {
                    var c = n[u = l[1]];
                    c || (n[u] = c = []),
                    c.push(o)
                }
            }
            var h = [];
            for (var u in n)
                h.push(mo.CreateFromMorphTargetSequence(u, n[u], t, i));
            return h
        },
        parseAnimation: function(e, t) {
            if (!e)
                return null;
            for (var i = function(e, t, i, n, r) {
                if (0 !== i.length) {
                    var s = []
                      , a = [];
                    to.flattenJSON(i, s, a, n),
                    0 !== s.length && r.push(new e(t,s,a))
                }
            }, n = [], r = e.name || "default", s = e.length || -1, a = e.fps || 30, o = e.hierarchy || [], l = 0; l < o.length; l++) {
                var c = o[l].keys;
                if (c && 0 !== c.length)
                    if (c[0].morphTargets) {
                        for (var h = {}, u = 0; u < c.length; u++)
                            if (c[u].morphTargets)
                                for (var p = 0; p < c[u].morphTargets.length; p++)
                                    h[c[u].morphTargets[p]] = -1;
                        for (var d in h) {
                            var f = []
                              , m = [];
                            for (p = 0; p !== c[u].morphTargets.length; ++p) {
                                var g = c[u];
                                f.push(g.time),
                                m.push(g.morphTarget === d ? 1 : 0)
                            }
                            n.push(new co(".morphTargetInfluence[" + d + "]",f,m))
                        }
                        s = h.length * (a || 1)
                    } else {
                        var v = ".bones[" + t[l].name + "]";
                        i(fo, v + ".position", c, "pos", n),
                        i(uo, v + ".quaternion", c, "rot", n),
                        i(fo, v + ".scale", c, "scl", n)
                    }
            }
            return 0 === n.length ? null : new mo(r,s,n)
        }
    }),
    Object.assign(mo.prototype, {
        resetDuration: function() {
            for (var e = 0, t = 0, i = this.tracks.length; t !== i; ++t) {
                var n = this.tracks[t];
                e = Math.max(e, n.times[n.times.length - 1])
            }
            return this.duration = e,
            this
        },
        trim: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var e = !0, t = 0; t < this.tracks.length; t++)
                e = e && this.tracks[t].validate();
            return e
        },
        optimize: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].optimize();
            return this
        },
        clone: function() {
            for (var e = [], t = 0; t < this.tracks.length; t++)
                e.push(this.tracks[t].clone());
            return new mo(this.name,this.duration,e)
        }
    });
    var vo = {
        enabled: !1,
        files: {},
        add: function(e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        },
        get: function(e) {
            if (!1 !== this.enabled)
                return this.files[e]
        },
        remove: function(e) {
            delete this.files[e]
        },
        clear: function() {
            this.files = {}
        }
    };
    function yo(e, t, i) {
        var n = this
          , r = !1
          , s = 0
          , a = 0
          , o = void 0;
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(e) {
            a++,
            !1 === r && void 0 !== n.onStart && n.onStart(e, s, a),
            r = !0
        }
        ,
        this.itemEnd = function(e) {
            s++,
            void 0 !== n.onProgress && n.onProgress(e, s, a),
            s === a && (r = !1,
            void 0 !== n.onLoad && n.onLoad())
        }
        ,
        this.itemError = function(e) {
            void 0 !== n.onError && n.onError(e)
        }
        ,
        this.resolveURL = function(e) {
            return o ? o(e) : e
        }
        ,
        this.setURLModifier = function(e) {
            return o = e,
            this
        }
    }
    var bo = new yo
      , xo = {};
    function wo(e) {
        this.manager = void 0 !== e ? e : bo
    }
    function _o(e) {
        this.manager = void 0 !== e ? e : bo,
        this._parser = null
    }
    function To(e) {
        this.manager = void 0 !== e ? e : bo
    }
    function Mo(e) {
        this.manager = void 0 !== e ? e : bo
    }
    function So(e) {
        this.manager = void 0 !== e ? e : bo
    }
    function Ao() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    function Po(e, t, i, n, r, s, a, o) {
        Ao.call(this),
        this.type = "EllipseCurve",
        this.aX = e || 0,
        this.aY = t || 0,
        this.xRadius = i || 1,
        this.yRadius = n || 1,
        this.aStartAngle = r || 0,
        this.aEndAngle = s || 2 * Math.PI,
        this.aClockwise = a || !1,
        this.aRotation = o || 0
    }
    function Co(e, t, i, n, r, s) {
        Po.call(this, e, t, i, i, n, r, s),
        this.type = "ArcCurve"
    }
    function Lo() {
        var e = 0
          , t = 0
          , i = 0
          , n = 0;
        function r(r, s, a, o) {
            e = r,
            t = a,
            i = -3 * r + 3 * s - 2 * a - o,
            n = 2 * r - 2 * s + a + o
        }
        return {
            initCatmullRom: function(e, t, i, n, s) {
                r(t, i, s * (i - e), s * (n - t))
            },
            initNonuniformCatmullRom: function(e, t, i, n, s, a, o) {
                var l = (t - e) / s - (i - e) / (s + a) + (i - t) / a
                  , c = (i - t) / a - (n - t) / (a + o) + (n - i) / o;
                r(t, i, l *= a, c *= a)
            },
            calc: function(r) {
                var s = r * r;
                return e + t * r + i * s + n * (s * r)
            }
        }
    }
    Object.assign(wo.prototype, {
        load: function(e, t, i, n) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var r = this
              , s = vo.get(e);
            if (void 0 !== s)
                return r.manager.itemStart(e),
                setTimeout(function() {
                    t && t(s),
                    r.manager.itemEnd(e)
                }, 0),
                s;
            if (void 0 === xo[e]) {
                var a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    var o = a[1]
                      , l = !!a[2]
                      , c = a[3];
                    c = decodeURIComponent(c),
                    l && (c = atob(c));
                    try {
                        var h, u = (this.responseType || "").toLowerCase();
                        switch (u) {
                        case "arraybuffer":
                        case "blob":
                            for (var p = new Uint8Array(c.length), d = 0; d < c.length; d++)
                                p[d] = c.charCodeAt(d);
                            h = "blob" === u ? new Blob([p.buffer],{
                                type: o
                            }) : p.buffer;
                            break;
                        case "document":
                            var f = new DOMParser;
                            h = f.parseFromString(c, o);
                            break;
                        case "json":
                            h = JSON.parse(c);
                            break;
                        default:
                            h = c
                        }
                        setTimeout(function() {
                            t && t(h),
                            r.manager.itemEnd(e)
                        }, 0)
                    } catch (t) {
                        setTimeout(function() {
                            n && n(t),
                            r.manager.itemError(e),
                            r.manager.itemEnd(e)
                        }, 0)
                    }
                } else {
                    xo[e] = [],
                    xo[e].push({
                        onLoad: t,
                        onProgress: i,
                        onError: n
                    });
                    var m = new XMLHttpRequest;
                    for (var g in m.open("GET", e, !0),
                    m.addEventListener("load", function(t) {
                        var i = this.response;
                        vo.add(e, i);
                        var n = xo[e];
                        if (delete xo[e],
                        200 === this.status || 0 === this.status) {
                            this.status;
                            for (var s = 0, a = n.length; s < a; s++) {
                                (o = n[s]).onLoad && o.onLoad(i)
                            }
                            r.manager.itemEnd(e)
                        } else {
                            for (s = 0,
                            a = n.length; s < a; s++) {
                                var o;
                                (o = n[s]).onError && o.onError(t)
                            }
                            r.manager.itemError(e),
                            r.manager.itemEnd(e)
                        }
                    }, !1),
                    m.addEventListener("progress", function(t) {
                        for (var i = xo[e], n = 0, r = i.length; n < r; n++) {
                            var s = i[n];
                            s.onProgress && s.onProgress(t)
                        }
                    }, !1),
                    m.addEventListener("error", function(t) {
                        var i = xo[e];
                        delete xo[e];
                        for (var n = 0, s = i.length; n < s; n++) {
                            var a = i[n];
                            a.onError && a.onError(t)
                        }
                        r.manager.itemError(e),
                        r.manager.itemEnd(e)
                    }, !1),
                    m.addEventListener("abort", function(t) {
                        var i = xo[e];
                        delete xo[e];
                        for (var n = 0, s = i.length; n < s; n++) {
                            var a = i[n];
                            a.onError && a.onError(t)
                        }
                        r.manager.itemError(e),
                        r.manager.itemEnd(e)
                    }, !1),
                    void 0 !== this.responseType && (m.responseType = this.responseType),
                    void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials),
                    m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"),
                    this.requestHeader)
                        m.setRequestHeader(g, this.requestHeader[g]);
                    m.send(null)
                }
                return r.manager.itemStart(e),
                m
            }
            xo[e].push({
                onLoad: t,
                onProgress: i,
                onError: n
            })
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setResponseType: function(e) {
            return this.responseType = e,
            this
        },
        setWithCredentials: function(e) {
            return this.withCredentials = e,
            this
        },
        setMimeType: function(e) {
            return this.mimeType = e,
            this
        },
        setRequestHeader: function(e) {
            return this.requestHeader = e,
            this
        }
    }),
    Object.assign(function(e) {
        this.manager = void 0 !== e ? e : bo
    }
    .prototype, {
        load: function(e, t, i, n) {
            var r = this
              , s = new wo(r.manager);
            s.setPath(r.path),
            s.load(e, function(e) {
                t(r.parse(JSON.parse(e)))
            }, i, n)
        },
        parse: function(e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = mo.parse(e[i]);
                t.push(n)
            }
            return t
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(function(e) {
        this.manager = void 0 !== e ? e : bo,
        this._parser = null
    }
    .prototype, {
        load: function(e, t, i, n) {
            var r = this
              , s = []
              , a = new Cs;
            a.image = s;
            var o = new wo(this.manager);
            function l(l) {
                o.load(e[l], function(e) {
                    var i = r._parser(e, !0);
                    s[l] = {
                        width: i.width,
                        height: i.height,
                        format: i.format,
                        mipmaps: i.mipmaps
                    },
                    6 === (c += 1) && (1 === i.mipmapCount && (a.minFilter = ve),
                    a.format = i.format,
                    a.needsUpdate = !0,
                    t && t(a))
                }, i, n)
            }
            if (o.setPath(this.path),
            o.setResponseType("arraybuffer"),
            Array.isArray(e))
                for (var c = 0, h = 0, u = e.length; h < u; ++h)
                    l(h);
            else
                o.load(e, function(e) {
                    var i = r._parser(e, !0);
                    if (i.isCubemap)
                        for (var n = i.mipmaps.length / i.mipmapCount, o = 0; o < n; o++) {
                            s[o] = {
                                mipmaps: []
                            };
                            for (var l = 0; l < i.mipmapCount; l++)
                                s[o].mipmaps.push(i.mipmaps[o * i.mipmapCount + l]),
                                s[o].format = i.format,
                                s[o].width = i.width,
                                s[o].height = i.height
                        }
                    else
                        a.image.width = i.width,
                        a.image.height = i.height,
                        a.mipmaps = i.mipmaps;
                    1 === i.mipmapCount && (a.minFilter = ve),
                    a.format = i.format,
                    a.needsUpdate = !0,
                    t && t(a)
                }, i, n);
            return a
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(_o.prototype, {
        load: function(e, t, i, n) {
            var r = this
              , s = new Zt
              , a = new wo(this.manager);
            return a.setResponseType("arraybuffer"),
            a.setPath(this.path),
            a.load(e, function(e) {
                var i = r._parser(e);
                i && (void 0 !== i.image ? s.image = i.image : void 0 !== i.data && (s.image.width = i.width,
                s.image.height = i.height,
                s.image.data = i.data),
                s.wrapS = void 0 !== i.wrapS ? i.wrapS : pe,
                s.wrapT = void 0 !== i.wrapT ? i.wrapT : pe,
                s.magFilter = void 0 !== i.magFilter ? i.magFilter : ve,
                s.minFilter = void 0 !== i.minFilter ? i.minFilter : be,
                s.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1,
                void 0 !== i.format && (s.format = i.format),
                void 0 !== i.type && (s.type = i.type),
                void 0 !== i.mipmaps && (s.mipmaps = i.mipmaps),
                1 === i.mipmapCount && (s.minFilter = ve),
                s.needsUpdate = !0,
                t && t(s, i))
            }, i, n),
            s
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(To.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var r = this
              , s = vo.get(e);
            if (void 0 !== s)
                return r.manager.itemStart(e),
                setTimeout(function() {
                    t && t(s),
                    r.manager.itemEnd(e)
                }, 0),
                s;
            var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            function o() {
                a.removeEventListener("load", o, !1),
                a.removeEventListener("error", l, !1),
                vo.add(e, this),
                t && t(this),
                r.manager.itemEnd(e)
            }
            function l(t) {
                a.removeEventListener("load", o, !1),
                a.removeEventListener("error", l, !1),
                n && n(t),
                r.manager.itemError(e),
                r.manager.itemEnd(e)
            }
            return a.addEventListener("load", o, !1),
            a.addEventListener("error", l, !1),
            "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(e),
            a.src = e,
            a
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Mo.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            var r = new An
              , s = new To(this.manager);
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path);
            var a = 0;
            function o(i) {
                s.load(e[i], function(e) {
                    r.images[i] = e,
                    6 === ++a && (r.needsUpdate = !0,
                    t && t(r))
                }, void 0, n)
            }
            for (var l = 0; l < e.length; ++l)
                o(l);
            return r
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(So.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            var r = new Wt
              , s = new To(this.manager);
            return s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path),
            s.load(e, function(i) {
                r.image = i;
                var n = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                r.format = n ? Fe : Oe,
                r.needsUpdate = !0,
                void 0 !== t && t(r)
            }, i, n),
            r
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Ao.prototype, {
        getPoint: function() {
            return null
        },
        getPointAt: function(e, t) {
            var i = this.getUtoTmapping(e);
            return this.getPoint(i, t)
        },
        getPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++)
                t.push(this.getPoint(i / e));
            return t
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++)
                t.push(this.getPointAt(i / e));
            return t
        },
        getLength: function() {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function(e) {
            if (void 0 === e && (e = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, i, n = [], r = this.getPoint(0), s = 0;
            for (n.push(0),
            i = 1; i <= e; i++)
                s += (t = this.getPoint(i / e)).distanceTo(r),
                n.push(s),
                r = t;
            return this.cacheArcLengths = n,
            n
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(e, t) {
            var i, n = this.getLengths(), r = 0, s = n.length;
            i = t || e * n[s - 1];
            for (var a, o = 0, l = s - 1; o <= l; )
                if ((a = n[r = Math.floor(o + (l - o) / 2)] - i) < 0)
                    o = r + 1;
                else {
                    if (!(a > 0)) {
                        l = r;
                        break
                    }
                    l = r - 1
                }
            if (n[r = l] === i)
                return r / (s - 1);
            var c = n[r];
            return (r + (i - c) / (n[r + 1] - c)) / (s - 1)
        },
        getTangent: function(e) {
            var t = e - 1e-4
              , i = e + 1e-4;
            t < 0 && (t = 0),
            i > 1 && (i = 1);
            var n = this.getPoint(t);
            return this.getPoint(i).clone().sub(n).normalize()
        },
        getTangentAt: function(e) {
            var t = this.getUtoTmapping(e);
            return this.getTangent(t)
        },
        computeFrenetFrames: function(e, t) {
            var i, n, r, s = new Ct, a = [], o = [], l = [], c = new Ct, h = new ii;
            for (i = 0; i <= e; i++)
                n = i / e,
                a[i] = this.getTangentAt(n),
                a[i].normalize();
            o[0] = new Ct,
            l[0] = new Ct;
            var u = Number.MAX_VALUE
              , p = Math.abs(a[0].x)
              , d = Math.abs(a[0].y)
              , f = Math.abs(a[0].z);
            for (p <= u && (u = p,
            s.set(1, 0, 0)),
            d <= u && (u = d,
            s.set(0, 1, 0)),
            f <= u && s.set(0, 0, 1),
            c.crossVectors(a[0], s).normalize(),
            o[0].crossVectors(a[0], c),
            l[0].crossVectors(a[0], o[0]),
            i = 1; i <= e; i++)
                o[i] = o[i - 1].clone(),
                l[i] = l[i - 1].clone(),
                c.crossVectors(a[i - 1], a[i]),
                c.length() > Number.EPSILON && (c.normalize(),
                r = Math.acos(St.clamp(a[i - 1].dot(a[i]), -1, 1)),
                o[i].applyMatrix4(h.makeRotationAxis(c, r))),
                l[i].crossVectors(a[i], o[i]);
            if (!0 === t)
                for (r = Math.acos(St.clamp(o[0].dot(o[e]), -1, 1)),
                r /= e,
                a[0].dot(c.crossVectors(o[0], o[e])) > 0 && (r = -r),
                i = 1; i <= e; i++)
                    o[i].applyMatrix4(h.makeRotationAxis(a[i], r * i)),
                    l[i].crossVectors(a[i], o[i]);
            return {
                tangents: a,
                normals: o,
                binormals: l
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions,
            e.type = this.type,
            e
        },
        fromJSON: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        }
    }),
    Po.prototype = Object.create(Ao.prototype),
    Po.prototype.constructor = Po,
    Po.prototype.isEllipseCurve = !0,
    Po.prototype.getPoint = function(e, t) {
        for (var i = t || new At, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, s = Math.abs(r) < Number.EPSILON; r < 0; )
            r += n;
        for (; r > n; )
            r -= n;
        r < Number.EPSILON && (r = s ? 0 : n),
        !0 !== this.aClockwise || s || (r === n ? r = -n : r -= n);
        var a = this.aStartAngle + e * r
          , o = this.aX + this.xRadius * Math.cos(a)
          , l = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
            var c = Math.cos(this.aRotation)
              , h = Math.sin(this.aRotation)
              , u = o - this.aX
              , p = l - this.aY;
            o = u * c - p * h + this.aX,
            l = u * h + p * c + this.aY
        }
        return i.set(o, l)
    }
    ,
    Po.prototype.copy = function(e) {
        return Ao.prototype.copy.call(this, e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    ,
    Po.prototype.toJSON = function() {
        var e = Ao.prototype.toJSON.call(this);
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    ,
    Po.prototype.fromJSON = function(e) {
        return Ao.prototype.fromJSON.call(this, e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    ,
    Co.prototype = Object.create(Po.prototype),
    Co.prototype.constructor = Co,
    Co.prototype.isArcCurve = !0;
    var ko = new Ct
      , Eo = new Lo
      , Io = new Lo
      , Fo = new Lo;
    function Oo(e, t, i, n) {
        Ao.call(this),
        this.type = "CatmullRomCurve3",
        this.points = e || [],
        this.closed = t || !1,
        this.curveType = i || "centripetal",
        this.tension = n || .5
    }
    function Ro(e, t, i, n, r) {
        var s = .5 * (n - t)
          , a = .5 * (r - i)
          , o = e * e;
        return (2 * i - 2 * n + s + a) * (e * o) + (-3 * i + 3 * n - 2 * s - a) * o + s * e + i
    }
    function zo(e, t, i, n) {
        return function(e, t) {
            var i = 1 - e;
            return i * i * t
        }(e, t) + function(e, t) {
            return 2 * (1 - e) * e * t
        }(e, i) + function(e, t) {
            return e * e * t
        }(e, n)
    }
    function No(e, t, i, n, r) {
        return function(e, t) {
            var i = 1 - e;
            return i * i * i * t
        }(e, t) + function(e, t) {
            var i = 1 - e;
            return 3 * i * i * e * t
        }(e, i) + function(e, t) {
            return 3 * (1 - e) * e * e * t
        }(e, n) + function(e, t) {
            return e * e * e * t
        }(e, r)
    }
    function Do(e, t, i, n) {
        Ao.call(this),
        this.type = "CubicBezierCurve",
        this.v0 = e || new At,
        this.v1 = t || new At,
        this.v2 = i || new At,
        this.v3 = n || new At
    }
    function Uo(e, t, i, n) {
        Ao.call(this),
        this.type = "CubicBezierCurve3",
        this.v0 = e || new Ct,
        this.v1 = t || new Ct,
        this.v2 = i || new Ct,
        this.v3 = n || new Ct
    }
    function Bo(e, t) {
        Ao.call(this),
        this.type = "LineCurve",
        this.v1 = e || new At,
        this.v2 = t || new At
    }
    function jo(e, t) {
        Ao.call(this),
        this.type = "LineCurve3",
        this.v1 = e || new Ct,
        this.v2 = t || new Ct
    }
    function Vo(e, t, i) {
        Ao.call(this),
        this.type = "QuadraticBezierCurve",
        this.v0 = e || new At,
        this.v1 = t || new At,
        this.v2 = i || new At
    }
    function Go(e, t, i) {
        Ao.call(this),
        this.type = "QuadraticBezierCurve3",
        this.v0 = e || new Ct,
        this.v1 = t || new Ct,
        this.v2 = i || new Ct
    }
    function Xo(e) {
        Ao.call(this),
        this.type = "SplineCurve",
        this.points = e || []
    }
    Oo.prototype = Object.create(Ao.prototype),
    Oo.prototype.constructor = Oo,
    Oo.prototype.isCatmullRomCurve3 = !0,
    Oo.prototype.getPoint = function(e, t) {
        var i, n, r, s, a = t || new Ct, o = this.points, l = o.length, c = (l - (this.closed ? 0 : 1)) * e, h = Math.floor(c), u = c - h;
        if (this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / l) + 1) * l : 0 === u && h === l - 1 && (h = l - 2,
        u = 1),
        this.closed || h > 0 ? i = o[(h - 1) % l] : (ko.subVectors(o[0], o[1]).add(o[0]),
        i = ko),
        n = o[h % l],
        r = o[(h + 1) % l],
        this.closed || h + 2 < l ? s = o[(h + 2) % l] : (ko.subVectors(o[l - 1], o[l - 2]).add(o[l - 1]),
        s = ko),
        "centripetal" === this.curveType || "chordal" === this.curveType) {
            var p = "chordal" === this.curveType ? .5 : .25
              , d = Math.pow(i.distanceToSquared(n), p)
              , f = Math.pow(n.distanceToSquared(r), p)
              , m = Math.pow(r.distanceToSquared(s), p);
            f < 1e-4 && (f = 1),
            d < 1e-4 && (d = f),
            m < 1e-4 && (m = f),
            Eo.initNonuniformCatmullRom(i.x, n.x, r.x, s.x, d, f, m),
            Io.initNonuniformCatmullRom(i.y, n.y, r.y, s.y, d, f, m),
            Fo.initNonuniformCatmullRom(i.z, n.z, r.z, s.z, d, f, m)
        } else
            "catmullrom" === this.curveType && (Eo.initCatmullRom(i.x, n.x, r.x, s.x, this.tension),
            Io.initCatmullRom(i.y, n.y, r.y, s.y, this.tension),
            Fo.initCatmullRom(i.z, n.z, r.z, s.z, this.tension));
        return a.set(Eo.calc(u), Io.calc(u), Fo.calc(u)),
        a
    }
    ,
    Oo.prototype.copy = function(e) {
        Ao.prototype.copy.call(this, e),
        this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push(n.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    ,
    Oo.prototype.toJSON = function() {
        var e = Ao.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++) {
            var n = this.points[t];
            e.points.push(n.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    ,
    Oo.prototype.fromJSON = function(e) {
        Ao.prototype.fromJSON.call(this, e),
        this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push((new Ct).fromArray(n))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    ,
    Do.prototype = Object.create(Ao.prototype),
    Do.prototype.constructor = Do,
    Do.prototype.isCubicBezierCurve = !0,
    Do.prototype.getPoint = function(e, t) {
        var i = t || new At
          , n = this.v0
          , r = this.v1
          , s = this.v2
          , a = this.v3;
        return i.set(No(e, n.x, r.x, s.x, a.x), No(e, n.y, r.y, s.y, a.y)),
        i
    }
    ,
    Do.prototype.copy = function(e) {
        return Ao.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    ,
    Do.prototype.toJSON = function() {
        var e = Ao.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    ,
    Do.prototype.fromJSON = function(e) {
        return Ao.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
    ,
    Uo.prototype = Object.create(Ao.prototype),
    Uo.prototype.constructor = Uo,
    Uo.prototype.isCubicBezierCurve3 = !0,
    Uo.prototype.getPoint = function(e, t) {
        var i = t || new Ct
          , n = this.v0
          , r = this.v1
          , s = this.v2
          , a = this.v3;
        return i.set(No(e, n.x, r.x, s.x, a.x), No(e, n.y, r.y, s.y, a.y), No(e, n.z, r.z, s.z, a.z)),
        i
    }
    ,
    Uo.prototype.copy = function(e) {
        return Ao.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    ,
    Uo.prototype.toJSON = function() {
        var e = Ao.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    ,
    Uo.prototype.fromJSON = function(e) {
        return Ao.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
    ,
    Bo.prototype = Object.create(Ao.prototype),
    Bo.prototype.constructor = Bo,
    Bo.prototype.isLineCurve = !0,
    Bo.prototype.getPoint = function(e, t) {
        var i = t || new At;
        return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    ,
    Bo.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }
    ,
    Bo.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }
    ,
    Bo.prototype.copy = function(e) {
        return Ao.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Bo.prototype.toJSON = function() {
        var e = Ao.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Bo.prototype.fromJSON = function(e) {
        return Ao.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    jo.prototype = Object.create(Ao.prototype),
    jo.prototype.constructor = jo,
    jo.prototype.isLineCurve3 = !0,
    jo.prototype.getPoint = function(e, t) {
        var i = t || new Ct;
        return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    ,
    jo.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }
    ,
    jo.prototype.copy = function(e) {
        return Ao.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    jo.prototype.toJSON = function() {
        var e = Ao.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    jo.prototype.fromJSON = function(e) {
        return Ao.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    Vo.prototype = Object.create(Ao.prototype),
    Vo.prototype.constructor = Vo,
    Vo.prototype.isQuadraticBezierCurve = !0,
    Vo.prototype.getPoint = function(e, t) {
        var i = t || new At
          , n = this.v0
          , r = this.v1
          , s = this.v2;
        return i.set(zo(e, n.x, r.x, s.x), zo(e, n.y, r.y, s.y)),
        i
    }
    ,
    Vo.prototype.copy = function(e) {
        return Ao.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Vo.prototype.toJSON = function() {
        var e = Ao.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Vo.prototype.fromJSON = function(e) {
        return Ao.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    Go.prototype = Object.create(Ao.prototype),
    Go.prototype.constructor = Go,
    Go.prototype.isQuadraticBezierCurve3 = !0,
    Go.prototype.getPoint = function(e, t) {
        var i = t || new Ct
          , n = this.v0
          , r = this.v1
          , s = this.v2;
        return i.set(zo(e, n.x, r.x, s.x), zo(e, n.y, r.y, s.y), zo(e, n.z, r.z, s.z)),
        i
    }
    ,
    Go.prototype.copy = function(e) {
        return Ao.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Go.prototype.toJSON = function() {
        var e = Ao.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Go.prototype.fromJSON = function(e) {
        return Ao.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    Xo.prototype = Object.create(Ao.prototype),
    Xo.prototype.constructor = Xo,
    Xo.prototype.isSplineCurve = !0,
    Xo.prototype.getPoint = function(e, t) {
        var i = t || new At
          , n = this.points
          , r = (n.length - 1) * e
          , s = Math.floor(r)
          , a = r - s
          , o = n[0 === s ? s : s - 1]
          , l = n[s]
          , c = n[s > n.length - 2 ? n.length - 1 : s + 1]
          , h = n[s > n.length - 3 ? n.length - 1 : s + 2];
        return i.set(Ro(a, o.x, l.x, c.x, h.x), Ro(a, o.y, l.y, c.y, h.y)),
        i
    }
    ,
    Xo.prototype.copy = function(e) {
        Ao.prototype.copy.call(this, e),
        this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push(n.clone())
        }
        return this
    }
    ,
    Xo.prototype.toJSON = function() {
        var e = Ao.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++) {
            var n = this.points[t];
            e.points.push(n.toArray())
        }
        return e
    }
    ,
    Xo.prototype.fromJSON = function(e) {
        Ao.prototype.fromJSON.call(this, e),
        this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push((new At).fromArray(n))
        }
        return this
    }
    ;
    var Yo = Object.freeze({
        ArcCurve: Co,
        CatmullRomCurve3: Oo,
        CubicBezierCurve: Do,
        CubicBezierCurve3: Uo,
        EllipseCurve: Po,
        LineCurve: Bo,
        LineCurve3: jo,
        QuadraticBezierCurve: Vo,
        QuadraticBezierCurve3: Go,
        SplineCurve: Xo
    });
    function Wo() {
        Ao.call(this),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    function qo(e) {
        Wo.call(this),
        this.type = "Path",
        this.currentPoint = new At,
        e && this.setFromPoints(e)
    }
    function Ho(e) {
        qo.call(this, e),
        this.uuid = St.generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    function Qo(e, t) {
        Mi.call(this),
        this.type = "Light",
        this.color = new hi(e),
        this.intensity = void 0 !== t ? t : 1,
        this.receiveShadow = void 0
    }
    function Jo(e, t, i) {
        Qo.call(this, e, i),
        this.type = "HemisphereLight",
        this.castShadow = void 0,
        this.position.copy(Mi.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new hi(t)
    }
    function Zo(e) {
        this.camera = e,
        this.bias = 0,
        this.radius = 1,
        this.mapSize = new At(512,512),
        this.map = null,
        this.matrix = new ii
    }
    function $o() {
        Zo.call(this, new Jr(50,1,.5,500))
    }
    function Ko(e, t, i, n, r, s) {
        Qo.call(this, e, t),
        this.type = "SpotLight",
        this.position.copy(Mi.DefaultUp),
        this.updateMatrix(),
        this.target = new Mi,
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / Math.PI
            }
        }),
        this.distance = void 0 !== i ? i : 0,
        this.angle = void 0 !== n ? n : Math.PI / 3,
        this.penumbra = void 0 !== r ? r : 0,
        this.decay = void 0 !== s ? s : 1,
        this.shadow = new $o
    }
    function el(e, t, i, n) {
        Qo.call(this, e, t),
        this.type = "PointLight",
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / (4 * Math.PI)
            }
        }),
        this.distance = void 0 !== i ? i : 0,
        this.decay = void 0 !== n ? n : 1,
        this.shadow = new Zo(new Jr(90,1,.5,500))
    }
    function tl(e, t, i, n, r, s) {
        Qr.call(this),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = void 0 !== e ? e : -1,
        this.right = void 0 !== t ? t : 1,
        this.top = void 0 !== i ? i : 1,
        this.bottom = void 0 !== n ? n : -1,
        this.near = void 0 !== r ? r : .1,
        this.far = void 0 !== s ? s : 2e3,
        this.updateProjectionMatrix()
    }
    function il() {
        Zo.call(this, new tl(-5,5,5,-5,.5,500))
    }
    function nl(e, t) {
        Qo.call(this, e, t),
        this.type = "DirectionalLight",
        this.position.copy(Mi.DefaultUp),
        this.updateMatrix(),
        this.target = new Mi,
        this.shadow = new il
    }
    function rl(e, t) {
        Qo.call(this, e, t),
        this.type = "AmbientLight",
        this.castShadow = void 0
    }
    function sl(e, t, i, n) {
        Qo.call(this, e, t),
        this.type = "RectAreaLight",
        this.width = void 0 !== i ? i : 10,
        this.height = void 0 !== n ? n : 10
    }
    function al(e) {
        this.manager = void 0 !== e ? e : bo,
        this.textures = {}
    }
    Wo.prototype = Object.assign(Object.create(Ao.prototype), {
        constructor: Wo,
        add: function(e) {
            this.curves.push(e)
        },
        closePath: function() {
            var e = this.curves[0].getPoint(0)
              , t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new Bo(t,e))
        },
        getPoint: function(e) {
            for (var t = e * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length; ) {
                if (i[n] >= t) {
                    var r = i[n] - t
                      , s = this.curves[n]
                      , a = s.getLength()
                      , o = 0 === a ? 0 : 1 - r / a;
                    return s.getPointAt(o)
                }
                n++
            }
            return null
        },
        getLength: function() {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var e = [], t = 0, i = 0, n = this.curves.length; i < n; i++)
                t += this.curves[i].getLength(),
                e.push(t);
            return this.cacheLengths = e,
            e
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 40);
            for (var t = [], i = 0; i <= e; i++)
                t.push(this.getPoint(i / e));
            return this.autoClose && t.push(t[0]),
            t
        },
        getPoints: function(e) {
            e = e || 12;
            for (var t, i = [], n = 0, r = this.curves; n < r.length; n++)
                for (var s = r[n], a = s && s.isEllipseCurve ? 2 * e : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? e * s.points.length : e, o = s.getPoints(a), l = 0; l < o.length; l++) {
                    var c = o[l];
                    t && t.equals(c) || (i.push(c),
                    t = c)
                }
            return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]),
            i
        },
        copy: function(e) {
            Ao.prototype.copy.call(this, e),
            this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) {
                var n = e.curves[t];
                this.curves.push(n.clone())
            }
            return this.autoClose = e.autoClose,
            this
        },
        toJSON: function() {
            var e = Ao.prototype.toJSON.call(this);
            e.autoClose = this.autoClose,
            e.curves = [];
            for (var t = 0, i = this.curves.length; t < i; t++) {
                var n = this.curves[t];
                e.curves.push(n.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            Ao.prototype.fromJSON.call(this, e),
            this.autoClose = e.autoClose,
            this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) {
                var n = e.curves[t];
                this.curves.push((new Yo[n.type]).fromJSON(n))
            }
            return this
        }
    }),
    qo.prototype = Object.assign(Object.create(Wo.prototype), {
        constructor: qo,
        setFromPoints: function(e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, i = e.length; t < i; t++)
                this.lineTo(e[t].x, e[t].y)
        },
        moveTo: function(e, t) {
            this.currentPoint.set(e, t)
        },
        lineTo: function(e, t) {
            var i = new Bo(this.currentPoint.clone(),new At(e,t));
            this.curves.push(i),
            this.currentPoint.set(e, t)
        },
        quadraticCurveTo: function(e, t, i, n) {
            var r = new Vo(this.currentPoint.clone(),new At(e,t),new At(i,n));
            this.curves.push(r),
            this.currentPoint.set(i, n)
        },
        bezierCurveTo: function(e, t, i, n, r, s) {
            var a = new Do(this.currentPoint.clone(),new At(e,t),new At(i,n),new At(r,s));
            this.curves.push(a),
            this.currentPoint.set(r, s)
        },
        splineThru: function(e) {
            var t = new Xo([this.currentPoint.clone()].concat(e));
            this.curves.push(t),
            this.currentPoint.copy(e[e.length - 1])
        },
        arc: function(e, t, i, n, r, s) {
            var a = this.currentPoint.x
              , o = this.currentPoint.y;
            this.absarc(e + a, t + o, i, n, r, s)
        },
        absarc: function(e, t, i, n, r, s) {
            this.absellipse(e, t, i, i, n, r, s)
        },
        ellipse: function(e, t, i, n, r, s, a, o) {
            var l = this.currentPoint.x
              , c = this.currentPoint.y;
            this.absellipse(e + l, t + c, i, n, r, s, a, o)
        },
        absellipse: function(e, t, i, n, r, s, a, o) {
            var l = new Po(e,t,i,n,r,s,a,o);
            if (this.curves.length > 0) {
                var c = l.getPoint(0);
                c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
            }
            this.curves.push(l);
            var h = l.getPoint(1);
            this.currentPoint.copy(h)
        },
        copy: function(e) {
            return Wo.prototype.copy.call(this, e),
            this.currentPoint.copy(e.currentPoint),
            this
        },
        toJSON: function() {
            var e = Wo.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(),
            e
        },
        fromJSON: function(e) {
            return Wo.prototype.fromJSON.call(this, e),
            this.currentPoint.fromArray(e.currentPoint),
            this
        }
    }),
    Ho.prototype = Object.assign(Object.create(qo.prototype), {
        constructor: Ho,
        getPointsHoles: function(e) {
            for (var t = [], i = 0, n = this.holes.length; i < n; i++)
                t[i] = this.holes[i].getPoints(e);
            return t
        },
        extractPoints: function(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        copy: function(e) {
            qo.prototype.copy.call(this, e),
            this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) {
                var n = e.holes[t];
                this.holes.push(n.clone())
            }
            return this
        },
        toJSON: function() {
            var e = qo.prototype.toJSON.call(this);
            e.uuid = this.uuid,
            e.holes = [];
            for (var t = 0, i = this.holes.length; t < i; t++) {
                var n = this.holes[t];
                e.holes.push(n.toJSON())
            }
            return e
        },
        fromJSON: function(e) {
            qo.prototype.fromJSON.call(this, e),
            this.uuid = e.uuid,
            this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) {
                var n = e.holes[t];
                this.holes.push((new qo).fromJSON(n))
            }
            return this
        }
    }),
    Qo.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: Qo,
        isLight: !0,
        copy: function(e) {
            return Mi.prototype.copy.call(this, e),
            this.color.copy(e.color),
            this.intensity = e.intensity,
            this
        },
        toJSON: function(e) {
            var t = Mi.prototype.toJSON.call(this, e);
            return t.object.color = this.color.getHex(),
            t.object.intensity = this.intensity,
            void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            t
        }
    }),
    Jo.prototype = Object.assign(Object.create(Qo.prototype), {
        constructor: Jo,
        isHemisphereLight: !0,
        copy: function(e) {
            return Qo.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
        }
    }),
    Object.assign(Zo.prototype, {
        copy: function(e) {
            return this.camera = e.camera.clone(),
            this.bias = e.bias,
            this.radius = e.radius,
            this.mapSize.copy(e.mapSize),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias),
            1 !== this.radius && (e.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
            e.camera = this.camera.toJSON(!1).object,
            delete e.camera.matrix,
            e
        }
    }),
    $o.prototype = Object.assign(Object.create(Zo.prototype), {
        constructor: $o,
        isSpotLightShadow: !0,
        update: function(e) {
            var t = this.camera
              , i = 2 * St.RAD2DEG * e.angle
              , n = this.mapSize.width / this.mapSize.height
              , r = e.distance || t.far;
            i === t.fov && n === t.aspect && r === t.far || (t.fov = i,
            t.aspect = n,
            t.far = r,
            t.updateProjectionMatrix())
        }
    }),
    Ko.prototype = Object.assign(Object.create(Qo.prototype), {
        constructor: Ko,
        isSpotLight: !0,
        copy: function(e) {
            return Qo.prototype.copy.call(this, e),
            this.distance = e.distance,
            this.angle = e.angle,
            this.penumbra = e.penumbra,
            this.decay = e.decay,
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    el.prototype = Object.assign(Object.create(Qo.prototype), {
        constructor: el,
        isPointLight: !0,
        copy: function(e) {
            return Qo.prototype.copy.call(this, e),
            this.distance = e.distance,
            this.decay = e.decay,
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    tl.prototype = Object.assign(Object.create(Qr.prototype), {
        constructor: tl,
        isOrthographicCamera: !0,
        copy: function(e, t) {
            return Qr.prototype.copy.call(this, e, t),
            this.left = e.left,
            this.right = e.right,
            this.top = e.top,
            this.bottom = e.bottom,
            this.near = e.near,
            this.far = e.far,
            this.zoom = e.zoom,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this
        },
        setViewOffset: function(e, t, i, n, r, s) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = i,
            this.view.offsetY = n,
            this.view.width = r,
            this.view.height = s,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e = (this.right - this.left) / (2 * this.zoom)
              , t = (this.top - this.bottom) / (2 * this.zoom)
              , i = (this.right + this.left) / 2
              , n = (this.top + this.bottom) / 2
              , r = i - e
              , s = i + e
              , a = n + t
              , o = n - t;
            if (null !== this.view && this.view.enabled) {
                var l = this.zoom / (this.view.width / this.view.fullWidth)
                  , c = this.zoom / (this.view.height / this.view.fullHeight)
                  , h = (this.right - this.left) / this.view.width
                  , u = (this.top - this.bottom) / this.view.height;
                s = (r += h * (this.view.offsetX / l)) + h * (this.view.width / l),
                o = (a -= u * (this.view.offsetY / c)) - u * (this.view.height / c)
            }
            this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            var t = Mi.prototype.toJSON.call(this, e);
            return t.object.zoom = this.zoom,
            t.object.left = this.left,
            t.object.right = this.right,
            t.object.top = this.top,
            t.object.bottom = this.bottom,
            t.object.near = this.near,
            t.object.far = this.far,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t
        }
    }),
    il.prototype = Object.assign(Object.create(Zo.prototype), {
        constructor: il
    }),
    nl.prototype = Object.assign(Object.create(Qo.prototype), {
        constructor: nl,
        isDirectionalLight: !0,
        copy: function(e) {
            return Qo.prototype.copy.call(this, e),
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    rl.prototype = Object.assign(Object.create(Qo.prototype), {
        constructor: rl,
        isAmbientLight: !0
    }),
    sl.prototype = Object.assign(Object.create(Qo.prototype), {
        constructor: sl,
        isRectAreaLight: !0,
        copy: function(e) {
            return Qo.prototype.copy.call(this, e),
            this.width = e.width,
            this.height = e.height,
            this
        },
        toJSON: function(e) {
            var t = Qo.prototype.toJSON.call(this, e);
            return t.object.width = this.width,
            t.object.height = this.height,
            t
        }
    }),
    Object.assign(al.prototype, {
        load: function(e, t, i, n) {
            var r = this
              , s = new wo(r.manager);
            s.setPath(r.path),
            s.load(e, function(e) {
                t(r.parse(JSON.parse(e)))
            }, i, n)
        },
        parse: function(e) {
            var t = this.textures;
            function i(e) {
                return t[e],
                t[e]
            }
            var n = new eo[e.type];
            if (void 0 !== e.uuid && (n.uuid = e.uuid),
            void 0 !== e.name && (n.name = e.name),
            void 0 !== e.color && n.color.setHex(e.color),
            void 0 !== e.roughness && (n.roughness = e.roughness),
            void 0 !== e.metalness && (n.metalness = e.metalness),
            void 0 !== e.emissive && n.emissive.setHex(e.emissive),
            void 0 !== e.specular && n.specular.setHex(e.specular),
            void 0 !== e.shininess && (n.shininess = e.shininess),
            void 0 !== e.clearCoat && (n.clearCoat = e.clearCoat),
            void 0 !== e.clearCoatRoughness && (n.clearCoatRoughness = e.clearCoatRoughness),
            void 0 !== e.vertexColors && (n.vertexColors = e.vertexColors),
            void 0 !== e.fog && (n.fog = e.fog),
            void 0 !== e.flatShading && (n.flatShading = e.flatShading),
            void 0 !== e.blending && (n.blending = e.blending),
            void 0 !== e.combine && (n.combine = e.combine),
            void 0 !== e.side && (n.side = e.side),
            void 0 !== e.opacity && (n.opacity = e.opacity),
            void 0 !== e.transparent && (n.transparent = e.transparent),
            void 0 !== e.alphaTest && (n.alphaTest = e.alphaTest),
            void 0 !== e.depthTest && (n.depthTest = e.depthTest),
            void 0 !== e.depthWrite && (n.depthWrite = e.depthWrite),
            void 0 !== e.colorWrite && (n.colorWrite = e.colorWrite),
            void 0 !== e.wireframe && (n.wireframe = e.wireframe),
            void 0 !== e.wireframeLinewidth && (n.wireframeLinewidth = e.wireframeLinewidth),
            void 0 !== e.wireframeLinecap && (n.wireframeLinecap = e.wireframeLinecap),
            void 0 !== e.wireframeLinejoin && (n.wireframeLinejoin = e.wireframeLinejoin),
            void 0 !== e.rotation && (n.rotation = e.rotation),
            1 !== e.linewidth && (n.linewidth = e.linewidth),
            void 0 !== e.dashSize && (n.dashSize = e.dashSize),
            void 0 !== e.gapSize && (n.gapSize = e.gapSize),
            void 0 !== e.scale && (n.scale = e.scale),
            void 0 !== e.polygonOffset && (n.polygonOffset = e.polygonOffset),
            void 0 !== e.polygonOffsetFactor && (n.polygonOffsetFactor = e.polygonOffsetFactor),
            void 0 !== e.polygonOffsetUnits && (n.polygonOffsetUnits = e.polygonOffsetUnits),
            void 0 !== e.skinning && (n.skinning = e.skinning),
            void 0 !== e.morphTargets && (n.morphTargets = e.morphTargets),
            void 0 !== e.dithering && (n.dithering = e.dithering),
            void 0 !== e.visible && (n.visible = e.visible),
            void 0 !== e.userData && (n.userData = e.userData),
            void 0 !== e.uniforms)
                for (var r in e.uniforms) {
                    var s = e.uniforms[r];
                    switch (n.uniforms[r] = {},
                    s.type) {
                    case "t":
                        n.uniforms[r].value = i(s.value);
                        break;
                    case "c":
                        n.uniforms[r].value = (new hi).setHex(s.value);
                        break;
                    case "v2":
                        n.uniforms[r].value = (new At).fromArray(s.value);
                        break;
                    case "v3":
                        n.uniforms[r].value = (new Ct).fromArray(s.value);
                        break;
                    case "v4":
                        n.uniforms[r].value = (new qt).fromArray(s.value);
                        break;
                    case "m3":
                        n.uniforms[r].value = (new Lt).fromArray(s.value);
                    case "m4":
                        n.uniforms[r].value = (new ii).fromArray(s.value);
                        break;
                    default:
                        n.uniforms[r].value = s.value
                    }
                }
            if (void 0 !== e.defines && (n.defines = e.defines),
            void 0 !== e.vertexShader && (n.vertexShader = e.vertexShader),
            void 0 !== e.fragmentShader && (n.fragmentShader = e.fragmentShader),
            void 0 !== e.extensions)
                for (var a in e.extensions)
                    n.extensions[a] = e.extensions[a];
            if (void 0 !== e.shading && (n.flatShading = 1 === e.shading),
            void 0 !== e.size && (n.size = e.size),
            void 0 !== e.sizeAttenuation && (n.sizeAttenuation = e.sizeAttenuation),
            void 0 !== e.map && (n.map = i(e.map)),
            void 0 !== e.matcap && (n.matcap = i(e.matcap)),
            void 0 !== e.alphaMap && (n.alphaMap = i(e.alphaMap),
            n.transparent = !0),
            void 0 !== e.bumpMap && (n.bumpMap = i(e.bumpMap)),
            void 0 !== e.bumpScale && (n.bumpScale = e.bumpScale),
            void 0 !== e.normalMap && (n.normalMap = i(e.normalMap)),
            void 0 !== e.normalMapType && (n.normalMapType = e.normalMapType),
            void 0 !== e.normalScale) {
                var o = e.normalScale;
                !1 === Array.isArray(o) && (o = [o, o]),
                n.normalScale = (new At).fromArray(o)
            }
            return void 0 !== e.displacementMap && (n.displacementMap = i(e.displacementMap)),
            void 0 !== e.displacementScale && (n.displacementScale = e.displacementScale),
            void 0 !== e.displacementBias && (n.displacementBias = e.displacementBias),
            void 0 !== e.roughnessMap && (n.roughnessMap = i(e.roughnessMap)),
            void 0 !== e.metalnessMap && (n.metalnessMap = i(e.metalnessMap)),
            void 0 !== e.emissiveMap && (n.emissiveMap = i(e.emissiveMap)),
            void 0 !== e.emissiveIntensity && (n.emissiveIntensity = e.emissiveIntensity),
            void 0 !== e.specularMap && (n.specularMap = i(e.specularMap)),
            void 0 !== e.envMap && (n.envMap = i(e.envMap)),
            void 0 !== e.envMapIntensity && (n.envMapIntensity = e.envMapIntensity),
            void 0 !== e.reflectivity && (n.reflectivity = e.reflectivity),
            void 0 !== e.lightMap && (n.lightMap = i(e.lightMap)),
            void 0 !== e.lightMapIntensity && (n.lightMapIntensity = e.lightMapIntensity),
            void 0 !== e.aoMap && (n.aoMap = i(e.aoMap)),
            void 0 !== e.aoMapIntensity && (n.aoMapIntensity = e.aoMapIntensity),
            void 0 !== e.gradientMap && (n.gradientMap = i(e.gradientMap)),
            n
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setTextures: function(e) {
            return this.textures = e,
            this
        }
    });
    var ol = function(e) {
        var t = e.lastIndexOf("/");
        return -1 === t ? "./" : e.substr(0, t + 1)
    };
    function ll(e) {
        this.manager = void 0 !== e ? e : bo
    }
    Object.assign(ll.prototype, {
        load: function(e, t, i, n) {
            var r = this
              , s = new wo(r.manager);
            s.setPath(r.path),
            s.load(e, function(e) {
                t(r.parse(JSON.parse(e)))
            }, i, n)
        },
        parse: function(e) {
            var t = new Vi
              , i = e.data.index;
            if (void 0 !== i) {
                var n = new cl[i.type](i.array);
                t.setIndex(new Li(n,1))
            }
            var r = e.data.attributes;
            for (var s in r) {
                var a = r[s]
                  , o = new Li(n = new cl[a.type](a.array),a.itemSize,a.normalized);
                void 0 !== a.name && (o.name = a.name),
                t.addAttribute(s, o)
            }
            var l = e.data.morphAttributes;
            if (l)
                for (var s in l) {
                    for (var c = l[s], h = [], u = 0, p = c.length; u < p; u++) {
                        a = c[u],
                        o = new Li(n = new cl[a.type](a.array),a.itemSize,a.normalized);
                        void 0 !== a.name && (o.name = a.name),
                        h.push(o)
                    }
                    t.morphAttributes[s] = h
                }
            var d = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== d) {
                u = 0;
                for (var f = d.length; u !== f; ++u) {
                    var m = d[u];
                    t.addGroup(m.start, m.count, m.materialIndex)
                }
            }
            var g = e.data.boundingSphere;
            if (void 0 !== g) {
                var v = new Ct;
                void 0 !== g.center && v.fromArray(g.center),
                t.boundingSphere = new Kt(v,g.radius)
            }
            return e.name && (t.name = e.name),
            e.userData && (t.userData = e.userData),
            t
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    });
    var cl = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    function hl(e) {
        this.manager = void 0 !== e ? e : bo,
        this.resourcePath = ""
    }
    Object.assign(hl.prototype, {
        crossOrigin: "anonymous",
        load: function(e, t, i, n) {
            var r = this
              , s = void 0 === this.path ? ol(e) : this.path;
            this.resourcePath = this.resourcePath || s;
            var a = new wo(r.manager);
            a.setPath(this.path),
            a.load(e, function(e) {
                var i = null;
                try {
                    i = JSON.parse(e)
                } catch (e) {
                    return void (void 0 !== n && n(e))
                }
                var s = i.metadata;
                void 0 !== s && void 0 !== s.type && "geometry" !== s.type.toLowerCase() && r.parse(i, t)
            }, i, n)
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setResourcePath: function(e) {
            return this.resourcePath = e,
            this
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        parse: function(e, t) {
            var i = this.parseShape(e.shapes)
              , n = this.parseGeometries(e.geometries, i)
              , r = this.parseImages(e.images, function() {
                void 0 !== t && t(o)
            })
              , s = this.parseTextures(e.textures, r)
              , a = this.parseMaterials(e.materials, s)
              , o = this.parseObject(e.object, n, a);
            return e.animations && (o.animations = this.parseAnimations(e.animations)),
            void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(o),
            o
        },
        parseShape: function(e) {
            var t = {};
            if (void 0 !== e)
                for (var i = 0, n = e.length; i < n; i++) {
                    var r = (new Ho).fromJSON(e[i]);
                    t[r.uuid] = r
                }
            return t
        },
        parseGeometries: function(e, t) {
            var i = {};
            if (void 0 !== e)
                for (var n = new ll, r = 0, s = e.length; r < s; r++) {
                    var a, o = e[r];
                    switch (o.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        a = new Ga[o.type](o.width,o.height,o.widthSegments,o.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        a = new Ga[o.type](o.width,o.height,o.depth,o.widthSegments,o.heightSegments,o.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        a = new Ga[o.type](o.radius,o.segments,o.thetaStart,o.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        a = new Ga[o.type](o.radiusTop,o.radiusBottom,o.height,o.radialSegments,o.heightSegments,o.openEnded,o.thetaStart,o.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        a = new Ga[o.type](o.radius,o.height,o.radialSegments,o.heightSegments,o.openEnded,o.thetaStart,o.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        a = new Ga[o.type](o.radius,o.widthSegments,o.heightSegments,o.phiStart,o.phiLength,o.thetaStart,o.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                        a = new Ga[o.type](o.radius,o.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        a = new Ga[o.type](o.innerRadius,o.outerRadius,o.thetaSegments,o.phiSegments,o.thetaStart,o.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        a = new Ga[o.type](o.radius,o.tube,o.radialSegments,o.tubularSegments,o.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        a = new Ga[o.type](o.radius,o.tube,o.tubularSegments,o.radialSegments,o.p,o.q);
                        break;
                    case "TubeGeometry":
                    case "TubeBufferGeometry":
                        a = new Ga[o.type]((new Yo[o.path.type]).fromJSON(o.path),o.tubularSegments,o.radius,o.radialSegments,o.closed);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        a = new Ga[o.type](o.points,o.segments,o.phiStart,o.phiLength);
                        break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                        a = new Ga[o.type](o.vertices,o.indices,o.radius,o.details);
                        break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                        for (var l = [], c = 0, h = o.shapes.length; c < h; c++) {
                            var u = t[o.shapes[c]];
                            l.push(u)
                        }
                        a = new Ga[o.type](l,o.curveSegments);
                        break;
                    case "ExtrudeGeometry":
                    case "ExtrudeBufferGeometry":
                        for (l = [],
                        c = 0,
                        h = o.shapes.length; c < h; c++) {
                            u = t[o.shapes[c]];
                            l.push(u)
                        }
                        var p = o.options.extrudePath;
                        void 0 !== p && (o.options.extrudePath = (new Yo[p.type]).fromJSON(p)),
                        a = new Ga[o.type](l,o.options);
                        break;
                    case "BufferGeometry":
                        a = n.parse(o);
                        break;
                    case "Geometry":
                        if ("THREE"in window && "LegacyJSONLoader"in THREE)
                            a = (new THREE.LegacyJSONLoader).parse(o, this.resourcePath).geometry;
                        break;
                    default:
                        continue
                    }
                    a.uuid = o.uuid,
                    void 0 !== o.name && (a.name = o.name),
                    !0 === a.isBufferGeometry && void 0 !== o.userData && (a.userData = o.userData),
                    i[o.uuid] = a
                }
            return i
        },
        parseMaterials: function(e, t) {
            var i = {}
              , n = {};
            if (void 0 !== e) {
                var r = new al;
                r.setTextures(t);
                for (var s = 0, a = e.length; s < a; s++) {
                    var o = e[s];
                    if ("MultiMaterial" === o.type) {
                        for (var l = [], c = 0; c < o.materials.length; c++) {
                            var h = o.materials[c];
                            void 0 === i[h.uuid] && (i[h.uuid] = r.parse(h)),
                            l.push(i[h.uuid])
                        }
                        n[o.uuid] = l
                    } else
                        void 0 === i[o.uuid] && (i[o.uuid] = r.parse(o)),
                        n[o.uuid] = i[o.uuid]
                }
            }
            return n
        },
        parseAnimations: function(e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = e[i]
                  , r = mo.parse(n);
                void 0 !== n.uuid && (r.uuid = n.uuid),
                t.push(r)
            }
            return t
        },
        parseImages: function(e, t) {
            var i = this
              , n = {};
            function r(e) {
                return i.manager.itemStart(e),
                s.load(e, function() {
                    i.manager.itemEnd(e)
                }, void 0, function() {
                    i.manager.itemError(e),
                    i.manager.itemEnd(e)
                })
            }
            if (void 0 !== e && e.length > 0) {
                var s = new To(new yo(t));
                s.setCrossOrigin(this.crossOrigin);
                for (var a = 0, o = e.length; a < o; a++) {
                    var l = e[a]
                      , c = l.url;
                    if (Array.isArray(c)) {
                        n[l.uuid] = [];
                        for (var h = 0, u = c.length; h < u; h++) {
                            var p = c[h]
                              , d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : i.resourcePath + p;
                            n[l.uuid].push(r(d))
                        }
                    } else {
                        d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : i.resourcePath + l.url;
                        n[l.uuid] = r(d)
                    }
                }
            }
            return n
        },
        parseTextures: function(e, t) {
            function i(e, t) {
                return "number" == typeof e ? e : t[e]
            }
            var n = {};
            if (void 0 !== e)
                for (var r = 0, s = e.length; r < s; r++) {
                    var a, o = e[r];
                    o.image,
                    t[o.image],
                    (a = Array.isArray(t[o.image]) ? new An(t[o.image]) : new Wt(t[o.image])).needsUpdate = !0,
                    a.uuid = o.uuid,
                    void 0 !== o.name && (a.name = o.name),
                    void 0 !== o.mapping && (a.mapping = i(o.mapping, gl)),
                    void 0 !== o.offset && a.offset.fromArray(o.offset),
                    void 0 !== o.repeat && a.repeat.fromArray(o.repeat),
                    void 0 !== o.center && a.center.fromArray(o.center),
                    void 0 !== o.rotation && (a.rotation = o.rotation),
                    void 0 !== o.wrap && (a.wrapS = i(o.wrap[0], vl),
                    a.wrapT = i(o.wrap[1], vl)),
                    void 0 !== o.format && (a.format = o.format),
                    void 0 !== o.type && (a.type = o.type),
                    void 0 !== o.encoding && (a.encoding = o.encoding),
                    void 0 !== o.minFilter && (a.minFilter = i(o.minFilter, yl)),
                    void 0 !== o.magFilter && (a.magFilter = i(o.magFilter, yl)),
                    void 0 !== o.anisotropy && (a.anisotropy = o.anisotropy),
                    void 0 !== o.flipY && (a.flipY = o.flipY),
                    void 0 !== o.premultiplyAlpha && (a.premultiplyAlpha = o.premultiplyAlpha),
                    void 0 !== o.unpackAlignment && (a.unpackAlignment = o.unpackAlignment),
                    n[o.uuid] = a
                }
            return n
        },
        parseObject: function(e, t, i) {
            var n;
            function r(e) {
                return t[e],
                t[e]
            }
            function s(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        for (var t = [], n = 0, r = e.length; n < r; n++) {
                            var s = e[n];
                            i[s],
                            t.push(i[s])
                        }
                        return t
                    }
                    return i[e],
                    i[e]
                }
            }
            switch (e.type) {
            case "Scene":
                n = new ps,
                void 0 !== e.background && Number.isInteger(e.background) && (n.background = new hi(e.background)),
                void 0 !== e.fog && ("Fog" === e.fog.type ? n.fog = new us(e.fog.color,e.fog.near,e.fog.far) : "FogExp2" === e.fog.type && (n.fog = new hs(e.fog.color,e.fog.density)));
                break;
            case "PerspectiveCamera":
                n = new Jr(e.fov,e.aspect,e.near,e.far),
                void 0 !== e.focus && (n.focus = e.focus),
                void 0 !== e.zoom && (n.zoom = e.zoom),
                void 0 !== e.filmGauge && (n.filmGauge = e.filmGauge),
                void 0 !== e.filmOffset && (n.filmOffset = e.filmOffset),
                void 0 !== e.view && (n.view = Object.assign({}, e.view));
                break;
            case "OrthographicCamera":
                n = new tl(e.left,e.right,e.top,e.bottom,e.near,e.far),
                void 0 !== e.zoom && (n.zoom = e.zoom),
                void 0 !== e.view && (n.view = Object.assign({}, e.view));
                break;
            case "AmbientLight":
                n = new rl(e.color,e.intensity);
                break;
            case "DirectionalLight":
                n = new nl(e.color,e.intensity);
                break;
            case "PointLight":
                n = new el(e.color,e.intensity,e.distance,e.decay);
                break;
            case "RectAreaLight":
                n = new sl(e.color,e.intensity,e.width,e.height);
                break;
            case "SpotLight":
                n = new Ko(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
                break;
            case "HemisphereLight":
                n = new Jo(e.color,e.groundColor,e.intensity);
                break;
            case "SkinnedMesh":
            case "Mesh":
                var a = r(e.geometry)
                  , o = s(e.material);
                n = a.bones && a.bones.length > 0 ? new ys(a,o) : new fn(a,o),
                void 0 !== e.drawMode && n.setDrawMode(e.drawMode);
                break;
            case "LOD":
                n = new vs;
                break;
            case "Line":
                n = new _s(r(e.geometry),s(e.material),e.mode);
                break;
            case "LineLoop":
                n = new Ms(r(e.geometry),s(e.material));
                break;
            case "LineSegments":
                n = new Ts(r(e.geometry),s(e.material));
                break;
            case "PointCloud":
            case "Points":
                n = new As(r(e.geometry),s(e.material));
                break;
            case "Sprite":
                n = new gs(s(e.material));
                break;
            case "Group":
                n = new Hr;
                break;
            default:
                n = new Mi
            }
            if (n.uuid = e.uuid,
            void 0 !== e.name && (n.name = e.name),
            void 0 !== e.matrix ? (n.matrix.fromArray(e.matrix),
            void 0 !== e.matrixAutoUpdate && (n.matrixAutoUpdate = e.matrixAutoUpdate),
            n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== e.position && n.position.fromArray(e.position),
            void 0 !== e.rotation && n.rotation.fromArray(e.rotation),
            void 0 !== e.quaternion && n.quaternion.fromArray(e.quaternion),
            void 0 !== e.scale && n.scale.fromArray(e.scale)),
            void 0 !== e.castShadow && (n.castShadow = e.castShadow),
            void 0 !== e.receiveShadow && (n.receiveShadow = e.receiveShadow),
            e.shadow && (void 0 !== e.shadow.bias && (n.shadow.bias = e.shadow.bias),
            void 0 !== e.shadow.radius && (n.shadow.radius = e.shadow.radius),
            void 0 !== e.shadow.mapSize && n.shadow.mapSize.fromArray(e.shadow.mapSize),
            void 0 !== e.shadow.camera && (n.shadow.camera = this.parseObject(e.shadow.camera))),
            void 0 !== e.visible && (n.visible = e.visible),
            void 0 !== e.frustumCulled && (n.frustumCulled = e.frustumCulled),
            void 0 !== e.renderOrder && (n.renderOrder = e.renderOrder),
            void 0 !== e.userData && (n.userData = e.userData),
            void 0 !== e.layers && (n.layers.mask = e.layers),
            void 0 !== e.children)
                for (var l = e.children, c = 0; c < l.length; c++)
                    n.add(this.parseObject(l[c], t, i));
            if ("LOD" === e.type)
                for (var h = e.levels, u = 0; u < h.length; u++) {
                    var p = h[u]
                      , d = n.getObjectByProperty("uuid", p.object);
                    void 0 !== d && n.addLevel(d, p.distance)
                }
            return n
        }
    });
    var ul, pl, dl, fl, ml, gl = {
        UVMapping: 300,
        CubeReflectionMapping: re,
        CubeRefractionMapping: se,
        EquirectangularReflectionMapping: ae,
        EquirectangularRefractionMapping: oe,
        SphericalReflectionMapping: le,
        CubeUVReflectionMapping: ce,
        CubeUVRefractionMapping: he
    }, vl = {
        RepeatWrapping: ue,
        ClampToEdgeWrapping: pe,
        MirroredRepeatWrapping: de
    }, yl = {
        NearestFilter: fe,
        NearestMipMapNearestFilter: me,
        NearestMipMapLinearFilter: ge,
        LinearFilter: ve,
        LinearMipMapNearestFilter: ye,
        LinearMipMapLinearFilter: be
    };
    function bl(e) {
        this.manager = void 0 !== e ? e : bo,
        this.options = void 0
    }
    function xl() {
        this.type = "ShapePath",
        this.color = new hi,
        this.subPaths = [],
        this.currentPath = null
    }
    function wl(e) {
        this.type = "Font",
        this.data = e
    }
    function _l(e, t, i, n, r) {
        var s = r.glyphs[e] || r.glyphs["?"];
        if (s) {
            var a, o, l, c, h, u, p, d, f = new xl;
            if (s.o)
                for (var m = s._cachedOutline || (s._cachedOutline = s.o.split(" ")), g = 0, v = m.length; g < v; ) {
                    switch (m[g++]) {
                    case "m":
                        a = m[g++] * t + i,
                        o = m[g++] * t + n,
                        f.moveTo(a, o);
                        break;
                    case "l":
                        a = m[g++] * t + i,
                        o = m[g++] * t + n,
                        f.lineTo(a, o);
                        break;
                    case "q":
                        l = m[g++] * t + i,
                        c = m[g++] * t + n,
                        h = m[g++] * t + i,
                        u = m[g++] * t + n,
                        f.quadraticCurveTo(h, u, l, c);
                        break;
                    case "b":
                        l = m[g++] * t + i,
                        c = m[g++] * t + n,
                        h = m[g++] * t + i,
                        u = m[g++] * t + n,
                        p = m[g++] * t + i,
                        d = m[g++] * t + n,
                        f.bezierCurveTo(h, u, p, d, l, c)
                    }
                }
            return {
                offsetX: s.ha * t,
                path: f
            }
        }
    }
    function Tl() {}
    bl.prototype = {
        constructor: bl,
        setOptions: function(e) {
            return this.options = e,
            this
        },
        load: function(e, t, i, n) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            var r = this
              , s = vo.get(e);
            if (void 0 !== s)
                return r.manager.itemStart(e),
                setTimeout(function() {
                    t && t(s),
                    r.manager.itemEnd(e)
                }, 0),
                s;
            fetch(e).then(function(e) {
                return e.blob()
            }).then(function(e) {
                return void 0 === r.options ? createImageBitmap(e) : createImageBitmap(e, r.options)
            }).then(function(i) {
                vo.add(e, i),
                t && t(i),
                r.manager.itemEnd(e)
            }).catch(function(t) {
                n && n(t),
                r.manager.itemError(e),
                r.manager.itemEnd(e)
            }),
            r.manager.itemStart(e)
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    },
    Object.assign(xl.prototype, {
        moveTo: function(e, t) {
            this.currentPath = new qo,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(e, t)
        },
        lineTo: function(e, t) {
            this.currentPath.lineTo(e, t)
        },
        quadraticCurveTo: function(e, t, i, n) {
            this.currentPath.quadraticCurveTo(e, t, i, n)
        },
        bezierCurveTo: function(e, t, i, n, r, s) {
            this.currentPath.bezierCurveTo(e, t, i, n, r, s)
        },
        splineThru: function(e) {
            this.currentPath.splineThru(e)
        },
        toShapes: function(e, t) {
            function i(e) {
                for (var t = [], i = 0, n = e.length; i < n; i++) {
                    var r = e[i]
                      , s = new Ho;
                    s.curves = r.curves,
                    t.push(s)
                }
                return t
            }
            function n(e, t) {
                for (var i = t.length, n = !1, r = i - 1, s = 0; s < i; r = s++) {
                    var a = t[r]
                      , o = t[s]
                      , l = o.x - a.x
                      , c = o.y - a.y;
                    if (Math.abs(c) > Number.EPSILON) {
                        if (c < 0 && (a = t[s],
                        l = -l,
                        o = t[r],
                        c = -c),
                        e.y < a.y || e.y > o.y)
                            continue;
                        if (e.y === a.y) {
                            if (e.x === a.x)
                                return !0
                        } else {
                            var h = c * (e.x - a.x) - l * (e.y - a.y);
                            if (0 === h)
                                return !0;
                            if (h < 0)
                                continue;
                            n = !n
                        }
                    } else {
                        if (e.y !== a.y)
                            continue;
                        if (o.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= o.x)
                            return !0
                    }
                }
                return n
            }
            var r = ya.isClockWise
              , s = this.subPaths;
            if (0 === s.length)
                return [];
            if (!0 === t)
                return i(s);
            var a, o, l, c = [];
            if (1 === s.length)
                return o = s[0],
                (l = new Ho).curves = o.curves,
                c.push(l),
                c;
            var h = !r(s[0].getPoints());
            h = e ? !h : h;
            var u, p, d = [], f = [], m = [], g = 0;
            f[g] = void 0,
            m[g] = [];
            for (var v = 0, y = s.length; v < y; v++)
                a = r(u = (o = s[v]).getPoints()),
                (a = e ? !a : a) ? (!h && f[g] && g++,
                f[g] = {
                    s: new Ho,
                    p: u
                },
                f[g].s.curves = o.curves,
                h && g++,
                m[g] = []) : m[g].push({
                    h: o,
                    p: u[0]
                });
            if (!f[0])
                return i(s);
            if (f.length > 1) {
                for (var b = !1, x = [], w = 0, _ = f.length; w < _; w++)
                    d[w] = [];
                for (w = 0,
                _ = f.length; w < _; w++)
                    for (var T = m[w], M = 0; M < T.length; M++) {
                        for (var S = T[M], A = !0, P = 0; P < f.length; P++)
                            n(S.p, f[P].p) && (w !== P && x.push({
                                froms: w,
                                tos: P,
                                hole: M
                            }),
                            A ? (A = !1,
                            d[P].push(S)) : b = !0);
                        A && d[w].push(S)
                    }
                x.length > 0 && (b || (m = d))
            }
            v = 0;
            for (var C = f.length; v < C; v++) {
                l = f[v].s,
                c.push(l);
                for (var L = 0, k = (p = m[v]).length; L < k; L++)
                    l.holes.push(p[L].h)
            }
            return c
        }
    }),
    Object.assign(wl.prototype, {
        isFont: !0,
        generateShapes: function(e, t) {
            void 0 === t && (t = 100);
            for (var i = [], n = function(e, t, i) {
                for (var n = Array.from ? Array.from(e) : String(e).split(""), r = t / i.resolution, s = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, a = [], o = 0, l = 0, c = 0; c < n.length; c++) {
                    var h = n[c];
                    if ("\n" === h)
                        o = 0,
                        l -= s;
                    else {
                        var u = _l(h, r, o, l, i);
                        o += u.offsetX,
                        a.push(u.path)
                    }
                }
                return a
            }(e, t, this.data), r = 0, s = n.length; r < s; r++)
                Array.prototype.push.apply(i, n[r].toShapes());
            return i
        }
    }),
    Object.assign(function(e) {
        this.manager = void 0 !== e ? e : bo
    }
    .prototype, {
        load: function(e, t, i, n) {
            var r = this
              , s = new wo(this.manager);
            s.setPath(this.path),
            s.load(e, function(e) {
                var i;
                try {
                    i = JSON.parse(e)
                } catch (t) {
                    i = JSON.parse(e.substring(65, e.length - 2))
                }
                var n = r.parse(i);
                t && t(n)
            }, i, n)
        },
        parse: function(e) {
            return new wl(e)
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Tl.Handlers = {
        handlers: [],
        add: function(e, t) {
            this.handlers.push(e, t)
        },
        get: function(e) {
            for (var t = this.handlers, i = 0, n = t.length; i < n; i += 2) {
                var r = t[i]
                  , s = t[i + 1];
                if (r.test(e))
                    return s
            }
            return null
        }
    },
    Object.assign(Tl.prototype, {
        crossOrigin: "anonymous",
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(e, t, i) {
            for (var n = [], r = 0; r < e.length; ++r)
                n[r] = this.createMaterial(e[r], t, i);
            return n
        },
        createMaterial: (ul = {
            NoBlending: b,
            NormalBlending: x,
            AdditiveBlending: w,
            SubtractiveBlending: _,
            MultiplyBlending: T,
            CustomBlending: M
        },
        pl = new hi,
        dl = new So,
        fl = new al,
        function(e, t, i) {
            var n = {};
            function r(e, r, s, a, o) {
                var l, c = t + e, h = Tl.Handlers.get(c);
                null !== h ? l = h.load(c) : (dl.setCrossOrigin(i),
                l = dl.load(c)),
                void 0 !== r && (l.repeat.fromArray(r),
                1 !== r[0] && (l.wrapS = ue),
                1 !== r[1] && (l.wrapT = ue)),
                void 0 !== s && l.offset.fromArray(s),
                void 0 !== a && ("repeat" === a[0] && (l.wrapS = ue),
                "mirror" === a[0] && (l.wrapS = de),
                "repeat" === a[1] && (l.wrapT = ue),
                "mirror" === a[1] && (l.wrapT = de)),
                void 0 !== o && (l.anisotropy = o);
                var u = St.generateUUID();
                return n[u] = l,
                u
            }
            var s = {
                uuid: St.generateUUID(),
                type: "MeshLambertMaterial"
            };
            for (var a in e) {
                var o = e[a];
                switch (a) {
                case "DbgColor":
                case "DbgIndex":
                case "opticalDensity":
                case "illumination":
                    break;
                case "DbgName":
                    s.name = o;
                    break;
                case "blending":
                    s.blending = ul[o];
                    break;
                case "colorAmbient":
                case "mapAmbient":
                    break;
                case "colorDiffuse":
                    s.color = pl.fromArray(o).getHex();
                    break;
                case "colorSpecular":
                    s.specular = pl.fromArray(o).getHex();
                    break;
                case "colorEmissive":
                    s.emissive = pl.fromArray(o).getHex();
                    break;
                case "specularCoef":
                    s.shininess = o;
                    break;
                case "shading":
                    "basic" === o.toLowerCase() && (s.type = "MeshBasicMaterial"),
                    "phong" === o.toLowerCase() && (s.type = "MeshPhongMaterial"),
                    "standard" === o.toLowerCase() && (s.type = "MeshStandardMaterial");
                    break;
                case "mapDiffuse":
                    s.map = r(o, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                    break;
                case "mapDiffuseRepeat":
                case "mapDiffuseOffset":
                case "mapDiffuseWrap":
                case "mapDiffuseAnisotropy":
                    break;
                case "mapEmissive":
                    s.emissiveMap = r(o, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                    break;
                case "mapEmissiveRepeat":
                case "mapEmissiveOffset":
                case "mapEmissiveWrap":
                case "mapEmissiveAnisotropy":
                    break;
                case "mapLight":
                    s.lightMap = r(o, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                    break;
                case "mapLightRepeat":
                case "mapLightOffset":
                case "mapLightWrap":
                case "mapLightAnisotropy":
                    break;
                case "mapAO":
                    s.aoMap = r(o, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                    break;
                case "mapAORepeat":
                case "mapAOOffset":
                case "mapAOWrap":
                case "mapAOAnisotropy":
                    break;
                case "mapBump":
                    s.bumpMap = r(o, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                    break;
                case "mapBumpScale":
                    s.bumpScale = o;
                    break;
                case "mapBumpRepeat":
                case "mapBumpOffset":
                case "mapBumpWrap":
                case "mapBumpAnisotropy":
                    break;
                case "mapNormal":
                    s.normalMap = r(o, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                    break;
                case "mapNormalFactor":
                    s.normalScale = o;
                    break;
                case "mapNormalRepeat":
                case "mapNormalOffset":
                case "mapNormalWrap":
                case "mapNormalAnisotropy":
                    break;
                case "mapSpecular":
                    s.specularMap = r(o, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                    break;
                case "mapSpecularRepeat":
                case "mapSpecularOffset":
                case "mapSpecularWrap":
                case "mapSpecularAnisotropy":
                    break;
                case "mapMetalness":
                    s.metalnessMap = r(o, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                    break;
                case "mapMetalnessRepeat":
                case "mapMetalnessOffset":
                case "mapMetalnessWrap":
                case "mapMetalnessAnisotropy":
                    break;
                case "mapRoughness":
                    s.roughnessMap = r(o, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                    break;
                case "mapRoughnessRepeat":
                case "mapRoughnessOffset":
                case "mapRoughnessWrap":
                case "mapRoughnessAnisotropy":
                    break;
                case "mapAlpha":
                    s.alphaMap = r(o, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                    break;
                case "mapAlphaRepeat":
                case "mapAlphaOffset":
                case "mapAlphaWrap":
                case "mapAlphaAnisotropy":
                    break;
                case "flipSided":
                    s.side = f;
                    break;
                case "doubleSided":
                    s.side = m;
                    break;
                case "transparency":
                    s.opacity = o;
                    break;
                case "depthTest":
                case "depthWrite":
                case "colorWrite":
                case "opacity":
                case "reflectivity":
                case "transparent":
                case "visible":
                case "wireframe":
                    s[a] = o;
                    break;
                case "vertexColors":
                    !0 === o && (s.vertexColors = y),
                    "face" === o && (s.vertexColors = v)
                }
            }
            return "MeshBasicMaterial" === s.type && delete s.emissive,
            "MeshPhongMaterial" !== s.type && delete s.specular,
            s.opacity < 1 && (s.transparent = !0),
            fl.setTextures(n),
            fl.parse(s)
        }
        )
    });
    var Ml = {
        getContext: function() {
            return void 0 === ml && (ml = new (window.AudioContext || window.webkitAudioContext)),
            ml
        },
        setContext: function(e) {
            ml = e
        }
    };
    function Sl(e) {
        this.manager = void 0 !== e ? e : bo
    }
    function Al() {
        this.coefficients = [];
        for (var e = 0; e < 9; e++)
            this.coefficients.push(new Ct)
    }
    function Pl(e, t) {
        Qo.call(this, void 0, t),
        this.sh = void 0 !== e ? e : new Al
    }
    function Cl(e, t, i) {
        Pl.call(this, void 0, i);
        var n = (new hi).set(e)
          , r = (new hi).set(t)
          , s = new Ct(n.r,n.g,n.b)
          , a = new Ct(r.r,r.g,r.b)
          , o = Math.sqrt(Math.PI)
          , l = o * Math.sqrt(.75);
        this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
        this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
    }
    function Ll(e, t) {
        Pl.call(this, void 0, t);
        var i = (new hi).set(e);
        this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    Object.assign(Sl.prototype, {
        load: function(e, t, i, n) {
            var r = new wo(this.manager);
            r.setResponseType("arraybuffer"),
            r.setPath(this.path),
            r.load(e, function(e) {
                var i = e.slice(0);
                Ml.getContext().decodeAudioData(i, function(e) {
                    t(e)
                })
            }, i, n)
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Al.prototype, {
        isSphericalHarmonics3: !0,
        set: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].copy(e[t]);
            return this
        },
        zero: function() {
            for (var e = 0; e < 9; e++)
                this.coefficients[e].set(0, 0, 0);
            return this
        },
        getAt: function(e, t) {
            var i = e.x
              , n = e.y
              , r = e.z
              , s = this.coefficients;
            return t = .282095 * s[0],
            t += .488603 * s[1] * n,
            t += .488603 * s[2] * r,
            t += .488603 * s[3] * i,
            t += 1.092548 * s[4] * (i * n),
            t += 1.092548 * s[5] * (n * r),
            t += .315392 * s[6] * (3 * r * r - 1),
            t += 1.092548 * s[7] * (i * r),
            t += .546274 * s[8] * (i * i - n * n)
        },
        getIrradianceAt: function(e, t) {
            var i = e.x
              , n = e.y
              , r = e.z
              , s = this.coefficients;
            return t = .886227 * s[0],
            t += 2 * s[1] * .511664 * n,
            t += 2 * s[2] * .511664 * r,
            t += 2 * s[3] * .511664 * i,
            t += 2 * s[4] * .429043 * i * n,
            t += 2 * s[5] * .429043 * n * r,
            t += s[6] * (.743125 * r * r - .247708),
            t += 2 * s[7] * .429043 * i * r,
            t += .429043 * s[8] * (i * i - n * n)
        },
        add: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].add(e.coefficients[t]);
            return this
        },
        scale: function(e) {
            for (var t = 0; t < 9; t++)
                this.coefficients[t].multiplyScalar(e);
            return this
        },
        lerp: function(e, t) {
            for (var i = 0; i < 9; i++)
                this.coefficients[i].lerp(e.coefficients[i], t);
            return this
        },
        equals: function(e) {
            for (var t = 0; t < 9; t++)
                if (!this.coefficients[t].equals(e.coefficients[t]))
                    return !1;
            return !0
        },
        copy: function(e) {
            return this.set(e.coefficients)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        fromArray: function(e) {
            for (var t = this.coefficients, i = 0; i < 9; i++)
                t[i].fromArray(e, 3 * i);
            return this
        },
        toArray: function() {
            for (var e = [], t = this.coefficients, i = 0; i < 9; i++)
                t[i].toArray(e, 3 * i);
            return e
        }
    }),
    Object.assign(Al, {
        getBasisAt: function(e, t) {
            var i = e.x
              , n = e.y
              , r = e.z;
            t[0] = .282095,
            t[1] = .488603 * n,
            t[2] = .488603 * r,
            t[3] = .488603 * i,
            t[4] = 1.092548 * i * n,
            t[5] = 1.092548 * n * r,
            t[6] = .315392 * (3 * r * r - 1),
            t[7] = 1.092548 * i * r,
            t[8] = .546274 * (i * i - n * n)
        }
    }),
    Pl.prototype = Object.assign(Object.create(Qo.prototype), {
        constructor: Pl,
        isLightProbe: !0,
        copy: function(e) {
            return Qo.prototype.copy.call(this, e),
            this.sh.copy(e.sh),
            this.intensity = e.intensity,
            this
        },
        toJSON: function(e) {
            return Qo.prototype.toJSON.call(this, e)
        }
    }),
    Cl.prototype = Object.assign(Object.create(Pl.prototype), {
        constructor: Cl,
        isHemisphereLightProbe: !0,
        copy: function(e) {
            return Pl.prototype.copy.call(this, e),
            this
        },
        toJSON: function(e) {
            return Pl.prototype.toJSON.call(this, e)
        }
    }),
    Ll.prototype = Object.assign(Object.create(Pl.prototype), {
        constructor: Ll,
        isAmbientLightProbe: !0,
        copy: function(e) {
            return Pl.prototype.copy.call(this, e),
            this
        },
        toJSON: function(e) {
            return Pl.prototype.toJSON.call(this, e)
        }
    }),
    Object.assign(function() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new Jr,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new Jr,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1
    }
    .prototype, {
        update: function() {
            var e, t, i, n, r, s, a, o, l = new ii, c = new ii;
            return function(h) {
                if (e !== this || t !== h.focus || i !== h.fov || n !== h.aspect * this.aspect || r !== h.near || s !== h.far || a !== h.zoom || o !== this.eyeSep) {
                    e = this,
                    t = h.focus,
                    i = h.fov,
                    n = h.aspect * this.aspect,
                    r = h.near,
                    s = h.far,
                    a = h.zoom;
                    var u, p, d = h.projectionMatrix.clone(), f = (o = this.eyeSep / 2) * r / t, m = r * Math.tan(St.DEG2RAD * i * .5) / a;
                    c.elements[12] = -o,
                    l.elements[12] = o,
                    u = -m * n + f,
                    p = m * n + f,
                    d.elements[0] = 2 * r / (p - u),
                    d.elements[8] = (p + u) / (p - u),
                    this.cameraL.projectionMatrix.copy(d),
                    u = -m * n - f,
                    p = m * n - f,
                    d.elements[0] = 2 * r / (p - u),
                    d.elements[8] = (p + u) / (p - u),
                    this.cameraR.projectionMatrix.copy(d)
                }
                this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(c),
                this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(l)
            }
        }()
    });
    var kl = 90
      , El = 1;
    function Il(e, t, i, n) {
        Mi.call(this),
        this.type = "CubeCamera";
        var r = new Jr(kl,El,e,t);
        r.up.set(0, -1, 0),
        r.lookAt(new Ct(1,0,0)),
        this.add(r);
        var s = new Jr(kl,El,e,t);
        s.up.set(0, -1, 0),
        s.lookAt(new Ct(-1,0,0)),
        this.add(s);
        var a = new Jr(kl,El,e,t);
        a.up.set(0, 0, 1),
        a.lookAt(new Ct(0,1,0)),
        this.add(a);
        var o = new Jr(kl,El,e,t);
        o.up.set(0, 0, -1),
        o.lookAt(new Ct(0,-1,0)),
        this.add(o);
        var l = new Jr(kl,El,e,t);
        l.up.set(0, -1, 0),
        l.lookAt(new Ct(0,0,1)),
        this.add(l);
        var c = new Jr(kl,El,e,t);
        c.up.set(0, -1, 0),
        c.lookAt(new Ct(0,0,-1)),
        this.add(c),
        n = n || {
            format: Fe,
            magFilter: ve,
            minFilter: ve
        },
        this.renderTarget = new Jt(i,i,n),
        this.renderTarget.texture.name = "CubeCamera",
        this.update = function(e, t) {
            null === this.parent && this.updateMatrixWorld();
            var i = e.getRenderTarget()
              , n = this.renderTarget
              , h = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1,
            e.setRenderTarget(n, 0),
            e.render(t, r),
            e.setRenderTarget(n, 1),
            e.render(t, s),
            e.setRenderTarget(n, 2),
            e.render(t, a),
            e.setRenderTarget(n, 3),
            e.render(t, o),
            e.setRenderTarget(n, 4),
            e.render(t, l),
            n.texture.generateMipmaps = h,
            e.setRenderTarget(n, 5),
            e.render(t, c),
            e.setRenderTarget(i)
        }
        ,
        this.clear = function(e, t, i, n) {
            for (var r = e.getRenderTarget(), s = this.renderTarget, a = 0; a < 6; a++)
                e.setRenderTarget(s, a),
                e.clear(t, i, n);
            e.setRenderTarget(r)
        }
    }
    function Fl(e) {
        this.autoStart = void 0 === e || e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    function Ol() {
        Mi.call(this),
        this.type = "AudioListener",
        this.context = Ml.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0
    }
    function Rl(e) {
        Mi.call(this),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.startTime = 0,
        this.offset = 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.sourceType = "empty",
        this.filters = []
    }
    function zl(e) {
        Rl.call(this, e),
        this.panner = this.context.createPanner(),
        this.panner.connect(this.gain)
    }
    function Nl(e, t) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = void 0 !== t ? t : 2048,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    function Dl(e, t, i) {
        this.binding = e,
        this.valueSize = i;
        var n, r = Float64Array;
        switch (t) {
        case "quaternion":
            n = this._slerp;
            break;
        case "string":
        case "bool":
            r = Array,
            n = this._select;
            break;
        default:
            n = this._lerp
        }
        this.buffer = new r(4 * i),
        this._mixBufferRegion = n,
        this.cumulativeWeight = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    Il.prototype = Object.create(Mi.prototype),
    Il.prototype.constructor = Il,
    Object.assign(Fl.prototype, {
        start: function() {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
            this.oldTime = this.startTime,
            this.elapsedTime = 0,
            this.running = !0
        },
        stop: function() {
            this.getElapsedTime(),
            this.running = !1,
            this.autoStart = !1
        },
        getElapsedTime: function() {
            return this.getDelta(),
            this.elapsedTime
        },
        getDelta: function() {
            var e = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                var t = ("undefined" == typeof performance ? Date : performance).now();
                e = (t - this.oldTime) / 1e3,
                this.oldTime = t,
                this.elapsedTime += e
            }
            return e
        }
    }),
    Ol.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: Ol,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null),
            this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(e) {
            return null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = e,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        },
        updateMatrixWorld: function() {
            var e = new Ct
              , t = new Pt
              , i = new Ct
              , n = new Ct
              , r = new Fl;
            return function(s) {
                Mi.prototype.updateMatrixWorld.call(this, s);
                var a = this.context.listener
                  , o = this.up;
                if (this.timeDelta = r.getDelta(),
                this.matrixWorld.decompose(e, t, i),
                n.set(0, 0, -1).applyQuaternion(t),
                a.positionX) {
                    var l = this.context.currentTime + this.timeDelta;
                    a.positionX.linearRampToValueAtTime(e.x, l),
                    a.positionY.linearRampToValueAtTime(e.y, l),
                    a.positionZ.linearRampToValueAtTime(e.z, l),
                    a.forwardX.linearRampToValueAtTime(n.x, l),
                    a.forwardY.linearRampToValueAtTime(n.y, l),
                    a.forwardZ.linearRampToValueAtTime(n.z, l),
                    a.upX.linearRampToValueAtTime(o.x, l),
                    a.upY.linearRampToValueAtTime(o.y, l),
                    a.upZ.linearRampToValueAtTime(o.z, l)
                } else
                    a.setPosition(e.x, e.y, e.z),
                    a.setOrientation(n.x, n.y, n.z, o.x, o.y, o.z)
            }
        }()
    }),
    Rl.prototype = Object.assign(Object.create(Mi.prototype), {
        constructor: Rl,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = e,
            this.connect(),
            this
        },
        setMediaElementSource: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaNode",
            this.source = this.context.createMediaElementSource(e),
            this.connect(),
            this
        },
        setBuffer: function(e) {
            return this.buffer = e,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        },
        play: function() {
            if (!0 !== this.isPlaying && !1 !== this.hasPlaybackControl) {
                var e = this.context.createBufferSource();
                return e.buffer = this.buffer,
                e.loop = this.loop,
                e.onended = this.onEnded.bind(this),
                this.startTime = this.context.currentTime,
                e.start(this.startTime, this.offset, this.duration),
                this.isPlaying = !0,
                this.source = e,
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
            }
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this.source.stop(),
                this.source.onended = null,
                this.offset += (this.context.currentTime - this.startTime) * this.playbackRate,
                this.isPlaying = !1),
                this
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl)
                return this.source && this.isPlaying && (this.source.stop(),
                this.source.onended = null),
                this.offset = 0,
                this.isPlaying = !1,
                this
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(e) {
            return e || (e = []),
            !0 === this.isPlaying ? (this.disconnect(),
            this.filters = e,
            this.connect()) : this.filters = e,
            this
        },
        setDetune: function(e) {
            if (this.detune = e,
            void 0 !== this.source.detune)
                return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                this
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(e) {
            return this.setFilters(e ? [e] : [])
        },
        setPlaybackRate: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = e,
                !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 !== this.hasPlaybackControl && this.loop
        },
        setLoop: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = e,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        }
    }),
    zl.prototype = Object.assign(Object.create(Rl.prototype), {
        constructor: zl,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(e) {
            return this.panner.refDistance = e,
            this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(e) {
            return this.panner.rolloffFactor = e,
            this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(e) {
            return this.panner.distanceModel = e,
            this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(e) {
            return this.panner.maxDistance = e,
            this
        },
        setDirectionalCone: function(e, t, i) {
            return this.panner.coneInnerAngle = e,
            this.panner.coneOuterAngle = t,
            this.panner.coneOuterGain = i,
            this
        },
        updateMatrixWorld: function() {
            var e = new Ct
              , t = new Pt
              , i = new Ct
              , n = new Ct;
            return function(r) {
                if (Mi.prototype.updateMatrixWorld.call(this, r),
                !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                    this.matrixWorld.decompose(e, t, i),
                    n.set(0, 0, 1).applyQuaternion(t);
                    var s = this.panner;
                    if (s.positionX) {
                        var a = this.context.currentTime + this.listener.timeDelta;
                        s.positionX.linearRampToValueAtTime(e.x, a),
                        s.positionY.linearRampToValueAtTime(e.y, a),
                        s.positionZ.linearRampToValueAtTime(e.z, a),
                        s.orientationX.linearRampToValueAtTime(n.x, a),
                        s.orientationY.linearRampToValueAtTime(n.y, a),
                        s.orientationZ.linearRampToValueAtTime(n.z, a)
                    } else
                        s.setPosition(e.x, e.y, e.z),
                        s.setOrientation(n.x, n.y, n.z)
                }
            }
        }()
    }),
    Object.assign(Nl.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        },
        getAverageFrequency: function() {
            for (var e = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++)
                e += t[i];
            return e / t.length
        }
    }),
    Object.assign(Dl.prototype, {
        accumulate: function(e, t) {
            var i = this.buffer
              , n = this.valueSize
              , r = e * n + n
              , s = this.cumulativeWeight;
            if (0 === s) {
                for (var a = 0; a !== n; ++a)
                    i[r + a] = i[a];
                s = t
            } else {
                var o = t / (s += t);
                this._mixBufferRegion(i, r, 0, o, n)
            }
            this.cumulativeWeight = s
        },
        apply: function(e) {
            var t = this.valueSize
              , i = this.buffer
              , n = e * t + t
              , r = this.cumulativeWeight
              , s = this.binding;
            if (this.cumulativeWeight = 0,
            r < 1) {
                var a = 3 * t;
                this._mixBufferRegion(i, n, a, 1 - r, t)
            }
            for (var o = t, l = t + t; o !== l; ++o)
                if (i[o] !== i[o + t]) {
                    s.setValue(i, n);
                    break
                }
        },
        saveOriginalState: function() {
            var e = this.binding
              , t = this.buffer
              , i = this.valueSize
              , n = 3 * i;
            e.getValue(t, n);
            for (var r = i, s = n; r !== s; ++r)
                t[r] = t[n + r % i];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            var e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e)
        },
        _select: function(e, t, i, n, r) {
            if (n >= .5)
                for (var s = 0; s !== r; ++s)
                    e[t + s] = e[i + s]
        },
        _slerp: function(e, t, i, n) {
            Pt.slerpFlat(e, t, e, t, e, i, n)
        },
        _lerp: function(e, t, i, n, r) {
            for (var s = 1 - n, a = 0; a !== r; ++a) {
                var o = t + a;
                e[o] = e[o] * s + e[i + a] * n
            }
        }
    });
    var Ul, Bl, jl, Vl, Gl, Xl, Yl, Wl, ql, Hl, Ql, Jl, Zl, $l, Kl;
    function ec(e, t, i) {
        var n = i || tc.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, n)
    }
    function tc(e, t, i) {
        this.path = t,
        this.parsedPath = i || tc.parseTrackName(t),
        this.node = tc.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e
    }
    function ic(e, t, i) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = i || null;
        for (var n = t.tracks, r = n.length, s = new Array(r), a = {
            endingStart: ht,
            endingEnd: ht
        }, o = 0; o !== r; ++o) {
            var l = n[o].createInterpolant(null);
            s[o] = l,
            l.settings = a
        }
        this._interpolantSettings = a,
        this._interpolants = s,
        this._propertyBindings = new Array(r),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = ct,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    function nc(e) {
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    function rc(e) {
        "string" == typeof e && (e = arguments[1]),
        this.value = e
    }
    function sc() {
        Vi.call(this),
        this.type = "InstancedBufferGeometry",
        this.maxInstancedCount = void 0
    }
    function ac(e, t, i) {
        ds.call(this, e, t),
        this.meshPerAttribute = i || 1
    }
    function oc(e, t, i, n) {
        "number" == typeof i && (n = i,
        i = !1),
        Li.call(this, e, t, i),
        this.meshPerAttribute = n || 1
    }
    function lc(e, t, i, n) {
        this.ray = new un(e,t),
        this.near = i || 0,
        this.far = n || 1 / 0,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return this.Points
                }
            }
        })
    }
    function cc(e, t) {
        return e.distance - t.distance
    }
    function hc(e, t, i, n) {
        if (!1 !== e.visible && (e.raycast(t, i),
        !0 === n))
            for (var r = e.children, s = 0, a = r.length; s < a; s++)
                hc(r[s], t, i, !0)
    }
    function uc(e, t) {
        this.min = void 0 !== e ? e : new At(1 / 0,1 / 0),
        this.max = void 0 !== t ? t : new At(-1 / 0,-1 / 0)
    }
    function pc(e, t) {
        this.start = void 0 !== e ? e : new Ct,
        this.end = void 0 !== t ? t : new Ct
    }
    function dc(e) {
        Mi.call(this),
        this.material = e,
        this.render = function() {}
    }
    function fc(e, t, i, n) {
        this.object = e,
        this.size = void 0 !== t ? t : 1;
        var r = void 0 !== i ? i : 16711680
          , s = void 0 !== n ? n : 1
          , a = 0
          , o = this.object.geometry;
        o && o.isGeometry ? a = 3 * o.faces.length : o && o.isBufferGeometry && (a = o.attributes.normal.count);
        var l = new Vi
          , c = new Ni(2 * a * 3,3);
        l.addAttribute("position", c),
        Ts.call(this, l, new ws({
            color: r,
            linewidth: s
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function mc(e, t) {
        Mi.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = t;
        for (var i = new Vi, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, s = 1; r < 32; r++,
        s++) {
            var a = r / 32 * Math.PI * 2
              , o = s / 32 * Math.PI * 2;
            n.push(Math.cos(a), Math.sin(a), 1, Math.cos(o), Math.sin(o), 1)
        }
        i.addAttribute("position", new Ni(n,3));
        var l = new ws({
            fog: !1
        });
        this.cone = new Ts(i,l),
        this.add(this.cone),
        this.update()
    }
    function gc(e) {
        for (var t = function e(t) {
            var i = [];
            t && t.isBone && i.push(t);
            for (var n = 0; n < t.children.length; n++)
                i.push.apply(i, e(t.children[n]));
            return i
        }(e), i = new Vi, n = [], r = [], s = new hi(0,0,1), a = new hi(0,1,0), o = 0; o < t.length; o++) {
            var l = t[o];
            l.parent && l.parent.isBone && (n.push(0, 0, 0),
            n.push(0, 0, 0),
            r.push(s.r, s.g, s.b),
            r.push(a.r, a.g, a.b))
        }
        i.addAttribute("position", new Ni(n,3)),
        i.addAttribute("color", new Ni(r,3));
        var c = new ws({
            vertexColors: y,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        Ts.call(this, i, c),
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    function vc(e, t, i) {
        this.light = e,
        this.light.updateMatrixWorld(),
        this.color = i;
        var n = new Ca(t,4,2)
          , r = new dn({
            wireframe: !0,
            fog: !1
        });
        fn.call(this, n, r),
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function yc(e, t) {
        this.type = "RectAreaLightHelper",
        this.light = e,
        this.color = t;
        var i = new Vi;
        i.addAttribute("position", new Ni([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],3)),
        i.computeBoundingSphere();
        var n = new ws({
            fog: !1
        });
        _s.call(this, i, n);
        var r = new Vi;
        r.addAttribute("position", new Ni([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],3)),
        r.computeBoundingSphere(),
        this.add(new fn(r,new dn({
            side: f,
            fog: !1
        }))),
        this.update()
    }
    function bc(e, t, i) {
        Mi.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i;
        var n = new Us(t);
        n.rotateY(.5 * Math.PI),
        this.material = new dn({
            wireframe: !0,
            fog: !1
        }),
        void 0 === this.color && (this.material.vertexColors = y);
        var r = n.getAttribute("position")
          , s = new Float32Array(3 * r.count);
        n.addAttribute("color", new Li(s,3)),
        this.add(new fn(n,this.material)),
        this.update()
    }
    function xc(e, t) {
        this.lightProbe = e,
        this.size = t;
        var i = {
            GAMMA_OUTPUT: ""
        }
          , n = new hn({
            defines: i,
            uniforms: {
                sh: {
                    value: this.lightProbe.sh.coefficients
                },
                intensity: {
                    value: this.lightProbe.intensity
                }
            },
            vertexShader: ["varying vec3 vNormal;", "void main() {", "\tvNormal = normalize( normalMatrix * normal );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["#define RECIPROCAL_PI 0.318309886", "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {", "\t// matrix is assumed to be orthogonal", "\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );", "}", "vec3 linearToOutput( in vec3 a ) {", "\t#ifdef GAMMA_OUTPUT", "\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );", "\t#else", "\t\treturn a;", "\t#endif", "}", "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf", "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {", "\t// normal is assumed to have unit length", "\tfloat x = normal.x, y = normal.y, z = normal.z;", "\t// band 0", "\tvec3 result = shCoefficients[ 0 ] * 0.886227;", "\t// band 1", "\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;", "\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;", "\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;", "\t// band 2", "\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;", "\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;", "\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );", "\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;", "\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );", "\treturn result;", "}", "uniform vec3 sh[ 9 ]; // sh coefficients", "uniform float intensity; // light probe intensity", "varying vec3 vNormal;", "void main() {", "\tvec3 normal = normalize( vNormal );", "\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", "\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );", "\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;", "\toutgoingLight = linearToOutput( outgoingLight );", "\tgl_FragColor = vec4( outgoingLight, 1.0 );", "}"].join("\n")
        })
          , r = new Ca(1,32,16);
        fn.call(this, r, n),
        this.onBeforeRender()
    }
    function wc(e, t, i, n) {
        e = e || 10,
        t = t || 10,
        i = new hi(void 0 !== i ? i : 4473924),
        n = new hi(void 0 !== n ? n : 8947848);
        for (var r = t / 2, s = e / t, a = e / 2, o = [], l = [], c = 0, h = 0, u = -a; c <= t; c++,
        u += s) {
            o.push(-a, 0, u, a, 0, u),
            o.push(u, 0, -a, u, 0, a);
            var p = c === r ? i : n;
            p.toArray(l, h),
            h += 3,
            p.toArray(l, h),
            h += 3,
            p.toArray(l, h),
            h += 3,
            p.toArray(l, h),
            h += 3
        }
        var d = new Vi;
        d.addAttribute("position", new Ni(o,3)),
        d.addAttribute("color", new Ni(l,3));
        var f = new ws({
            vertexColors: y
        });
        Ts.call(this, d, f)
    }
    function _c(e, t, i, n, r, s) {
        e = e || 10,
        t = t || 16,
        i = i || 8,
        n = n || 64,
        r = new hi(void 0 !== r ? r : 4473924),
        s = new hi(void 0 !== s ? s : 8947848);
        var a, o, l, c, h, u, p, d = [], f = [];
        for (c = 0; c <= t; c++)
            l = c / t * (2 * Math.PI),
            a = Math.sin(l) * e,
            o = Math.cos(l) * e,
            d.push(0, 0, 0),
            d.push(a, 0, o),
            p = 1 & c ? r : s,
            f.push(p.r, p.g, p.b),
            f.push(p.r, p.g, p.b);
        for (c = 0; c <= i; c++)
            for (p = 1 & c ? r : s,
            u = e - e / i * c,
            h = 0; h < n; h++)
                l = h / n * (2 * Math.PI),
                a = Math.sin(l) * u,
                o = Math.cos(l) * u,
                d.push(a, 0, o),
                f.push(p.r, p.g, p.b),
                l = (h + 1) / n * (2 * Math.PI),
                a = Math.sin(l) * u,
                o = Math.cos(l) * u,
                d.push(a, 0, o),
                f.push(p.r, p.g, p.b);
        var m = new Vi;
        m.addAttribute("position", new Ni(d,3)),
        m.addAttribute("color", new Ni(f,3));
        var g = new ws({
            vertexColors: y
        });
        Ts.call(this, m, g)
    }
    function Tc(e, t, i, n) {
        this.audio = e,
        this.range = t || 1,
        this.divisionsInnerAngle = i || 16,
        this.divisionsOuterAngle = n || 2;
        var r = new Vi
          , s = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle
          , a = new Float32Array(3 * (3 * s + 3));
        r.addAttribute("position", new Li(a,3));
        var o = new ws({
            color: 65280
        })
          , l = new ws({
            color: 16776960
        });
        _s.call(this, r, [l, o]),
        this.update()
    }
    function Mc(e, t, i, n) {
        this.object = e,
        this.size = void 0 !== t ? t : 1;
        var r = void 0 !== i ? i : 16776960
          , s = void 0 !== n ? n : 1
          , a = 0
          , o = this.object.geometry;
        o && o.isGeometry && (a = o.faces.length);
        var l = new Vi
          , c = new Ni(2 * a * 3,3);
        l.addAttribute("position", c),
        Ts.call(this, l, new ws({
            color: r,
            linewidth: s
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Sc(e, t, i) {
        Mi.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        void 0 === t && (t = 1);
        var n = new Vi;
        n.addAttribute("position", new Ni([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        var r = new ws({
            fog: !1
        });
        this.lightPlane = new _s(n,r),
        this.add(this.lightPlane),
        (n = new Vi).addAttribute("position", new Ni([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new _s(n,r),
        this.add(this.targetLine),
        this.update()
    }
    function Ac(e) {
        var t = new Vi
          , i = new ws({
            color: 16777215,
            vertexColors: v
        })
          , n = []
          , r = []
          , s = {}
          , a = new hi(16755200)
          , o = new hi(16711680)
          , l = new hi(43775)
          , c = new hi(16777215)
          , h = new hi(3355443);
        function u(e, t, i) {
            p(e, i),
            p(t, i)
        }
        function p(e, t) {
            n.push(0, 0, 0),
            r.push(t.r, t.g, t.b),
            void 0 === s[e] && (s[e] = []),
            s[e].push(n.length / 3 - 1)
        }
        u("n1", "n2", a),
        u("n2", "n4", a),
        u("n4", "n3", a),
        u("n3", "n1", a),
        u("f1", "f2", a),
        u("f2", "f4", a),
        u("f4", "f3", a),
        u("f3", "f1", a),
        u("n1", "f1", a),
        u("n2", "f2", a),
        u("n3", "f3", a),
        u("n4", "f4", a),
        u("p", "n1", o),
        u("p", "n2", o),
        u("p", "n3", o),
        u("p", "n4", o),
        u("u1", "u2", l),
        u("u2", "u3", l),
        u("u3", "u1", l),
        u("c", "t", c),
        u("p", "c", h),
        u("cn1", "cn2", h),
        u("cn3", "cn4", h),
        u("cf1", "cf2", h),
        u("cf3", "cf4", h),
        t.addAttribute("position", new Ni(n,3)),
        t.addAttribute("color", new Ni(r,3)),
        Ts.call(this, t, i),
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = s,
        this.update()
    }
    function Pc(e, t) {
        this.object = e,
        void 0 === t && (t = 16776960);
        var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , n = new Float32Array(24)
          , r = new Vi;
        r.setIndex(new Li(i,1)),
        r.addAttribute("position", new Li(n,3)),
        Ts.call(this, r, new ws({
            color: t
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Cc(e, t) {
        this.type = "Box3Helper",
        this.box = e;
        var i = void 0 !== t ? t : 16776960
          , n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = new Vi;
        r.setIndex(new Li(n,1)),
        r.addAttribute("position", new Ni([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
        Ts.call(this, r, new ws({
            color: i
        })),
        this.geometry.computeBoundingSphere()
    }
    function Lc(e, t, i) {
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = void 0 === t ? 1 : t;
        var n = void 0 !== i ? i : 16776960
          , r = new Vi;
        r.addAttribute("position", new Ni([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],3)),
        r.computeBoundingSphere(),
        _s.call(this, r, new ws({
            color: n
        }));
        var s = new Vi;
        s.addAttribute("position", new Ni([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],3)),
        s.computeBoundingSphere(),
        this.add(new fn(s,new dn({
            color: n,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }
    function kc(e, t, i, n, r, s) {
        Mi.call(this),
        void 0 === e && (e = new Ct(0,0,1)),
        void 0 === t && (t = new Ct(0,0,0)),
        void 0 === i && (i = 1),
        void 0 === n && (n = 16776960),
        void 0 === r && (r = .2 * i),
        void 0 === s && (s = .2 * r),
        void 0 === Jl && ((Jl = new Vi).addAttribute("position", new Ni([0, 0, 0, 0, 1, 0],3)),
        (Zl = new Da(0,.5,1,5,1)).translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new _s(Jl,new ws({
            color: n
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new fn(Zl,new dn({
            color: n
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(i, r, s)
    }
    function Ec(e) {
        var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , i = new Vi;
        i.addAttribute("position", new Ni(t,3)),
        i.addAttribute("color", new Ni([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3));
        var n = new ws({
            vertexColors: y
        });
        Ts.call(this, i, n)
    }
    Object.assign(ec.prototype, {
        getValue: function(e, t) {
            this.bind();
            var i = this._targetGroup.nCachedObjects_
              , n = this._bindings[i];
            void 0 !== n && n.getValue(e, t)
        },
        setValue: function(e, t) {
            for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
                i[n].setValue(e, t)
        },
        bind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
                e[t].bind()
        },
        unbind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
                e[t].unbind()
        }
    }),
    Object.assign(tc, {
        Composite: ec,
        create: function(e, t, i) {
            return e && e.isAnimationObjectGroup ? new tc.Composite(e,t,i) : new tc(e,t,i)
        },
        sanitizeNodeName: (ql = new RegExp("[\\[\\]\\.:\\/]","g"),
        function(e) {
            return e.replace(/\s/g, "_").replace(ql, "")
        }
        ),
        parseTrackName: (Ul = "[^\\[\\]\\.:\\/]",
        Bl = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        jl = /((?:WC+[\/:])*)/.source.replace("WC", Ul),
        Vl = /(WCOD+)?/.source.replace("WCOD", Bl),
        Gl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Ul),
        Xl = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Ul),
        Yl = new RegExp("^" + jl + Vl + Gl + Xl + "$"),
        Wl = ["material", "materials", "bones"],
        function(e) {
            var t = Yl.exec(e);
            if (!t)
                throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            var i = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            }
              , n = i.nodeName && i.nodeName.lastIndexOf(".");
            if (void 0 !== n && -1 !== n) {
                var r = i.nodeName.substring(n + 1);
                -1 !== Wl.indexOf(r) && (i.nodeName = i.nodeName.substring(0, n),
                i.objectName = r)
            }
            if (null === i.propertyName || 0 === i.propertyName.length)
                throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return i
        }
        ),
        findNode: function(e, t) {
            if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                return e;
            if (e.skeleton) {
                var i = e.skeleton.getBoneByName(t);
                if (void 0 !== i)
                    return i
            }
            if (e.children) {
                var n = function(e) {
                    for (var i = 0; i < e.length; i++) {
                        var r = e[i];
                        if (r.name === t || r.uuid === t)
                            return r;
                        var s = n(r.children);
                        if (s)
                            return s
                    }
                    return null
                }
                  , r = n(e.children);
                if (r)
                    return r
            }
            return null
        }
    }),
    Object.assign(tc.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(e, t) {
            e[t] = this.node[this.propertyName]
        }
        , function(e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                e[t++] = i[n]
        }
        , function(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
        , function(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                i[n] = e[t++]
        }
        , function(e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                i[n] = e[t++];
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                i[n] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(e, t) {
            this.bind(),
            this.getValue(e, t)
        },
        setValue: function(e, t) {
            this.bind(),
            this.setValue(e, t)
        },
        bind: function() {
            var e = this.node
              , t = this.parsedPath
              , i = t.objectName
              , n = t.propertyName
              , r = t.propertyIndex;
            if (e || (e = tc.findNode(this.rootNode, t.nodeName) || this.rootNode,
            this.node = e),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            e) {
                if (i) {
                    var s = t.objectIndex;
                    switch (i) {
                    case "materials":
                        if (!e.material)
                            return;
                        if (!e.material.materials)
                            return;
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton)
                            return;
                        e = e.skeleton.bones;
                        for (var a = 0; a < e.length; a++)
                            if (e[a].name === s) {
                                s = a;
                                break
                            }
                        break;
                    default:
                        if (void 0 === e[i])
                            return;
                        e = e[i]
                    }
                    if (void 0 !== s) {
                        if (void 0 === e[s])
                            return;
                        e = e[s]
                    }
                }
                var o = e[n];
                if (void 0 !== o) {
                    var l = this.Versioning.None;
                    this.targetObject = e,
                    void 0 !== e.needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                    var c = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!e.geometry)
                                return;
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes)
                                    return;
                                for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                    if (e.geometry.morphAttributes.position[a].name === r) {
                                        r = a;
                                        break
                                    }
                            } else {
                                if (!e.geometry.morphTargets)
                                    return;
                                for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                    if (e.geometry.morphTargets[a].name === r) {
                                        r = a;
                                        break
                                    }
                            }
                        }
                        c = this.BindingType.ArrayElement,
                        this.resolvedProperty = o,
                        this.propertyIndex = r
                    } else
                        void 0 !== o.fromArray && void 0 !== o.toArray ? (c = this.BindingType.HasFromToArray,
                        this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray,
                        this.resolvedProperty = o) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[c],
                    this.setValue = this.SetterByBindingTypeAndVersioning[c][l]
                } else
                    t.nodeName
            }
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    Object.assign(tc.prototype, {
        _getValue_unbound: tc.prototype.getValue,
        _setValue_unbound: tc.prototype.setValue
    }),
    Object.assign(function() {
        this.uuid = St.generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, i = arguments.length; t !== i; ++t)
            e[arguments[t].uuid] = t;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        var n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                },
                get inUse() {
                    return this.total - n.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }
    .prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, s = this._parsedPaths, a = this._bindings, o = a.length, l = 0, c = arguments.length; l !== c; ++l) {
                var h = arguments[l]
                  , u = h.uuid
                  , p = n[u];
                if (void 0 === p) {
                    p = t++,
                    n[u] = p,
                    e.push(h);
                    for (var d = 0, f = o; d !== f; ++d)
                        a[d].push(new tc(h,r[d],s[d]))
                } else if (p < i) {
                    e[p];
                    var m = --i
                      , g = e[m];
                    n[g.uuid] = p,
                    e[p] = g,
                    n[u] = m,
                    e[m] = h;
                    for (d = 0,
                    f = o; d !== f; ++d) {
                        var v = a[d]
                          , y = v[m]
                          , b = v[p];
                        v[p] = y,
                        void 0 === b && (b = new tc(h,r[d],s[d])),
                        v[m] = b
                    }
                } else
                    e[p]
            }
            this.nCachedObjects_ = i
        },
        remove: function() {
            for (var e = this._objects, t = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, s = 0, a = arguments.length; s !== a; ++s) {
                var o = arguments[s]
                  , l = o.uuid
                  , c = i[l];
                if (void 0 !== c && c >= t) {
                    var h = t++
                      , u = e[h];
                    i[u.uuid] = c,
                    e[c] = u,
                    i[l] = h,
                    e[h] = o;
                    for (var p = 0, d = r; p !== d; ++p) {
                        var f = n[p]
                          , m = f[h]
                          , g = f[c];
                        f[c] = m,
                        f[h] = g
                    }
                }
            }
            this.nCachedObjects_ = t
        },
        uncache: function() {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, s = r.length, a = 0, o = arguments.length; a !== o; ++a) {
                var l = arguments[a]
                  , c = l.uuid
                  , h = n[c];
                if (void 0 !== h)
                    if (delete n[c],
                    h < i) {
                        var u = --i
                          , p = e[u]
                          , d = e[y = --t];
                        n[p.uuid] = h,
                        e[h] = p,
                        n[d.uuid] = u,
                        e[u] = d,
                        e.pop();
                        for (var f = 0, m = s; f !== m; ++f) {
                            var g = (b = r[f])[u]
                              , v = b[y];
                            b[h] = g,
                            b[u] = v,
                            b.pop()
                        }
                    } else {
                        var y;
                        n[(d = e[y = --t]).uuid] = h,
                        e[h] = d,
                        e.pop();
                        for (f = 0,
                        m = s; f !== m; ++f) {
                            var b;
                            (b = r[f])[h] = b[y],
                            b.pop()
                        }
                    }
            }
            this.nCachedObjects_ = i
        },
        subscribe_: function(e, t) {
            var i = this._bindingsIndicesByPath
              , n = i[e]
              , r = this._bindings;
            if (void 0 !== n)
                return r[n];
            var s = this._paths
              , a = this._parsedPaths
              , o = this._objects
              , l = o.length
              , c = this.nCachedObjects_
              , h = new Array(l);
            n = r.length,
            i[e] = n,
            s.push(e),
            a.push(t),
            r.push(h);
            for (var u = c, p = o.length; u !== p; ++u) {
                var d = o[u];
                h[u] = new tc(d,e,t)
            }
            return h
        },
        unsubscribe_: function(e) {
            var t = this._bindingsIndicesByPath
              , i = t[e];
            if (void 0 !== i) {
                var n = this._paths
                  , r = this._parsedPaths
                  , s = this._bindings
                  , a = s.length - 1
                  , o = s[a];
                t[e[a]] = i,
                s[i] = o,
                s.pop(),
                r[i] = r[a],
                r.pop(),
                n[i] = n[a],
                n.pop()
            }
        }
    }),
    Object.assign(ic.prototype, {
        play: function() {
            return this._mixer._activateAction(this),
            this
        },
        stop: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        },
        reset: function() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(e) {
            return this._startTime = e,
            this
        },
        setLoop: function(e, t) {
            return this.loop = e,
            this.repetitions = t,
            this
        },
        setEffectiveWeight: function(e) {
            return this.weight = e,
            this._effectiveWeight = this.enabled ? e : 0,
            this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(e) {
            return this._scheduleFading(e, 0, 1)
        },
        fadeOut: function(e) {
            return this._scheduleFading(e, 1, 0)
        },
        crossFadeFrom: function(e, t, i) {
            if (e.fadeOut(t),
            this.fadeIn(t),
            i) {
                var n = this._clip.duration
                  , r = e._clip.duration
                  , s = r / n
                  , a = n / r;
                e.warp(1, s, t),
                this.warp(a, 1, t)
            }
            return this
        },
        crossFadeTo: function(e, t, i) {
            return e.crossFadeFrom(this, t, i)
        },
        stopFading: function() {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        },
        setEffectiveTimeScale: function(e) {
            return this.timeScale = e,
            this._effectiveTimeScale = this.paused ? 0 : e,
            this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(e) {
            return this.timeScale = this._clip.duration / e,
            this.stopWarping()
        },
        syncWith: function(e) {
            return this.time = e.time,
            this.timeScale = e.timeScale,
            this.stopWarping()
        },
        halt: function(e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        },
        warp: function(e, t, i) {
            var n = this._mixer
              , r = n.time
              , s = this._timeScaleInterpolant
              , a = this.timeScale;
            null === s && (s = n._lendControlInterpolant(),
            this._timeScaleInterpolant = s);
            var o = s.parameterPositions
              , l = s.sampleValues;
            return o[0] = r,
            o[1] = r + i,
            l[0] = e / a,
            l[1] = t / a,
            this
        },
        stopWarping: function() {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(e, t, i, n) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    var s = (e - r) * i;
                    if (s < 0 || 0 === i)
                        return;
                    this._startTime = null,
                    t = i * s
                }
                t *= this._updateTimeScale(e);
                var a = this._updateTime(t)
                  , o = this._updateWeight(e);
                if (o > 0)
                    for (var l = this._interpolants, c = this._propertyBindings, h = 0, u = l.length; h !== u; ++h)
                        l[h].evaluate(a),
                        c[h].accumulate(n, o)
            } else
                this._updateWeight(e)
        },
        _updateWeight: function(e) {
            var t = 0;
            if (this.enabled) {
                t = this.weight;
                var i = this._weightInterpolant;
                if (null !== i) {
                    var n = i.evaluate(e)[0];
                    t *= n,
                    e > i.parameterPositions[1] && (this.stopFading(),
                    0 === n && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t,
            t
        },
        _updateTimeScale: function(e) {
            var t = 0;
            if (!this.paused) {
                t = this.timeScale;
                var i = this._timeScaleInterpolant;
                if (null !== i)
                    t *= i.evaluate(e)[0],
                    e > i.parameterPositions[1] && (this.stopWarping(),
                    0 === t ? this.paused = !0 : this.timeScale = t)
            }
            return this._effectiveTimeScale = t,
            t
        },
        _updateTime: function(e) {
            var t = this.time + e
              , i = this._clip.duration
              , n = this.loop
              , r = this._loopCount
              , s = 2202 === n;
            if (0 === e)
                return -1 === r ? t : s && 1 == (1 & r) ? i - t : t;
            if (2200 === n) {
                -1 === r && (this._loopCount = 0,
                this._setEndings(!0, !0, !1));
                e: {
                    if (t >= i)
                        t = i;
                    else {
                        if (!(t < 0))
                            break e;
                        t = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === r && (e >= 0 ? (r = 0,
                this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)),
                t >= i || t < 0) {
                    var a = Math.floor(t / i);
                    t -= i * a,
                    r += Math.abs(a);
                    var o = this.repetitions - r;
                    if (o <= 0)
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        t = e > 0 ? i : 0,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                    else {
                        if (1 === o) {
                            var l = e < 0;
                            this._setEndings(l, !l, s)
                        } else
                            this._setEndings(!1, !1, s);
                        this._loopCount = r,
                        this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: a
                        })
                    }
                }
                if (s && 1 == (1 & r))
                    return this.time = t,
                    i - t
            }
            return this.time = t,
            t
        },
        _setEndings: function(e, t, i) {
            var n = this._interpolantSettings;
            i ? (n.endingStart = 2401,
            n.endingEnd = 2401) : (n.endingStart = e ? this.zeroSlopeAtStart ? 2401 : ht : 2402,
            n.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : ht : 2402)
        },
        _scheduleFading: function(e, t, i) {
            var n = this._mixer
              , r = n.time
              , s = this._weightInterpolant;
            null === s && (s = n._lendControlInterpolant(),
            this._weightInterpolant = s);
            var a = s.parameterPositions
              , o = s.sampleValues;
            return a[0] = r,
            o[0] = t,
            a[1] = r + e,
            o[1] = i,
            this
        }
    }),
    nc.prototype = Object.assign(Object.create(n.prototype), {
        constructor: nc,
        _bindAction: function(e, t) {
            var i = e._localRoot || this._root
              , n = e._clip.tracks
              , r = n.length
              , s = e._propertyBindings
              , a = e._interpolants
              , o = i.uuid
              , l = this._bindingsByRootAndName
              , c = l[o];
            void 0 === c && (c = {},
            l[o] = c);
            for (var h = 0; h !== r; ++h) {
                var u = n[h]
                  , p = u.name
                  , d = c[p];
                if (void 0 !== d)
                    s[h] = d;
                else {
                    if (void 0 !== (d = s[h])) {
                        null === d._cacheIndex && (++d.referenceCount,
                        this._addInactiveBinding(d, o, p));
                        continue
                    }
                    var f = t && t._propertyBindings[h].binding.parsedPath;
                    ++(d = new Dl(tc.create(i, p, f),u.ValueTypeName,u.getValueSize())).referenceCount,
                    this._addInactiveBinding(d, o, p),
                    s[h] = d
                }
                a[h].resultBuffer = d.buffer
            }
        },
        _activateAction: function(e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    var t = (e._localRoot || this._root).uuid
                      , i = e._clip.uuid
                      , n = this._actionsByClip[i];
                    this._bindAction(e, n && n.knownActions[0]),
                    this._addInactiveAction(e, i, t)
                }
                for (var r = e._propertyBindings, s = 0, a = r.length; s !== a; ++s) {
                    var o = r[s];
                    0 == o.useCount++ && (this._lendBinding(o),
                    o.saveOriginalState())
                }
                this._lendAction(e)
            }
        },
        _deactivateAction: function(e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
                    var r = t[i];
                    0 == --r.useCount && (r.restoreOriginalState(),
                    this._takeBackBinding(r))
                }
                this._takeBackAction(e)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(e) {
            var t = e._cacheIndex;
            return null !== t && t < this._nActiveActions
        },
        _addInactiveAction: function(e, t, i) {
            var n = this._actions
              , r = this._actionsByClip
              , s = r[t];
            if (void 0 === s)
                s = {
                    knownActions: [e],
                    actionByRoot: {}
                },
                e._byClipCacheIndex = 0,
                r[t] = s;
            else {
                var a = s.knownActions;
                e._byClipCacheIndex = a.length,
                a.push(e)
            }
            e._cacheIndex = n.length,
            n.push(e),
            s.actionByRoot[i] = e
        },
        _removeInactiveAction: function(e) {
            var t = this._actions
              , i = t[t.length - 1]
              , n = e._cacheIndex;
            i._cacheIndex = n,
            t[n] = i,
            t.pop(),
            e._cacheIndex = null;
            var r = e._clip.uuid
              , s = this._actionsByClip
              , a = s[r]
              , o = a.knownActions
              , l = o[o.length - 1]
              , c = e._byClipCacheIndex;
            l._byClipCacheIndex = c,
            o[c] = l,
            o.pop(),
            e._byClipCacheIndex = null,
            delete a.actionByRoot[(e._localRoot || this._root).uuid],
            0 === o.length && delete s[r],
            this._removeInactiveBindingsForAction(e)
        },
        _removeInactiveBindingsForAction: function(e) {
            for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
                var r = t[i];
                0 == --r.referenceCount && this._removeInactiveBinding(r)
            }
        },
        _lendAction: function(e) {
            var t = this._actions
              , i = e._cacheIndex
              , n = this._nActiveActions++
              , r = t[n];
            e._cacheIndex = n,
            t[n] = e,
            r._cacheIndex = i,
            t[i] = r
        },
        _takeBackAction: function(e) {
            var t = this._actions
              , i = e._cacheIndex
              , n = --this._nActiveActions
              , r = t[n];
            e._cacheIndex = n,
            t[n] = e,
            r._cacheIndex = i,
            t[i] = r
        },
        _addInactiveBinding: function(e, t, i) {
            var n = this._bindingsByRootAndName
              , r = n[t]
              , s = this._bindings;
            void 0 === r && (r = {},
            n[t] = r),
            r[i] = e,
            e._cacheIndex = s.length,
            s.push(e)
        },
        _removeInactiveBinding: function(e) {
            var t = this._bindings
              , i = e.binding
              , n = i.rootNode.uuid
              , r = i.path
              , s = this._bindingsByRootAndName
              , a = s[n]
              , o = t[t.length - 1]
              , l = e._cacheIndex;
            o._cacheIndex = l,
            t[l] = o,
            t.pop(),
            delete a[r];
            e: {
                for (var c in a)
                    break e;
                delete s[n]
            }
        },
        _lendBinding: function(e) {
            var t = this._bindings
              , i = e._cacheIndex
              , n = this._nActiveBindings++
              , r = t[n];
            e._cacheIndex = n,
            t[n] = e,
            r._cacheIndex = i,
            t[i] = r
        },
        _takeBackBinding: function(e) {
            var t = this._bindings
              , i = e._cacheIndex
              , n = --this._nActiveBindings
              , r = t[n];
            e._cacheIndex = n,
            t[n] = e,
            r._cacheIndex = i,
            t[i] = r
        },
        _lendControlInterpolant: function() {
            var e = this._controlInterpolants
              , t = this._nActiveControlInterpolants++
              , i = e[t];
            return void 0 === i && ((i = new ro(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex = t,
            e[t] = i),
            i
        },
        _takeBackControlInterpolant: function(e) {
            var t = this._controlInterpolants
              , i = e.__cacheIndex
              , n = --this._nActiveControlInterpolants
              , r = t[n];
            e.__cacheIndex = n,
            t[n] = e,
            r.__cacheIndex = i,
            t[i] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(e, t) {
            var i = t || this._root
              , n = i.uuid
              , r = "string" == typeof e ? mo.findByName(i, e) : e
              , s = null !== r ? r.uuid : e
              , a = this._actionsByClip[s]
              , o = null;
            if (void 0 !== a) {
                var l = a.actionByRoot[n];
                if (void 0 !== l)
                    return l;
                o = a.knownActions[0],
                null === r && (r = o._clip)
            }
            if (null === r)
                return null;
            var c = new ic(this,r,t);
            return this._bindAction(c, o),
            this._addInactiveAction(c, s, n),
            c
        },
        existingAction: function(e, t) {
            var i = t || this._root
              , n = i.uuid
              , r = "string" == typeof e ? mo.findByName(i, e) : e
              , s = r ? r.uuid : e
              , a = this._actionsByClip[s];
            return void 0 !== a && a.actionByRoot[n] || null
        },
        stopAllAction: function() {
            var e = this._actions
              , t = this._nActiveActions
              , i = this._bindings
              , n = this._nActiveBindings;
            this._nActiveActions = 0,
            this._nActiveBindings = 0;
            for (var r = 0; r !== t; ++r)
                e[r].reset();
            for (r = 0; r !== n; ++r)
                i[r].useCount = 0;
            return this
        },
        update: function(e) {
            e *= this.timeScale;
            for (var t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), s = this._accuIndex ^= 1, a = 0; a !== i; ++a) {
                t[a]._update(n, e, r, s)
            }
            var o = this._bindings
              , l = this._nActiveBindings;
            for (a = 0; a !== l; ++a)
                o[a].apply(s);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(e) {
            var t = this._actions
              , i = e.uuid
              , n = this._actionsByClip
              , r = n[i];
            if (void 0 !== r) {
                for (var s = r.knownActions, a = 0, o = s.length; a !== o; ++a) {
                    var l = s[a];
                    this._deactivateAction(l);
                    var c = l._cacheIndex
                      , h = t[t.length - 1];
                    l._cacheIndex = null,
                    l._byClipCacheIndex = null,
                    h._cacheIndex = c,
                    t[c] = h,
                    t.pop(),
                    this._removeInactiveBindingsForAction(l)
                }
                delete n[i]
            }
        },
        uncacheRoot: function(e) {
            var t = e.uuid
              , i = this._actionsByClip;
            for (var n in i) {
                var r = i[n].actionByRoot[t];
                void 0 !== r && (this._deactivateAction(r),
                this._removeInactiveAction(r))
            }
            var s = this._bindingsByRootAndName[t];
            if (void 0 !== s)
                for (var a in s) {
                    var o = s[a];
                    o.restoreOriginalState(),
                    this._removeInactiveBinding(o)
                }
        },
        uncacheAction: function(e, t) {
            var i = this.existingAction(e, t);
            null !== i && (this._deactivateAction(i),
            this._removeInactiveAction(i))
        }
    }),
    rc.prototype.clone = function() {
        return new rc(void 0 === this.value.clone ? this.value : this.value.clone())
    }
    ,
    sc.prototype = Object.assign(Object.create(Vi.prototype), {
        constructor: sc,
        isInstancedBufferGeometry: !0,
        copy: function(e) {
            return Vi.prototype.copy.call(this, e),
            this.maxInstancedCount = e.maxInstancedCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    ac.prototype = Object.assign(Object.create(ds.prototype), {
        constructor: ac,
        isInstancedInterleavedBuffer: !0,
        copy: function(e) {
            return ds.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        }
    }),
    oc.prototype = Object.assign(Object.create(Li.prototype), {
        constructor: oc,
        isInstancedBufferAttribute: !0,
        copy: function(e) {
            return Li.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        }
    }),
    Object.assign(lc.prototype, {
        linePrecision: 1,
        set: function(e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function(e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
            this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera && (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
            this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld))
        },
        intersectObject: function(e, t, i) {
            var n = i || [];
            return hc(e, this, n, t),
            n.sort(cc),
            n
        },
        intersectObjects: function(e, t, i) {
            var n = i || [];
            if (!1 === Array.isArray(e))
                return n;
            for (var r = 0, s = e.length; r < s; r++)
                hc(e[r], this, n, t);
            return n.sort(cc),
            n
        }
    }),
    Object.assign(function(e, t, i) {
        return this.radius = void 0 !== e ? e : 1,
        this.phi = void 0 !== t ? t : 0,
        this.theta = void 0 !== i ? i : 0,
        this
    }
    .prototype, {
        set: function(e, t, i) {
            return this.radius = e,
            this.phi = t,
            this.theta = i,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius,
            this.phi = e.phi,
            this.theta = e.theta,
            this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, i) {
            return this.radius = Math.sqrt(e * e + t * t + i * i),
            0 === this.radius ? (this.theta = 0,
            this.phi = 0) : (this.theta = Math.atan2(e, i),
            this.phi = Math.acos(St.clamp(t / this.radius, -1, 1))),
            this
        }
    }),
    Object.assign(function(e, t, i) {
        return this.radius = void 0 !== e ? e : 1,
        this.theta = void 0 !== t ? t : 0,
        this.y = void 0 !== i ? i : 0,
        this
    }
    .prototype, {
        set: function(e, t, i) {
            return this.radius = e,
            this.theta = t,
            this.y = i,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius,
            this.theta = e.theta,
            this.y = e.y,
            this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, i) {
            return this.radius = Math.sqrt(e * e + i * i),
            this.theta = Math.atan2(e, i),
            this.y = t,
            this
        }
    }),
    Object.assign(uc.prototype, {
        set: function(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++)
                this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: function() {
            var e = new At;
            return function(t, i) {
                var n = e.copy(i).multiplyScalar(.5);
                return this.min.copy(t).sub(n),
                this.max.copy(t).add(n),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(e) {
            return void 0 === e && (e = new At),
            this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (e = new At),
            this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        },
        expandByVector: function(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        },
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function(e, t) {
            return void 0 === t && (t = new At),
            t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function(e, t) {
            return void 0 === t && (t = new At),
            t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var e = new At;
            return function(t) {
                return e.copy(t).clamp(this.min, this.max).sub(t).length()
            }
        }(),
        intersect: function(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this
        },
        union: function(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        },
        translate: function(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }),
    Object.assign(pc.prototype, {
        set: function(e, t) {
            return this.start.copy(e),
            this.end.copy(t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.start.copy(e.start),
            this.end.copy(e.end),
            this
        },
        getCenter: function(e) {
            return void 0 === e && (e = new Ct),
            e.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(e) {
            return void 0 === e && (e = new Ct),
            e.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(e, t) {
            return void 0 === t && (t = new Ct),
            this.delta(t).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: (Hl = new Ct,
        Ql = new Ct,
        function(e, t) {
            Hl.subVectors(e, this.start),
            Ql.subVectors(this.end, this.start);
            var i = Ql.dot(Ql)
              , n = Ql.dot(Hl) / i;
            return t && (n = St.clamp(n, 0, 1)),
            n
        }
        ),
        closestPointToPoint: function(e, t, i) {
            var n = this.closestPointToPointParameter(e, t);
            return void 0 === i && (i = new Ct),
            this.delta(i).multiplyScalar(n).add(this.start)
        },
        applyMatrix4: function(e) {
            return this.start.applyMatrix4(e),
            this.end.applyMatrix4(e),
            this
        },
        equals: function(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }),
    dc.prototype = Object.create(Mi.prototype),
    dc.prototype.constructor = dc,
    dc.prototype.isImmediateRenderObject = !0,
    fc.prototype = Object.create(Ts.prototype),
    fc.prototype.constructor = fc,
    fc.prototype.update = function() {
        var e = new Ct
          , t = new Ct
          , i = new Lt;
        return function() {
            var n = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0),
            i.getNormalMatrix(this.object.matrixWorld);
            var r = this.object.matrixWorld
              , s = this.geometry.attributes.position
              , a = this.object.geometry;
            if (a && a.isGeometry)
                for (var o = a.vertices, l = a.faces, c = 0, h = 0, u = l.length; h < u; h++)
                    for (var p = l[h], d = 0, f = p.vertexNormals.length; d < f; d++) {
                        var m = o[p[n[d]]]
                          , g = p.vertexNormals[d];
                        e.copy(m).applyMatrix4(r),
                        t.copy(g).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e),
                        s.setXYZ(c, e.x, e.y, e.z),
                        c += 1,
                        s.setXYZ(c, t.x, t.y, t.z),
                        c += 1
                    }
            else if (a && a.isBufferGeometry) {
                var v = a.attributes.position
                  , y = a.attributes.normal;
                for (c = 0,
                d = 0,
                f = v.count; d < f; d++)
                    e.set(v.getX(d), v.getY(d), v.getZ(d)).applyMatrix4(r),
                    t.set(y.getX(d), y.getY(d), y.getZ(d)),
                    t.applyMatrix3(i).normalize().multiplyScalar(this.size).add(e),
                    s.setXYZ(c, e.x, e.y, e.z),
                    c += 1,
                    s.setXYZ(c, t.x, t.y, t.z),
                    c += 1
            }
            s.needsUpdate = !0
        }
    }(),
    mc.prototype = Object.create(Mi.prototype),
    mc.prototype.constructor = mc,
    mc.prototype.dispose = function() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    ,
    mc.prototype.update = function() {
        var e = new Ct;
        return function() {
            this.light.updateMatrixWorld();
            var t = this.light.distance ? this.light.distance : 1e3
              , i = t * Math.tan(this.light.angle);
            this.cone.scale.set(i, i, t),
            e.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(e),
            void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }(),
    gc.prototype = Object.create(Ts.prototype),
    gc.prototype.constructor = gc,
    gc.prototype.updateMatrixWorld = function() {
        var e = new Ct
          , t = new ii
          , i = new ii;
        return function(n) {
            var r = this.bones
              , s = this.geometry
              , a = s.getAttribute("position");
            i.getInverse(this.root.matrixWorld);
            for (var o = 0, l = 0; o < r.length; o++) {
                var c = r[o];
                c.parent && c.parent.isBone && (t.multiplyMatrices(i, c.matrixWorld),
                e.setFromMatrixPosition(t),
                a.setXYZ(l, e.x, e.y, e.z),
                t.multiplyMatrices(i, c.parent.matrixWorld),
                e.setFromMatrixPosition(t),
                a.setXYZ(l + 1, e.x, e.y, e.z),
                l += 2)
            }
            s.getAttribute("position").needsUpdate = !0,
            Mi.prototype.updateMatrixWorld.call(this, n)
        }
    }(),
    vc.prototype = Object.create(fn.prototype),
    vc.prototype.constructor = vc,
    vc.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    vc.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
    ,
    yc.prototype = Object.create(_s.prototype),
    yc.prototype.constructor = yc,
    yc.prototype.update = function() {
        if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1),
        void 0 !== this.color)
            this.material.color.set(this.color),
            this.children[0].material.color.set(this.color);
        else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var e = this.material.color
              , t = Math.max(e.r, e.g, e.b);
            t > 1 && e.multiplyScalar(1 / t),
            this.children[0].material.color.copy(this.material.color)
        }
    }
    ,
    yc.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    bc.prototype = Object.create(Mi.prototype),
    bc.prototype.constructor = bc,
    bc.prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    bc.prototype.update = function() {
        var e = new Ct
          , t = new hi
          , i = new hi;
        return function() {
            var n = this.children[0];
            if (void 0 !== this.color)
                this.material.color.set(this.color);
            else {
                var r = n.geometry.getAttribute("color");
                t.copy(this.light.color),
                i.copy(this.light.groundColor);
                for (var s = 0, a = r.count; s < a; s++) {
                    var o = s < a / 2 ? t : i;
                    r.setXYZ(s, o.r, o.g, o.b)
                }
                r.needsUpdate = !0
            }
            n.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate())
        }
    }(),
    xc.prototype = Object.create(fn.prototype),
    xc.prototype.constructor = xc,
    xc.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    xc.prototype.onBeforeRender = function() {
        this.position.copy(this.lightProbe.position),
        this.scale.set(1, 1, 1).multiplyScalar(this.size),
        this.material.uniforms.intensity.value = this.lightProbe.intensity
    }
    ,
    wc.prototype = Object.assign(Object.create(Ts.prototype), {
        constructor: wc,
        copy: function(e) {
            return Ts.prototype.copy.call(this, e),
            this.geometry.copy(e.geometry),
            this.material.copy(e.material),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    _c.prototype = Object.create(Ts.prototype),
    _c.prototype.constructor = _c,
    Tc.prototype = Object.create(_s.prototype),
    Tc.prototype.constructor = Tc,
    Tc.prototype.update = function() {
        var e, t, i = this.audio, n = this.range, r = this.divisionsInnerAngle, s = this.divisionsOuterAngle, a = St.degToRad(i.panner.coneInnerAngle), o = St.degToRad(i.panner.coneOuterAngle), l = a / 2, c = o / 2, h = 0, u = 0, p = this.geometry, d = p.attributes.position;
        function f(i, r, s, a) {
            var o = (r - i) / s;
            for (d.setXYZ(h, 0, 0, 0),
            u++,
            e = i; e < r; e += o)
                t = h + u,
                d.setXYZ(t, Math.sin(e) * n, 0, Math.cos(e) * n),
                d.setXYZ(t + 1, Math.sin(Math.min(e + o, r)) * n, 0, Math.cos(Math.min(e + o, r)) * n),
                d.setXYZ(t + 2, 0, 0, 0),
                u += 3;
            p.addGroup(h, u, a),
            h += u,
            u = 0
        }
        p.clearGroups(),
        f(-c, -l, s, 0),
        f(-l, l, r, 1),
        f(l, c, s, 0),
        d.needsUpdate = !0,
        a === o && (this.material[0].visible = !1)
    }
    ,
    Tc.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material[0].dispose(),
        this.material[1].dispose()
    }
    ,
    Mc.prototype = Object.create(Ts.prototype),
    Mc.prototype.constructor = Mc,
    Mc.prototype.update = function() {
        var e = new Ct
          , t = new Ct
          , i = new Lt;
        return function() {
            this.object.updateMatrixWorld(!0),
            i.getNormalMatrix(this.object.matrixWorld);
            for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, s = this.object.geometry, a = s.vertices, o = s.faces, l = 0, c = 0, h = o.length; c < h; c++) {
                var u = o[c]
                  , p = u.normal;
                e.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(n),
                t.copy(p).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e),
                r.setXYZ(l, e.x, e.y, e.z),
                l += 1,
                r.setXYZ(l, t.x, t.y, t.z),
                l += 1
            }
            r.needsUpdate = !0
        }
    }(),
    Sc.prototype = Object.create(Mi.prototype),
    Sc.prototype.constructor = Sc,
    Sc.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    ,
    Sc.prototype.update = function() {
        var e = new Ct
          , t = new Ct
          , i = new Ct;
        return function() {
            e.setFromMatrixPosition(this.light.matrixWorld),
            t.setFromMatrixPosition(this.light.target.matrixWorld),
            i.subVectors(t, e),
            this.lightPlane.lookAt(t),
            void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
            this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(t),
            this.targetLine.scale.z = i.length()
        }
    }(),
    Ac.prototype = Object.create(Ts.prototype),
    Ac.prototype.constructor = Ac,
    Ac.prototype.update = function() {
        var e, t, i = new Ct, n = new Qr;
        function r(r, s, a, o) {
            i.set(s, a, o).unproject(n);
            var l = t[r];
            if (void 0 !== l)
                for (var c = e.getAttribute("position"), h = 0, u = l.length; h < u; h++)
                    c.setXYZ(l[h], i.x, i.y, i.z)
        }
        return function() {
            e = this.geometry,
            t = this.pointMap;
            n.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
            r("c", 0, 0, -1),
            r("t", 0, 0, 1),
            r("n1", -1, -1, -1),
            r("n2", 1, -1, -1),
            r("n3", -1, 1, -1),
            r("n4", 1, 1, -1),
            r("f1", -1, -1, 1),
            r("f2", 1, -1, 1),
            r("f3", -1, 1, 1),
            r("f4", 1, 1, 1),
            r("u1", .7, 1.1, -1),
            r("u2", -.7, 1.1, -1),
            r("u3", 0, 2, -1),
            r("cf1", -1, 0, 1),
            r("cf2", 1, 0, 1),
            r("cf3", 0, -1, 1),
            r("cf4", 0, 1, 1),
            r("cn1", -1, 0, -1),
            r("cn2", 1, 0, -1),
            r("cn3", 0, -1, -1),
            r("cn4", 0, 1, -1),
            e.getAttribute("position").needsUpdate = !0
        }
    }(),
    Pc.prototype = Object.create(Ts.prototype),
    Pc.prototype.constructor = Pc,
    Pc.prototype.update = function() {
        var e = new $t;
        return function(t) {
            if (void 0 !== this.object && e.setFromObject(this.object),
            !e.isEmpty()) {
                var i = e.min
                  , n = e.max
                  , r = this.geometry.attributes.position
                  , s = r.array;
                s[0] = n.x,
                s[1] = n.y,
                s[2] = n.z,
                s[3] = i.x,
                s[4] = n.y,
                s[5] = n.z,
                s[6] = i.x,
                s[7] = i.y,
                s[8] = n.z,
                s[9] = n.x,
                s[10] = i.y,
                s[11] = n.z,
                s[12] = n.x,
                s[13] = n.y,
                s[14] = i.z,
                s[15] = i.x,
                s[16] = n.y,
                s[17] = i.z,
                s[18] = i.x,
                s[19] = i.y,
                s[20] = i.z,
                s[21] = n.x,
                s[22] = i.y,
                s[23] = i.z,
                r.needsUpdate = !0,
                this.geometry.computeBoundingSphere()
            }
        }
    }(),
    Pc.prototype.setFromObject = function(e) {
        return this.object = e,
        this.update(),
        this
    }
    ,
    Pc.prototype.copy = function(e) {
        return Ts.prototype.copy.call(this, e),
        this.object = e.object,
        this
    }
    ,
    Pc.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    Cc.prototype = Object.create(Ts.prototype),
    Cc.prototype.constructor = Cc,
    Cc.prototype.updateMatrixWorld = function(e) {
        var t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        Mi.prototype.updateMatrixWorld.call(this, e))
    }
    ,
    Lc.prototype = Object.create(_s.prototype),
    Lc.prototype.constructor = Lc,
    Lc.prototype.updateMatrixWorld = function(e) {
        var t = -this.plane.constant;
        Math.abs(t) < 1e-8 && (t = 1e-8),
        this.scale.set(.5 * this.size, .5 * this.size, t),
        this.children[0].material.side = t < 0 ? f : d,
        this.lookAt(this.plane.normal),
        Mi.prototype.updateMatrixWorld.call(this, e)
    }
    ,
    kc.prototype = Object.create(Mi.prototype),
    kc.prototype.constructor = kc,
    kc.prototype.setDirection = (Kl = new Ct,
    function(e) {
        e.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (Kl.set(e.z, 0, -e.x).normalize(),
        $l = Math.acos(e.y),
        this.quaternion.setFromAxisAngle(Kl, $l))
    }
    ),
    kc.prototype.setLength = function(e, t, i) {
        void 0 === t && (t = .2 * e),
        void 0 === i && (i = .2 * t),
        this.line.scale.set(1, Math.max(0, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, t, i),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    ,
    kc.prototype.setColor = function(e) {
        this.line.material.color.copy(e),
        this.cone.material.color.copy(e)
    }
    ,
    kc.prototype.copy = function(e) {
        return Mi.prototype.copy.call(this, e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    ,
    kc.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    Ec.prototype = Object.create(Ts.prototype),
    Ec.prototype.constructor = Ec;
    function Ic(e) {
        Oo.call(this, e),
        this.type = "catmullrom"
    }
    Ao.create = function(e, t) {
        return e.prototype = Object.create(Ao.prototype),
        e.prototype.constructor = e,
        e.prototype.getPoint = t,
        e
    }
    ,
    Object.assign(Wo.prototype, {
        createPointsGeometry: function(e) {
            var t = this.getPoints(e);
            return this.createGeometry(t)
        },
        createSpacedPointsGeometry: function(e) {
            var t = this.getSpacedPoints(e);
            return this.createGeometry(t)
        },
        createGeometry: function(e) {
            for (var t = new Ci, i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.vertices.push(new Ct(r.x,r.y,r.z || 0))
            }
            return t
        }
    }),
    Object.assign(qo.prototype, {
        fromPoints: function(e) {
            this.setFromPoints(e)
        }
    }),
    Object.create(Oo.prototype),
    Object.create(Oo.prototype),
    Ic.prototype = Object.create(Oo.prototype),
    Object.assign(Ic.prototype, {
        initFromArray: function() {},
        getControlPointsArray: function() {},
        reparametrizeByArcLength: function() {}
    }),
    wc.prototype.setColors = function() {}
    ,
    gc.prototype.update = function() {}
    ,
    Object.assign(Tl.prototype, {
        extractUrlBase: function(e) {
            return ol(e)
        }
    }),
    Object.assign(hl.prototype, {
        setTexturePath: function(e) {
            return this.setResourcePath(e)
        }
    }),
    Object.assign(uc.prototype, {
        center: function(e) {
            return this.getCenter(e)
        },
        empty: function() {
            return this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return this.intersectsBox(e)
        },
        size: function(e) {
            return this.getSize(e)
        }
    }),
    Object.assign($t.prototype, {
        center: function(e) {
            return this.getCenter(e)
        },
        empty: function() {
            return this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return this.intersectsBox(e)
        },
        isIntersectionSphere: function(e) {
            return this.intersectsSphere(e)
        },
        size: function(e) {
            return this.getSize(e)
        }
    }),
    pc.prototype.center = function(e) {
        return this.getCenter(e)
    }
    ,
    Object.assign(St, {
        random16: function() {
            return Math.random()
        },
        nearestPowerOfTwo: function(e) {
            return St.floorPowerOfTwo(e)
        },
        nextPowerOfTwo: function(e) {
            return St.ceilPowerOfTwo(e)
        }
    }),
    Object.assign(Lt.prototype, {
        flattenToArrayOffset: function(e, t) {
            return this.toArray(e, t)
        },
        multiplyVector3: function(e) {
            return e.applyMatrix3(this)
        },
        multiplyVector3Array: function() {},
        applyToBuffer: function(e) {
            return this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {}
    }),
    Object.assign(ii.prototype, {
        extractPosition: function(e) {
            return this.copyPosition(e)
        },
        flattenToArrayOffset: function(e, t) {
            return this.toArray(e, t)
        },
        getPosition: function() {
            var e;
            return function() {
                return void 0 === e && (e = new Ct),
                e.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(e) {
            return this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function() {},
        multiplyVector3: function(e) {
            return e.applyMatrix4(this)
        },
        multiplyVector4: function(e) {
            return e.applyMatrix4(this)
        },
        multiplyVector3Array: function() {},
        rotateAxis: function(e) {
            e.transformDirection(this)
        },
        crossVector: function(e) {
            return e.applyMatrix4(this)
        },
        translate: function() {},
        rotateX: function() {},
        rotateY: function() {},
        rotateZ: function() {},
        rotateByAxis: function() {},
        applyToBuffer: function(e) {
            return this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {},
        makeFrustum: function(e, t, i, n, r, s) {
            return this.makePerspective(e, t, n, i, r, s)
        }
    }),
    ei.prototype.isIntersectionLine = function(e) {
        return this.intersectsLine(e)
    }
    ,
    Pt.prototype.multiplyVector3 = function(e) {
        return e.applyQuaternion(this)
    }
    ,
    Object.assign(un.prototype, {
        isIntersectionBox: function(e) {
            return this.intersectsBox(e)
        },
        isIntersectionPlane: function(e) {
            return this.intersectsPlane(e)
        },
        isIntersectionSphere: function(e) {
            return this.intersectsSphere(e)
        }
    }),
    Object.assign(pn.prototype, {
        area: function() {
            return this.getArea()
        },
        barycoordFromPoint: function(e, t) {
            return this.getBarycoord(e, t)
        },
        midpoint: function(e) {
            return this.getMidpoint(e)
        },
        normal: function(e) {
            return this.getNormal(e)
        },
        plane: function(e) {
            return this.getPlane(e)
        }
    }),
    Object.assign(pn, {
        barycoordFromPoint: function(e, t, i, n, r) {
            return pn.getBarycoord(e, t, i, n, r)
        },
        normal: function(e, t, i, n) {
            return pn.getNormal(e, t, i, n)
        }
    }),
    Object.assign(Ho.prototype, {
        extractAllPoints: function(e) {
            return this.extractPoints(e)
        },
        extrude: function(e) {
            return new wa(this,e)
        },
        makeGeometry: function(e) {
            return new Fa(this,e)
        }
    }),
    Object.assign(At.prototype, {
        fromAttribute: function(e, t, i) {
            return this.fromBufferAttribute(e, t, i)
        },
        distanceToManhattan: function(e) {
            return this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return this.manhattanLength()
        }
    }),
    Object.assign(Ct.prototype, {
        setEulerFromRotationMatrix: function() {},
        setEulerFromQuaternion: function() {},
        getPositionFromMatrix: function(e) {
            return this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function(e) {
            return this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function(e, t) {
            return this.setFromMatrixColumn(t, e)
        },
        applyProjection: function(e) {
            return this.applyMatrix4(e)
        },
        fromAttribute: function(e, t, i) {
            return this.fromBufferAttribute(e, t, i)
        },
        distanceToManhattan: function(e) {
            return this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return this.manhattanLength()
        }
    }),
    Object.assign(qt.prototype, {
        fromAttribute: function(e, t, i) {
            return this.fromBufferAttribute(e, t, i)
        },
        lengthManhattan: function() {
            return this.manhattanLength()
        }
    }),
    Object.assign(Ci.prototype, {
        computeTangents: function() {},
        computeLineDistances: function() {}
    }),
    Object.assign(Mi.prototype, {
        getChildByName: function(e) {
            return this.getObjectByName(e)
        },
        renderDepth: function() {},
        translate: function(e, t) {
            return this.translateOnAxis(t, e)
        },
        getWorldRotation: function() {}
    }),
    Object.defineProperties(Mi.prototype, {
        eulerOrder: {
            get: function() {
                return this.rotation.order
            },
            set: function(e) {
                this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function() {},
            set: function() {}
        }
    }),
    Object.defineProperties(vs.prototype, {
        objects: {
            get: function() {
                return this.levels
            }
        }
    }),
    Object.defineProperty(bs.prototype, "useVertexTexture", {
        get: function() {},
        set: function() {}
    }),
    ys.prototype.initBones = function() {}
    ,
    Object.defineProperty(Ao.prototype, "__arcLengthDivisions", {
        get: function() {
            return this.arcLengthDivisions
        },
        set: function(e) {
            this.arcLengthDivisions = e
        }
    }),
    Jr.prototype.setLens = function(e, t) {
        void 0 !== t && (this.filmGauge = t),
        this.setFocalLength(e)
    }
    ,
    Object.defineProperties(Qo.prototype, {
        onlyShadow: {
            set: function() {}
        },
        shadowCameraFov: {
            set: function(e) {
                this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function(e) {
                this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function(e) {
                this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function(e) {
                this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function(e) {
                this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function(e) {
                this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function(e) {
                this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function() {}
        },
        shadowBias: {
            set: function(e) {
                this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function() {}
        },
        shadowMapWidth: {
            set: function(e) {
                this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function(e) {
                this.shadow.mapSize.height = e
            }
        }
    }),
    Object.defineProperties(Li.prototype, {
        length: {
            get: function() {
                return this.array.length
            }
        },
        copyIndicesArray: function() {}
    }),
    Object.assign(Vi.prototype, {
        addIndex: function(e) {
            this.setIndex(e)
        },
        addDrawCall: function(e, t, i) {
            this.addGroup(e, t)
        },
        clearDrawCalls: function() {
            this.clearGroups()
        },
        computeTangents: function() {},
        computeOffsets: function() {}
    }),
    Object.defineProperties(Vi.prototype, {
        drawcalls: {
            get: function() {
                return this.groups
            }
        },
        offsets: {
            get: function() {
                return this.groups
            }
        }
    }),
    Object.assign(_a.prototype, {
        getArrays: function() {},
        addShapeList: function() {},
        addShape: function() {}
    }),
    Object.defineProperties(rc.prototype, {
        dynamic: {
            set: function() {}
        },
        onUpdate: {
            value: function() {
                return this
            }
        }
    }),
    Object.defineProperties(Hi.prototype, {
        wrapAround: {
            get: function() {},
            set: function() {}
        },
        overdraw: {
            get: function() {},
            set: function() {}
        },
        wrapRGB: {
            get: function() {
                return new hi
            }
        },
        shading: {
            get: function() {},
            set: function(e) {
                this.flatShading = 1 === e
            }
        }
    }),
    Object.defineProperties(Ha.prototype, {
        metal: {
            get: function() {
                return !1
            },
            set: function() {}
        }
    }),
    Object.defineProperties(hn.prototype, {
        derivatives: {
            get: function() {
                return this.extensions.derivatives
            },
            set: function(e) {
                this.extensions.derivatives = e
            }
        }
    }),
    Object.assign(cs.prototype, {
        clearTarget: function(e, t, i, n) {
            this.setRenderTarget(e),
            this.clear(t, i, n)
        },
        animate: function(e) {
            this.setAnimationLoop(e)
        },
        getCurrentRenderTarget: function() {
            return this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return this.capabilities.precision
        },
        resetGLState: function() {
            return this.state.reset()
        },
        supportsFloatTextures: function() {
            return this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(e) {
            this.setScissorTest(e)
        },
        initMaterial: function() {},
        addPrePlugin: function() {},
        addPostPlugin: function() {},
        updateShadowMap: function() {},
        setFaceCulling: function() {},
        allocTextureUnit: function() {},
        setTexture: function() {},
        setTexture2D: function() {},
        setTextureCube: function() {}
    }),
    Object.defineProperties(cs.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(e) {
                this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(e) {
                this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function() {},
            set: function() {}
        }
    }),
    Object.defineProperties(Xr.prototype, {
        cullFace: {
            get: function() {},
            set: function() {}
        },
        renderReverseSided: {
            get: function() {},
            set: function() {}
        },
        renderSingleSided: {
            get: function() {},
            set: function() {}
        }
    }),
    Object.defineProperties(Jt.prototype, {
        activeCubeFace: {
            set: function() {}
        },
        activeMipMapLevel: {
            set: function() {}
        }
    }),
    Object.defineProperties(Ht.prototype, {
        wrapS: {
            get: function() {
                return this.texture.wrapS
            },
            set: function(e) {
                this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function() {
                return this.texture.wrapT
            },
            set: function(e) {
                this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function() {
                return this.texture.magFilter
            },
            set: function(e) {
                this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function() {
                return this.texture.minFilter
            },
            set: function(e) {
                this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function() {
                return this.texture.anisotropy
            },
            set: function(e) {
                this.texture.anisotropy = e
            }
        },
        offset: {
            get: function() {
                return this.texture.offset
            },
            set: function(e) {
                this.texture.offset = e
            }
        },
        repeat: {
            get: function() {
                return this.texture.repeat
            },
            set: function(e) {
                this.texture.repeat = e
            }
        },
        format: {
            get: function() {
                return this.texture.format
            },
            set: function(e) {
                this.texture.format = e
            }
        },
        type: {
            get: function() {
                return this.texture.type
            },
            set: function(e) {
                this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function() {
                return this.texture.generateMipmaps
            },
            set: function(e) {
                this.texture.generateMipmaps = e
            }
        }
    }),
    Object.defineProperties(os.prototype, {
        standing: {
            set: function() {}
        },
        userHeight: {
            set: function() {}
        }
    }),
    Rl.prototype.load = function(e) {
        var t = this;
        return (new Sl).load(e, function(e) {
            t.setBuffer(e)
        }),
        this
    }
    ,
    Nl.prototype.getData = function() {
        return this.getFrequencyData()
    }
    ,
    Il.prototype.updateCubeMap = function(e, t) {
        return this.update(e, t)
    }
    ;
    Xt.crossOrigin = void 0,
    Xt.loadTexture = function(e, t, i, n) {
        var r = new So;
        r.setCrossOrigin(this.crossOrigin);
        var s = r.load(e, i, void 0, n);
        return t && (s.mapping = t),
        s
    }
    ,
    Xt.loadTextureCube = function(e, t, i, n) {
        var r = new Mo;
        r.setCrossOrigin(this.crossOrigin);
        var s = r.load(e, i, void 0, n);
        return t && (s.mapping = t),
        s
    }
    ,
    Xt.loadCompressedTexture = function() {}
    ,
    Xt.loadCompressedTextureCube = function() {}
}
, function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return a
    });
    var n = i(71)
      , r = i.n(n);
    function s(e=0) {
        let t = r()(e);
        return t.nextFloat(),
        t.nextFloat(),
        {
            setSeed: function(i) {
                e = i,
                t = r()(e)
            },
            random: function() {
                return t.nextFloat()
            },
            randomFloat: function(e=0, i=1) {
                return t.nextFloat() * (i - e) + e
            },
            randomInt: function(e, i) {
                return Math.floor(t.nextFloat() * (i - e + 1)) + e
            },
            hash2d: i,
            hash2dInt: function(e, t, n, r) {
                return Math.floor(i(e, t) * (r - n + 1)) + n
            }
        };
        function i(e, t) {
            return function(e) {
                return e - Math.floor(e)
            }(43758.5453 * Math.sin(e * 78.233 - 12.9898 * t))
        }
    }
    const a = s
      , o = s(Date.now());
    t.b = o
}
, , function(e, t, i) {
    "use strict";
    var n = i(14);
    class r extends n.a {
        set(e, t) {
            if (!t && this.current === e)
                return;
            const i = this.current;
            this.current = e;
            let n = this._first;
            for (; n; )
                n.fn.call(n.ctx, this.current, i),
                n.once && this.unsubscribe(n),
                n = n.next
        }
        update(e, t) {
            this.set(e(this.current), t)
        }
    }
    t.a = function(e) {
        return new r(e)
    }
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(20)
      , r = i(27)
      , s = i(62)
      , a = i(34)
      , o = i(24);
    function l() {
        const e = n.a.menuOpen.current || n.a.seedListOpen.current || n.a.notificationOpen.current;
        r.a.overlayVisible.set(e)
    }
    var c = function() {
        n.a.menuOpen.subscribe(l),
        n.a.seedListOpen.subscribe(l),
        n.a.notificationOpen.subscribe(l),
        l()
    }
      , h = i(39);
    const u = 1e3
      , p = document.body;
    let d, f;
    function m() {
        const e = !!f;
        n.a.seedUiVisible.set(e),
        p.classList.toggle("on-seed", e)
    }
    function g() {
        d && (d.destroy(),
        d = null)
    }
    function v() {
        g();
        const e = n.a.routeStatus.current
          , t = "seed" === e.to.id;
        2 === e.status && t && (f = !0,
        m())
    }
    function y(e) {
        if (2 !== e.status)
            return;
        const t = "seed" === e.to.id;
        g(),
        t ? d = Object(h.a)(u, v) : (f = !1,
        m())
    }
    var b = function() {
        n.a.routeStatus.subscribe(y),
        y(n.a.routeStatus.current),
        m()
    };
    let x, w;
    const _ = document.body;
    let T = !1
      , M = !1
      , S = !1;
    function A() {
        S = !1;
        const e = T
          , t = M;
        M = !!(o.a.getCurrent() && o.a.getCurrent().unlocked.current && o.a.getCurrent().visibleLevel.current > 0 && n.a.seedUiVisible.current),
        (T = M && o.a.getCurrent().visibleLevel.current >= 4) && (M = !1);
        const i = T !== e || M !== t;
        i && x && (x.destroy(),
        x = null),
        i && e && M ? x = Object(h.a)(400, C) : C(),
        i && t && T ? x = Object(h.a)(400, P) : P()
    }
    function P() {
        n.a.giftButtonVisible.set(T),
        _.classList.toggle("resources-gift-visible", T)
    }
    function C() {
        n.a.resourceButtonsVisible.set(M),
        _.classList.toggle("resources-visible", M)
    }
    function L() {
        S || (S = !0,
        window.requestAnimationFrame(A))
    }
    function k(e) {
        w && (w.unlocked.unsubscribe(L),
        w.visibleLevel.unsubscribe(L)),
        e && ((w = e).unlocked.subscribe(L),
        w.visibleLevel.subscribe(L),
        L())
    }
    var E = function() {
        n.a.seedUiVisible.subscribe(L),
        o.a.currentSeed.subscribe(k),
        k(o.a.currentSeed.current),
        L()
    };
    i.d(t, "AppStore", function() {
        return n.a
    }),
    i.d(t, "CanvasStore", function() {
        return r.a
    }),
    i.d(t, "DebugStore", function() {
        return s.a
    }),
    i.d(t, "GameStore", function() {
        return a.a
    }),
    i.d(t, "PlayerStore", function() {
        return o.a
    }),
    c(),
    b(),
    E()
}
, , function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return a
    });
    var n = i(20)
      , r = i(58)
      , s = i.n(r);
    function a(e, t=!0) {
        const i = s()(n.a.language.current.content, e);
        return t ? null != i ? i : "KEY_MISSING" : i
    }
}
, , function(e, t, i) {
    "use strict";
    t.a = {
        state: {},
        data: Object.assign({}, window.config, {
            content: window.content,
            manifest: window.manifest,
            language: window.config && window.config.locale && window.config.locale.language
        })
    }
}
, function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return o
    });
    var n = i(58)
      , r = i.n(n)
      , s = i(28)
      , a = i(4);
    class o extends s.a {
        constructor(e) {
            super(e),
            this.unlisteners = [],
            this.store = {},
            this.boundsDomMethod = {}
        }
        afterRender() {
            this.parseStoreDatasets(),
            this.parseEventDatasets()
        }
        parseStoreDatasets() {
            const e = Array.from(this.nodes.main.querySelectorAll("[data-store]"));
            this.nodes.main.dataset.store && e.push(this.nodes.main);
            for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t];
                if (!i.dataset.store)
                    continue;
                const n = i.dataset.store.split(",");
                for (let e = 0, t = n.length; e < t; e++) {
                    let t = n[e].trim().split("->");
                    const s = (t[1] || "setText").split(":")
                      , o = s[0]
                      , l = s[1];
                    if (!o || !this[o])
                        continue;
                    const c = (t = t[0].split(".")).splice(0, 1)[0];
                    let h, u = t.join(".");
                    if (u ? h = this.store[c] || a[c] : (h = this.store,
                    u = c),
                    !h)
                        return;
                    const p = r()(h, u);
                    this.addStoreListener(i, p, o, l)
                }
            }
        }
        parseEventDatasets() {
            const e = Array.from(this.nodes.main.querySelectorAll("[data-event]"));
            this.nodes.main.dataset.event && e.push(this.nodes.main);
            for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t];
                if (!i.dataset.event)
                    continue;
                const n = i.dataset.event.split(",");
                for (let e = 0, t = n.length; e < t; e++) {
                    const t = n[e].trim().split("->")
                      , r = t[0]
                      , s = t[1];
                    r && s && this[s] && this.addDomListener(i, r, s)
                }
            }
        }
        addDomListener(e, t, i) {
            let n = this[i];
            this.boundsDomMethod[i] || (this[i] = n.bind(this),
            n = this[i],
            this.boundsDomMethod[i] = !0),
            e.addEventListener(t, n, !1),
            this.unlisteners.push( () => e && e.removeEventListener(t, n, !1))
        }
        addStoreListener(e, t, i, n, r=!0) {
            if (!t)
                return;
            const s = t.subscribe( () => this[i](e, t.current, n), this);
            return this.unlisteners.push( () => t.unsubscribe(s)),
            r && this[i](e, t.current, n),
            s
        }
        toggle(e, t, i) {
            const n = function(e, t) {
                let i = l;
                "=" === e[0] ? (e = e.substr(1),
                i = l) : ">" === e[0] ? (e = e.substr(1),
                i = c) : "<" === e[0] && (e = e.substr(1),
                i = h);
                return i(t, e)
            }(i, t);
            e.style.display = n ? "" : "none"
        }
        setText(e, t) {
            e && (e.textContent = t + "")
        }
        destroy() {
            for (let e = 0, t = this.unlisteners.length; e < t; e++)
                this.unlisteners[e]();
            this.unlisteners = null,
            this.store = null,
            super.destroy()
        }
    }
    const l = (e, t) => e == t
      , c = (e, t) => e > t
      , h = (e, t) => e < t
}
, , , , function(e, t, i) {
    "use strict";
    var n = i(41)
      , r = i.n(n)
      , s = i(20)
      , a = i(56)
      , o = i(69)
      , l = i.n(o)
      , c = i(82)
      , h = i.n(c)
      , u = i(70)
      , p = i.n(u)
      , d = i(17)
      , f = i(24);
    const m = "wgy8hb2c3t7bkfz7pmwvuvd7"
      , g = {
        playerId: "hzrd9sn739cgmbmrbdj42stz",
        key: "w24ajq6je6r5muzz3t2fyxjw",
        key2: "key",
        save: "yzpqhjw6pezks9kvnn3k8yd8",
        save2: "save",
        currentSeed: "current_seed",
        socialFlag: "social_pending"
    }
      , v = Object(d.a)("🏠 LOCALSTORAGE", "black", "#d1b699", 1).log;
    function y() {
        let e = window.localStorage.getItem(g.key);
        return e || (e = p()(),
        window.localStorage.setItem(g.key, e),
        window.localStorage.setItem(g.key2, p()()),
        e)
    }
    function b(e, t) {
        const i = ([e,...t], n=[]) => void 0 === e ? n : [e, ...i(n, t)];
        return i(e.toLowerCase().split(""), t.toUpperCase().split("")).join("")
    }
    function x() {
        const e = window.localStorage.getItem(g.playerId);
        return !!e && e.toString()
    }
    function w(e) {
        void 0 !== e && x() !== e && (e ? window.localStorage.setItem(g.playerId, e) : window.localStorage.removeItem(g.playerId))
    }
    function _() {
        window.localStorage.removeItem(g.save),
        window.localStorage.removeItem(g.save2),
        window.localStorage.removeItem(g.key),
        window.localStorage.removeItem(g.key2),
        window.localStorage.removeItem(g.currentSeed)
    }
    f.a.id.subscribe(w);
    var T = {
        loadCurrentSeed: function() {
            let e = window.localStorage.getItem(g.currentSeed)
              , t = f.a.getSeedById(e);
            t || (e = "amandier",
            t = f.a.getSeedById(e),
            window.localStorage.setItem(g.currentSeed, e)),
            v(`Load current seed ${e}`),
            f.a.currentSeed.current = t
        },
        saveCurrentSeed: function() {
            const e = f.a.getCurrent().id.current;
            v(`Save current seed ${e}`),
            window.localStorage.setItem(g.currentSeed, e)
        },
        load: function() {
            v("Load");
            let e = window.localStorage.getItem(g.save);
            var t;
            return e && (t = e,
            e = l.a.decrypt(t, b(y(), m)).toString(h.a)),
            Promise.resolve(e)
        },
        save: function(e) {
            var t;
            return v("Save"),
            window.localStorage.setItem(g.save, (t = e,
            l.a.encrypt(t, b(y(), m)).toString())),
            window.localStorage.setItem(g.save2, e),
            Promise.resolve()
        },
        reset: function() {
            _(),
            window.localStorage.removeItem(g.playerId)
        },
        resetOnlySave: _,
        playerId: x,
        savePlayerId: w,
        addSocialFlag: function() {
            s.a.device.current.type.desktop || window.localStorage.setItem(g.socialFlag, "1")
        },
        removeSocialFlag: function() {
            s.a.device.current.type.desktop || window.localStorage.removeItem(g.socialFlag)
        },
        hasSocialFlag: function() {
            return !s.a.device.current.type.desktop && !!window.localStorage.getItem(g.socialFlag)
        }
    }
      , M = i(34)
      , S = i(62)
      , A = i(19)
      , P = i(55)
      , C = i(50)
      , L = i(64)
      , k = i.n(L)
      , E = i(42)
      , I = i(22);
    const F = Object(d.a)("DATABASE", "black", "#c0ffb8", 0).log;
    function O() {
        F("Disconnect 🚨"),
        f.a.id.set(void 0),
        f.a.sessionId.set(null)
    }
    function R(e, t) {
        return new Promise( (i, n) => {
            const r = new XMLHttpRequest
              , a = () => r.onreadystatechange = r.onerror = null;
            r.onerror = () => {
                a(),
                n()
            }
            ,
            r.onreadystatechange = () => {
                if (r.readyState !== XMLHttpRequest.DONE)
                    return;
                const e = JSON.parse(r.responseText);
                if (a(),
                "success" === e.type)
                    i(e);
                else {
                    switch (e.code) {
                    case 1:
                        "token" === e.invalid_params && O();
                        break;
                    case 2:
                        O()
                    }
                    n(e)
                }
            }
            ,
            r.open("POST", `${s.a.apiEndpoint.current}/${e}`),
            r.send(t)
        }
        )
    }
    function z(e, t=!1) {
        if ((e ? Object.keys(e) : []).length >= 8 && (f.a.gameComplete.set(!0),
        !s.a.demoMode.current && t)) {
            Object.keys(t).length > 0 && I.a.createAllSeedsComplete()
        }
    }
    var N = {
        login: function(e, t) {
            const i = new FormData
              , n = e !== f.a.id.current
              , r = e || f.a.id.current;
            return i.append("id", r),
            F("Login... 👨‍✈️ (id: " + r + ")"),
            R("login", i).then(i => {
                if (k()(JSON.stringify(i.save) + i.token).toString() !== i.checksum)
                    return O(),
                    null;
                const {market: r, code: a} = s.a.language.current;
                return i.lang !== a || i.market !== r ? t ? (F("Unlock Verveine."),
                f.a.sessionId.current = i.token,
                Promise.resolve().then( () => te.useSavestate(i.save)).then( () => Object(E.a)(s.a.unlockSeed.current)).then( () => te.remoteSave(!0)).then( () => ie.redirectUser(i))) : ie.redirectUser(i) : (e ? n ? (F("Logged ✨ – Save reset because it's a new user"),
                te.reset(!1, !0),
                f.a.id.set(e)) : (F("Logged ✨"),
                f.a.id.set(e)) : F("Logged ✨"),
                f.a.vouchers.current = i.vouchers,
                f.a.sessionId.set(i.token),
                z(i.vouchers),
                i.save)
            }
            ).catch( () => {
                !e && f.a.id.current ? (f.a.id.set(null),
                document.location.reload()) : e && document.location.reload()
            }
            )
        },
        sync: function(e) {
            const t = new FormData;
            return t.append("id", f.a.id.current),
            t.append("save", e),
            t.append("token", f.a.sessionId.current),
            t.append("checksum", k()(e + f.a.sessionId.current).toString()),
            R("sync", t).then(e => (F("Sync 👯‍♂️"),
            e))
        },
        register: function(e) {
            return e.append("optin", +("on" === e.get("optin"))),
            R("register", e).then(t => (f.a.id.set(t.id),
            f.a.sessionId.set(t.token),
            F("Register 📥"),
            ie.requestVouchers().then( () => ({
                id: t.id,
                market: e.get("market"),
                lang: e.get("lang")
            }))))
        },
        vouchers: function(e) {
            const t = new FormData;
            return t.append("id", f.a.id.current),
            t.append("save", e),
            t.append("token", f.a.sessionId.current),
            t.append("checksum", k()(e + f.a.sessionId.current).toString()),
            R("vouchers", t).then(e => (F("Vouchers 🎟"),
            f.a.vouchers.set(e.vouchers),
            z(e.vouchers, e.newVouchers),
            e)).catch(function() {})
        },
        social: function(e, t) {
            const i = new FormData;
            return i.append("type", e),
            i.append("token", t),
            R("social", i).then(e => (F("Social 🌀"),
            e))
        },
        email: function(e) {
            return R("email", e).then(e => (F("Email login ✉️"),
            e))
        }
    };
    const D = Object(d.a)("💾 SAVE", "black", "#e2e3e7", 0).log;
    let U = !1
      , B = !1
      , j = null
      , V = null
      , G = !1
      , X = !1
      , Y = !1;
    function W() {
        if (f.a.id.current)
            return !0;
        const e = T.playerId();
        return !!e && (f.a.id.set(e),
        !0)
    }
    const q = (e, t, i) => e.set(t, i)
      , H = (e, t) => e.current = t;
    function Q(e={}, t=!1) {
        G = !0,
        "string" == typeof e && (e = JSON.parse(e));
        const i = M.a.rules.current
          , n = t ? H : q;
        n(S.a.timeOffset, e.timeOffset),
        n(f.a.startDate, e.startDate),
        void 0 === e.flags && (e.flags = {}),
        void 0 === e.flags.openMessage && (e.flags.openMessage = !1),
        n(f.a.flags, e.flags),
        n(f.a.lastDay, e.lastDay || Object(P.a)()),
        n(f.a.daysCount, e.daysCount || 0);
        for (const t in f.a.highScores) {
            const i = e.highScores && e.highScores[t] || 0;
            f.a.highScores[t].set(i)
        }
        if (e.resources)
            for (const r in f.a.resources) {
                const s = f.a.resources[r]
                  , a = e.resources[r]
                  , o = a.collectable && a.collectable.current || 0;
                if (n(s.collectable, 0),
                C.a.addResource(r, o, t),
                n(s.lastRefill, a.lastRefillDate),
                M.a.disableResourceOverflow.current) {
                    const e = i.refills[r] && i.refills[r].limit;
                    n(s.amount, Math.min(a.amount, e))
                } else
                    n(s.amount, a.amount)
            }
        e.seeds && e.seeds.forEach(e => {
            const t = f.a.getSeedById(e.id)
              , r = i.seeds[e.id];
            if (t && r) {
                n(t.unlocked, !0),
                n(t.level, e.level),
                n(t.visibleLevel, e.level),
                r.starter && n(f.a.starterChosen, !0);
                for (const i in t.resources) {
                    const s = r["lvl" + e.level]
                      , a = t.resources[i]
                      , o = e.resources[i] || {
                        amount: 0,
                        query: null,
                        nextQueryDate: 0
                    };
                    n(a.amount, o.amount),
                    n(a.query, o.query),
                    n(a.nextQueryDate, o.nextQueryDate);
                    const l = "message" !== i ? s ? s[i].needed : 0 : 2 === e.level || 3 === e.level ? 1 : 0;
                    n(a.goal, l)
                }
            }
        }
        )
    }
    function J(e=!1) {
        const t = {
            saveDate: Object(A.a)(),
            startDate: e ? Object(A.a)() : f.a.startDate.current,
            lastDay: Object(P.a)(),
            daysCount: f.a.daysCount.current,
            timeOffset: e ? 0 : S.a.timeOffset.current,
            highScores: {},
            resources: {},
            seeds: [],
            flags: f.a.flags.current,
            expired: !!X
        };
        for (const i in f.a.highScores)
            t.highScores[i] = e ? 0 : f.a.highScores[i].current;
        for (const e in f.a.resources) {
            const i = f.a.resources[e];
            t.resources[e] = {
                collectable: i.collectable.current || 0,
                amount: i.amount.current,
                lastRefillDate: i.lastRefill.current
            }
        }
        return f.a.seedsArray.current.forEach(e => {
            if (!e.unlocked.current)
                return;
            const i = {
                id: e.id.current,
                level: e.level.current,
                resources: {}
            };
            t.seeds.push(i);
            for (const t in e.resources) {
                const n = e.resources[t];
                i.resources[t] = {
                    amount: n.amount.current,
                    query: n.query.current,
                    nextQueryDate: n.nextQueryDate.current
                }
            }
        }
        ),
        t
    }
    function Z() {
        return new Promise(e => {
            if (B = !1,
            !G)
                return D("Can't save before loading savestate"),
                e();
            if (X)
                return D("Expired save, need reload"),
                e();
            const t = JSON.stringify(J());
            T.save(t, f.a.sessionId.current).then( () => D("Saved in localstorage ")).then(e)
        }
        )
    }
    function $(e=!1) {
        return B = !1,
        W() ? G ? M.a.saving.current && !e ? (U = !0,
        D("was saving"),
        Y) : Y = new Promise( (e, t) => {
            M.a.saving.set(!0);
            const i = JSON.stringify(J());
            D("Saving in database... "),
            N.sync(i, f.a.sessionId.current).then( () => D("Saved in database")).then(e).catch(e => {
                switch (D("Error from database"),
                e.code) {
                case 2:
                    X = !0;
                    break;
                case 7:
                    ee(!0, !0)
                }
                t(e)
            }
            ).then( () => {
                M.a.saving.set(!1),
                Y = !1,
                U && (U = !1,
                K())
            }
            )
        }
        ) : (D("Can't save before loading savestate"),
        Promise.resolve()) : (D("Can't remote save, user not connected"),
        Promise.resolve())
    }
    function K() {
        if (B || (D("Request save"),
        B = !0),
        window.clearTimeout(j),
        j = window.setTimeout(Z, 500),
        W()) {
            if (window.clearTimeout(V),
            M.a.saving.current || U)
                return U = !0,
                Promise.resolve();
            V = window.setTimeout($, M.a.saveDebouncedDelay.current)
        }
    }
    function ee(e=!0, t=!1) {
        t ? T.resetOnlySave() : T.reset(),
        e && document.location.reload(!0)
    }
    var te = {
        load: function(e, t) {
            return new Promise( (i, n) => {
                let r = !1
                  , s = null
                  , a = null;
                Promise.resolve().then(T.load).then(e => s = JSON.parse(e)).then( () => W() || e ? N.login(e, t) : Promise.resolve(null)).then(e => a = e && Object.keys(e).length ? e : null).then( () => {
                    if (a && (e || !s || s.expired || s.saveDate < a.saveDate))
                        D("Use remote savestate"),
                        Q(a, !0),
                        Z();
                    else if (s && (!a || s.saveDate > a.saveDate))
                        D("Use local savestate"),
                        s.expired = !1,
                        Q(s, !0),
                        W() && (r = !0);
                    else {
                        D("Create and use a new save");
                        const e = J(!0);
                        T.save(JSON.stringify(e)),
                        Q(e, !0),
                        W() && (r = !0)
                    }
                }
                ).then( () => T.loadCurrentSeed()).then( () => r ? $() : Promise.resolve()).then(i).catch(e => {
                    n(e)
                }
                )
            }
            )
        },
        reset: ee,
        requestSave: K,
        remoteSave: $,
        requestVouchers: function() {
            const e = JSON.stringify(J());
            return N.vouchers(e).then(e => e)
        },
        useSavestate: Q,
        isLogged: W
    };
    var ie = t.a = {
        load: te.load,
        save: te.remoteSave,
        isLogged: te.isLogged,
        logout: te.reset,
        requestVouchers: te.requestVouchers,
        requestSave: te.requestSave,
        resetSave: te.reset,
        saveCurrentSeed: T.saveCurrentSeed,
        sendEmail: N.email,
        register: N.register,
        socialConnect: N.social,
        addSocialFlag: T.addSocialFlag,
        removeSocialFlag: T.removeSocialFlag,
        hasSocialFlag: T.hasSocialFlag,
        redirectUser: function(e) {
            const t = r.a.compile(s.a.loginPath.current);
            a.a.redirect({
                market: e.market,
                lang: e.lang,
                path: t({
                    userId: e.id
                })
            })
        },
        checkLoginUrl: function() {
            const e = window.location.pathname.replace(s.a.language.current.locale, "")
              , t = r()(s.a.loginPath.current).exec(e);
            if (!t || !t[1])
                return;
            const i = t[1];
            return window.history.replaceState({}, "", a.a.url("default")),
            T.removeSocialFlag(),
            i
        }
    }
}
, function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return r
    });
    var n = i(32);
    class r extends n.a {
        constructor(e) {
            super(),
            this.current = e
        }
        get() {
            return this.current
        }
    }
    t.b = function(e) {
        return new r(e)
    }
}
, , function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return u
    });
    let n = 0;
    const r = (e, t) => void 0 !== e ? e : t
      , s = () => ++n
      , a = new Map
      , o = new Set(["opacity", "transform"])
      , l = new Set(["target", "ease", "duration", "delay", "willChange"])
      , c = {
        "out-swift": "cubic-bezier(0.55, 0, 0.1, 1)",
        bouncy: "cubic-bezier(.18, .89, .34, 1.76)",
        "long-keyframe": "cubic-bezier(.49, .05, .32, 1.04)",
        elastic: "cubic-bezier(0, .49, .205, 1)"
    };
    function h(e, t=1e3, i="linear", n=0) {
        return c[i] && (i = c[i]),
        `${e} ${t}ms ${Array.isArray(i) ? `cubic-bezier(${i.join(",")})` : i} ${n}ms`
    }
    function u(e={}) {
        const t = !!e.willChange
          , i = e.target
          , n = {
            ease: e.ease || "linear",
            duration: e.duration || 1e3,
            delay: e.delay || 0
        };
        i.dataset.csstweenId || (i.dataset.csstweenId = s());
        const c = i.dataset.csstweenId
          , u = {
            play: function({instant: s}={}) {
                return new Promise(m => {
                    a.has(c) && a.get(c).destroy(),
                    a.set(c, u),
                    d = m;
                    const g = []
                      , v = []
                      , y = {}
                      , b = {};
                    for (const t in e) {
                        if (l.has(t))
                            continue;
                        const i = e[t];
                        if (null == i)
                            continue;
                        const a = "object" != typeof i || Array.isArray(i) ? {
                            value: i
                        } : i
                          , c = r(a.duration, n.duration)
                          , u = r(a.delay, n.delay)
                          , p = r(a.ease, n.ease);
                        v.push(h(t, c, p, u));
                        const d = Array.isArray(a.value) ? a.value : [null, a.value];
                        (s || u <= 0 && (!c || c <= 0)) && (d[0] = d[1],
                        d[1] = null),
                        null !== d[0] && (y[t] = d[0]),
                        null !== d[1] && (b[t] = d[1]),
                        o.has(t) && g.push(t)
                    }
                    if (t && g.length > 0 && (i.style.willChange = g.join(", ")),
                    Object.keys(y).length > 0) {
                        for (const e in y)
                            i.style[e] = y[e];
                        i.getBoundingClientRect()
                    }
                    if (Object.keys(b).length > 0) {
                        i.style.transition = v.join(", ");
                        for (const e in b)
                            i.style[e] = b[e],
                            p.add(e);
                        i.addEventListener("transitionend", f)
                    } else
                        m()
                }
                )
            },
            destroy: m,
            stop: m
        }
          , p = new Set;
        let d = null;
        return u;
        function f(e) {
            i.style.willChange = "",
            p.delete(e.propertyName),
            p.size > 0 || (d && d(),
            m())
        }
        function m() {
            i.style.transition = "",
            i.removeEventListener("transitionend", f),
            a.delete(c),
            p.clear(),
            d = null
        }
    }
}
, function(e, t, i) {
    "use strict";
    function n() {}
    const r = {
        log: n,
        warn: n,
        error: n
    };
    t.a = () => r
}
, function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return s
    });
    var n = i(34)
      , r = i(24);
    function s(e) {
        const t = n.a.rules.current
          , i = r.a.getSeedById(e)
          , s = t.seeds[e];
        return {
            rules: t,
            seedStore: i,
            seedSettings: s,
            lvlSettings: i && s ? s["lvl" + i.level.current] : null
        }
    }
}
, function(e, t, i) {
    "use strict";
    var n = i(62);
    t.a = function(e=!1) {
        const t = .001 * Date.now() + parseFloat(n.a.timeOffset.current);
        return e ? t : Math.floor(t)
    }
}
, function(e, t, i) {
    "use strict";
    var n = i(3)
      , r = i(14)
      , s = i(32);
    const a = Object.freeze({
        demoMode: Object(n.a)(!1),
        env: Object(n.a)(null),
        webview: Object(n.a)(null),
        timestamp: Object(n.a)(null),
        assetsUrl: Object(n.a)(null),
        manifest: Object(n.a)(null),
        routes: Object(n.a)(null),
        language: Object(n.a)({}),
        colors: Object(n.a)(null),
        breakpoints: Object(n.a)(null),
        lineId: Object(n.a)(null),
        facebookId: Object(n.a)(null),
        apiEndpoint: Object(n.a)(null),
        useMarketDomain: Object(n.a)(!1),
        unlockSeed: Object(r.b)("verveine"),
        unlockSeedPath: Object(r.b)("/unlock/tN6yLTEe3hGg"),
        loginPath: Object(r.b)("/user/:userId([a-zA-Z0-9]{15,25})"),
        appReady: Object(n.a)(!1),
        scrollable: Object(n.a)(!1),
        routeStatus: Object(n.a)({
            status: 0,
            id: null
        }),
        previousView: Object(n.a)({
            id: null
        }),
        currentView: Object(n.a)({
            id: null
        }),
        viewportSize: Object(n.a)([0, 0]),
        viewportRatio: Object(n.a)(0),
        screenSize: Object(n.a)([0, 0]),
        screenOrientation: Object(n.a)("landscape"),
        screenPixelRatio: Object(n.a)(1),
        siteVisible: Object(n.a)(!0),
        device: Object(n.a)(null),
        pressed: Object(n.a)(!1),
        swipeLeft: new s.a,
        swipeRight: new s.a,
        touch: Object(n.a)({
            pressed: !1,
            pos: new Float32Array([0, 0]),
            relativePos: new Float32Array([0, 0]),
            delta: new Float32Array([0, 0])
        }),
        palette: Object(n.a)(null),
        seedUI: Object(n.a)(!0),
        muteSound: Object(n.a)(!1),
        menuOpen: Object(n.a)(!1),
        seedListOpen: Object(n.a)(!1),
        notificationOpen: Object(n.a)(!1),
        leftPanelView: Object(n.a)(null),
        rightPanelView: Object(n.a)(null),
        giftButtonClickable: Object(n.a)(!1),
        giftButtonHover: Object(n.a)(!1),
        homeUiVisible: Object(n.a)(!1),
        choiceUiVisible: Object(n.a)(!1),
        registerFromPopin: Object(n.a)(!1),
        registerFromError: Object(n.a)(!1),
        seedUiVisible: Object(n.a)(!1),
        giftButtonVisible: Object(n.a)(!1),
        resourceButtonsVisible: Object(n.a)(!1),
        currentStarterChoice: Object(n.a)(null),
        seedChosen: Object(n.a)(!1)
    });
    t.a = a
}
, function(e, t, i) {
    "use strict";
    const n = [{
        id: "ground_c",
        pos: [-5.5, -.438, -2.5],
        size: [13.5, 10.5],
        ang: 0,
        color: 7,
        children: [{
            id: "plant_medium_q",
            pos: [-.1, -.07, -.1],
            size: [2, 2],
            ang: -.3,
            color: 4
        }, {
            id: "plant_medium_h",
            pos: [-.04, -.025, -.1],
            size: [1, 1],
            ang: 0,
            color: 4
        }, {
            id: "plant_big_c",
            pos: [.05, -.02, -.1],
            size: [.8, .8],
            ang: 0,
            color: 7
        }]
    }, {
        id: "ground_f",
        pos: [-12, -.5, -3.2],
        size: [16, 16],
        ang: 0,
        color: 4,
        children: [{
            id: "plant_big_c",
            pos: [.15, -.015, 0],
            size: [.65, .65],
            ang: .3,
            color: 4
        }]
    }, {
        id: "ground_a",
        pos: [7.5, -.276, -3.5],
        size: [17.5, 19.5],
        ang: 0,
        color: 4,
        children: [{
            id: "plant_big_d",
            pos: [-.08, -.01, 0],
            size: [1.5, 1.5],
            ang: -.1,
            color: 4
        }, {
            id: "bush_a",
            pos: [-.17, -.034, -.1],
            size: [1.2, 1.2],
            ang: -.1,
            color: 3
        }, {
            id: "plant_medium_q",
            pos: [-.01, -.02, -.1],
            size: [1.5, 1.5],
            ang: -.1,
            color: 7
        }, {
            id: "plant_medium_i",
            pos: [.1, -.045, -.2],
            size: [1.5, 1.5],
            ang: .2,
            color: 4
        }]
    }, {
        id: "ground_i",
        pos: [-7.5, -1.7, -8],
        size: [10, 8],
        ang: 0,
        color: 10,
        children: [{
            id: "plant_small_d",
            pos: [.15, -.08, 0],
            size: [1.2, 1.2],
            ang: .3,
            color: 10
        }, {
            id: "plant_small_d",
            pos: [.143, -.08, 0],
            size: [1.2, 1.2],
            ang: -.1,
            color: 10
        }, {
            id: "plant_big_b",
            pos: [.243, -.07, 0],
            size: [1, 1],
            ang: 0,
            color: 10
        }]
    }, {
        id: "ground_i",
        pos: [4, -1.3, -8],
        size: [10, 8],
        ang: 0,
        color: 10,
        children: [{
            id: "plant_small_e",
            pos: [.25, -.06, 0],
            size: [1.2, 1.2],
            ang: .3,
            color: 10
        }, {
            id: "plant_small_e",
            pos: [.243, -.06, 0],
            size: [1.2, 1.2],
            ang: -.1,
            color: 10
        }, {
            id: "plant_big_c",
            pos: [.15, -.07, 0],
            size: [1, 1],
            ang: 0,
            color: 10
        }, {
            id: "plant_big_a",
            pos: [-.15, -.07, 0],
            size: [1, 1],
            ang: 0,
            color: 10
        }, {
            id: "plant_small_e",
            pos: [.01, -.045, 0],
            size: [1.2, 1.2],
            ang: .3,
            color: 10
        }, {
            id: "plant_small_e",
            pos: [0, -.038, 0],
            size: [1.2, 1.2],
            ang: -.1,
            color: 10
        }]
    }, {
        id: "ground_e",
        pos: [-.7, -.046, .1],
        size: [25, 5],
        ang: 0,
        color: 5,
        children: [{
            id: "bush_c",
            pos: [-.06, -.05, -.01],
            size: [1.8, 1.8],
            ang: -.4,
            color: 5
        }, {
            id: "plant_medium_o",
            pos: [-.145, -.16, -.01],
            size: [1, 1],
            ang: -.2,
            color: 5
        }, {
            id: "plant_medium_o",
            pos: [.1, -.13, .01],
            size: [1, 1],
            ang: .7,
            color: 5
        }, {
            id: "plant_big_c",
            pos: [-.04, -.05, -.1],
            size: [.4, .4],
            ang: 0,
            color: 5
        }]
    }, {
        id: "ground_f",
        pos: [2, -.046, 1.5],
        size: [12, 10],
        ang: 0,
        color: 1,
        children: [{
            id: "plant_small_d",
            pos: [.108, .23 - .245, 0],
            size: [1, 1],
            ang: -.5,
            color: 1
        }, {
            id: "plant_small_d",
            pos: [.11, .23 - .245, 0],
            size: [1, 1],
            ang: 0,
            color: 1
        }, {
            id: "plant_small_d",
            pos: [.112, .23 - .245, 0],
            size: [1, 1],
            ang: .6,
            color: 1
        }, {
            id: "plant_big_c",
            pos: [-.1, -.1, -.1],
            size: [.5, .5],
            ang: -.3,
            color: 1
        }]
    }, {
        id: "ground_e",
        pos: [0, .3, 5.1],
        size: [22.5, 6],
        ang: 0,
        color: 4,
        children: [{
            id: "plant_medium_d",
            pos: [-.1, -.07, -.03],
            size: [.5, .5],
            ang: -.3,
            color: 4
        }, {
            id: "plant_medium_e",
            pos: [-.101, -.08, -.08],
            size: [.5, .5],
            ang: -.1,
            color: 2
        }, {
            id: "plant_medium_i",
            pos: [-.06, -.02, -.01],
            size: [1, 1],
            ang: -.3,
            color: 4
        }, {
            id: "plant_big_k",
            pos: [.06, -.08, -.01],
            size: [1, 1],
            ang: .3,
            color: 4
        }, {
            id: "bush_a",
            pos: [-.11, -.1, -.09],
            size: [.8, .8],
            ang: -.4,
            color: 5
        }, {
            id: "plant_small_g",
            pos: [-.035, -.018, -.07],
            size: [.3, .3],
            ang: -.2,
            color: 4
        }, {
            id: "plant_medium_h",
            pos: [-.02, -.019, -.07],
            size: [.6, .6],
            ang: -.2,
            color: 4
        }]
    }, {
        id: "ground_b",
        pos: [8.6, .5, 5.8],
        size: [18.5, 8],
        ang: 0,
        color: 1,
        children: [{
            id: "plant_big_a",
            pos: [-.1, -.04, -.01],
            size: [.85, .85],
            ang: -.2,
            color: 7
        }, {
            id: "plant_big_j",
            pos: [.2, -.32, .01],
            size: [2.5, 2.5],
            ang: .2,
            color: 7
        }, {
            id: "plant_big_c",
            pos: [-.15, -.3, .01],
            size: [1, 1],
            ang: -.3,
            color: 7
        }]
    }, {
        id: "ground_ka",
        pos: [-7.9, .2, 6],
        size: [6.5, 6.5],
        ang: 0,
        color: 7,
        children: [{
            id: "ground_kb",
            pos: [.03, -.05, .012],
            size: [6.5, 6.5],
            ang: 0,
            color: 4
        }, {
            id: "plant_big_k",
            pos: [.45, -.04, -.05],
            size: [.8, .8],
            ang: .2,
            color: 9
        }, {
            id: "plant_medium_f",
            pos: [.57, -.08, -.001],
            size: [.8, .8],
            ang: .5,
            color: 7
        }]
    }, {
        id: "ground_ja",
        pos: [4.6, -.02, 3.8],
        size: [5, 5],
        ang: 0,
        color: 3,
        children: [{
            id: "ground_jb",
            pos: [0, -.05, .001],
            size: [5, 5],
            ang: 0,
            color: 4
        }, {
            id: "plant_medium_i",
            pos: [-.12, -.13, -.04],
            size: [1, 1],
            ang: -.3,
            color: 4
        }, {
            id: "plant_small_d",
            pos: [.208, -.03, .001],
            size: [.5, .5],
            ang: -.1,
            color: 3
        }, {
            id: "plant_small_d",
            pos: [.211, -.03, .001],
            size: [.5, .5],
            ang: .3,
            color: 3
        }, {
            id: "plant_small_d",
            pos: [.214, -.03, .001],
            size: [.5, .5],
            ang: .8,
            color: 3
        }]
    }, {
        id: "ground_i",
        pos: [9.5, -.04, 1],
        size: [15, 15],
        ang: 0,
        color: 5,
        children: [{
            id: "plant_small_f",
            pos: [.029, -.043, -.01],
            size: [1, 1],
            ang: -.1,
            color: 5
        }, {
            id: "plant_small_f",
            pos: [.03, -.046, -.01],
            size: [1, 1],
            ang: .3,
            color: 5
        }, {
            id: "plant_small_f",
            pos: [.032, -.045, -.01],
            size: [1, 1],
            ang: .7,
            color: 5
        }]
    }, {
        id: "ground_d",
        pos: [12, .8, 4],
        size: [30, 10],
        ang: 0,
        color: 4,
        children: [{
            id: "plant_small_f",
            pos: [0, -.04, 0],
            size: [1, 1.4],
            ang: -.3,
            color: 4
        }, {
            id: "plant_small_f",
            pos: [.001, -.023, 0],
            size: [1, 1.3],
            ang: .2,
            color: 4
        }]
    }, {
        id: "ground_d",
        pos: [25, 1.8, 3],
        size: [80, 30],
        ang: 0,
        color: 7,
        children: [{
            id: "plant_big_d",
            pos: [0, -.04, 0],
            size: [1.5, 1.5],
            ang: -.1,
            color: 7
        }, {
            id: "plant_big_c",
            pos: [-.05, -.17, .01],
            size: [2.5, 2.5],
            ang: 0,
            color: 2
        }]
    }, {
        id: "ground_b",
        pos: [-11, .9, 4.3],
        size: [20, 10],
        ang: 0,
        color: 1,
        children: [{
            id: "plant_big_f",
            pos: [.05, -.03, -.01],
            size: [.85, .85],
            ang: .1,
            color: 7
        }, {
            id: "bush_a",
            pos: [-.068, -.03, -.01],
            size: [.75, .75],
            ang: -.1,
            color: 1
        }, {
            id: "plant_medium_n",
            pos: [-.23, -.15, .01],
            size: [3, 3],
            ang: -.6,
            color: 1
        }, {
            id: "plant_big_a",
            pos: [-.1, -.33, .01],
            size: [1.5, 1.5],
            ang: -.3,
            color: 4
        }, {
            id: "plant_big_e",
            pos: [.05, -.32, .01],
            size: [1.2, 1.2],
            ang: .2,
            color: 4
        }]
    }, {
        id: "ground_d",
        pos: [-5, -.05, 2],
        size: [25, 8],
        ang: 0,
        color: 3,
        children: [{
            id: "plant_small_g",
            pos: [-.03, -.02, .01],
            size: [1, 1],
            ang: 0,
            color: 3
        }, {
            id: "bush_c",
            pos: [-.12, -.07, 0],
            size: [1.6, 1.6],
            ang: -.6,
            color: 3
        }, {
            id: "bush_b",
            pos: [.01, -.054, -.1],
            size: [2.5, 2.5],
            ang: .1,
            color: 2
        }, {
            id: "plant_medium_i",
            pos: [-.08, -.035, .1],
            size: [1.5, 1.5],
            ang: -.2,
            color: 3
        }]
    }, {
        id: "ground_d",
        pos: [-14, -1, -1],
        size: [30, 10],
        ang: 0,
        color: 5,
        children: [{
            id: "plant_small_f",
            pos: [-.05, .36 - .38, -.01],
            size: [1, 1.4],
            ang: -.3,
            color: 5
        }, {
            id: "plant_small_f",
            pos: [-.048, .35 - .38, -.01],
            size: [1, 1.3],
            ang: .2,
            color: 5
        }]
    }, {
        id: "ground_d",
        pos: [-17, .8, 4],
        size: [30, 10],
        ang: 0,
        color: 4,
        children: [{
            id: "plant_small_f",
            pos: [0, -.02, 0],
            size: [1, 1.4],
            ang: -.3,
            color: 4
        }, {
            id: "plant_small_f",
            pos: [.001, -.023, 0],
            size: [1, 1.3],
            ang: .2,
            color: 4
        }]
    }, {
        id: "ground_d",
        pos: [-25, 1.8, 5],
        size: [80, 30],
        ang: 0,
        color: 7,
        children: [{
            id: "plant_big_d",
            pos: [.07, -.06, 0],
            size: [1.5, 1.5],
            ang: .3,
            color: 7
        }, {
            id: "plant_big_i",
            pos: [.04, -.14, .5],
            size: [3, 3],
            ang: 0,
            color: 2
        }]
    }];
    n.forEach(e => {}
    ),
    t.a = {
        commonMisc: {
            prngSeed: 420
        },
        commonCamera: {
            lvl1: {
                cameraPositionPortrait: [.0496790401646031, 2.1126545641958385, 8.670646097365598],
                cameraRotationPortrait: [-.18382117049282592, .0017544061096452653, .0003261789975321793],
                cameraPositionLandscape: [.02011758723612407, 2.0786934522418656, 9.092284072031884],
                cameraRotationLandscape: [-.11933579444366336, .006885483457036979, .0008256008208852272]
            },
            lvl2: {
                cameraPositionPortrait: [-.023500755125586366, 2.9666298658500407, 10.195540752666096],
                cameraRotationPortrait: [-.15858430880073093, .003969930145298852, .0006348981825206649],
                cameraPositionLandscape: [-.2595335896261679, 3.859003555076481, 9.375164922448622],
                cameraRotationLandscape: [-.22646747660346253, -.025874136750328756, -.005961188960620516]
            },
            lvl3: {
                cameraPositionPortrait: [.44802209769965257, 2.9707052389817785, 16.16637782836729],
                cameraRotationPortrait: [.12974161684804034, .00034755650882428235, -4534727028102494e-20],
                cameraPositionLandscape: [.44802209769965257, 2.9707052389817785, 16.16637782836729],
                cameraRotationLandscape: [.12974161684804034, .00034755650882428235, -4534727028102494e-20]
            },
            lvl4: {
                cameraPositionPortrait: [.03517321751652233, 5.848420716204117, 24.233447697210103],
                cameraRotationPortrait: [.08109950400683669, .0014092769486694602, -.00011454285445748868],
                cameraPositionLandscape: [.11738807557034811, 5.958315924627909, 21.714234720583253],
                cameraRotationLandscape: [.04238709387336126, -.0018441190766770247, 7821365082617605e-20]
            }
        },
        commonScene: n,
        hideCamera: {
            cameraPositionHide: [-.14820971612492265, -.6323476820226778, 5.904166917437574],
            cameraRotationHide: [.06619242342195768, -.014856855358470594, .0009848134853483108],
            cameraHideColor: 4
        }
    }
}
, function(e, t, i) {
    "use strict";
    var n = i(9)
      , r = i(31)
      , s = i(38)
      , a = i(35)
      , o = i(20)
      , l = i(88)
      , c = i.n(l)
      , h = i(89)
      , u = i.n(h);
    class p extends n.a {
        constructor(e) {
            super(Object.assign({
                name: "Game Entry",
                log: 0,
                template: c.a,
                styles: u.a
            }, e))
        }
        afterMount() {
            super.afterMount(),
            this.title = this.addComponent(a.a, {
                data: {
                    text: this.data.title || "Congratulations",
                    underline: !1
                }
            }).mount(this.nodes.gameEntryTitle),
            this.gameIcon = this.addComponent(s.a, {
                name: this.data.gameName,
                renderer: this.data.unlocked ? "canvas" : "svg",
                speed: 2.5,
                data: {
                    modifiers: `${this.data.gameName}, game, ${this.data.unlocked ? "unlocked" : "locked"}`
                }
            }).mount(this.nodes.gameAnim)
        }
        beforeDestroy() {
            super.beforeDestroy()
        }
        close() {
            this.props.onClose && this.props.onClose()
        }
        playAnim() {
            o.a.device.current.type.mobile || (this.lockIcon ? this.lockIcon.lottie.play() : this.gameIcon.lottie.play())
        }
    }
    var d = i(81)
      , f = i(56)
      , m = i(13)
      , g = i(196)
      , v = i(24)
      , y = i(3)
      , b = i(16)
      , x = i(157)
      , w = i(83)
      , _ = i.n(w)
      , T = i(84)
      , M = i.n(T);
    class S extends n.a {
        constructor(e) {
            super(Object.assign({
                name: "notification",
                log: 0,
                template: _.a,
                styles: M.a
            }, e)),
            this.store.content = Object(y.a)("<p>Content</p>"),
            this.close = this.close.bind(this),
            this.tweens = {},
            this.isGameList = "game-list" === this.data.modifiers
        }
        afterMount() {
            super.afterMount(),
            this._mountComponents(),
            this._moveCloseOverlay(),
            this._bind(),
            this._onResize(),
            this.show()
        }
        beforeDestroy() {
            this.destroyed || (super.beforeDestroy(),
            this.nodes && this.nodes.close && this.nodes.close.parentNode.removeChild(this.nodes.close),
            this._unbind(),
            clearTimeout(this.showTimer))
        }
        _mountComponents() {
            if (this.title || (this.title = this.addComponent(a.a, {
                data: {
                    text: this.data.title
                }
            }).mount(e => this.nodes.inner.prepend(e))),
            this.data.button && !this.button) {
                let e = {
                    data: {
                        text: this.data.button.label,
                        modifiers: "blue, center",
                        url: this.data.button.url || "",
                        copyToClipboard: this.data.button.copyToClipboard,
                        copyText: this.data.button.copyText,
                        ref: this.data.button.ref
                    }
                };
                const t = e => {
                    e.target.getAttribute("rel") || e.preventDefault(),
                    this.data.button.noClose || this.close(),
                    this.data.button.onClick && this.data.button.onClick()
                }
                ;
                this.data.button.copyToClipboard || (e = Object.assign({
                    onClick: t
                }, e)),
                this.button = this.addComponent(r.a, e).mount(this.nodes.notificationButton),
                this.data.button.url && "internal" === this.button.nodes.main.getAttribute("rel") && this.button.nodes.main.removeAttribute("rel")
            }
            this.data.button2 && !this.button2 && (this.button2 = this.addComponent(r.a, {
                onClick: () => {
                    this.data.button.noClose || this.close(),
                    this.data.button2.onClick && this.data.button2.onClick()
                }
                ,
                data: {
                    text: this.data.button2.label,
                    modifiers: "blue, line-arrow"
                }
            }).mount(this.nodes.notificationButton),
            this.data.button2.url && "internal" === this.button2.nodes.main.getAttribute("rel") && this.button2.nodes.main.removeAttribute("rel")),
            this._mountGameList(this.data.game_list)
        }
        _moveCloseOverlay() {
            const e = this.nodes.close;
            document.body.appendChild(e)
        }
        _onResize() {
            if (!this.nodes)
                return;
            const e = d.a.mq({
                from: "md"
            });
            if (this.nodes.container.width = null,
            this.nodes.container.height = null,
            e) {
                this.boundingRect = this.nodes.container.getBoundingClientRect();
                const e = 2 * Math.ceil(Math.max(this.boundingRect.width, this.boundingRect.height) / 2);
                this.nodes.container.style.width = `${e}px`,
                this.nodes.container.style.height = `${e - .05 * e}px`
            }
        }
        _bind() {
            o.a.viewportSize.subscribe(this._onResize, this)
        }
        _unbind() {
            this.nodes.close.removeEventListener("click", this.close),
            o.a.viewportSize.unsubscribe(this._onResize, this)
        }
        _mountGameList(e) {
            if (e) {
                this.gameList = [];
                for (const t in e)
                    this.gameEntry = this.addComponent(p, {
                        data: {
                            title: e[t].title,
                            score: e[t].score,
                            best_score: e[t].best_score,
                            unlocked: e[t].unlocked,
                            water: e[t].water,
                            sun: e[t].sun,
                            gameName: e[t].name,
                            unlock_guide: e[t].unlock_guide
                        },
                        onClose: () => this.close(null, !0)
                    }).mount(this.nodes.notificationContent)
            }
        }
        show() {
            const e = d.a.mq({
                from: "md"
            })
              , t = this.nodes.sun ? 50 : 0;
            this.nodes.sun && (this.showSun = Object(b.a)({
                target: this.nodes.sun,
                duration: 250,
                transform: ["translateY(50%) scale(0)", "translateY(0) scale(1)"],
                ease: "bouncy",
                willChange: !0
            })),
            this.nodes.water && (this.showWater = Object(b.a)({
                target: this.nodes.water,
                duration: 250,
                delay: t,
                transform: ["translateY(50%) scale(0)", "translateY(0) scale(1)"],
                ease: "bouncy",
                willChange: !0
            })),
            this.nodes.won && (this.showTotal = Object(b.a)({
                target: this.nodes.won,
                duration: 250,
                delay: 50 + t,
                transform: ["translateY(50%) scale(0)", "translateY(0) scale(1)"],
                ease: "bouncy",
                willChange: !0
            })),
            Object(b.a)({
                target: this.nodes.container,
                duration: e ? 250 : 500,
                opacity: e ? [0, 1] : [.99, 1],
                transform: e ? ["scale(0.5)", "scale(1)"] : ["translateY(125%)", "translateY(0)"],
                ease: e ? [0, 1.38, .37, 1] : "out-swift",
                willChange: !0
            }).play().then( () => {
                this.showSun && this.showSun.play(),
                this.showWater && this.showWater.play(),
                this.showTotal && this.showTotal.play()
            }
            ),
            Object(b.a)({
                target: this.nodes.close,
                duration: 250,
                opacity: [0, 1],
                ease: "out-swift",
                willChange: !0
            }).play().then( () => this.visible = !0),
            o.a.notificationOpen.set(!0),
            g.a.play("game_menu_open")
        }
        close(e, t) {
            if (!this.visible)
                return;
            const i = d.a.mq({
                from: "md"
            });
            if (this.data.onClose && this.data.onClose(),
            Object(b.a)({
                target: this.nodes.container,
                duration: i ? 250 : 500,
                opacity: !!i && 0,
                transform: i ? "scale(0.75)" : "translateY(125%)",
                ease: i ? [.58, .005, .67, -.6] : "out-swift"
            }).play(),
            Object(b.a)({
                target: this.nodes.close,
                delay: 100,
                duration: 300,
                opacity: 0,
                ease: "out-swift"
            }).play().then( () => {
                this.data.button && this.data.button.url && !this.data.button.noRedirect && f.a.navigate(this.data.button.url),
                I.destroy(this),
                this.visible = !1,
                o.a.notificationOpen.set(!1)
            }
            ),
            this.data.game_list) {
                const e = v.a.flags.current;
                e.openGame || (e.openGame = !0,
                v.a.flags.set(e, !0),
                x.a.replanQueries(),
                m.a.requestSave())
            }
            t ? g.a.play("game_menu_validate") : g.a.play("game_menu_close")
        }
    }
    var A = i(158)
      , P = i(6)
      , C = i(50)
      , L = i(52);
    const k = () => {
        let e = 0;
        const t = v.a.seedsArray.current;
        for (let i = 0, n = t.length; i < n; i++)
            if (t[i].level.current > 0 && e++,
            e >= 2)
                return !0;
        return !1
    }
      , E = () => v.a.getSeedById("karite").unlocked.current;
    var I = t.a = new class {
        constructor() {
            this.current = null,
            this.queued = [],
            this.body = document.body
        }
        add(e) {
            this.current ? this.queued.push(e) : (this.current = e,
            this.mount(e))
        }
        createBase(e) {
            const t = new S({
                data: e
            });
            return this.add(t),
            t
        }
        createDemoModeAlert() {
            const e = new S({
                data: {
                    title: Object(P.a)("interface.demo_mode.title"),
                    text: Object(P.a)("interface.demo_mode.desc"),
                    button: {
                        label: Object(P.a)("interface.demo_mode.cta"),
                        onClick: () => {}
                    }
                }
            });
            return this.add(e),
            e
        }
        createAskRegister(e={}) {
            if (o.a.demoMode.current)
                return void (e.onClose && e.onClose());
            const t = new S({
                data: {
                    title: Object(P.a)("interface.inscription.title"),
                    text: Object(P.a)(`interface.inscription.description_${e.type || "gift"}`),
                    button: {
                        label: Object(P.a)("interface.inscription.cta_to_save"),
                        onClick: () => {
                            o.a.seedListOpen.set(!1),
                            o.a.menuOpen.set(!0),
                            o.a.leftPanelView.set({
                                type: "login"
                            }),
                            o.a.registerFromPopin.set(!0),
                            "tutoriel" === e.type && A.a.event({
                                type: "mmEvent",
                                category: "introduction",
                                action: "tutorial_register"
                            })
                        }
                    },
                    button2: {
                        label: Object(P.a)("interface.inscription.cta_save_later"),
                        onClick: () => {
                            A.a.event({
                                type: "mmEvent",
                                category: "tutoriel" === e.type ? "introduction" : "voucher",
                                action: "tutoriel" === e.type ? "tutorial_register_later" : "gift_register_later"
                            })
                        }
                    },
                    onClose: e.onClose
                }
            });
            return this.add(t),
            t
        }
        createRegisterConfirm(e={}) {
            const t = new S({
                data: {
                    title: Object(P.a)("interface.form.confirmation_title"),
                    text: Object(P.a)("interface.form.confirmation_description"),
                    button: {
                        label: Object(P.a)("interface.form.confirmation_cta")
                    },
                    onClose: e.onClose
                }
            });
            return this.add(t),
            A.a.event({
                type: "mmEvent",
                category: "form",
                action: "confirm_inscription"
            }),
            o.a.registerFromPopin.current && A.a.event({
                type: "mmEvent",
                category: "voucher",
                action: "gift_register"
            }),
            t
        }
        createDisconnect() {
            const e = new S({
                data: {
                    prevent_overlay_close: !0,
                    title: Object(P.a)("interface.connection.disconnect_title"),
                    text: Object(P.a)("interface.connection.disconnect_description"),
                    button: {
                        label: Object(P.a)("interface.form.confirmation_cta"),
                        onClick: () => {
                            document.location.reload()
                        }
                    }
                }
            });
            return this.add(e),
            e
        }
        createGameOver(e="bucket") {
            const t = v.a.currentSeed.current ? v.a.currentSeed.current.id.current : "cerisier"
              , i = L.games[e]
              , n = {
                prevent_overlay_close: !0,
                modifiers: `game-over, ${e}`,
                title: Object(P.a)("interface.game.game_over"),
                button: {
                    label: Object(P.a)("interface.game.cta_collect"),
                    url: f.a.url("seed", {
                        id: t
                    })
                },
                game_over: {
                    score: v.a.scores[e].current || 0,
                    best_score: v.a.highScores[e].current || 0,
                    points: Object(P.a)("interface.game.point"),
                    best_score_text: Object(P.a)("interface.game.best_score"),
                    resources_won: C.a.scoreToResources(e, v.a.scores[e].current) || 0,
                    water: !!i.water,
                    sun: !!i.sun
                }
            }
              , r = new S({
                data: n
            });
            this.add(r);
            let s = "water_game";
            switch (e) {
            case "caterpillars":
                s = "parasites_game";
                break;
            case "spiders":
                s = "light_game"
            }
            return A.a.event({
                type: "mmEvent",
                category: "mini-game",
                action: `score_${s}`,
                label: v.a.scores[e].current
            }),
            r
        }
        createAllSeedsComplete() {
            this.delay && (clearTimeout(this.delay),
            this.delay = null);
            const e = Object(P.a)("api.finalChallenge")
              , t = {
                title: e ? e.popinTitle : Object(P.a)("interface.messages.end_game_title"),
                text: e ? e.popinDescription : Object(P.a)("interface.messages.end_game_text"),
                button: {
                    label: e ? e.buttonLabel : Object(P.a)("interface.messages.end_game_cta"),
                    url: e ? v.a.vouchers.current.final.link : "",
                    noRedirect: !!e,
                    onClick: () => {
                        e || (o.a.leftPanelView.set({
                            type: "vouchers"
                        }),
                        o.a.menuOpen.set(!0))
                    }
                }
            }
              , i = new S({
                data: t
            });
            return this.delay = setTimeout( () => {
                this.add(i)
            }
            , 3e3),
            A.a.event({
                type: "mmEvent",
                category: "plant",
                action: "end_game"
            }),
            i
        }
        mount(e) {
            e && e.mount(this.body)
        }
        createGameList() {
            const e = {
                modifiers: "game-list",
                title: Object(P.a)("interface.game.title"),
                game_list: {
                    bucket: {
                        unlocked: !0,
                        title: Object(P.a)("interface.game.game_bucket"),
                        name: "bucket",
                        score: 0,
                        best_score: v.a.highScores.bucket.current,
                        water: !0
                    },
                    spiders: {
                        unlocked: k(),
                        title: Object(P.a)("interface.game.game_spiders"),
                        name: "spiders",
                        score: 0,
                        best_score: v.a.highScores.spiders.current,
                        unlock_guide: Object(P.a)("interface.game.game_spiders_unlock"),
                        sun: !0
                    },
                    caterpillars: {
                        unlocked: E(),
                        title: Object(P.a)("interface.game.game_caterpillars"),
                        name: "caterpillars",
                        score: 0,
                        best_score: v.a.highScores.caterpillars.current,
                        unlock_guide: Object(P.a)("interface.game.game_caterpillars_unlock"),
                        sun: !0,
                        water: !0
                    }
                }
            }
              , t = new S({
                data: e
            });
            return this.add(t),
            t
        }
        destroy(e) {
            if (e)
                if (e == this.current)
                    this.current.destroy(),
                    this.current = null,
                    this.checkQueue();
                else {
                    const t = this.queued.indexOf(e);
                    -1 !== t && (this.queued.splice(t, 1),
                    e.destroy())
                }
        }
        checkQueue() {
            this.queued.length > 0 && (this.add(this.queued[0]),
            this.queued.splice(0, 1))
        }
    }
}
, , function(e, t, i) {
    "use strict";
    var n = i(3)
      , r = i(14)
      , s = i(32);
    function a(e) {
        for (let t = h.seedsArray.current.length - 1; t >= 0; t--)
            if (e === h.seedsArray.current[t])
                return t;
        return 0
    }
    var o = {
        getSeedById: function(e) {
            return h.seeds.current[e] || null
        },
        getSeedByIndex: function(e) {
            return h.seedsArray.current[e] || null
        },
        getIndexFromSeed: a,
        getPreviousSeed: function(e) {
            const t = a(e || h.currentSeed.current)
              , i = t > 0 ? t - 1 : h.seedsArray.current.length - 1;
            return h.seedsArray.current[i]
        },
        getNextSeed: function(e) {
            const t = a(e || h.currentSeed.current)
              , i = t < h.seedsArray.current.length - 1 ? t + 1 : 0;
            return h.seedsArray.current[i]
        },
        getSeedsCount: function() {
            return h.seedsArray.current.length
        }
    };
    const l = () => ({
        collectable: Object(n.a)(0),
        amount: Object(n.a)(0),
        lastRefill: Object(n.a)(0)
    })
      , c = Object.freeze({
        playTime: Object(n.a)(0),
        id: Object(n.a)(null),
        sessionId: Object(n.a)(Date.now() + ""),
        socialPrefill: Object(n.a)(null),
        startDate: Object(n.a)(0),
        lastDay: Object(n.a)(0),
        daysCount: Object(n.a)(0),
        starterChosen: Object(n.a)(!1),
        gameComplete: Object(n.a)(!1),
        vouchers: Object(n.a)({}),
        gameButtonCalled: Object(n.a)(!1),
        flags: Object(n.a)({
            gaveWater: !1,
            gaveSun: !1,
            gaveLove: !1,
            openGame: !1,
            openMessage: !1,
            openBag: !1,
            openGift: !1,
            useGarden: !1,
            hasNotifications: !1
        }),
        highScores: {
            bucket: Object(n.a)(0),
            caterpillars: Object(n.a)(0),
            spiders: Object(n.a)(0)
        },
        scores: {
            bucket: Object(n.a)(0),
            caterpillars: Object(n.a)(0),
            spiders: Object(n.a)(0)
        },
        resources: {
            water: l(),
            sun: l(),
            game: l()
        },
        playerReady: new s.a,
        pooledResources: Object(r.b)({
            sun: 0,
            water: 0
        }),
        offsetMultiplier: Object(n.a)(0),
        previousSeed: Object(n.a)(null),
        requestedSeed: Object(n.a)(null),
        currentSeed: Object(n.a)(null),
        seedsArray: Object(n.a)([]),
        seeds: Object(n.a)({}),
        getCurrent: () => c.currentSeed.current,
        getSeedsCount: o.getSeedsCount,
        getSeedById: o.getSeedById,
        getSeedByIndex: o.getSeedByIndex,
        getIndexFromSeed: o.getIndexFromSeed,
        getPreviousSeed: o.getPreviousSeed,
        getNextSeed: o.getNextSeed
    });
    var h = t.a = c
}
, function(e, t, i) {
    "use strict";
    t.a = function(e) {
        const t = function(e) {
            const t = [];
            do {
                const i = Object.getOwnPropertyNames(e);
                for (let n = 0, r = i.length; n < r; n++) {
                    const r = i[n]
                      , s = Object.getOwnPropertyDescriptor(e, r);
                    s.get || s.set || t.push(r)
                }
            } while (e = Object.getPrototypeOf(e));
            return t
        }(e);
        for (let i = 0, n = t.length; i < n; i++) {
            const n = t[i]
              , r = e[n];
            "constructor" !== n && "function" == typeof r && (e[n] = e[n].bind(e))
        }
        return e
    }
}
, , function(e, t, i) {
    "use strict";
    var n = i(3)
      , r = i(32);
    const s = Object.freeze({
        quality: Object(n.a)("low"),
        forceCompressedTextureInDev: Object(n.a)(!0),
        useCompressedTexture: Object(n.a)(!0),
        compressedTextureFormat: Object(n.a)(null),
        canvasSize: Object(n.a)([0, 0]),
        canvasPixelRatio: Object(n.a)(1.5),
        canvasPixelRatios: Object(n.a)([0, 0]),
        bgColor: Object(n.a)(!1),
        enableShadows: Object(n.a)(!1),
        drawingBufferSize: Object(n.a)([0, 0]),
        recomputeDOMObjects: new r.a,
        overlayVisible: Object(n.a)(!1)
    });
    t.a = s
}
, function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return a
    });
    var n = i(8)
      , r = i(17);
    const s = {
        noTemplate: "Can not initialize module, template is undefined",
        cantMount: "Can't mount View without parentNode",
        badRendering: "Error on getting nodes: no main DOM node"
    };
    class a {
        constructor(e={}) {
            this.props = e,
            this.template = e.template,
            this.styles = e.styles,
            this.name = e.name || this.constructor && this.constructor.name || (e.isView ? "View" : "Component"),
            this.parent = null,
            this.components = [],
            this.nodes = {},
            this.refs = {},
            this.data = e.data || {},
            this.anims = {},
            this.rendered = !1,
            this.mounted = !1,
            this.destroyed = !1;
            const t = e.log || e.useLog || !1;
            this.logger = Object(r.a)({
                prefix: this.name.toUpperCase(),
                color: "#000",
                background: "#d9dddf",
                disable: !t
            }),
            this.logger.log("Create")
        }
        beforeRender() {}
        afterRender() {}
        beforeMount() {}
        afterMount() {}
        beforeDestroy() {}
        enter() {}
        exit() {
            this.destroy()
        }
        addComponent(e, t) {
            const i = e.render ? e : new e(t);
            return ~this.components.indexOf(i) || this.components.push(i),
            i.parent = this,
            i
        }
        removeComponent(e) {
            const t = this.components.indexOf(e);
            ~t && this.components.splice(t, 1),
            e.parentNode === this && (e.parentNode = null)
        }
        hydrate(e) {
            this.destroyed || this.rendered || this.mounted || (this.logger.log("Hydrate"),
            this.render(e),
            this.mount(null, e))
        }
        render(e) {
            if (!this.destroyed && !this.rendered) {
                if (!e && !this.template)
                    return this.logger.error(s.noTemplate);
                if (this.beforeRender(this.props),
                this.logger.log("Render"),
                e)
                    this.nodes.main = e,
                    this.nodes.main && n.a.templateEngine.getNodesFromDom(this.nodes.main, this.nodes);
                else {
                    const e = Object.assign({}, this.data, n.a.data, n.a.files.getAssetPaths());
                    this.nodes = n.a.templateEngine.render(this.template, e)
                }
                if (!this.nodes.main)
                    return this.logger.error(s.badRendering);
                this.rendered = !0,
                this.afterRender(this.props)
            }
        }
        mount(e, t) {
            if (!t && !e)
                return this.logger.error(s.cantMount);
            if (this.destroyed)
                return;
            if (this.rendered || this.render(),
            !this.rendered)
                return;
            const i = t || this.mounted;
            return this.beforeMount(this.props, i),
            this.logger.log("Mount"),
            t || ("function" == typeof e ? e(this.nodes.main) : e.appendChild(this.nodes.main)),
            this.mounted = !0,
            this.afterMount(this.props, i),
            this
        }
        beforeUnmount() {}
        unmount() {
            !this.destroyed && this.mounted && (this.beforeUnmount(),
            this.nodes.main && this.nodes.main.parentNode ? (this.nodes.main.parentNode.removeChild(this.nodes.main),
            this.mounted = !1) : this.mounted = !1)
        }
        destroy() {
            if (!this.destroyed) {
                this.logger.log("Destroy"),
                this.beforeDestroy(this.props);
                for (let e = this.components.length - 1; e >= 0; e--)
                    this.components[e].destroy();
                this.parent && this.parent.removeComponent(this),
                this.unmount(),
                this.parent = null,
                this.components = null,
                this.nodes = null,
                this.props = null,
                this.template = null,
                this.styles = null,
                this.refs = null,
                this.data = null,
                this.mounted = !1,
                this.rendered = !1,
                this.destroyed = !0
            }
        }
    }
}
, function(e, t, i) {
    "use strict";
    var n = i(17);
    t.a = Object(n.a)("🌱 SEEDS", "black", "#ecffca", 1).log
}
, function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return r
    });
    const n = {
        amandier: "almond-tree",
        lavande: "lavender",
        immortelle: "immortelle",
        rose: "rose",
        cerisier: "cherry-tree",
        verveine: "verbena",
        cedrat: "citrus-tree",
        karite: "shea-tree"
    };
    function r(e) {
        return n[e] || e
    }
}
, function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return h
    });
    var n = i(86)
      , r = i(9)
      , s = i(30)
      , a = i(158)
      , o = i(20)
      , l = i(87)
      , c = i.n(l);
    class h extends r.a {
        constructor(e) {
            super(Object.assign({
                name: "Call To Action",
                log: 0,
                template: c()
            }, e)),
            this.props.onClick && (this.props.data.onClick = !0,
            this.onClick = this.props.onClick)
        }
        copyToClipboard(e) {
            e.stopPropagation(),
            e.preventDefault(),
            n.a(this.nodes.main.dataset.copyText),
            this.openTooltip(),
            o.a.menuOpen.current && a.a.event({
                type: "mmEvent",
                category: "voucher",
                action: "copy_voucher",
                label: Object(s.a)(e.target.dataset.seedId)
            })
        }
        openTooltip() {
            this.nodes.callToActionTooltip.classList.add("is-visible"),
            this.tooltipDelay = setTimeout(this.closeTooltip.bind(this), 3e3)
        }
        closeTooltip() {
            clearTimeout(this.tooltipDelay),
            this.tooltipDelay = null,
            this.buttonText = null,
            this.nodes && this.nodes.callToActionTooltip.classList.remove("is-visible")
        }
    }
}
, function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return s
    });
    function n(e, t, i, n) {
        0,
        this.fn = t,
        this.ctx = i || null,
        this.owner = e,
        this.once = !!n
    }
    function r(e, t) {
        0,
        t.prev && (t.prev.next = t.next),
        t.next && (t.next.prev = t.prev),
        t.ctx = t.fn = t.owner = null,
        t === e._first && (e._first = t.next),
        t === e._last && (e._last = t.prev)
    }
    class s {
        constructor() {
            this._first = this._last = null
        }
        dispatch(e, t, i, n, r) {
            let s = this._first;
            for (; s; )
                s.fn.call(s.ctx, e, t, i, n, r),
                s.once && this.unsubscribe(s),
                s = s.next
        }
        subscribe(e, t, i) {
            const r = new n(this,e,t,i);
            return this._first ? (this._last.next = r,
            r.prev = this._last,
            this._last = r) : (this._first = r,
            this._last = r),
            r
        }
        subscribeOnce(e, t) {
            return this.subscribe(e, t, !0)
        }
        unsubscribe(e, t) {
            if (e instanceof n)
                return r(this, e);
            t || (t = null);
            let i = this._first;
            for (; i; )
                i.fn === e && i.ctx === t && r(this, i),
                i = i.next
        }
        unsubscribeAll() {
            let e = this._first;
            for (this._first = this._last = null; e; )
                r(this, e),
                e = e.next
        }
    }
}
, function(e, t, i) {
    "use strict";
    var n = i(0)
      , r = i(27);
    class s {
        constructor(e, t) {
            this.arrayBuffer = e;
            const i = new Uint8Array(this.arrayBuffer,0,12);
            if (171 !== i[0] || 75 !== i[1] || 84 !== i[2] || 88 !== i[3] || 32 !== i[4] || 49 !== i[5] || 49 !== i[6] || 187 !== i[7] || 13 !== i[8] || 10 !== i[9] || 26 !== i[10] || 10 !== i[11])
                return;
            const n = Uint32Array.BYTES_PER_ELEMENT
              , r = new DataView(this.arrayBuffer,12,13 * n)
              , a = 67305985 === r.getUint32(0, !0);
            this.glType = r.getUint32(1 * n, a),
            this.glTypeSize = r.getUint32(2 * n, a),
            this.glFormat = r.getUint32(3 * n, a),
            this.glInternalFormat = r.getUint32(4 * n, a),
            this.glBaseInternalFormat = r.getUint32(5 * n, a),
            this.pixelWidth = r.getUint32(6 * n, a),
            this.pixelHeight = r.getUint32(7 * n, a),
            this.pixelDepth = r.getUint32(8 * n, a),
            this.numberOfArrayElements = r.getUint32(9 * n, a),
            this.numberOfFaces = r.getUint32(10 * n, a),
            this.numberOfMipmapLevels = r.getUint32(11 * n, a),
            this.bytesOfKeyValueData = r.getUint32(12 * n, a),
            0 === this.glType && (this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels),
            0 !== this.pixelHeight && 0 === this.pixelDepth && 0 === this.numberOfArrayElements && this.numberOfFaces === t && (this.loadType = s.COMPRESSED_2D))
        }
        mipmaps(e) {
            const t = [];
            let i = s.HEADER_LEN + this.bytesOfKeyValueData
              , n = this.pixelWidth
              , r = this.pixelHeight;
            const a = e ? this.numberOfMipmapLevels : 1;
            for (let e = 0; e < a; e++) {
                const e = new Int32Array(this.arrayBuffer,i,1)[0];
                i += 4;
                for (let s = 0; s < this.numberOfFaces; s++) {
                    const s = new Uint8Array(this.arrayBuffer,i,e);
                    t.push({
                        data: s,
                        width: n,
                        height: r
                    }),
                    i += e,
                    i += 3 - (e + 3) % 4
                }
                n = Math.max(1, .5 * n),
                r = Math.max(1, .5 * r)
            }
            return t
        }
    }
    function a(e, t) {
        const i = new s(e,1);
        return {
            mipmaps: i.mipmaps(t),
            width: i.pixelWidth,
            height: i.pixelHeight,
            format: i.glInternalFormat,
            isCubemap: 6 === i.numberOfFaces,
            mipmapCount: i.numberOfMipmapLevels
        }
    }
    s.HEADER_LEN = 64,
    s.COMPRESSED_2D = 0,
    s.COMPRESSED_3D = 1,
    s.TEX_2D = 2,
    s.TEX_3D = 3;
    var o = i(135)
      , l = i(74)
      , c = i.n(l);
    const h = {
        jpg: !0,
        jpeg: !0,
        png: !0,
        gif: !0,
        tga: !0
    };
    function u() {
        return r.a.useCompressedTexture.current
    }
    function p() {
        return u() ? r.a.compressedTextureFormat.current : null
    }
    function d(e) {
        if (!m(e))
            return e;
        const t = e.split("?")[0].split(".")
          , i = t[t.length - 1];
        return h[i] ? (t[t.length - 1] = "ktx",
        t.join(".")) : e
    }
    function f(e) {
        return m(e) ? e.replace(/\.tex\.pack/, "." + p() + ".pack") : e
    }
    function m(e) {
        if (!u())
            return !1;
        const t = e.split(".pack")[0].split("/").pop() + ".pack";
        return !(c.a.packs[t] || c.a.packs.default).noCompression
    }
    t.a = {
        isUsed: u,
        getFormat: p,
        replacePath: function(e) {
            return m(e) ? d(f(e)) : e
        },
        replaceImagePath: d,
        replacePackPath: f,
        parseKTX: a,
        createTexture: function(e, t) {
            let i;
            return i = e.format || e.mipmaps ? e : a(e, t),
            new n.l(i.mipmaps,i.width,i.height,i.format)
        },
        canImageBeCompressed: m,
        getOriginalSize: function(e) {
            const t = e.split("/").pop();
            return o[t] || null
        }
    }
}
, function(e, t, i) {
    "use strict";
    var n = i(0)
      , r = i(3)
      , s = i(14)
      , a = i(32);
    const o = (e, t) => ({
        position: new n.T,
        scale: new n.T(e,t)
    })
      , l = Object.freeze({
        disableResourceOverflow: Object(s.b)(!1),
        date: Object(r.a)(0),
        dateFloat: Object(r.a)(0),
        time: Object(r.a)(0),
        sceneTime: Object(r.a)(0),
        playerResourceTypes: Object(s.b)(["water", "sun", "game"]),
        seedResourceTypes: Object(s.b)(["water", "sun", "love"]),
        saveDelay: Object(s.b)(2e4),
        saveDebouncedDelay: Object(s.b)(2e3),
        updateDelay: Object(s.b)(500),
        saving: Object(r.a)(!1),
        panelOffset: Object(r.a)(0),
        blobOffset: Object(r.a)(0),
        resourceButtonPositions: {
            water: new n.T,
            sun: new n.T
        },
        resourceButtonClick: new a.a,
        resourceButtonEnd: new a.a,
        resourceButtonReceive: {
            water: new a.a,
            sun: new a.a,
            game: new a.a
        },
        rules: Object(r.a)({}),
        gardenNotification: Object(r.a)(!1),
        spinePrescale: Object(s.b)(.023),
        spineScale: Object(s.b)(.06),
        resourcesColors: Object(s.b)({
            sun: {
                normal: new n.k,
                light: new n.k
            },
            water: {
                normal: new n.k,
                light: new n.k
            },
            love: {
                normal: new n.k,
                light: new n.k
            },
            game: {
                normal: new n.k,
                light: new n.k
            },
            gift: {
                normal: new n.k("#c79a4b"),
                light: new n.k("#c79a4b")
            },
            message: {
                normal: new n.k("#c79a4b"),
                light: new n.k("#c79a4b")
            }
        }),
        muteGuide: Object(r.a)(!1),
        guideAnchors: Object(r.a)({
            water: o(-1, 1),
            sun: o(-1, 1),
            game: o(1, 1),
            seed: o(-1, -1),
            bag: o(-1, -1),
            gift: o(1, 1),
            garden: o(1, -1),
            starter: o(1, -1)
        }),
        palettes: Object(s.b)({
            supablue: [new n.k("#121758"), new n.k("#1f2e7d"), new n.k("#171e5f"), new n.k("#1a2565"), new n.k("#2180c3"), new n.k("#254c8e"), new n.k("#101648"), new n.k("#0f1346"), new n.k("#d5a552"), new n.k("#ffffff"), new n.k("#1f2e7d")],
            blue: [new n.k("#161d6e"), new n.k("#243683"), new n.k("#1f2a74"), new n.k("#80caf1"), new n.k("#3964ab"), new n.k("#5ea3dc"), new n.k("#3964ab"), new n.k("#0d124f"), new n.k("#3daebf"), new n.k("#ffffff"), new n.k("#243683")],
            red: [new n.k("#97204a"), new n.k("#9d3459"), new n.k("#a64060"), new n.k("#ffc8c3"), new n.k("#fd8296"), new n.k("#f4b7bf"), new n.k("#752e45"), new n.k("#562032"), new n.k("#d5a552"), new n.k("#ffffff"), new n.k("#9a3056")],
            tchern: [new n.k("#cdfafc"), new n.k("#93f0e6"), new n.k("#bef0fa"), new n.k("#aaedff"), new n.k("#24b2b9"), new n.k("#7dd2c9"), new n.k("#082941"), new n.k("#083d64"), new n.k("#ffffff"), new n.k("#92c0bf"), new n.k("#bef0fa")],
            safari: [new n.k("#f4ebd7"), new n.k("#e7d7ca"), new n.k("#fffadc"), new n.k("#e3c07a"), new n.k("#788560"), new n.k("#93a17b"), new n.k("#3d3c4e"), new n.k("#090d3a"), new n.k("#e3ddcf"), new n.k("#E3C07A"), new n.k("#eadccc")]
        })
    });
    t.a = l
}
, function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return a
    });
    var n = i(9)
      , r = i(85)
      , s = i.n(r);
    class a extends n.a {
        constructor(e) {
            super(Object.assign({
                name: "Title",
                log: 0,
                template: s()
            }, e)),
            e.store && (this.store.titleText = e.store,
            e.data.store = !0)
        }
    }
}
, , , function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return p
    });
    var n = i(90)
      , r = i.n(n)
      , s = i(9)
      , a = i(8)
      , o = i(186)
      , l = i(91)
      , c = i.n(l)
      , h = i(92)
      , u = i.n(h);
    class p extends s.a {
        constructor(e) {
            super(Object.assign({
                name: `Bodymovin - ${e.name}`,
                log: 0,
                template: c(),
                styles: u()
            }, e)),
            this.noPlay = o.a.lessEqual("low"),
            this.settings = {
                renderer: e.renderer || "canvas",
                loop: e.loop || !1,
                autoplay: !this.noPlay && (e.loop || !1),
                animationData: a.a.files.get(`app.pack/bodymovin/${e.name}.json`),
                speed: e.speed || 1
            }
        }
        afterMount() {
            super.afterMount(),
            this.settings.container = this.nodes.main,
            this.lottie = r.a.loadAnimation(this.settings),
            this.lottie.setSpeed(this.settings.speed),
            this.noPlay && this.lottie.stop(),
            this.settings.loop || this.lottie.addEventListener("complete", () => this.lottie.stop())
        }
        beforeDestroy() {
            super.beforeDestroy(),
            this.lottie && this.lottie.destroy(),
            this.logger.log(this.lottie)
        }
        play(e) {
            (e || !this.settings.autoplay && !this.noPlay) && (this.lottie.stop(),
            this.lottie.play())
        }
        stop() {
            this.lottie.stop()
        }
    }
}
, function(e, t, i) {
    "use strict";
    i.d(t, "b", function() {
        return s
    }),
    i.d(t, "a", function() {
        return a
    });
    var n = i(12);
    const r = [];
    function s(e) {
        let t = r.length;
        for (; t--; )
            r[t].update(e),
            r[t] && !r[t]._stopped || (r[t] && r[t].dispose(),
            r.splice(t, 1))
    }
    function a(e=1e3, t) {
        const i = new n.a(e,t);
        return r.push(i),
        {
            destroy: function() {
                i.dispose();
                const e = r.indexOf(i);
                ~e && r.splice(e, 1)
            }
        }
    }
}
, , , function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return c
    });
    var n = i(13)
      , r = i(158)
      , s = i(30)
      , a = i(24)
      , o = i(29)
      , l = i(18);
    function c(e) {
        const {seedStore: t, seedSettings: i} = Object(l.a)(e);
        t && i && (t.unlocked.current || (Object(o.a)(`Unlock ${e}`),
        t.unlocked.set(!0),
        i.starter && !a.a.starterChosen.current && a.a.starterChosen.set(!0),
        n.a.requestSave(),
        r.a.event({
            type: "mmEvent",
            category: "plant",
            action: "unlock_seed",
            label: `${Object(s.a)(e)}`
        })))
    }
}
, , function(e, t, i) {
    "use strict";
    var n = i(8)
      , r = i(34)
      , s = i(33)
      , a = i(0)
      , o = (i(12),
    "precision highp float;\n#define GLSLIFY 1\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nattribute vec2 uv;\nattribute vec3 position;\nattribute vec4 color;\n\nvarying vec3 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvUv = uv;\n\tvColor = color.rgb;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4 (\n\t\t-position.x,\n\t\tposition.yz,\n\t\t1.0\n\t);\n\n}\n")
      , l = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D map;\nuniform float flash;\nuniform float time;\n\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nconst vec3 white = vec3(1.);\n\nvoid main(void) {\n\n\tvec4 color = texture2D(map, vUv).rgba;\n\tcolor.rgb = clamp(color.rgb / clamp(color.a * 0.96, 0.000001, 1.), 0., 1.);\n\tcolor.rgb = mix(color.rgb, white, flash) * vColor;\n\tif (color.a < 0.65) discard;\n\tgl_FragColor = color;\n\n}\n";
    let c = null;
    const h = [];
    class u extends a.M {
        constructor() {
            super({
                uniforms: {
                    map: {
                        type: "t",
                        value: null
                    },
                    flash: {
                        type: "f",
                        value: 0
                    }
                },
                vertexShader: o,
                fragmentShader: l,
                transparent: !0
            }),
            this.useObjectUniforms = !0,
            this.isSkeletonMeshMaterial = !0
        }
    }
    u.get = function() {
        let e = h.shift();
        return c || (c = new u),
        e || (e = c.clone()),
        e
    }
    ,
    u.release = function(e) {
        e.uniforms.map.value = null,
        e.uniforms.flash.value = 0,
        h.length < 4 ? h.push(e) : e.dispose()
    }
    ,
    u.prototype.release = function() {
        u.release(this)
    }
    ;
    const p = function(e) {
        var t, i, n, r = this && this.__extends || (t = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(e, t) {
            e.__proto__ = t
        }
        || function(e, t) {
            for (var i in t)
                t.hasOwnProperty(i) && (e[i] = t[i])
        }
        ,
        function(e, i) {
            function n() {
                this.constructor = e
            }
            t(e, i),
            e.prototype = null === i ? Object.create(i) : (n.prototype = i.prototype,
            new n)
        }
        );
        return function(e) {
            var t, i, n, s = function() {
                function e(e, t, i) {
                    if (null == e)
                        throw new Error("name cannot be null.");
                    if (null == t)
                        throw new Error("timelines cannot be null.");
                    this.name = e,
                    this.timelines = t,
                    this.duration = i
                }
                return e.prototype.apply = function(e, t, i, n, r, s, a, o) {
                    if (null == e)
                        throw new Error("skeleton cannot be null.");
                    n && 0 != this.duration && (i %= this.duration,
                    t > 0 && (t %= this.duration));
                    for (var l = this.timelines, c = 0, h = l.length; c < h; c++)
                        l[c].apply(e, t, i, r, s, a, o)
                }
                ,
                e.binarySearch = function(e, t, i) {
                    void 0 === i && (i = 1);
                    var n = 0
                      , r = e.length / i - 2;
                    if (0 == r)
                        return i;
                    for (var s = r >>> 1; ; ) {
                        if (e[(s + 1) * i] <= t ? n = s + 1 : r = s,
                        n == r)
                            return (n + 1) * i;
                        s = n + r >>> 1
                    }
                }
                ,
                e.linearSearch = function(e, t, i) {
                    for (var n = 0, r = e.length - i; n <= r; n += i)
                        if (e[n] > t)
                            return n;
                    return -1
                }
                ,
                e
            }();
            e.Animation = s,
            function(e) {
                e[e.setup = 0] = "setup",
                e[e.first = 1] = "first",
                e[e.replace = 2] = "replace",
                e[e.add = 3] = "add"
            }(t = e.MixBlend || (e.MixBlend = {})),
            function(e) {
                e[e.in = 0] = "in",
                e[e.out = 1] = "out"
            }(i = e.MixDirection || (e.MixDirection = {})),
            function(e) {
                e[e.rotate = 0] = "rotate",
                e[e.translate = 1] = "translate",
                e[e.scale = 2] = "scale",
                e[e.shear = 3] = "shear",
                e[e.attachment = 4] = "attachment",
                e[e.color = 5] = "color",
                e[e.deform = 6] = "deform",
                e[e.event = 7] = "event",
                e[e.drawOrder = 8] = "drawOrder",
                e[e.ikConstraint = 9] = "ikConstraint",
                e[e.transformConstraint = 10] = "transformConstraint",
                e[e.pathConstraintPosition = 11] = "pathConstraintPosition",
                e[e.pathConstraintSpacing = 12] = "pathConstraintSpacing",
                e[e.pathConstraintMix = 13] = "pathConstraintMix",
                e[e.twoColor = 14] = "twoColor"
            }(n = e.TimelineType || (e.TimelineType = {}));
            var a = function() {
                function t(i) {
                    if (i <= 0)
                        throw new Error("frameCount must be > 0: " + i);
                    this.curves = e.Utils.newFloatArray((i - 1) * t.BEZIER_SIZE)
                }
                return t.prototype.getFrameCount = function() {
                    return this.curves.length / t.BEZIER_SIZE + 1
                }
                ,
                t.prototype.setLinear = function(e) {
                    this.curves[e * t.BEZIER_SIZE] = t.LINEAR
                }
                ,
                t.prototype.setStepped = function(e) {
                    this.curves[e * t.BEZIER_SIZE] = t.STEPPED
                }
                ,
                t.prototype.getCurveType = function(e) {
                    var i = e * t.BEZIER_SIZE;
                    if (i == this.curves.length)
                        return t.LINEAR;
                    var n = this.curves[i];
                    return n == t.LINEAR ? t.LINEAR : n == t.STEPPED ? t.STEPPED : t.BEZIER
                }
                ,
                t.prototype.setCurve = function(e, i, n, r, s) {
                    var a = .03 * (2 * -i + r)
                      , o = .03 * (2 * -n + s)
                      , l = .006 * (3 * (i - r) + 1)
                      , c = .006 * (3 * (n - s) + 1)
                      , h = 2 * a + l
                      , u = 2 * o + c
                      , p = .3 * i + a + .16666667 * l
                      , d = .3 * n + o + .16666667 * c
                      , f = e * t.BEZIER_SIZE
                      , m = this.curves;
                    m[f++] = t.BEZIER;
                    for (var g = p, v = d, y = f + t.BEZIER_SIZE - 1; f < y; f += 2)
                        m[f] = g,
                        m[f + 1] = v,
                        p += h,
                        d += u,
                        h += l,
                        u += c,
                        g += p,
                        v += d
                }
                ,
                t.prototype.getCurvePercent = function(i, n) {
                    n = e.MathUtils.clamp(n, 0, 1);
                    var r = this.curves
                      , s = i * t.BEZIER_SIZE
                      , a = r[s];
                    if (a == t.LINEAR)
                        return n;
                    if (a == t.STEPPED)
                        return 0;
                    for (var o = 0, l = ++s, c = s + t.BEZIER_SIZE - 1; s < c; s += 2)
                        if ((o = r[s]) >= n) {
                            var h = void 0
                              , u = void 0;
                            return s == l ? (h = 0,
                            u = 0) : (h = r[s - 2],
                            u = r[s - 1]),
                            u + (r[s + 1] - u) * (n - h) / (o - h)
                        }
                    var p = r[s - 1];
                    return p + (1 - p) * (n - o) / (1 - o)
                }
                ,
                t.LINEAR = 0,
                t.STEPPED = 1,
                t.BEZIER = 2,
                t.BEZIER_SIZE = 19,
                t
            }();
            e.CurveTimeline = a;
            var o = function(i) {
                function a(t) {
                    var n = i.call(this, t) || this;
                    return n.frames = e.Utils.newFloatArray(t << 1),
                    n
                }
                return r(a, i),
                a.prototype.getPropertyId = function() {
                    return (n.rotate << 24) + this.boneIndex
                }
                ,
                a.prototype.setFrame = function(e, t, i) {
                    e <<= 1,
                    this.frames[e] = t,
                    this.frames[e + a.ROTATION] = i
                }
                ,
                a.prototype.apply = function(e, i, n, r, o, l, c) {
                    var h = this.frames
                      , u = e.bones[this.boneIndex];
                    if (n < h[0])
                        switch (l) {
                        case t.setup:
                            return void (u.rotation = u.data.rotation);
                        case t.first:
                            var p = u.data.rotation - u.rotation;
                            u.rotation += (p - 360 * (16384 - (16384.499999999996 - p / 360 | 0))) * o
                        }
                    else if (n >= h[h.length - a.ENTRIES]) {
                        var d = h[h.length + a.PREV_ROTATION];
                        switch (l) {
                        case t.setup:
                            u.rotation = u.data.rotation + d * o;
                            break;
                        case t.first:
                        case t.replace:
                            d += u.data.rotation - u.rotation,
                            d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0));
                        case t.add:
                            u.rotation += d * o
                        }
                    } else {
                        var f = s.binarySearch(h, n, a.ENTRIES)
                          , m = h[f + a.PREV_ROTATION]
                          , g = h[f]
                          , v = this.getCurvePercent((f >> 1) - 1, 1 - (n - g) / (h[f + a.PREV_TIME] - g))
                          , y = h[f + a.ROTATION] - m;
                        switch (y = m + (y - 360 * (16384 - (16384.499999999996 - y / 360 | 0))) * v,
                        l) {
                        case t.setup:
                            u.rotation = u.data.rotation + (y - 360 * (16384 - (16384.499999999996 - y / 360 | 0))) * o;
                            break;
                        case t.first:
                        case t.replace:
                            y += u.data.rotation - u.rotation;
                        case t.add:
                            u.rotation += (y - 360 * (16384 - (16384.499999999996 - y / 360 | 0))) * o
                        }
                    }
                }
                ,
                a.ENTRIES = 2,
                a.PREV_TIME = -2,
                a.PREV_ROTATION = -1,
                a.ROTATION = 1,
                a
            }(a);
            e.RotateTimeline = o;
            var l = function(i) {
                function a(t) {
                    var n = i.call(this, t) || this;
                    return n.frames = e.Utils.newFloatArray(t * a.ENTRIES),
                    n
                }
                return r(a, i),
                a.prototype.getPropertyId = function() {
                    return (n.translate << 24) + this.boneIndex
                }
                ,
                a.prototype.setFrame = function(e, t, i, n) {
                    e *= a.ENTRIES,
                    this.frames[e] = t,
                    this.frames[e + a.X] = i,
                    this.frames[e + a.Y] = n
                }
                ,
                a.prototype.apply = function(e, i, n, r, o, l, c) {
                    var h = this.frames
                      , u = e.bones[this.boneIndex];
                    if (n < h[0])
                        switch (l) {
                        case t.setup:
                            return u.x = u.data.x,
                            void (u.y = u.data.y);
                        case t.first:
                            u.x += (u.data.x - u.x) * o,
                            u.y += (u.data.y - u.y) * o
                        }
                    else {
                        var p = 0
                          , d = 0;
                        if (n >= h[h.length - a.ENTRIES])
                            p = h[h.length + a.PREV_X],
                            d = h[h.length + a.PREV_Y];
                        else {
                            var f = s.binarySearch(h, n, a.ENTRIES);
                            p = h[f + a.PREV_X],
                            d = h[f + a.PREV_Y];
                            var m = h[f]
                              , g = this.getCurvePercent(f / a.ENTRIES - 1, 1 - (n - m) / (h[f + a.PREV_TIME] - m));
                            p += (h[f + a.X] - p) * g,
                            d += (h[f + a.Y] - d) * g
                        }
                        switch (l) {
                        case t.setup:
                            u.x = u.data.x + p * o,
                            u.y = u.data.y + d * o;
                            break;
                        case t.first:
                        case t.replace:
                            u.x += (u.data.x + p - u.x) * o,
                            u.y += (u.data.y + d - u.y) * o;
                            break;
                        case t.add:
                            u.x += p * o,
                            u.y += d * o
                        }
                    }
                }
                ,
                a.ENTRIES = 3,
                a.PREV_TIME = -3,
                a.PREV_X = -2,
                a.PREV_Y = -1,
                a.X = 1,
                a.Y = 2,
                a
            }(a);
            e.TranslateTimeline = l;
            var c = function(a) {
                function o(e) {
                    return a.call(this, e) || this
                }
                return r(o, a),
                o.prototype.getPropertyId = function() {
                    return (n.scale << 24) + this.boneIndex
                }
                ,
                o.prototype.apply = function(n, r, a, l, c, h, u) {
                    var p = this.frames
                      , d = n.bones[this.boneIndex];
                    if (a < p[0])
                        switch (h) {
                        case t.setup:
                            return d.scaleX = d.data.scaleX,
                            void (d.scaleY = d.data.scaleY);
                        case t.first:
                            d.scaleX += (d.data.scaleX - d.scaleX) * c,
                            d.scaleY += (d.data.scaleY - d.scaleY) * c
                        }
                    else {
                        var f = 0
                          , m = 0;
                        if (a >= p[p.length - o.ENTRIES])
                            f = p[p.length + o.PREV_X] * d.data.scaleX,
                            m = p[p.length + o.PREV_Y] * d.data.scaleY;
                        else {
                            var g = s.binarySearch(p, a, o.ENTRIES);
                            f = p[g + o.PREV_X],
                            m = p[g + o.PREV_Y];
                            var v = p[g]
                              , y = this.getCurvePercent(g / o.ENTRIES - 1, 1 - (a - v) / (p[g + o.PREV_TIME] - v));
                            f = (f + (p[g + o.X] - f) * y) * d.data.scaleX,
                            m = (m + (p[g + o.Y] - m) * y) * d.data.scaleY
                        }
                        if (1 == c)
                            h == t.add ? (d.scaleX += f - d.data.scaleX,
                            d.scaleY += m - d.data.scaleY) : (d.scaleX = f,
                            d.scaleY = m);
                        else {
                            var b = 0
                              , x = 0;
                            if (u == i.out)
                                switch (h) {
                                case t.setup:
                                    b = d.data.scaleX,
                                    x = d.data.scaleY,
                                    d.scaleX = b + (Math.abs(f) * e.MathUtils.signum(b) - b) * c,
                                    d.scaleY = x + (Math.abs(m) * e.MathUtils.signum(x) - x) * c;
                                    break;
                                case t.first:
                                case t.replace:
                                    b = d.scaleX,
                                    x = d.scaleY,
                                    d.scaleX = b + (Math.abs(f) * e.MathUtils.signum(b) - b) * c,
                                    d.scaleY = x + (Math.abs(m) * e.MathUtils.signum(x) - x) * c;
                                    break;
                                case t.add:
                                    b = d.scaleX,
                                    x = d.scaleY,
                                    d.scaleX = b + (Math.abs(f) * e.MathUtils.signum(b) - d.data.scaleX) * c,
                                    d.scaleY = x + (Math.abs(m) * e.MathUtils.signum(x) - d.data.scaleY) * c
                                }
                            else
                                switch (h) {
                                case t.setup:
                                    b = Math.abs(d.data.scaleX) * e.MathUtils.signum(f),
                                    x = Math.abs(d.data.scaleY) * e.MathUtils.signum(m),
                                    d.scaleX = b + (f - b) * c,
                                    d.scaleY = x + (m - x) * c;
                                    break;
                                case t.first:
                                case t.replace:
                                    b = Math.abs(d.scaleX) * e.MathUtils.signum(f),
                                    x = Math.abs(d.scaleY) * e.MathUtils.signum(m),
                                    d.scaleX = b + (f - b) * c,
                                    d.scaleY = x + (m - x) * c;
                                    break;
                                case t.add:
                                    b = e.MathUtils.signum(f),
                                    x = e.MathUtils.signum(m),
                                    d.scaleX = Math.abs(d.scaleX) * b + (f - Math.abs(d.data.scaleX) * b) * c,
                                    d.scaleY = Math.abs(d.scaleY) * x + (m - Math.abs(d.data.scaleY) * x) * c
                                }
                        }
                    }
                }
                ,
                o
            }(l);
            e.ScaleTimeline = c;
            var h = function(e) {
                function i(t) {
                    return e.call(this, t) || this
                }
                return r(i, e),
                i.prototype.getPropertyId = function() {
                    return (n.shear << 24) + this.boneIndex
                }
                ,
                i.prototype.apply = function(e, n, r, a, o, l, c) {
                    var h = this.frames
                      , u = e.bones[this.boneIndex];
                    if (r < h[0])
                        switch (l) {
                        case t.setup:
                            return u.shearX = u.data.shearX,
                            void (u.shearY = u.data.shearY);
                        case t.first:
                            u.shearX += (u.data.shearX - u.shearX) * o,
                            u.shearY += (u.data.shearY - u.shearY) * o
                        }
                    else {
                        var p = 0
                          , d = 0;
                        if (r >= h[h.length - i.ENTRIES])
                            p = h[h.length + i.PREV_X],
                            d = h[h.length + i.PREV_Y];
                        else {
                            var f = s.binarySearch(h, r, i.ENTRIES);
                            p = h[f + i.PREV_X],
                            d = h[f + i.PREV_Y];
                            var m = h[f]
                              , g = this.getCurvePercent(f / i.ENTRIES - 1, 1 - (r - m) / (h[f + i.PREV_TIME] - m));
                            p += (h[f + i.X] - p) * g,
                            d += (h[f + i.Y] - d) * g
                        }
                        switch (l) {
                        case t.setup:
                            u.shearX = u.data.shearX + p * o,
                            u.shearY = u.data.shearY + d * o;
                            break;
                        case t.first:
                        case t.replace:
                            u.shearX += (u.data.shearX + p - u.shearX) * o,
                            u.shearY += (u.data.shearY + d - u.shearY) * o;
                            break;
                        case t.add:
                            u.shearX += p * o,
                            u.shearY += d * o
                        }
                    }
                }
                ,
                i
            }(l);
            e.ShearTimeline = h;
            var u = function(i) {
                function a(t) {
                    var n = i.call(this, t) || this;
                    return n.frames = e.Utils.newFloatArray(t * a.ENTRIES),
                    n
                }
                return r(a, i),
                a.prototype.getPropertyId = function() {
                    return (n.color << 24) + this.slotIndex
                }
                ,
                a.prototype.setFrame = function(e, t, i, n, r, s) {
                    e *= a.ENTRIES,
                    this.frames[e] = t,
                    this.frames[e + a.R] = i,
                    this.frames[e + a.G] = n,
                    this.frames[e + a.B] = r,
                    this.frames[e + a.A] = s
                }
                ,
                a.prototype.apply = function(e, i, n, r, o, l, c) {
                    var h = e.slots[this.slotIndex]
                      , u = this.frames;
                    if (n < u[0])
                        switch (l) {
                        case t.setup:
                            return void h.color.setFromColor(h.data.color);
                        case t.first:
                            var p = h.color
                              , d = h.data.color;
                            p.add((d.r - p.r) * o, (d.g - p.g) * o, (d.b - p.b) * o, (d.a - p.a) * o)
                        }
                    else {
                        var f = 0
                          , m = 0
                          , g = 0
                          , v = 0;
                        if (n >= u[u.length - a.ENTRIES]) {
                            var y = u.length;
                            f = u[y + a.PREV_R],
                            m = u[y + a.PREV_G],
                            g = u[y + a.PREV_B],
                            v = u[y + a.PREV_A]
                        } else {
                            var b = s.binarySearch(u, n, a.ENTRIES);
                            f = u[b + a.PREV_R],
                            m = u[b + a.PREV_G],
                            g = u[b + a.PREV_B],
                            v = u[b + a.PREV_A];
                            var x = u[b]
                              , w = this.getCurvePercent(b / a.ENTRIES - 1, 1 - (n - x) / (u[b + a.PREV_TIME] - x));
                            f += (u[b + a.R] - f) * w,
                            m += (u[b + a.G] - m) * w,
                            g += (u[b + a.B] - g) * w,
                            v += (u[b + a.A] - v) * w
                        }
                        1 == o ? h.color.set(f, m, g, v) : (p = h.color,
                        l == t.setup && p.setFromColor(h.data.color),
                        p.add((f - p.r) * o, (m - p.g) * o, (g - p.b) * o, (v - p.a) * o))
                    }
                }
                ,
                a.ENTRIES = 5,
                a.PREV_TIME = -5,
                a.PREV_R = -4,
                a.PREV_G = -3,
                a.PREV_B = -2,
                a.PREV_A = -1,
                a.R = 1,
                a.G = 2,
                a.B = 3,
                a.A = 4,
                a
            }(a);
            e.ColorTimeline = u;
            var p = function(i) {
                function a(t) {
                    var n = i.call(this, t) || this;
                    return n.frames = e.Utils.newFloatArray(t * a.ENTRIES),
                    n
                }
                return r(a, i),
                a.prototype.getPropertyId = function() {
                    return (n.twoColor << 24) + this.slotIndex
                }
                ,
                a.prototype.setFrame = function(e, t, i, n, r, s, o, l, c) {
                    e *= a.ENTRIES,
                    this.frames[e] = t,
                    this.frames[e + a.R] = i,
                    this.frames[e + a.G] = n,
                    this.frames[e + a.B] = r,
                    this.frames[e + a.A] = s,
                    this.frames[e + a.R2] = o,
                    this.frames[e + a.G2] = l,
                    this.frames[e + a.B2] = c
                }
                ,
                a.prototype.apply = function(e, i, n, r, o, l, c) {
                    var h = e.slots[this.slotIndex]
                      , u = this.frames;
                    if (n < u[0])
                        switch (l) {
                        case t.setup:
                            return h.color.setFromColor(h.data.color),
                            void h.darkColor.setFromColor(h.data.darkColor);
                        case t.first:
                            var p = h.color
                              , d = h.darkColor
                              , f = h.data.color
                              , m = h.data.darkColor;
                            p.add((f.r - p.r) * o, (f.g - p.g) * o, (f.b - p.b) * o, (f.a - p.a) * o),
                            d.add((m.r - d.r) * o, (m.g - d.g) * o, (m.b - d.b) * o, 0)
                        }
                    else {
                        var g = 0
                          , v = 0
                          , y = 0
                          , b = 0
                          , x = 0
                          , w = 0
                          , _ = 0;
                        if (n >= u[u.length - a.ENTRIES]) {
                            var T = u.length;
                            g = u[T + a.PREV_R],
                            v = u[T + a.PREV_G],
                            y = u[T + a.PREV_B],
                            b = u[T + a.PREV_A],
                            x = u[T + a.PREV_R2],
                            w = u[T + a.PREV_G2],
                            _ = u[T + a.PREV_B2]
                        } else {
                            var M = s.binarySearch(u, n, a.ENTRIES);
                            g = u[M + a.PREV_R],
                            v = u[M + a.PREV_G],
                            y = u[M + a.PREV_B],
                            b = u[M + a.PREV_A],
                            x = u[M + a.PREV_R2],
                            w = u[M + a.PREV_G2],
                            _ = u[M + a.PREV_B2];
                            var S = u[M]
                              , A = this.getCurvePercent(M / a.ENTRIES - 1, 1 - (n - S) / (u[M + a.PREV_TIME] - S));
                            g += (u[M + a.R] - g) * A,
                            v += (u[M + a.G] - v) * A,
                            y += (u[M + a.B] - y) * A,
                            b += (u[M + a.A] - b) * A,
                            x += (u[M + a.R2] - x) * A,
                            w += (u[M + a.G2] - w) * A,
                            _ += (u[M + a.B2] - _) * A
                        }
                        1 == o ? (h.color.set(g, v, y, b),
                        h.darkColor.set(x, w, _, 1)) : (p = h.color,
                        d = h.darkColor,
                        l == t.setup && (p.setFromColor(h.data.color),
                        d.setFromColor(h.data.darkColor)),
                        p.add((g - p.r) * o, (v - p.g) * o, (y - p.b) * o, (b - p.a) * o),
                        d.add((x - d.r) * o, (w - d.g) * o, (_ - d.b) * o, 0))
                    }
                }
                ,
                a.ENTRIES = 8,
                a.PREV_TIME = -8,
                a.PREV_R = -7,
                a.PREV_G = -6,
                a.PREV_B = -5,
                a.PREV_A = -4,
                a.PREV_R2 = -3,
                a.PREV_G2 = -2,
                a.PREV_B2 = -1,
                a.R = 1,
                a.G = 2,
                a.B = 3,
                a.A = 4,
                a.R2 = 5,
                a.G2 = 6,
                a.B2 = 7,
                a
            }(a);
            e.TwoColorTimeline = p;
            var d = function() {
                function r(t) {
                    this.frames = e.Utils.newFloatArray(t),
                    this.attachmentNames = new Array(t)
                }
                return r.prototype.getPropertyId = function() {
                    return (n.attachment << 24) + this.slotIndex
                }
                ,
                r.prototype.getFrameCount = function() {
                    return this.frames.length
                }
                ,
                r.prototype.setFrame = function(e, t, i) {
                    this.frames[e] = t,
                    this.attachmentNames[e] = i
                }
                ,
                r.prototype.apply = function(e, n, r, a, o, l, c) {
                    var h = e.slots[this.slotIndex];
                    if (c != i.out || l != t.setup) {
                        var u = this.frames;
                        if (r < u[0]) {
                            if (l == t.setup || l == t.first) {
                                var p = h.data.attachmentName;
                                h.setAttachment(null == p ? null : e.getAttachment(this.slotIndex, p))
                            }
                        } else {
                            var d = 0;
                            d = r >= u[u.length - 1] ? u.length - 1 : s.binarySearch(u, r, 1) - 1;
                            var f = this.attachmentNames[d];
                            e.slots[this.slotIndex].setAttachment(null == f ? null : e.getAttachment(this.slotIndex, f))
                        }
                    } else {
                        var m = h.data.attachmentName;
                        h.setAttachment(null == m ? null : e.getAttachment(this.slotIndex, m))
                    }
                }
                ,
                r
            }();
            e.AttachmentTimeline = d;
            var f = null
              , m = function(i) {
                function a(t) {
                    var n = i.call(this, t) || this;
                    return n.frames = e.Utils.newFloatArray(t),
                    n.frameVertices = new Array(t),
                    null == f && (f = e.Utils.newFloatArray(64)),
                    n
                }
                return r(a, i),
                a.prototype.getPropertyId = function() {
                    return (n.deform << 27) + +this.attachment.id + this.slotIndex
                }
                ,
                a.prototype.setFrame = function(e, t, i) {
                    this.frames[e] = t,
                    this.frameVertices[e] = i
                }
                ,
                a.prototype.apply = function(i, n, r, a, o, l, c) {
                    var h = i.slots[this.slotIndex]
                      , u = h.getAttachment();
                    if (u instanceof e.VertexAttachment && u.applyDeform(this.attachment)) {
                        var p = h.attachmentVertices;
                        0 == p.length && (l = t.setup);
                        var d = this.frameVertices
                          , f = d[0].length
                          , m = this.frames;
                        if (r < m[0]) {
                            var g = u;
                            switch (l) {
                            case t.setup:
                                return void (p.length = 0);
                            case t.first:
                                if (1 == o) {
                                    p.length = 0;
                                    break
                                }
                                var v = e.Utils.setArraySize(p, f);
                                if (null == g.bones)
                                    for (var y = g.vertices, b = 0; b < f; b++)
                                        v[b] += (y[b] - v[b]) * o;
                                else
                                    for (o = 1 - o,
                                    b = 0; b < f; b++)
                                        v[b] *= o
                            }
                        } else {
                            var x = e.Utils.setArraySize(p, f);
                            if (r >= m[m.length - 1]) {
                                var w = d[m.length - 1];
                                if (1 == o)
                                    if (l == t.add)
                                        if (null == (g = u).bones) {
                                            y = g.vertices;
                                            for (var _ = 0; _ < f; _++)
                                                x[_] += w[_] - y[_]
                                        } else
                                            for (var T = 0; T < f; T++)
                                                x[T] += w[T];
                                    else
                                        e.Utils.arrayCopy(w, 0, x, 0, f);
                                else
                                    switch (l) {
                                    case t.setup:
                                        var M = u;
                                        if (null == M.bones) {
                                            y = M.vertices;
                                            for (var S = 0; S < f; S++) {
                                                var A = y[S];
                                                x[S] = A + (w[S] - A) * o
                                            }
                                        } else
                                            for (var P = 0; P < f; P++)
                                                x[P] = w[P] * o;
                                        break;
                                    case t.first:
                                    case t.replace:
                                        for (var C = 0; C < f; C++)
                                            x[C] += (w[C] - x[C]) * o;
                                    case t.add:
                                        if (null == (g = u).bones) {
                                            y = g.vertices;
                                            for (var L = 0; L < f; L++)
                                                x[L] += (w[L] - y[L]) * o
                                        } else
                                            for (var k = 0; k < f; k++)
                                                x[k] += w[k] * o
                                    }
                            } else {
                                var E = s.binarySearch(m, r)
                                  , I = d[E - 1]
                                  , F = d[E]
                                  , O = m[E]
                                  , R = this.getCurvePercent(E - 1, 1 - (r - O) / (m[E - 1] - O));
                                if (1 == o)
                                    if (l == t.add)
                                        if (null == (g = u).bones) {
                                            y = g.vertices;
                                            for (var z = 0; z < f; z++) {
                                                var N = I[z];
                                                x[z] += N + (F[z] - N) * R - y[z]
                                            }
                                        } else
                                            for (var D = 0; D < f; D++)
                                                N = I[D],
                                                x[D] += N + (F[D] - N) * R;
                                    else
                                        for (var U = 0; U < f; U++)
                                            N = I[U],
                                            x[U] = N + (F[U] - N) * R;
                                else
                                    switch (l) {
                                    case t.setup:
                                        var B = u;
                                        if (null == B.bones) {
                                            y = B.vertices;
                                            for (var j = 0; j < f; j++)
                                                N = I[j],
                                                A = y[j],
                                                x[j] = A + (N + (F[j] - N) * R - A) * o
                                        } else
                                            for (var V = 0; V < f; V++)
                                                N = I[V],
                                                x[V] = (N + (F[V] - N) * R) * o;
                                        break;
                                    case t.first:
                                    case t.replace:
                                        for (var G = 0; G < f; G++)
                                            N = I[G],
                                            x[G] += (N + (F[G] - N) * R - x[G]) * o;
                                        break;
                                    case t.add:
                                        if (null == (g = u).bones) {
                                            y = g.vertices;
                                            for (var X = 0; X < f; X++)
                                                N = I[X],
                                                x[X] += (N + (F[X] - N) * R - y[X]) * o
                                        } else
                                            for (var Y = 0; Y < f; Y++)
                                                N = I[Y],
                                                x[Y] += (N + (F[Y] - N) * R) * o
                                    }
                            }
                        }
                    }
                }
                ,
                a
            }(a);
            e.DeformTimeline = m;
            var g = function() {
                function t(t) {
                    this.frames = e.Utils.newFloatArray(t),
                    this.events = new Array(t)
                }
                return t.prototype.getPropertyId = function() {
                    return n.event << 24
                }
                ,
                t.prototype.getFrameCount = function() {
                    return this.frames.length
                }
                ,
                t.prototype.setFrame = function(e, t) {
                    this.frames[e] = t.time,
                    this.events[e] = t
                }
                ,
                t.prototype.apply = function(e, t, i, n, r, a, o) {
                    if (null != n) {
                        var l = this.frames
                          , c = this.frames.length;
                        if (t > i)
                            this.apply(e, t, Number.MAX_VALUE, n, r, a, o),
                            t = -1;
                        else if (t >= l[c - 1])
                            return;
                        if (!(i < l[0])) {
                            var h = 0;
                            if (t < l[0])
                                h = 0;
                            else
                                for (var u = l[h = s.binarySearch(l, t)]; h > 0 && l[h - 1] == u; )
                                    h--;
                            for (; h < c && i >= l[h]; h++)
                                n.push(this.events[h])
                        }
                    }
                }
                ,
                t
            }();
            e.EventTimeline = g;
            var v = function() {
                function r(t) {
                    this.frames = e.Utils.newFloatArray(t),
                    this.drawOrders = new Array(t)
                }
                return r.prototype.getPropertyId = function() {
                    return n.drawOrder << 24
                }
                ,
                r.prototype.getFrameCount = function() {
                    return this.frames.length
                }
                ,
                r.prototype.setFrame = function(e, t, i) {
                    this.frames[e] = t,
                    this.drawOrders[e] = i
                }
                ,
                r.prototype.apply = function(n, r, a, o, l, c, h) {
                    var u = n.drawOrder
                      , p = n.slots;
                    if (h != i.out || c != t.setup) {
                        var d = this.frames;
                        if (a < d[0])
                            c != t.setup && c != t.first || e.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length);
                        else {
                            var f = 0;
                            f = a >= d[d.length - 1] ? d.length - 1 : s.binarySearch(d, a) - 1;
                            var m = this.drawOrders[f];
                            if (null == m)
                                e.Utils.arrayCopy(p, 0, u, 0, p.length);
                            else
                                for (var g = 0, v = m.length; g < v; g++)
                                    u[g] = p[m[g]]
                        }
                    } else
                        e.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length)
                }
                ,
                r
            }();
            e.DrawOrderTimeline = v;
            var y = function(a) {
                function o(t) {
                    var i = a.call(this, t) || this;
                    return i.frames = e.Utils.newFloatArray(t * o.ENTRIES),
                    i
                }
                return r(o, a),
                o.prototype.getPropertyId = function() {
                    return (n.ikConstraint << 24) + this.ikConstraintIndex
                }
                ,
                o.prototype.setFrame = function(e, t, i, n, r, s) {
                    e *= o.ENTRIES,
                    this.frames[e] = t,
                    this.frames[e + o.MIX] = i,
                    this.frames[e + o.BEND_DIRECTION] = n,
                    this.frames[e + o.COMPRESS] = r ? 1 : 0,
                    this.frames[e + o.STRETCH] = s ? 1 : 0
                }
                ,
                o.prototype.apply = function(e, n, r, a, l, c, h) {
                    var u = this.frames
                      , p = e.ikConstraints[this.ikConstraintIndex];
                    if (r < u[0])
                        switch (c) {
                        case t.setup:
                            return p.mix = p.data.mix,
                            p.bendDirection = p.data.bendDirection,
                            p.compress = p.data.compress,
                            void (p.stretch = p.data.stretch);
                        case t.first:
                            p.mix += (p.data.mix - p.mix) * l,
                            p.bendDirection = p.data.bendDirection,
                            p.compress = p.data.compress,
                            p.stretch = p.data.stretch
                        }
                    else if (r >= u[u.length - o.ENTRIES])
                        c == t.setup ? (p.mix = p.data.mix + (u[u.length + o.PREV_MIX] - p.data.mix) * l,
                        h == i.out ? (p.bendDirection = p.data.bendDirection,
                        p.compress = p.data.compress,
                        p.stretch = p.data.stretch) : (p.bendDirection = u[u.length + o.PREV_BEND_DIRECTION],
                        p.compress = 0 != u[u.length + o.PREV_COMPRESS],
                        p.stretch = 0 != u[u.length + o.PREV_STRETCH])) : (p.mix += (u[u.length + o.PREV_MIX] - p.mix) * l,
                        h == i.in && (p.bendDirection = u[u.length + o.PREV_BEND_DIRECTION],
                        p.compress = 0 != u[u.length + o.PREV_COMPRESS],
                        p.stretch = 0 != u[u.length + o.PREV_STRETCH]));
                    else {
                        var d = s.binarySearch(u, r, o.ENTRIES)
                          , f = u[d + o.PREV_MIX]
                          , m = u[d]
                          , g = this.getCurvePercent(d / o.ENTRIES - 1, 1 - (r - m) / (u[d + o.PREV_TIME] - m));
                        c == t.setup ? (p.mix = p.data.mix + (f + (u[d + o.MIX] - f) * g - p.data.mix) * l,
                        h == i.out ? (p.bendDirection = p.data.bendDirection,
                        p.compress = p.data.compress,
                        p.stretch = p.data.stretch) : (p.bendDirection = u[d + o.PREV_BEND_DIRECTION],
                        p.compress = 0 != u[d + o.PREV_COMPRESS],
                        p.stretch = 0 != u[d + o.PREV_STRETCH])) : (p.mix += (f + (u[d + o.MIX] - f) * g - p.mix) * l,
                        h == i.in && (p.bendDirection = u[d + o.PREV_BEND_DIRECTION],
                        p.compress = 0 != u[d + o.PREV_COMPRESS],
                        p.stretch = 0 != u[d + o.PREV_STRETCH]))
                    }
                }
                ,
                o.ENTRIES = 5,
                o.PREV_TIME = -5,
                o.PREV_MIX = -4,
                o.PREV_BEND_DIRECTION = -3,
                o.PREV_COMPRESS = -2,
                o.PREV_STRETCH = -1,
                o.MIX = 1,
                o.BEND_DIRECTION = 2,
                o.COMPRESS = 3,
                o.STRETCH = 4,
                o
            }(a);
            e.IkConstraintTimeline = y;
            var b = function(i) {
                function a(t) {
                    var n = i.call(this, t) || this;
                    return n.frames = e.Utils.newFloatArray(t * a.ENTRIES),
                    n
                }
                return r(a, i),
                a.prototype.getPropertyId = function() {
                    return (n.transformConstraint << 24) + this.transformConstraintIndex
                }
                ,
                a.prototype.setFrame = function(e, t, i, n, r, s) {
                    e *= a.ENTRIES,
                    this.frames[e] = t,
                    this.frames[e + a.ROTATE] = i,
                    this.frames[e + a.TRANSLATE] = n,
                    this.frames[e + a.SCALE] = r,
                    this.frames[e + a.SHEAR] = s
                }
                ,
                a.prototype.apply = function(e, i, n, r, o, l, c) {
                    var h = this.frames
                      , u = e.transformConstraints[this.transformConstraintIndex];
                    if (n < h[0]) {
                        var p = u.data;
                        switch (l) {
                        case t.setup:
                            return u.rotateMix = p.rotateMix,
                            u.translateMix = p.translateMix,
                            u.scaleMix = p.scaleMix,
                            void (u.shearMix = p.shearMix);
                        case t.first:
                            u.rotateMix += (p.rotateMix - u.rotateMix) * o,
                            u.translateMix += (p.translateMix - u.translateMix) * o,
                            u.scaleMix += (p.scaleMix - u.scaleMix) * o,
                            u.shearMix += (p.shearMix - u.shearMix) * o
                        }
                    } else {
                        var d = 0
                          , f = 0
                          , m = 0
                          , g = 0;
                        if (n >= h[h.length - a.ENTRIES]) {
                            var v = h.length;
                            d = h[v + a.PREV_ROTATE],
                            f = h[v + a.PREV_TRANSLATE],
                            m = h[v + a.PREV_SCALE],
                            g = h[v + a.PREV_SHEAR]
                        } else {
                            var y = s.binarySearch(h, n, a.ENTRIES);
                            d = h[y + a.PREV_ROTATE],
                            f = h[y + a.PREV_TRANSLATE],
                            m = h[y + a.PREV_SCALE],
                            g = h[y + a.PREV_SHEAR];
                            var b = h[y]
                              , x = this.getCurvePercent(y / a.ENTRIES - 1, 1 - (n - b) / (h[y + a.PREV_TIME] - b));
                            d += (h[y + a.ROTATE] - d) * x,
                            f += (h[y + a.TRANSLATE] - f) * x,
                            m += (h[y + a.SCALE] - m) * x,
                            g += (h[y + a.SHEAR] - g) * x
                        }
                        l == t.setup ? (p = u.data,
                        u.rotateMix = p.rotateMix + (d - p.rotateMix) * o,
                        u.translateMix = p.translateMix + (f - p.translateMix) * o,
                        u.scaleMix = p.scaleMix + (m - p.scaleMix) * o,
                        u.shearMix = p.shearMix + (g - p.shearMix) * o) : (u.rotateMix += (d - u.rotateMix) * o,
                        u.translateMix += (f - u.translateMix) * o,
                        u.scaleMix += (m - u.scaleMix) * o,
                        u.shearMix += (g - u.shearMix) * o)
                    }
                }
                ,
                a.ENTRIES = 5,
                a.PREV_TIME = -5,
                a.PREV_ROTATE = -4,
                a.PREV_TRANSLATE = -3,
                a.PREV_SCALE = -2,
                a.PREV_SHEAR = -1,
                a.ROTATE = 1,
                a.TRANSLATE = 2,
                a.SCALE = 3,
                a.SHEAR = 4,
                a
            }(a);
            e.TransformConstraintTimeline = b;
            var x = function(i) {
                function a(t) {
                    var n = i.call(this, t) || this;
                    return n.frames = e.Utils.newFloatArray(t * a.ENTRIES),
                    n
                }
                return r(a, i),
                a.prototype.getPropertyId = function() {
                    return (n.pathConstraintPosition << 24) + this.pathConstraintIndex
                }
                ,
                a.prototype.setFrame = function(e, t, i) {
                    e *= a.ENTRIES,
                    this.frames[e] = t,
                    this.frames[e + a.VALUE] = i
                }
                ,
                a.prototype.apply = function(e, i, n, r, o, l, c) {
                    var h = this.frames
                      , u = e.pathConstraints[this.pathConstraintIndex];
                    if (n < h[0])
                        switch (l) {
                        case t.setup:
                            return void (u.position = u.data.position);
                        case t.first:
                            u.position += (u.data.position - u.position) * o
                        }
                    else {
                        var p = 0;
                        if (n >= h[h.length - a.ENTRIES])
                            p = h[h.length + a.PREV_VALUE];
                        else {
                            var d = s.binarySearch(h, n, a.ENTRIES);
                            p = h[d + a.PREV_VALUE];
                            var f = h[d]
                              , m = this.getCurvePercent(d / a.ENTRIES - 1, 1 - (n - f) / (h[d + a.PREV_TIME] - f));
                            p += (h[d + a.VALUE] - p) * m
                        }
                        l == t.setup ? u.position = u.data.position + (p - u.data.position) * o : u.position += (p - u.position) * o
                    }
                }
                ,
                a.ENTRIES = 2,
                a.PREV_TIME = -2,
                a.PREV_VALUE = -1,
                a.VALUE = 1,
                a
            }(a);
            e.PathConstraintPositionTimeline = x;
            var w = function(e) {
                function i(t) {
                    return e.call(this, t) || this
                }
                return r(i, e),
                i.prototype.getPropertyId = function() {
                    return (n.pathConstraintSpacing << 24) + this.pathConstraintIndex
                }
                ,
                i.prototype.apply = function(e, n, r, a, o, l, c) {
                    var h = this.frames
                      , u = e.pathConstraints[this.pathConstraintIndex];
                    if (r < h[0])
                        switch (l) {
                        case t.setup:
                            return void (u.spacing = u.data.spacing);
                        case t.first:
                            u.spacing += (u.data.spacing - u.spacing) * o
                        }
                    else {
                        var p = 0;
                        if (r >= h[h.length - i.ENTRIES])
                            p = h[h.length + i.PREV_VALUE];
                        else {
                            var d = s.binarySearch(h, r, i.ENTRIES);
                            p = h[d + i.PREV_VALUE];
                            var f = h[d]
                              , m = this.getCurvePercent(d / i.ENTRIES - 1, 1 - (r - f) / (h[d + i.PREV_TIME] - f));
                            p += (h[d + i.VALUE] - p) * m
                        }
                        l == t.setup ? u.spacing = u.data.spacing + (p - u.data.spacing) * o : u.spacing += (p - u.spacing) * o
                    }
                }
                ,
                i
            }(x);
            e.PathConstraintSpacingTimeline = w;
            var _ = function(i) {
                function a(t) {
                    var n = i.call(this, t) || this;
                    return n.frames = e.Utils.newFloatArray(t * a.ENTRIES),
                    n
                }
                return r(a, i),
                a.prototype.getPropertyId = function() {
                    return (n.pathConstraintMix << 24) + this.pathConstraintIndex
                }
                ,
                a.prototype.setFrame = function(e, t, i, n) {
                    e *= a.ENTRIES,
                    this.frames[e] = t,
                    this.frames[e + a.ROTATE] = i,
                    this.frames[e + a.TRANSLATE] = n
                }
                ,
                a.prototype.apply = function(e, i, n, r, o, l, c) {
                    var h = this.frames
                      , u = e.pathConstraints[this.pathConstraintIndex];
                    if (n < h[0])
                        switch (l) {
                        case t.setup:
                            return u.rotateMix = u.data.rotateMix,
                            void (u.translateMix = u.data.translateMix);
                        case t.first:
                            u.rotateMix += (u.data.rotateMix - u.rotateMix) * o,
                            u.translateMix += (u.data.translateMix - u.translateMix) * o
                        }
                    else {
                        var p = 0
                          , d = 0;
                        if (n >= h[h.length - a.ENTRIES])
                            p = h[h.length + a.PREV_ROTATE],
                            d = h[h.length + a.PREV_TRANSLATE];
                        else {
                            var f = s.binarySearch(h, n, a.ENTRIES);
                            p = h[f + a.PREV_ROTATE],
                            d = h[f + a.PREV_TRANSLATE];
                            var m = h[f]
                              , g = this.getCurvePercent(f / a.ENTRIES - 1, 1 - (n - m) / (h[f + a.PREV_TIME] - m));
                            p += (h[f + a.ROTATE] - p) * g,
                            d += (h[f + a.TRANSLATE] - d) * g
                        }
                        l == t.setup ? (u.rotateMix = u.data.rotateMix + (p - u.data.rotateMix) * o,
                        u.translateMix = u.data.translateMix + (d - u.data.translateMix) * o) : (u.rotateMix += (p - u.rotateMix) * o,
                        u.translateMix += (d - u.translateMix) * o)
                    }
                }
                ,
                a.ENTRIES = 3,
                a.PREV_TIME = -3,
                a.PREV_ROTATE = -2,
                a.PREV_TRANSLATE = -1,
                a.ROTATE = 1,
                a.TRANSLATE = 2,
                a
            }(a);
            e.PathConstraintMixTimeline = _
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(t) {
                    this.tracks = new Array,
                    this.events = new Array,
                    this.listeners = new Array,
                    this.queue = new r(this),
                    this.propertyIDs = new e.IntSet,
                    this.animationsChanged = !1,
                    this.timeScale = 1,
                    this.trackEntryPool = new e.Pool(function() {
                        return new i
                    }
                    ),
                    this.data = t
                }
                return t.prototype.update = function(e) {
                    e *= this.timeScale;
                    for (var t = this.tracks, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (null != r) {
                            r.animationLast = r.nextAnimationLast,
                            r.trackLast = r.nextTrackLast;
                            var s = e * r.timeScale;
                            if (r.delay > 0) {
                                if (r.delay -= s,
                                r.delay > 0)
                                    continue;
                                s = -r.delay,
                                r.delay = 0
                            }
                            var a = r.next;
                            if (null != a) {
                                var o = r.trackLast - a.delay;
                                if (o >= 0) {
                                    for (a.delay = 0,
                                    a.trackTime = 0 == r.timeScale ? 0 : (o / r.timeScale + e) * a.timeScale,
                                    r.trackTime += s,
                                    this.setCurrent(i, a, !0); null != a.mixingFrom; )
                                        a.mixTime += e,
                                        a = a.mixingFrom;
                                    continue
                                }
                            } else if (r.trackLast >= r.trackEnd && null == r.mixingFrom) {
                                t[i] = null,
                                this.queue.end(r),
                                this.disposeNext(r);
                                continue
                            }
                            if (null != r.mixingFrom && this.updateMixingFrom(r, e)) {
                                var l = r.mixingFrom;
                                for (r.mixingFrom = null,
                                null != l && (l.mixingTo = null); null != l; )
                                    this.queue.end(l),
                                    l = l.mixingFrom
                            }
                            r.trackTime += s
                        }
                    }
                    this.queue.drain()
                }
                ,
                t.prototype.updateMixingFrom = function(e, t) {
                    var i = e.mixingFrom;
                    if (null == i)
                        return !0;
                    var n = this.updateMixingFrom(i, t);
                    return i.animationLast = i.nextAnimationLast,
                    i.trackLast = i.nextTrackLast,
                    e.mixTime > 0 && e.mixTime >= e.mixDuration ? (0 != i.totalAlpha && 0 != e.mixDuration || (e.mixingFrom = i.mixingFrom,
                    null != i.mixingFrom && (i.mixingFrom.mixingTo = e),
                    e.interruptAlpha = i.interruptAlpha,
                    this.queue.end(i)),
                    n) : (i.trackTime += t * i.timeScale,
                    e.mixTime += t,
                    !1)
                }
                ,
                t.prototype.apply = function(i) {
                    if (null == i)
                        throw new Error("skeleton cannot be null.");
                    this.animationsChanged && this._animationsChanged();
                    for (var n = this.events, r = this.tracks, s = !1, a = 0, o = r.length; a < o; a++) {
                        var l = r[a];
                        if (!(null == l || l.delay > 0)) {
                            s = !0;
                            var c = 0 == a ? e.MixBlend.first : l.mixBlend
                              , h = l.alpha;
                            null != l.mixingFrom ? h *= this.applyMixingFrom(l, i, c) : l.trackTime >= l.trackEnd && null == l.next && (h = 0);
                            var u = l.animationLast
                              , p = l.getAnimationTime()
                              , d = l.animation.timelines.length
                              , f = l.animation.timelines;
                            if (0 == a && 1 == h || c == e.MixBlend.add)
                                for (var m = 0; m < d; m++)
                                    f[m].apply(i, u, p, n, h, c, e.MixDirection.in);
                            else {
                                var g = l.timelineMode
                                  , v = 0 == l.timelinesRotation.length;
                                v && e.Utils.setArraySize(l.timelinesRotation, d << 1, null);
                                var y = l.timelinesRotation;
                                for (m = 0; m < d; m++) {
                                    var b = f[m]
                                      , x = g[m] == t.SUBSEQUENT ? c : e.MixBlend.setup;
                                    b instanceof e.RotateTimeline ? this.applyRotateTimeline(b, i, p, h, x, y, m << 1, v) : (e.Utils.webkit602BugfixHelper(h, c),
                                    b.apply(i, u, p, n, h, x, e.MixDirection.in))
                                }
                            }
                            this.queueEvents(l, p),
                            n.length = 0,
                            l.nextAnimationLast = p,
                            l.nextTrackLast = l.trackTime
                        }
                    }
                    return this.queue.drain(),
                    s
                }
                ,
                t.prototype.applyMixingFrom = function(i, n, r) {
                    var s = i.mixingFrom;
                    null != s.mixingFrom && this.applyMixingFrom(s, n, r);
                    var a = 0;
                    0 == i.mixDuration ? (a = 1,
                    r == e.MixBlend.first && (r = e.MixBlend.setup)) : ((a = i.mixTime / i.mixDuration) > 1 && (a = 1),
                    r != e.MixBlend.first && (r = s.mixBlend));
                    var o = a < s.eventThreshold ? this.events : null
                      , l = a < s.attachmentThreshold
                      , c = a < s.drawOrderThreshold
                      , h = s.animationLast
                      , u = s.getAnimationTime()
                      , p = s.animation.timelines.length
                      , d = s.animation.timelines
                      , f = s.alpha * i.interruptAlpha
                      , m = f * (1 - a);
                    if (r == e.MixBlend.add)
                        for (var g = 0; g < p; g++)
                            d[g].apply(n, h, u, o, m, r, e.MixDirection.out);
                    else {
                        var v = s.timelineMode
                          , y = s.timelineHoldMix
                          , b = 0 == s.timelinesRotation.length;
                        b && e.Utils.setArraySize(s.timelinesRotation, p << 1, null);
                        var x = s.timelinesRotation;
                        for (s.totalAlpha = 0,
                        g = 0; g < p; g++) {
                            var w = d[g]
                              , _ = e.MixDirection.out
                              , T = void 0
                              , M = 0;
                            switch (v[g]) {
                            case t.SUBSEQUENT:
                                if (!l && w instanceof e.AttachmentTimeline)
                                    continue;
                                if (!c && w instanceof e.DrawOrderTimeline)
                                    continue;
                                T = r,
                                M = m;
                                break;
                            case t.FIRST:
                                T = e.MixBlend.setup,
                                M = m;
                                break;
                            case t.HOLD:
                                T = e.MixBlend.setup,
                                M = f;
                                break;
                            default:
                                T = e.MixBlend.setup;
                                var S = y[g];
                                M = f * Math.max(0, 1 - S.mixTime / S.mixDuration)
                            }
                            s.totalAlpha += M,
                            w instanceof e.RotateTimeline ? this.applyRotateTimeline(w, n, u, M, T, x, g << 1, b) : (e.Utils.webkit602BugfixHelper(M, r),
                            T == e.MixBlend.setup && (w instanceof e.AttachmentTimeline ? l && (_ = e.MixDirection.out) : w instanceof e.DrawOrderTimeline && c && (_ = e.MixDirection.out)),
                            w.apply(n, h, u, o, M, T, _))
                        }
                    }
                    return i.mixDuration > 0 && this.queueEvents(s, u),
                    this.events.length = 0,
                    s.nextAnimationLast = u,
                    s.nextTrackLast = s.trackTime,
                    a
                }
                ,
                t.prototype.applyRotateTimeline = function(t, i, n, r, s, a, o, l) {
                    if (l && (a[o] = 0),
                    1 != r) {
                        var c = t
                          , h = c.frames
                          , u = i.bones[c.boneIndex]
                          , p = 0
                          , d = 0;
                        if (n < h[0])
                            switch (s) {
                            case e.MixBlend.setup:
                                u.rotation = u.data.rotation;
                            default:
                                return;
                            case e.MixBlend.first:
                                p = u.rotation,
                                d = u.data.rotation
                            }
                        else if (p = s == e.MixBlend.setup ? u.data.rotation : u.rotation,
                        n >= h[h.length - e.RotateTimeline.ENTRIES])
                            d = u.data.rotation + h[h.length + e.RotateTimeline.PREV_ROTATION];
                        else {
                            var f = e.Animation.binarySearch(h, n, e.RotateTimeline.ENTRIES)
                              , m = h[f + e.RotateTimeline.PREV_ROTATION]
                              , g = h[f]
                              , v = c.getCurvePercent((f >> 1) - 1, 1 - (n - g) / (h[f + e.RotateTimeline.PREV_TIME] - g));
                            d = h[f + e.RotateTimeline.ROTATION] - m,
                            d = m + (d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0))) * v + u.data.rotation,
                            d -= 360 * (16384 - (16384.499999999996 - d / 360 | 0))
                        }
                        var y = 0
                          , b = d - p;
                        if (0 == (b -= 360 * (16384 - (16384.499999999996 - b / 360 | 0))))
                            y = a[o];
                        else {
                            var x = 0
                              , w = 0;
                            l ? (x = 0,
                            w = b) : (x = a[o],
                            w = a[o + 1]);
                            var _ = b > 0
                              , T = x >= 0;
                            e.MathUtils.signum(w) != e.MathUtils.signum(b) && Math.abs(w) <= 90 && (Math.abs(x) > 180 && (x += 360 * e.MathUtils.signum(x)),
                            T = _),
                            y = b + x - x % 360,
                            T != _ && (y += 360 * e.MathUtils.signum(x)),
                            a[o] = y
                        }
                        a[o + 1] = b,
                        p += y * r,
                        u.rotation = p - 360 * (16384 - (16384.499999999996 - p / 360 | 0))
                    } else
                        t.apply(i, 0, n, null, 1, s, e.MixDirection.in)
                }
                ,
                t.prototype.queueEvents = function(e, t) {
                    for (var i = e.animationStart, n = e.animationEnd, r = n - i, s = e.trackLast % r, a = this.events, o = 0, l = a.length; o < l; o++) {
                        var c = a[o];
                        if (c.time < s)
                            break;
                        c.time > n || this.queue.event(e, c)
                    }
                    for ((e.loop ? 0 == r || s > e.trackTime % r : t >= n && e.animationLast < n) && this.queue.complete(e); o < l; o++)
                        a[o].time < i || this.queue.event(e, a[o])
                }
                ,
                t.prototype.clearTracks = function() {
                    var e = this.queue.drainDisabled;
                    this.queue.drainDisabled = !0;
                    for (var t = 0, i = this.tracks.length; t < i; t++)
                        this.clearTrack(t);
                    this.tracks.length = 0,
                    this.queue.drainDisabled = e,
                    this.queue.drain()
                }
                ,
                t.prototype.clearTrack = function(e) {
                    if (!(e >= this.tracks.length)) {
                        var t = this.tracks[e];
                        if (null != t) {
                            this.queue.end(t),
                            this.disposeNext(t);
                            for (var i = t; ; ) {
                                var n = i.mixingFrom;
                                if (null == n)
                                    break;
                                this.queue.end(n),
                                i.mixingFrom = null,
                                i.mixingTo = null,
                                i = n
                            }
                            this.tracks[t.trackIndex] = null,
                            this.queue.drain()
                        }
                    }
                }
                ,
                t.prototype.setCurrent = function(e, t, i) {
                    var n = this.expandToIndex(e);
                    this.tracks[e] = t,
                    null != n && (i && this.queue.interrupt(n),
                    t.mixingFrom = n,
                    n.mixingTo = t,
                    t.mixTime = 0,
                    null != n.mixingFrom && n.mixDuration > 0 && (t.interruptAlpha *= Math.min(1, n.mixTime / n.mixDuration)),
                    n.timelinesRotation.length = 0),
                    this.queue.start(t)
                }
                ,
                t.prototype.setAnimation = function(e, t, i) {
                    var n = this.data.skeletonData.findAnimation(t);
                    if (null == n)
                        throw new Error("Animation not found: " + t);
                    return this.setAnimationWith(e, n, i)
                }
                ,
                t.prototype.setAnimationWith = function(e, t, i) {
                    if (null == t)
                        throw new Error("animation cannot be null.");
                    var n = !0
                      , r = this.expandToIndex(e);
                    null != r && (-1 == r.nextTrackLast ? (this.tracks[e] = r.mixingFrom,
                    this.queue.interrupt(r),
                    this.queue.end(r),
                    this.disposeNext(r),
                    r = r.mixingFrom,
                    n = !1) : this.disposeNext(r));
                    var s = this.trackEntry(e, t, i, r);
                    return this.setCurrent(e, s, n),
                    this.queue.drain(),
                    s
                }
                ,
                t.prototype.addAnimation = function(e, t, i, n) {
                    var r = this.data.skeletonData.findAnimation(t);
                    if (null == r)
                        throw new Error("Animation not found: " + t);
                    return this.addAnimationWith(e, r, i, n)
                }
                ,
                t.prototype.addAnimationWith = function(e, t, i, n) {
                    if (null == t)
                        throw new Error("animation cannot be null.");
                    var r = this.expandToIndex(e);
                    if (null != r)
                        for (; null != r.next; )
                            r = r.next;
                    var s = this.trackEntry(e, t, i, r);
                    if (null == r)
                        this.setCurrent(e, s, !0),
                        this.queue.drain();
                    else if (r.next = s,
                    n <= 0) {
                        var a = r.animationEnd - r.animationStart;
                        0 != a ? (r.loop ? n += a * (1 + (r.trackTime / a | 0)) : n += Math.max(a, r.trackTime),
                        n -= this.data.getMix(r.animation, t)) : n = r.trackTime
                    }
                    return s.delay = n,
                    s
                }
                ,
                t.prototype.setEmptyAnimation = function(e, i) {
                    var n = this.setAnimationWith(e, t.emptyAnimation, !1);
                    return n.mixDuration = i,
                    n.trackEnd = i,
                    n
                }
                ,
                t.prototype.addEmptyAnimation = function(e, i, n) {
                    n <= 0 && (n -= i);
                    var r = this.addAnimationWith(e, t.emptyAnimation, !1, n);
                    return r.mixDuration = i,
                    r.trackEnd = i,
                    r
                }
                ,
                t.prototype.setEmptyAnimations = function(e) {
                    var t = this.queue.drainDisabled;
                    this.queue.drainDisabled = !0;
                    for (var i = 0, n = this.tracks.length; i < n; i++) {
                        var r = this.tracks[i];
                        null != r && this.setEmptyAnimation(r.trackIndex, e)
                    }
                    this.queue.drainDisabled = t,
                    this.queue.drain()
                }
                ,
                t.prototype.expandToIndex = function(t) {
                    return t < this.tracks.length ? this.tracks[t] : (e.Utils.ensureArrayCapacity(this.tracks, t + 1, null),
                    this.tracks.length = t + 1,
                    null)
                }
                ,
                t.prototype.trackEntry = function(e, t, i, n) {
                    var r = this.trackEntryPool.obtain();
                    return r.trackIndex = e,
                    r.animation = t,
                    r.loop = i,
                    r.holdPrevious = !1,
                    r.eventThreshold = 0,
                    r.attachmentThreshold = 0,
                    r.drawOrderThreshold = 0,
                    r.animationStart = 0,
                    r.animationEnd = t.duration,
                    r.animationLast = -1,
                    r.nextAnimationLast = -1,
                    r.delay = 0,
                    r.trackTime = 0,
                    r.trackLast = -1,
                    r.nextTrackLast = -1,
                    r.trackEnd = Number.MAX_VALUE,
                    r.timeScale = 1,
                    r.alpha = 1,
                    r.interruptAlpha = 1,
                    r.mixTime = 0,
                    r.mixDuration = null == n ? 0 : this.data.getMix(n.animation, t),
                    r
                }
                ,
                t.prototype.disposeNext = function(e) {
                    for (var t = e.next; null != t; )
                        this.queue.dispose(t),
                        t = t.next;
                    e.next = null
                }
                ,
                t.prototype._animationsChanged = function() {
                    this.animationsChanged = !1,
                    this.propertyIDs.clear();
                    for (var t = 0, i = this.tracks.length; t < i; t++) {
                        var n = this.tracks[t];
                        if (null != n) {
                            for (; null != n.mixingFrom; )
                                n = n.mixingFrom;
                            do {
                                null != n.mixingFrom && n.mixBlend == e.MixBlend.add || this.setTimelineModes(n),
                                n = n.mixingTo
                            } while (null != n)
                        }
                    }
                }
                ,
                t.prototype.setTimelineModes = function(i) {
                    var n = i.mixingTo
                      , r = i.animation.timelines
                      , s = i.animation.timelines.length
                      , a = e.Utils.setArraySize(i.timelineMode, s);
                    i.timelineHoldMix.length = 0;
                    var o = e.Utils.setArraySize(i.timelineHoldMix, s)
                      , l = this.propertyIDs;
                    if (null != n && n.holdPrevious)
                        for (var c = 0; c < s; c++)
                            l.add(r[c].getPropertyId()),
                            a[c] = t.HOLD;
                    else
                        e: for (c = 0; c < s; c++) {
                            var h = r[c].getPropertyId();
                            if (l.add(h))
                                if (null != n && this.hasTimeline(n, h)) {
                                    for (var u = n.mixingTo; null != u; u = u.mixingTo)
                                        if (!this.hasTimeline(u, h)) {
                                            if (i.mixDuration > 0) {
                                                a[c] = t.HOLD_MIX,
                                                o[c] = u;
                                                continue e
                                            }
                                            break
                                        }
                                    a[c] = t.HOLD
                                } else
                                    a[c] = t.FIRST;
                            else
                                a[c] = t.SUBSEQUENT
                        }
                }
                ,
                t.prototype.hasTimeline = function(e, t) {
                    for (var i = e.animation.timelines, n = 0, r = i.length; n < r; n++)
                        if (i[n].getPropertyId() == t)
                            return !0;
                    return !1
                }
                ,
                t.prototype.getCurrent = function(e) {
                    return e >= this.tracks.length ? null : this.tracks[e]
                }
                ,
                t.prototype.addListener = function(e) {
                    if (null == e)
                        throw new Error("listener cannot be null.");
                    this.listeners.push(e)
                }
                ,
                t.prototype.removeListener = function(e) {
                    var t = this.listeners.indexOf(e);
                    t >= 0 && this.listeners.splice(t, 1)
                }
                ,
                t.prototype.clearListeners = function() {
                    this.listeners.length = 0
                }
                ,
                t.prototype.clearListenerNotifications = function() {
                    this.queue.clear()
                }
                ,
                t.emptyAnimation = new e.Animation("<empty>",[],0),
                t.SUBSEQUENT = 0,
                t.FIRST = 1,
                t.HOLD = 2,
                t.HOLD_MIX = 3,
                t
            }();
            e.AnimationState = t;
            var i = function() {
                function t() {
                    this.mixBlend = e.MixBlend.replace,
                    this.timelineMode = new Array,
                    this.timelineHoldMix = new Array,
                    this.timelinesRotation = new Array
                }
                return t.prototype.reset = function() {
                    this.next = null,
                    this.mixingFrom = null,
                    this.mixingTo = null,
                    this.animation = null,
                    this.listener = null,
                    this.timelineMode.length = 0,
                    this.timelineHoldMix.length = 0,
                    this.timelinesRotation.length = 0
                }
                ,
                t.prototype.getAnimationTime = function() {
                    if (this.loop) {
                        var e = this.animationEnd - this.animationStart;
                        return 0 == e ? this.animationStart : this.trackTime % e + this.animationStart
                    }
                    return Math.min(this.trackTime + this.animationStart, this.animationEnd)
                }
                ,
                t.prototype.setAnimationLast = function(e) {
                    this.animationLast = e,
                    this.nextAnimationLast = e
                }
                ,
                t.prototype.isComplete = function() {
                    return this.trackTime >= this.animationEnd - this.animationStart
                }
                ,
                t.prototype.resetRotationDirections = function() {
                    this.timelinesRotation.length = 0
                }
                ,
                t
            }();
            e.TrackEntry = i;
            var n, r = function() {
                function e(e) {
                    this.objects = [],
                    this.drainDisabled = !1,
                    this.animState = e
                }
                return e.prototype.start = function(e) {
                    this.objects.push(n.start),
                    this.objects.push(e),
                    this.animState.animationsChanged = !0
                }
                ,
                e.prototype.interrupt = function(e) {
                    this.objects.push(n.interrupt),
                    this.objects.push(e)
                }
                ,
                e.prototype.end = function(e) {
                    this.objects.push(n.end),
                    this.objects.push(e),
                    this.animState.animationsChanged = !0
                }
                ,
                e.prototype.dispose = function(e) {
                    this.objects.push(n.dispose),
                    this.objects.push(e)
                }
                ,
                e.prototype.complete = function(e) {
                    this.objects.push(n.complete),
                    this.objects.push(e)
                }
                ,
                e.prototype.event = function(e, t) {
                    this.objects.push(n.event),
                    this.objects.push(e),
                    this.objects.push(t)
                }
                ,
                e.prototype.drain = function() {
                    if (!this.drainDisabled) {
                        this.drainDisabled = !0;
                        for (var e = this.objects, t = this.animState.listeners, i = 0; i < e.length; i += 2) {
                            var r = e[i]
                              , s = e[i + 1];
                            switch (r) {
                            case n.start:
                                null != s.listener && s.listener.start && s.listener.start(s);
                                for (var a = 0; a < t.length; a++)
                                    t[a].start && t[a].start(s);
                                break;
                            case n.interrupt:
                                for (null != s.listener && s.listener.interrupt && s.listener.interrupt(s),
                                a = 0; a < t.length; a++)
                                    t[a].interrupt && t[a].interrupt(s);
                                break;
                            case n.end:
                                for (null != s.listener && s.listener.end && s.listener.end(s),
                                a = 0; a < t.length; a++)
                                    t[a].end && t[a].end(s);
                            case n.dispose:
                                for (null != s.listener && s.listener.dispose && s.listener.dispose(s),
                                a = 0; a < t.length; a++)
                                    t[a].dispose && t[a].dispose(s);
                                this.animState.trackEntryPool.free(s);
                                break;
                            case n.complete:
                                for (null != s.listener && s.listener.complete && s.listener.complete(s),
                                a = 0; a < t.length; a++)
                                    t[a].complete && t[a].complete(s);
                                break;
                            case n.event:
                                var o = e[2 + i++];
                                for (null != s.listener && s.listener.event && s.listener.event(s, o),
                                a = 0; a < t.length; a++)
                                    t[a].event && t[a].event(s, o)
                            }
                        }
                        this.clear(),
                        this.drainDisabled = !1
                    }
                }
                ,
                e.prototype.clear = function() {
                    this.objects.length = 0
                }
                ,
                e
            }();
            e.EventQueue = r,
            function(e) {
                e[e.start = 0] = "start",
                e[e.interrupt = 1] = "interrupt",
                e[e.end = 2] = "end",
                e[e.dispose = 3] = "dispose",
                e[e.complete = 4] = "complete",
                e[e.event = 5] = "event"
            }(n = e.EventType || (e.EventType = {}));
            var s = function() {
                function e() {}
                return e.prototype.start = function(e) {}
                ,
                e.prototype.interrupt = function(e) {}
                ,
                e.prototype.end = function(e) {}
                ,
                e.prototype.dispose = function(e) {}
                ,
                e.prototype.complete = function(e) {}
                ,
                e.prototype.event = function(e, t) {}
                ,
                e
            }();
            e.AnimationStateAdapter2 = s
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function e(e) {
                    if (this.animationToMixTime = {},
                    this.defaultMix = 0,
                    null == e)
                        throw new Error("skeletonData cannot be null.");
                    this.skeletonData = e
                }
                return e.prototype.setMix = function(e, t, i) {
                    var n = this.skeletonData.findAnimation(e);
                    if (null == n)
                        throw new Error("Animation not found: " + e);
                    var r = this.skeletonData.findAnimation(t);
                    if (null == r)
                        throw new Error("Animation not found: " + t);
                    this.setMixWith(n, r, i)
                }
                ,
                e.prototype.setMixWith = function(e, t, i) {
                    if (null == e)
                        throw new Error("from cannot be null.");
                    if (null == t)
                        throw new Error("to cannot be null.");
                    var n = e.name + "." + t.name;
                    this.animationToMixTime[n] = i
                }
                ,
                e.prototype.getMix = function(e, t) {
                    var i = e.name + "." + t.name
                      , n = this.animationToMixTime[i];
                    return void 0 === n ? this.defaultMix : n
                }
                ,
                e
            }();
            e.AnimationStateData = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(e, t) {
                    void 0 === t && (t = ""),
                    this.assets = {},
                    this.errors = {},
                    this.toLoad = 0,
                    this.loaded = 0,
                    this.textureLoader = e,
                    this.pathPrefix = t
                }
                return t.downloadText = function(e, t, i) {
                    var n = new XMLHttpRequest;
                    n.open("GET", e, !0),
                    n.onload = function() {
                        200 == n.status ? t(n.responseText) : i(n.status, n.responseText)
                    }
                    ,
                    n.onerror = function() {
                        i(n.status, n.responseText)
                    }
                    ,
                    n.send()
                }
                ,
                t.downloadBinary = function(e, t, i) {
                    var n = new XMLHttpRequest;
                    n.open("GET", e, !0),
                    n.responseType = "arraybuffer",
                    n.onload = function() {
                        200 == n.status ? t(new Uint8Array(n.response)) : i(n.status, n.responseText)
                    }
                    ,
                    n.onerror = function() {
                        i(n.status, n.responseText)
                    }
                    ,
                    n.send()
                }
                ,
                t.prototype.loadText = function(e, i, n) {
                    var r = this;
                    void 0 === i && (i = null),
                    void 0 === n && (n = null),
                    e = this.pathPrefix + e,
                    this.toLoad++,
                    t.downloadText(e, function(t) {
                        r.assets[e] = t,
                        i && i(e, t),
                        r.toLoad--,
                        r.loaded++
                    }, function(t, i) {
                        r.errors[e] = "Couldn't load text " + e + ": status " + status + ", " + i,
                        n && n(e, "Couldn't load text " + e + ": status " + status + ", " + i),
                        r.toLoad--,
                        r.loaded++
                    })
                }
                ,
                t.prototype.loadTexture = function(e, t, i) {
                    var n = this;
                    void 0 === t && (t = null),
                    void 0 === i && (i = null),
                    e = this.pathPrefix + e,
                    this.toLoad++;
                    var r = new Image;
                    r.crossOrigin = "anonymous",
                    r.onload = function(i) {
                        var s = n.textureLoader(r);
                        n.assets[e] = s,
                        n.toLoad--,
                        n.loaded++,
                        t && t(e, r)
                    }
                    ,
                    r.onerror = function(t) {
                        n.errors[e] = "Couldn't load image " + e,
                        n.toLoad--,
                        n.loaded++,
                        i && i(e, "Couldn't load image " + e)
                    }
                    ,
                    r.src = e
                }
                ,
                t.prototype.loadTextureData = function(e, t, i, n) {
                    var r = this;
                    void 0 === i && (i = null),
                    void 0 === n && (n = null),
                    e = this.pathPrefix + e,
                    this.toLoad++;
                    var s = new Image;
                    s.onload = function(t) {
                        var n = r.textureLoader(s);
                        r.assets[e] = n,
                        r.toLoad--,
                        r.loaded++,
                        i && i(e, s)
                    }
                    ,
                    s.onerror = function(t) {
                        r.errors[e] = "Couldn't load image " + e,
                        r.toLoad--,
                        r.loaded++,
                        n && n(e, "Couldn't load image " + e)
                    }
                    ,
                    s.src = t
                }
                ,
                t.prototype.loadTextureAtlas = function(i, n, r) {
                    var s = this;
                    void 0 === n && (n = null),
                    void 0 === r && (r = null);
                    var a = i.lastIndexOf("/") >= 0 ? i.substring(0, i.lastIndexOf("/")) : "";
                    i = this.pathPrefix + i,
                    this.toLoad++,
                    t.downloadText(i, function(t) {
                        var o = {
                            count: 0
                        }
                          , l = new Array;
                        try {
                            new e.TextureAtlas(t,function(t) {
                                l.push(a + "/" + t);
                                var i = document.createElement("img");
                                return i.width = 16,
                                i.height = 16,
                                new e.FakeTexture(i)
                            }
                            )
                        } catch (e) {
                            var c = e;
                            return s.errors[i] = "Couldn't load texture atlas " + i + ": " + c.message,
                            r && r(i, "Couldn't load texture atlas " + i + ": " + c.message),
                            s.toLoad--,
                            void s.loaded++
                        }
                        for (var h = function(c) {
                            var h = !1;
                            s.loadTexture(c, function(c, u) {
                                if (o.count++,
                                o.count == l.length)
                                    if (h)
                                        s.errors[i] = "Couldn't load texture atlas page " + c + "} of atlas " + i,
                                        r && r(i, "Couldn't load texture atlas page " + c + " of atlas " + i),
                                        s.toLoad--,
                                        s.loaded++;
                                    else
                                        try {
                                            var p = new e.TextureAtlas(t,function(e) {
                                                return s.get(a + "/" + e)
                                            }
                                            );
                                            s.assets[i] = p,
                                            n && n(i, p),
                                            s.toLoad--,
                                            s.loaded++
                                        } catch (e) {
                                            var d = e;
                                            s.errors[i] = "Couldn't load texture atlas " + i + ": " + d.message,
                                            r && r(i, "Couldn't load texture atlas " + i + ": " + d.message),
                                            s.toLoad--,
                                            s.loaded++
                                        }
                            }, function(e, t) {
                                h = !0,
                                o.count++,
                                o.count == l.length && (s.errors[i] = "Couldn't load texture atlas page " + e + "} of atlas " + i,
                                r && r(i, "Couldn't load texture atlas page " + e + " of atlas " + i),
                                s.toLoad--,
                                s.loaded++)
                            })
                        }, u = 0, p = l; u < p.length; u++)
                            h(p[u])
                    }, function(e, t) {
                        s.errors[i] = "Couldn't load texture atlas " + i + ": status " + status + ", " + t,
                        r && r(i, "Couldn't load texture atlas " + i + ": status " + status + ", " + t),
                        s.toLoad--,
                        s.loaded++
                    })
                }
                ,
                t.prototype.get = function(e) {
                    return e = this.pathPrefix + e,
                    this.assets[e]
                }
                ,
                t.prototype.remove = function(e) {
                    e = this.pathPrefix + e;
                    var t = this.assets[e];
                    t.dispose && t.dispose(),
                    this.assets[e] = null
                }
                ,
                t.prototype.removeAll = function() {
                    for (var e in this.assets) {
                        var t = this.assets[e];
                        t.dispose && t.dispose()
                    }
                    this.assets = {}
                }
                ,
                t.prototype.isLoadingComplete = function() {
                    return 0 == this.toLoad
                }
                ,
                t.prototype.getToLoad = function() {
                    return this.toLoad
                }
                ,
                t.prototype.getLoaded = function() {
                    return this.loaded
                }
                ,
                t.prototype.dispose = function() {
                    this.removeAll()
                }
                ,
                t.prototype.hasErrors = function() {
                    return Object.keys(this.errors).length > 0
                }
                ,
                t.prototype.getErrors = function() {
                    return this.errors
                }
                ,
                t
            }();
            e.AssetManager = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(e) {
                    this.atlas = e
                }
                return t.prototype.newRegionAttachment = function(t, i, n) {
                    var r = this.atlas.findRegion(n);
                    if (null == r)
                        throw new Error("Region not found in atlas: " + n + " (region attachment: " + i + ")");
                    r.renderObject = r;
                    var s = new e.RegionAttachment(i);
                    return s.setRegion(r),
                    s
                }
                ,
                t.prototype.newMeshAttachment = function(t, i, n) {
                    var r = this.atlas.findRegion(n);
                    if (null == r)
                        throw new Error("Region not found in atlas: " + n + " (mesh attachment: " + i + ")");
                    r.renderObject = r;
                    var s = new e.MeshAttachment(i);
                    return s.region = r,
                    s
                }
                ,
                t.prototype.newBoundingBoxAttachment = function(t, i) {
                    return new e.BoundingBoxAttachment(i)
                }
                ,
                t.prototype.newPathAttachment = function(t, i) {
                    return new e.PathAttachment(i)
                }
                ,
                t.prototype.newPointAttachment = function(t, i) {
                    return new e.PointAttachment(i)
                }
                ,
                t.prototype.newClippingAttachment = function(t, i) {
                    return new e.ClippingAttachment(i)
                }
                ,
                t
            }();
            e.AtlasAttachmentLoader = t
        }(n || (n = {})),
        function(e) {
            !function(e) {
                e[e.Normal = 0] = "Normal",
                e[e.Additive = 1] = "Additive",
                e[e.Multiply = 2] = "Multiply",
                e[e.Screen = 3] = "Screen"
            }(e.BlendMode || (e.BlendMode = {}))
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(e, t, i) {
                    if (this.children = new Array,
                    this.x = 0,
                    this.y = 0,
                    this.rotation = 0,
                    this.scaleX = 0,
                    this.scaleY = 0,
                    this.shearX = 0,
                    this.shearY = 0,
                    this.ax = 0,
                    this.ay = 0,
                    this.arotation = 0,
                    this.ascaleX = 0,
                    this.ascaleY = 0,
                    this.ashearX = 0,
                    this.ashearY = 0,
                    this.appliedValid = !1,
                    this.a = 0,
                    this.b = 0,
                    this.worldX = 0,
                    this.c = 0,
                    this.d = 0,
                    this.worldY = 0,
                    this.sorted = !1,
                    null == e)
                        throw new Error("data cannot be null.");
                    if (null == t)
                        throw new Error("skeleton cannot be null.");
                    this.data = e,
                    this.skeleton = t,
                    this.parent = i,
                    this.setToSetupPose()
                }
                return t.prototype.update = function() {
                    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
                }
                ,
                t.prototype.updateWorldTransform = function() {
                    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
                }
                ,
                t.prototype.updateWorldTransformWith = function(t, i, n, r, s, a, o) {
                    this.ax = t,
                    this.ay = i,
                    this.arotation = n,
                    this.ascaleX = r,
                    this.ascaleY = s,
                    this.ashearX = a,
                    this.ashearY = o,
                    this.appliedValid = !0;
                    var l = this.parent;
                    if (null == l) {
                        var c = this.skeleton
                          , h = n + 90 + o
                          , u = c.scaleX
                          , p = c.scaleY;
                        return this.a = e.MathUtils.cosDeg(n + a) * r * u,
                        this.b = e.MathUtils.cosDeg(h) * s * u,
                        this.c = e.MathUtils.sinDeg(n + a) * r * p,
                        this.d = e.MathUtils.sinDeg(h) * s * p,
                        this.worldX = t * u + c.x,
                        void (this.worldY = i * p + c.y)
                    }
                    var d = l.a
                      , f = l.b
                      , m = l.c
                      , g = l.d;
                    switch (this.worldX = d * t + f * i + l.worldX,
                    this.worldY = m * t + g * i + l.worldY,
                    this.data.transformMode) {
                    case e.TransformMode.Normal:
                        h = n + 90 + o;
                        var v = e.MathUtils.cosDeg(n + a) * r
                          , y = e.MathUtils.cosDeg(h) * s
                          , b = e.MathUtils.sinDeg(n + a) * r
                          , x = e.MathUtils.sinDeg(h) * s;
                        return this.a = d * v + f * b,
                        this.b = d * y + f * x,
                        this.c = m * v + g * b,
                        void (this.d = m * y + g * x);
                    case e.TransformMode.OnlyTranslation:
                        h = n + 90 + o,
                        this.a = e.MathUtils.cosDeg(n + a) * r,
                        this.b = e.MathUtils.cosDeg(h) * s,
                        this.c = e.MathUtils.sinDeg(n + a) * r,
                        this.d = e.MathUtils.sinDeg(h) * s;
                        break;
                    case e.TransformMode.NoRotationOrReflection:
                        var w = 0;
                        (M = d * d + m * m) > 1e-4 ? (f = m * (M = Math.abs(d * g - f * m) / M),
                        g = d * M,
                        w = Math.atan2(m, d) * e.MathUtils.radDeg) : (d = 0,
                        m = 0,
                        w = 90 - Math.atan2(g, f) * e.MathUtils.radDeg);
                        var _ = n + a - w
                          , T = n + o - w + 90;
                        v = e.MathUtils.cosDeg(_) * r,
                        y = e.MathUtils.cosDeg(T) * s,
                        b = e.MathUtils.sinDeg(_) * r,
                        x = e.MathUtils.sinDeg(T) * s,
                        this.a = d * v - f * b,
                        this.b = d * y - f * x,
                        this.c = m * v + g * b,
                        this.d = m * y + g * x;
                        break;
                    case e.TransformMode.NoScale:
                    case e.TransformMode.NoScaleOrReflection:
                        var M, S = e.MathUtils.cosDeg(n), A = e.MathUtils.sinDeg(n), P = (d * S + f * A) / this.skeleton.scaleX, C = (m * S + g * A) / this.skeleton.scaleY;
                        (M = Math.sqrt(P * P + C * C)) > 1e-5 && (M = 1 / M),
                        P *= M,
                        C *= M,
                        M = Math.sqrt(P * P + C * C),
                        this.data.transformMode == e.TransformMode.NoScale && d * g - f * m < 0 != (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (M = -M);
                        var L = Math.PI / 2 + Math.atan2(C, P)
                          , k = Math.cos(L) * M
                          , E = Math.sin(L) * M;
                        v = e.MathUtils.cosDeg(a) * r,
                        y = e.MathUtils.cosDeg(90 + o) * s,
                        b = e.MathUtils.sinDeg(a) * r,
                        x = e.MathUtils.sinDeg(90 + o) * s,
                        this.a = P * v + k * b,
                        this.b = P * y + k * x,
                        this.c = C * v + E * b,
                        this.d = C * y + E * x
                    }
                    this.a *= this.skeleton.scaleX,
                    this.b *= this.skeleton.scaleX,
                    this.c *= this.skeleton.scaleY,
                    this.d *= this.skeleton.scaleY
                }
                ,
                t.prototype.setToSetupPose = function() {
                    var e = this.data;
                    this.x = e.x,
                    this.y = e.y,
                    this.rotation = e.rotation,
                    this.scaleX = e.scaleX,
                    this.scaleY = e.scaleY,
                    this.shearX = e.shearX,
                    this.shearY = e.shearY
                }
                ,
                t.prototype.getWorldRotationX = function() {
                    return Math.atan2(this.c, this.a) * e.MathUtils.radDeg
                }
                ,
                t.prototype.getWorldRotationY = function() {
                    return Math.atan2(this.d, this.b) * e.MathUtils.radDeg
                }
                ,
                t.prototype.getWorldScaleX = function() {
                    return Math.sqrt(this.a * this.a + this.c * this.c)
                }
                ,
                t.prototype.getWorldScaleY = function() {
                    return Math.sqrt(this.b * this.b + this.d * this.d)
                }
                ,
                t.prototype.updateAppliedTransform = function() {
                    this.appliedValid = !0;
                    var t = this.parent;
                    if (null == t)
                        return this.ax = this.worldX,
                        this.ay = this.worldY,
                        this.arotation = Math.atan2(this.c, this.a) * e.MathUtils.radDeg,
                        this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c),
                        this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d),
                        this.ashearX = 0,
                        void (this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * e.MathUtils.radDeg);
                    var i = t.a
                      , n = t.b
                      , r = t.c
                      , s = t.d
                      , a = 1 / (i * s - n * r)
                      , o = this.worldX - t.worldX
                      , l = this.worldY - t.worldY;
                    this.ax = o * s * a - l * n * a,
                    this.ay = l * i * a - o * r * a;
                    var c = a * s
                      , h = a * i
                      , u = a * n
                      , p = a * r
                      , d = c * this.a - u * this.c
                      , f = c * this.b - u * this.d
                      , m = h * this.c - p * this.a
                      , g = h * this.d - p * this.b;
                    if (this.ashearX = 0,
                    this.ascaleX = Math.sqrt(d * d + m * m),
                    this.ascaleX > 1e-4) {
                        var v = d * g - f * m;
                        this.ascaleY = v / this.ascaleX,
                        this.ashearY = Math.atan2(d * f + m * g, v) * e.MathUtils.radDeg,
                        this.arotation = Math.atan2(m, d) * e.MathUtils.radDeg
                    } else
                        this.ascaleX = 0,
                        this.ascaleY = Math.sqrt(f * f + g * g),
                        this.ashearY = 0,
                        this.arotation = 90 - Math.atan2(g, f) * e.MathUtils.radDeg
                }
                ,
                t.prototype.worldToLocal = function(e) {
                    var t = this.a
                      , i = this.b
                      , n = this.c
                      , r = this.d
                      , s = 1 / (t * r - i * n)
                      , a = e.x - this.worldX
                      , o = e.y - this.worldY;
                    return e.x = a * r * s - o * i * s,
                    e.y = o * t * s - a * n * s,
                    e
                }
                ,
                t.prototype.localToWorld = function(e) {
                    var t = e.x
                      , i = e.y;
                    return e.x = t * this.a + i * this.b + this.worldX,
                    e.y = t * this.c + i * this.d + this.worldY,
                    e
                }
                ,
                t.prototype.worldToLocalRotation = function(t) {
                    var i = e.MathUtils.sinDeg(t)
                      , n = e.MathUtils.cosDeg(t);
                    return Math.atan2(this.a * i - this.c * n, this.d * n - this.b * i) * e.MathUtils.radDeg + this.rotation - this.shearX
                }
                ,
                t.prototype.localToWorldRotation = function(t) {
                    t -= this.rotation - this.shearX;
                    var i = e.MathUtils.sinDeg(t)
                      , n = e.MathUtils.cosDeg(t);
                    return Math.atan2(n * this.c + i * this.d, n * this.a + i * this.b) * e.MathUtils.radDeg
                }
                ,
                t.prototype.rotateWorld = function(t) {
                    var i = this.a
                      , n = this.b
                      , r = this.c
                      , s = this.d
                      , a = e.MathUtils.cosDeg(t)
                      , o = e.MathUtils.sinDeg(t);
                    this.a = a * i - o * r,
                    this.b = a * n - o * s,
                    this.c = o * i + a * r,
                    this.d = o * n + a * s,
                    this.appliedValid = !1
                }
                ,
                t
            }();
            e.Bone = t
        }(n || (n = {})),
        function(e) {
            var t, i = function(e, i, n) {
                if (this.x = 0,
                this.y = 0,
                this.rotation = 0,
                this.scaleX = 1,
                this.scaleY = 1,
                this.shearX = 0,
                this.shearY = 0,
                this.transformMode = t.Normal,
                e < 0)
                    throw new Error("index must be >= 0.");
                if (null == i)
                    throw new Error("name cannot be null.");
                this.index = e,
                this.name = i,
                this.parent = n
            };
            e.BoneData = i,
            function(e) {
                e[e.Normal = 0] = "Normal",
                e[e.OnlyTranslation = 1] = "OnlyTranslation",
                e[e.NoRotationOrReflection = 2] = "NoRotationOrReflection",
                e[e.NoScale = 3] = "NoScale",
                e[e.NoScaleOrReflection = 4] = "NoScaleOrReflection"
            }(t = e.TransformMode || (e.TransformMode = {}))
        }(n || (n = {})),
        function(e) {
            var t = function(e, t) {
                if (null == t)
                    throw new Error("data cannot be null.");
                this.time = e,
                this.data = t
            };
            e.Event = t
        }(n || (n = {})),
        function(e) {
            var t = function(e) {
                this.name = e
            };
            e.EventData = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(e, t) {
                    if (this.bendDirection = 0,
                    this.compress = !1,
                    this.stretch = !1,
                    this.mix = 1,
                    null == e)
                        throw new Error("data cannot be null.");
                    if (null == t)
                        throw new Error("skeleton cannot be null.");
                    this.data = e,
                    this.mix = e.mix,
                    this.bendDirection = e.bendDirection,
                    this.compress = e.compress,
                    this.stretch = e.stretch,
                    this.bones = new Array;
                    for (var i = 0; i < e.bones.length; i++)
                        this.bones.push(t.findBone(e.bones[i].name));
                    this.target = t.findBone(e.target.name)
                }
                return t.prototype.getOrder = function() {
                    return this.data.order
                }
                ,
                t.prototype.apply = function() {
                    this.update()
                }
                ,
                t.prototype.update = function() {
                    var e = this.target
                      , t = this.bones;
                    switch (t.length) {
                    case 1:
                        this.apply1(t[0], e.worldX, e.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                        break;
                    case 2:
                        this.apply2(t[0], t[1], e.worldX, e.worldY, this.bendDirection, this.stretch, this.mix)
                    }
                }
                ,
                t.prototype.apply1 = function(t, i, n, r, s, a, o) {
                    t.appliedValid || t.updateAppliedTransform();
                    var l = t.parent
                      , c = 1 / (l.a * l.d - l.b * l.c)
                      , h = i - l.worldX
                      , u = n - l.worldY
                      , p = (h * l.d - u * l.b) * c - t.ax
                      , d = (u * l.a - h * l.c) * c - t.ay
                      , f = Math.atan2(d, p) * e.MathUtils.radDeg - t.ashearX - t.arotation;
                    t.ascaleX < 0 && (f += 180),
                    f > 180 ? f -= 360 : f < -180 && (f += 360);
                    var m = t.ascaleX
                      , g = t.ascaleY;
                    if (r || s) {
                        var v = t.data.length * m
                          , y = Math.sqrt(p * p + d * d);
                        if (r && y < v || s && y > v && v > 1e-4) {
                            var b = (y / v - 1) * o + 1;
                            m *= b,
                            a && (g *= b)
                        }
                    }
                    t.updateWorldTransformWith(t.ax, t.ay, t.arotation + f * o, m, g, t.ashearX, t.ashearY)
                }
                ,
                t.prototype.apply2 = function(t, i, n, r, s, a, o) {
                    if (0 != o) {
                        t.appliedValid || t.updateAppliedTransform(),
                        i.appliedValid || i.updateAppliedTransform();
                        var l = t.ax
                          , c = t.ay
                          , h = t.ascaleX
                          , u = h
                          , p = t.ascaleY
                          , d = i.ascaleX
                          , f = 0
                          , m = 0
                          , g = 0;
                        h < 0 ? (h = -h,
                        f = 180,
                        g = -1) : (f = 0,
                        g = 1),
                        p < 0 && (p = -p,
                        g = -g),
                        d < 0 ? (d = -d,
                        m = 180) : m = 0;
                        var v = i.ax
                          , y = 0
                          , b = 0
                          , x = 0
                          , w = t.a
                          , _ = t.b
                          , T = t.c
                          , M = t.d
                          , S = Math.abs(h - p) <= 1e-4;
                        S ? (b = w * v + _ * (y = i.ay) + t.worldX,
                        x = T * v + M * y + t.worldY) : (y = 0,
                        b = w * v + t.worldX,
                        x = T * v + t.worldY);
                        var A = t.parent;
                        w = A.a,
                        _ = A.b,
                        T = A.c;
                        var P = 1 / (w * (M = A.d) - _ * T)
                          , C = n - A.worldX
                          , L = r - A.worldY
                          , k = (C * M - L * _) * P - l
                          , E = (L * w - C * T) * P - c
                          , I = k * k + E * E
                          , F = ((C = b - A.worldX) * M - (L = x - A.worldY) * _) * P - l
                          , O = (L * w - C * T) * P - c
                          , R = Math.sqrt(F * F + O * O)
                          , z = i.data.length * d
                          , N = 0
                          , D = 0;
                        e: if (S) {
                            var U = (I - R * R - (z *= h) * z) / (2 * R * z);
                            U < -1 ? U = -1 : U > 1 && (U = 1,
                            a && R + z > 1e-4 && (u *= (Math.sqrt(I) / (R + z) - 1) * o + 1)),
                            D = Math.acos(U) * s,
                            w = R + z * U,
                            _ = z * Math.sin(D),
                            N = Math.atan2(E * w - k * _, k * w + E * _)
                        } else {
                            var B = (w = h * z) * w
                              , j = (_ = p * z) * _
                              , V = Math.atan2(E, k)
                              , G = -2 * j * R
                              , X = j - B;
                            if ((M = G * G - 4 * X * (T = j * R * R + B * I - B * j)) >= 0) {
                                var Y = Math.sqrt(M);
                                G < 0 && (Y = -Y);
                                var W = (Y = -(G + Y) / 2) / X
                                  , q = T / Y
                                  , H = Math.abs(W) < Math.abs(q) ? W : q;
                                if (H * H <= I) {
                                    L = Math.sqrt(I - H * H) * s,
                                    N = V - Math.atan2(L, H),
                                    D = Math.atan2(L / p, (H - R) / h);
                                    break e
                                }
                            }
                            var Q = e.MathUtils.PI
                              , J = R - w
                              , Z = J * J
                              , $ = 0
                              , K = 0
                              , ee = R + w
                              , te = ee * ee
                              , ie = 0;
                            (T = -w * R / (B - j)) >= -1 && T <= 1 && (T = Math.acos(T),
                            (M = (C = w * Math.cos(T) + R) * C + (L = _ * Math.sin(T)) * L) < Z && (Q = T,
                            Z = M,
                            J = C,
                            $ = L),
                            M > te && (K = T,
                            te = M,
                            ee = C,
                            ie = L)),
                            I <= (Z + te) / 2 ? (N = V - Math.atan2($ * s, J),
                            D = Q * s) : (N = V - Math.atan2(ie * s, ee),
                            D = K * s)
                        }
                        var ne = Math.atan2(y, v) * g
                          , re = t.arotation;
                        (N = (N - ne) * e.MathUtils.radDeg + f - re) > 180 ? N -= 360 : N < -180 && (N += 360),
                        t.updateWorldTransformWith(l, c, re + N * o, u, t.ascaleY, 0, 0),
                        re = i.arotation,
                        (D = ((D + ne) * e.MathUtils.radDeg - i.ashearX) * g + m - re) > 180 ? D -= 360 : D < -180 && (D += 360),
                        i.updateWorldTransformWith(v, y, re + D * o, i.ascaleX, i.ascaleY, i.ashearX, i.ashearY)
                    } else
                        i.updateWorldTransform()
                }
                ,
                t
            }();
            e.IkConstraint = t
        }(n || (n = {})),
        function(e) {
            var t = function(e) {
                this.order = 0,
                this.bones = new Array,
                this.bendDirection = 1,
                this.compress = !1,
                this.stretch = !1,
                this.uniform = !1,
                this.mix = 1,
                this.name = e
            };
            e.IkConstraintData = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(e, t) {
                    if (this.position = 0,
                    this.spacing = 0,
                    this.rotateMix = 0,
                    this.translateMix = 0,
                    this.spaces = new Array,
                    this.positions = new Array,
                    this.world = new Array,
                    this.curves = new Array,
                    this.lengths = new Array,
                    this.segments = new Array,
                    null == e)
                        throw new Error("data cannot be null.");
                    if (null == t)
                        throw new Error("skeleton cannot be null.");
                    this.data = e,
                    this.bones = new Array;
                    for (var i = 0, n = e.bones.length; i < n; i++)
                        this.bones.push(t.findBone(e.bones[i].name));
                    this.target = t.findSlot(e.target.name),
                    this.position = e.position,
                    this.spacing = e.spacing,
                    this.rotateMix = e.rotateMix,
                    this.translateMix = e.translateMix
                }
                return t.prototype.apply = function() {
                    this.update()
                }
                ,
                t.prototype.update = function() {
                    var i = this.target.getAttachment();
                    if (i instanceof e.PathAttachment) {
                        var n = this.rotateMix
                          , r = this.translateMix
                          , s = n > 0;
                        if (r > 0 || s) {
                            var a = this.data
                              , o = a.spacingMode == e.SpacingMode.Percent
                              , l = a.rotateMode
                              , c = l == e.RotateMode.Tangent
                              , h = l == e.RotateMode.ChainScale
                              , u = this.bones.length
                              , p = c ? u : u + 1
                              , d = this.bones
                              , f = e.Utils.setArraySize(this.spaces, p)
                              , m = null
                              , g = this.spacing;
                            if (h || !o) {
                                h && (m = e.Utils.setArraySize(this.lengths, u));
                                for (var v = a.spacingMode == e.SpacingMode.Length, y = 0, b = p - 1; y < b; ) {
                                    var x = (E = d[y]).data.length;
                                    if (x < t.epsilon)
                                        h && (m[y] = 0),
                                        f[++y] = 0;
                                    else if (o) {
                                        if (h) {
                                            var w = x * E.a
                                              , _ = x * E.c
                                              , T = Math.sqrt(w * w + _ * _);
                                            m[y] = T
                                        }
                                        f[++y] = g
                                    } else {
                                        w = x * E.a,
                                        _ = x * E.c;
                                        var M = Math.sqrt(w * w + _ * _);
                                        h && (m[y] = M),
                                        f[++y] = (v ? x + g : g) * M / x
                                    }
                                }
                            } else
                                for (y = 1; y < p; y++)
                                    f[y] = g;
                            var S = this.computeWorldPositions(i, p, c, a.positionMode == e.PositionMode.Percent, o)
                              , A = S[0]
                              , P = S[1]
                              , C = a.offsetRotation
                              , L = !1;
                            0 == C ? L = l == e.RotateMode.Chain : (L = !1,
                            C *= (k = this.target.bone).a * k.d - k.b * k.c > 0 ? e.MathUtils.degRad : -e.MathUtils.degRad),
                            y = 0;
                            for (var k = 3; y < u; y++,
                            k += 3) {
                                var E;
                                (E = d[y]).worldX += (A - E.worldX) * r,
                                E.worldY += (P - E.worldY) * r;
                                var I = (w = S[k]) - A
                                  , F = (_ = S[k + 1]) - P;
                                if (h) {
                                    var O = m[y];
                                    if (0 != O) {
                                        var R = (Math.sqrt(I * I + F * F) / O - 1) * n + 1;
                                        E.a *= R,
                                        E.c *= R
                                    }
                                }
                                if (A = w,
                                P = _,
                                s) {
                                    var z = E.a
                                      , N = E.b
                                      , D = E.c
                                      , U = E.d
                                      , B = 0
                                      , j = 0
                                      , V = 0;
                                    if (B = c ? S[k - 1] : 0 == f[y + 1] ? S[k + 2] : Math.atan2(F, I),
                                    B -= Math.atan2(D, z),
                                    L) {
                                        j = Math.cos(B),
                                        V = Math.sin(B);
                                        var G = E.data.length;
                                        A += (G * (j * z - V * D) - I) * n,
                                        P += (G * (V * z + j * D) - F) * n
                                    } else
                                        B += C;
                                    B > e.MathUtils.PI ? B -= e.MathUtils.PI2 : B < -e.MathUtils.PI && (B += e.MathUtils.PI2),
                                    B *= n,
                                    j = Math.cos(B),
                                    V = Math.sin(B),
                                    E.a = j * z - V * D,
                                    E.b = j * N - V * U,
                                    E.c = V * z + j * D,
                                    E.d = V * N + j * U
                                }
                                E.appliedValid = !1
                            }
                        }
                    }
                }
                ,
                t.prototype.computeWorldPositions = function(i, n, r, s, a) {
                    var o = this.target
                      , l = this.position
                      , c = this.spaces
                      , h = e.Utils.setArraySize(this.positions, 3 * n + 2)
                      , u = null
                      , p = i.closed
                      , d = i.worldVerticesLength
                      , f = d / 6
                      , m = t.NONE;
                    if (!i.constantSpeed) {
                        var g = i.lengths
                          , v = g[f -= p ? 1 : 2];
                        if (s && (l *= v),
                        a)
                            for (var y = 1; y < n; y++)
                                c[y] *= v;
                        u = e.Utils.setArraySize(this.world, 8),
                        y = 0;
                        for (var b = 0, x = 0; y < n; y++,
                        b += 3) {
                            var w = l += Y = c[y];
                            if (p)
                                (w %= v) < 0 && (w += v),
                                x = 0;
                            else {
                                if (w < 0) {
                                    m != t.BEFORE && (m = t.BEFORE,
                                    i.computeWorldVertices(o, 2, 4, u, 0, 2)),
                                    this.addBeforePosition(w, u, 0, h, b);
                                    continue
                                }
                                if (w > v) {
                                    m != t.AFTER && (m = t.AFTER,
                                    i.computeWorldVertices(o, d - 6, 4, u, 0, 2)),
                                    this.addAfterPosition(w - v, u, 0, h, b);
                                    continue
                                }
                            }
                            for (; ; x++) {
                                var _ = g[x];
                                if (!(w > _)) {
                                    0 == x ? w /= _ : w = (w - (Q = g[x - 1])) / (_ - Q);
                                    break
                                }
                            }
                            x != m && (m = x,
                            p && x == f ? (i.computeWorldVertices(o, d - 4, 4, u, 0, 2),
                            i.computeWorldVertices(o, 0, 4, u, 4, 2)) : i.computeWorldVertices(o, 6 * x + 2, 8, u, 0, 2)),
                            this.addCurvePosition(w, u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], h, b, r || y > 0 && 0 == Y)
                        }
                        return h
                    }
                    p ? (d += 2,
                    u = e.Utils.setArraySize(this.world, d),
                    i.computeWorldVertices(o, 2, d - 4, u, 0, 2),
                    i.computeWorldVertices(o, 0, 2, u, d - 4, 2),
                    u[d - 2] = u[0],
                    u[d - 1] = u[1]) : (f--,
                    d -= 4,
                    u = e.Utils.setArraySize(this.world, d),
                    i.computeWorldVertices(o, 2, d, u, 0, 2));
                    for (var T = e.Utils.setArraySize(this.curves, f), M = 0, S = u[0], A = u[1], P = 0, C = 0, L = 0, k = 0, E = 0, I = 0, F = 0, O = 0, R = 0, z = 0, N = 0, D = 0, U = 0, B = 0, j = (y = 0,
                    2); y < f; y++,
                    j += 6)
                        P = u[j],
                        C = u[j + 1],
                        L = u[j + 2],
                        k = u[j + 3],
                        N = 2 * (F = .1875 * (S - 2 * P + L)) + (R = .09375 * (3 * (P - L) - S + (E = u[j + 4]))),
                        D = 2 * (O = .1875 * (A - 2 * C + k)) + (z = .09375 * (3 * (C - k) - A + (I = u[j + 5]))),
                        U = .75 * (P - S) + F + .16666667 * R,
                        B = .75 * (C - A) + O + .16666667 * z,
                        M += Math.sqrt(U * U + B * B),
                        U += N,
                        B += D,
                        N += R,
                        D += z,
                        M += Math.sqrt(U * U + B * B),
                        U += N,
                        B += D,
                        M += Math.sqrt(U * U + B * B),
                        U += N + R,
                        B += D + z,
                        M += Math.sqrt(U * U + B * B),
                        T[y] = M,
                        S = E,
                        A = I;
                    if (l *= s ? M : M / i.lengths[f - 1],
                    a)
                        for (y = 1; y < n; y++)
                            c[y] *= M;
                    for (var V = this.segments, G = 0, X = (y = 0,
                    b = 0,
                    x = 0,
                    0); y < n; y++,
                    b += 3) {
                        var Y;
                        if (w = l += Y = c[y],
                        p)
                            (w %= M) < 0 && (w += M),
                            x = 0;
                        else {
                            if (w < 0) {
                                this.addBeforePosition(w, u, 0, h, b);
                                continue
                            }
                            if (w > M) {
                                this.addAfterPosition(w - M, u, d - 4, h, b);
                                continue
                            }
                        }
                        for (; ; x++) {
                            var W = T[x];
                            if (!(w > W)) {
                                0 == x ? w /= W : w = (w - (Q = T[x - 1])) / (W - Q);
                                break
                            }
                        }
                        if (x != m) {
                            m = x;
                            var q = 6 * x;
                            for (S = u[q],
                            A = u[q + 1],
                            P = u[q + 2],
                            C = u[q + 3],
                            L = u[q + 4],
                            k = u[q + 5],
                            N = 2 * (F = .03 * (S - 2 * P + L)) + (R = .006 * (3 * (P - L) - S + (E = u[q + 6]))),
                            D = 2 * (O = .03 * (A - 2 * C + k)) + (z = .006 * (3 * (C - k) - A + (I = u[q + 7]))),
                            U = .3 * (P - S) + F + .16666667 * R,
                            B = .3 * (C - A) + O + .16666667 * z,
                            G = Math.sqrt(U * U + B * B),
                            V[0] = G,
                            q = 1; q < 8; q++)
                                U += N,
                                B += D,
                                N += R,
                                D += z,
                                G += Math.sqrt(U * U + B * B),
                                V[q] = G;
                            U += N,
                            B += D,
                            G += Math.sqrt(U * U + B * B),
                            V[8] = G,
                            U += N + R,
                            B += D + z,
                            G += Math.sqrt(U * U + B * B),
                            V[9] = G,
                            X = 0
                        }
                        for (w *= G; ; X++) {
                            var H = V[X];
                            if (!(w > H)) {
                                var Q;
                                0 == X ? w /= H : w = X + (w - (Q = V[X - 1])) / (H - Q);
                                break
                            }
                        }
                        this.addCurvePosition(.1 * w, S, A, P, C, L, k, E, I, h, b, r || y > 0 && 0 == Y)
                    }
                    return h
                }
                ,
                t.prototype.addBeforePosition = function(e, t, i, n, r) {
                    var s = t[i]
                      , a = t[i + 1]
                      , o = t[i + 2] - s
                      , l = t[i + 3] - a
                      , c = Math.atan2(l, o);
                    n[r] = s + e * Math.cos(c),
                    n[r + 1] = a + e * Math.sin(c),
                    n[r + 2] = c
                }
                ,
                t.prototype.addAfterPosition = function(e, t, i, n, r) {
                    var s = t[i + 2]
                      , a = t[i + 3]
                      , o = s - t[i]
                      , l = a - t[i + 1]
                      , c = Math.atan2(l, o);
                    n[r] = s + e * Math.cos(c),
                    n[r + 1] = a + e * Math.sin(c),
                    n[r + 2] = c
                }
                ,
                t.prototype.addCurvePosition = function(e, t, i, n, r, s, a, o, l, c, h, u) {
                    if (0 == e || isNaN(e))
                        return c[h] = t,
                        c[h + 1] = i,
                        void (c[h + 2] = Math.atan2(r - i, n - t));
                    var p = e * e
                      , d = p * e
                      , f = 1 - e
                      , m = f * f
                      , g = m * f
                      , v = f * e
                      , y = 3 * v
                      , b = f * y
                      , x = y * e
                      , w = t * g + n * b + s * x + o * d
                      , _ = i * g + r * b + a * x + l * d;
                    c[h] = w,
                    c[h + 1] = _,
                    u && (c[h + 2] = e < .001 ? Math.atan2(r - i, n - t) : Math.atan2(_ - (i * m + r * v * 2 + a * p), w - (t * m + n * v * 2 + s * p)))
                }
                ,
                t.prototype.getOrder = function() {
                    return this.data.order
                }
                ,
                t.NONE = -1,
                t.BEFORE = -2,
                t.AFTER = -3,
                t.epsilon = 1e-5,
                t
            }();
            e.PathConstraint = t
        }(n || (n = {})),
        function(e) {
            var t = function(e) {
                this.order = 0,
                this.bones = new Array,
                this.name = e
            };
            e.PathConstraintData = t,
            function(e) {
                e[e.Fixed = 0] = "Fixed",
                e[e.Percent = 1] = "Percent"
            }(e.PositionMode || (e.PositionMode = {})),
            function(e) {
                e[e.Length = 0] = "Length",
                e[e.Fixed = 1] = "Fixed",
                e[e.Percent = 2] = "Percent"
            }(e.SpacingMode || (e.SpacingMode = {})),
            function(e) {
                e[e.Tangent = 0] = "Tangent",
                e[e.Chain = 1] = "Chain",
                e[e.ChainScale = 2] = "ChainScale"
            }(e.RotateMode || (e.RotateMode = {}))
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function e(e) {
                    this.toLoad = new Array,
                    this.assets = {},
                    this.clientId = e
                }
                return e.prototype.loaded = function() {
                    var e = 0;
                    for (var t in this.assets)
                        e++;
                    return e
                }
                ,
                e
            }()
              , i = function() {
                function e(e) {
                    void 0 === e && (e = ""),
                    this.clientAssets = {},
                    this.queuedAssets = {},
                    this.rawAssets = {},
                    this.errors = {},
                    this.pathPrefix = e
                }
                return e.prototype.queueAsset = function(e, i, n) {
                    var r = this.clientAssets[e];
                    return null == r && (r = new t(e),
                    this.clientAssets[e] = r),
                    null !== i && (r.textureLoader = i),
                    r.toLoad.push(n),
                    this.queuedAssets[n] !== n && (this.queuedAssets[n] = n,
                    !0)
                }
                ,
                e.prototype.loadText = function(e, t) {
                    var i = this;
                    if (t = this.pathPrefix + t,
                    this.queueAsset(e, null, t)) {
                        var n = new XMLHttpRequest;
                        n.onreadystatechange = function() {
                            n.readyState == XMLHttpRequest.DONE && (n.status >= 200 && n.status < 300 ? i.rawAssets[t] = n.responseText : i.errors[t] = "Couldn't load text " + t + ": status " + n.status + ", " + n.responseText)
                        }
                        ,
                        n.open("GET", t, !0),
                        n.send()
                    }
                }
                ,
                e.prototype.loadJson = function(e, t) {
                    var i = this;
                    if (t = this.pathPrefix + t,
                    this.queueAsset(e, null, t)) {
                        var n = new XMLHttpRequest;
                        n.onreadystatechange = function() {
                            n.readyState == XMLHttpRequest.DONE && (n.status >= 200 && n.status < 300 ? i.rawAssets[t] = JSON.parse(n.responseText) : i.errors[t] = "Couldn't load text " + t + ": status " + n.status + ", " + n.responseText)
                        }
                        ,
                        n.open("GET", t, !0),
                        n.send()
                    }
                }
                ,
                e.prototype.loadTexture = function(e, t, i) {
                    var n = this;
                    if (i = this.pathPrefix + i,
                    this.queueAsset(e, t, i)) {
                        var r = new Image;
                        r.src = i,
                        r.crossOrigin = "anonymous",
                        r.onload = function(e) {
                            n.rawAssets[i] = r
                        }
                        ,
                        r.onerror = function(e) {
                            n.errors[i] = "Couldn't load image " + i
                        }
                    }
                }
                ,
                e.prototype.get = function(e, t) {
                    t = this.pathPrefix + t;
                    var i = this.clientAssets[e];
                    return null == i || i.assets[t]
                }
                ,
                e.prototype.updateClientAssets = function(e) {
                    for (var t = 0; t < e.toLoad.length; t++) {
                        var i = e.toLoad[t]
                          , n = e.assets[i];
                        if (null == n) {
                            var r = this.rawAssets[i];
                            if (null == r)
                                continue;
                            r instanceof HTMLImageElement ? e.assets[i] = e.textureLoader(r) : e.assets[i] = r
                        }
                    }
                }
                ,
                e.prototype.isLoadingComplete = function(e) {
                    var t = this.clientAssets[e];
                    return null == t || (this.updateClientAssets(t),
                    t.toLoad.length == t.loaded())
                }
                ,
                e.prototype.dispose = function() {}
                ,
                e.prototype.hasErrors = function() {
                    return Object.keys(this.errors).length > 0
                }
                ,
                e.prototype.getErrors = function() {
                    return this.errors
                }
                ,
                e
            }();
            e.SharedAssetManager = i
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(t) {
                    if (this._updateCache = new Array,
                    this.updateCacheReset = new Array,
                    this.time = 0,
                    this.scaleX = 1,
                    this.scaleY = 1,
                    this.x = 0,
                    this.y = 0,
                    null == t)
                        throw new Error("data cannot be null.");
                    this.data = t,
                    this.bones = new Array;
                    for (var i = 0; i < t.bones.length; i++) {
                        var n = t.bones[i]
                          , r = void 0;
                        if (null == n.parent)
                            r = new e.Bone(n,this,null);
                        else {
                            var s = this.bones[n.parent.index];
                            r = new e.Bone(n,this,s),
                            s.children.push(r)
                        }
                        this.bones.push(r)
                    }
                    for (this.slots = new Array,
                    this.drawOrder = new Array,
                    i = 0; i < t.slots.length; i++) {
                        var a = t.slots[i]
                          , o = (r = this.bones[a.boneData.index],
                        new e.Slot(a,r));
                        this.slots.push(o),
                        this.drawOrder.push(o)
                    }
                    for (this.ikConstraints = new Array,
                    i = 0; i < t.ikConstraints.length; i++) {
                        var l = t.ikConstraints[i];
                        this.ikConstraints.push(new e.IkConstraint(l,this))
                    }
                    for (this.transformConstraints = new Array,
                    i = 0; i < t.transformConstraints.length; i++) {
                        var c = t.transformConstraints[i];
                        this.transformConstraints.push(new e.TransformConstraint(c,this))
                    }
                    for (this.pathConstraints = new Array,
                    i = 0; i < t.pathConstraints.length; i++) {
                        var h = t.pathConstraints[i];
                        this.pathConstraints.push(new e.PathConstraint(h,this))
                    }
                    this.color = new e.Color(1,1,1,1),
                    this.updateCache()
                }
                return t.prototype.updateCache = function() {
                    this._updateCache.length = 0,
                    this.updateCacheReset.length = 0;
                    for (var e = this.bones, t = 0, i = e.length; t < i; t++)
                        e[t].sorted = !1;
                    var n = this.ikConstraints
                      , r = this.transformConstraints
                      , s = this.pathConstraints
                      , a = n.length
                      , o = r.length
                      , l = s.length
                      , c = a + o + l;
                    e: for (t = 0; t < c; t++) {
                        for (var h = 0; h < a; h++)
                            if ((u = n[h]).data.order == t) {
                                this.sortIkConstraint(u);
                                continue e
                            }
                        for (h = 0; h < o; h++)
                            if ((u = r[h]).data.order == t) {
                                this.sortTransformConstraint(u);
                                continue e
                            }
                        for (h = 0; h < l; h++) {
                            var u;
                            if ((u = s[h]).data.order == t) {
                                this.sortPathConstraint(u);
                                continue e
                            }
                        }
                    }
                    for (t = 0,
                    i = e.length; t < i; t++)
                        this.sortBone(e[t])
                }
                ,
                t.prototype.sortIkConstraint = function(e) {
                    var t = e.target;
                    this.sortBone(t);
                    var i = e.bones
                      , n = i[0];
                    if (this.sortBone(n),
                    i.length > 1) {
                        var r = i[i.length - 1];
                        this._updateCache.indexOf(r) > -1 || this.updateCacheReset.push(r)
                    }
                    this._updateCache.push(e),
                    this.sortReset(n.children),
                    i[i.length - 1].sorted = !0
                }
                ,
                t.prototype.sortPathConstraint = function(t) {
                    var i = t.target
                      , n = i.data.index
                      , r = i.bone;
                    null != this.skin && this.sortPathConstraintAttachment(this.skin, n, r),
                    null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, n, r);
                    for (var s = 0, a = this.data.skins.length; s < a; s++)
                        this.sortPathConstraintAttachment(this.data.skins[s], n, r);
                    var o = i.getAttachment();
                    o instanceof e.PathAttachment && this.sortPathConstraintAttachmentWith(o, r);
                    var l = t.bones
                      , c = l.length;
                    for (s = 0; s < c; s++)
                        this.sortBone(l[s]);
                    for (this._updateCache.push(t),
                    s = 0; s < c; s++)
                        this.sortReset(l[s].children);
                    for (s = 0; s < c; s++)
                        l[s].sorted = !0
                }
                ,
                t.prototype.sortTransformConstraint = function(e) {
                    this.sortBone(e.target);
                    var t = e.bones
                      , i = t.length;
                    if (e.data.local)
                        for (var n = 0; n < i; n++) {
                            var r = t[n];
                            this.sortBone(r.parent),
                            this._updateCache.indexOf(r) > -1 || this.updateCacheReset.push(r)
                        }
                    else
                        for (n = 0; n < i; n++)
                            this.sortBone(t[n]);
                    this._updateCache.push(e);
                    for (var s = 0; s < i; s++)
                        this.sortReset(t[s].children);
                    for (s = 0; s < i; s++)
                        t[s].sorted = !0
                }
                ,
                t.prototype.sortPathConstraintAttachment = function(e, t, i) {
                    var n = e.attachments[t];
                    if (n)
                        for (var r in n)
                            this.sortPathConstraintAttachmentWith(n[r], i)
                }
                ,
                t.prototype.sortPathConstraintAttachmentWith = function(t, i) {
                    if (t instanceof e.PathAttachment) {
                        var n = t.bones;
                        if (null == n)
                            this.sortBone(i);
                        else
                            for (var r = this.bones, s = 0; s < n.length; )
                                for (var a = n[s++], o = s + a; s < o; s++) {
                                    var l = n[s];
                                    this.sortBone(r[l])
                                }
                    }
                }
                ,
                t.prototype.sortBone = function(e) {
                    if (!e.sorted) {
                        var t = e.parent;
                        null != t && this.sortBone(t),
                        e.sorted = !0,
                        this._updateCache.push(e)
                    }
                }
                ,
                t.prototype.sortReset = function(e) {
                    for (var t = 0, i = e.length; t < i; t++) {
                        var n = e[t];
                        n.sorted && this.sortReset(n.children),
                        n.sorted = !1
                    }
                }
                ,
                t.prototype.updateWorldTransform = function() {
                    for (var e = this.updateCacheReset, t = 0, i = e.length; t < i; t++) {
                        var n = e[t];
                        n.ax = n.x,
                        n.ay = n.y,
                        n.arotation = n.rotation,
                        n.ascaleX = n.scaleX,
                        n.ascaleY = n.scaleY,
                        n.ashearX = n.shearX,
                        n.ashearY = n.shearY,
                        n.appliedValid = !0
                    }
                    var r = this._updateCache;
                    for (t = 0,
                    i = r.length; t < i; t++)
                        r[t].update()
                }
                ,
                t.prototype.setToSetupPose = function() {
                    this.setBonesToSetupPose(),
                    this.setSlotsToSetupPose()
                }
                ,
                t.prototype.setBonesToSetupPose = function() {
                    for (var e = this.bones, t = 0, i = e.length; t < i; t++)
                        e[t].setToSetupPose();
                    var n = this.ikConstraints;
                    for (t = 0,
                    i = n.length; t < i; t++)
                        (o = n[t]).mix = o.data.mix,
                        o.bendDirection = o.data.bendDirection,
                        o.compress = o.data.compress,
                        o.stretch = o.data.stretch;
                    var r = this.transformConstraints;
                    for (t = 0,
                    i = r.length; t < i; t++) {
                        var s = (o = r[t]).data;
                        o.rotateMix = s.rotateMix,
                        o.translateMix = s.translateMix,
                        o.scaleMix = s.scaleMix,
                        o.shearMix = s.shearMix
                    }
                    var a = this.pathConstraints;
                    for (t = 0,
                    i = a.length; t < i; t++) {
                        var o;
                        s = (o = a[t]).data,
                        o.position = s.position,
                        o.spacing = s.spacing,
                        o.rotateMix = s.rotateMix,
                        o.translateMix = s.translateMix
                    }
                }
                ,
                t.prototype.setSlotsToSetupPose = function() {
                    var t = this.slots;
                    e.Utils.arrayCopy(t, 0, this.drawOrder, 0, t.length);
                    for (var i = 0, n = t.length; i < n; i++)
                        t[i].setToSetupPose()
                }
                ,
                t.prototype.getRootBone = function() {
                    return 0 == this.bones.length ? null : this.bones[0]
                }
                ,
                t.prototype.findBone = function(e) {
                    if (null == e)
                        throw new Error("boneName cannot be null.");
                    for (var t = this.bones, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.data.name == e)
                            return r
                    }
                    return null
                }
                ,
                t.prototype.findBoneIndex = function(e) {
                    if (null == e)
                        throw new Error("boneName cannot be null.");
                    for (var t = this.bones, i = 0, n = t.length; i < n; i++)
                        if (t[i].data.name == e)
                            return i;
                    return -1
                }
                ,
                t.prototype.findSlot = function(e) {
                    if (null == e)
                        throw new Error("slotName cannot be null.");
                    for (var t = this.slots, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.data.name == e)
                            return r
                    }
                    return null
                }
                ,
                t.prototype.findSlotIndex = function(e) {
                    if (null == e)
                        throw new Error("slotName cannot be null.");
                    for (var t = this.slots, i = 0, n = t.length; i < n; i++)
                        if (t[i].data.name == e)
                            return i;
                    return -1
                }
                ,
                t.prototype.setSkinByName = function(e) {
                    var t = this.data.findSkin(e);
                    if (null == t)
                        throw new Error("Skin not found: " + e);
                    this.setSkin(t)
                }
                ,
                t.prototype.setSkin = function(e) {
                    if (null != e)
                        if (null != this.skin)
                            e.attachAll(this, this.skin);
                        else
                            for (var t = this.slots, i = 0, n = t.length; i < n; i++) {
                                var r = t[i]
                                  , s = r.data.attachmentName;
                                if (null != s) {
                                    var a = e.getAttachment(i, s);
                                    null != a && r.setAttachment(a)
                                }
                            }
                    this.skin = e
                }
                ,
                t.prototype.getAttachmentByName = function(e, t) {
                    return this.getAttachment(this.data.findSlotIndex(e), t)
                }
                ,
                t.prototype.getAttachment = function(e, t) {
                    if (null == t)
                        throw new Error("attachmentName cannot be null.");
                    if (null != this.skin) {
                        var i = this.skin.getAttachment(e, t);
                        if (null != i)
                            return i
                    }
                    return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(e, t) : null
                }
                ,
                t.prototype.setAttachment = function(e, t) {
                    if (null == e)
                        throw new Error("slotName cannot be null.");
                    for (var i = this.slots, n = 0, r = i.length; n < r; n++) {
                        var s = i[n];
                        if (s.data.name == e) {
                            var a = null;
                            if (null != t && null == (a = this.getAttachment(n, t)))
                                throw new Error("Attachment not found: " + t + ", for slot: " + e);
                            return void s.setAttachment(a)
                        }
                    }
                    throw new Error("Slot not found: " + e)
                }
                ,
                t.prototype.findIkConstraint = function(e) {
                    if (null == e)
                        throw new Error("constraintName cannot be null.");
                    for (var t = this.ikConstraints, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.data.name == e)
                            return r
                    }
                    return null
                }
                ,
                t.prototype.findTransformConstraint = function(e) {
                    if (null == e)
                        throw new Error("constraintName cannot be null.");
                    for (var t = this.transformConstraints, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.data.name == e)
                            return r
                    }
                    return null
                }
                ,
                t.prototype.findPathConstraint = function(e) {
                    if (null == e)
                        throw new Error("constraintName cannot be null.");
                    for (var t = this.pathConstraints, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.data.name == e)
                            return r
                    }
                    return null
                }
                ,
                t.prototype.getBounds = function(t, i, n) {
                    if (void 0 === n && (n = new Array(2)),
                    null == t)
                        throw new Error("offset cannot be null.");
                    if (null == i)
                        throw new Error("size cannot be null.");
                    for (var r = this.drawOrder, s = Number.POSITIVE_INFINITY, a = Number.POSITIVE_INFINITY, o = Number.NEGATIVE_INFINITY, l = Number.NEGATIVE_INFINITY, c = 0, h = r.length; c < h; c++) {
                        var u = r[c]
                          , p = 0
                          , d = null
                          , f = u.getAttachment();
                        if (f instanceof e.RegionAttachment)
                            p = 8,
                            d = e.Utils.setArraySize(n, p, 0),
                            f.computeWorldVertices(u.bone, d, 0, 2);
                        else if (f instanceof e.MeshAttachment) {
                            var m = f;
                            p = m.worldVerticesLength,
                            d = e.Utils.setArraySize(n, p, 0),
                            m.computeWorldVertices(u, 0, p, d, 0, 2)
                        }
                        if (null != d)
                            for (var g = 0, v = d.length; g < v; g += 2) {
                                var y = d[g]
                                  , b = d[g + 1];
                                s = Math.min(s, y),
                                a = Math.min(a, b),
                                o = Math.max(o, y),
                                l = Math.max(l, b)
                            }
                    }
                    t.set(s, a),
                    i.set(o - s, l - a)
                }
                ,
                t.prototype.update = function(e) {
                    this.time += e
                }
                ,
                t
            }();
            e.Skeleton = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t() {
                    this.minX = 0,
                    this.minY = 0,
                    this.maxX = 0,
                    this.maxY = 0,
                    this.boundingBoxes = new Array,
                    this.polygons = new Array,
                    this.polygonPool = new e.Pool(function() {
                        return e.Utils.newFloatArray(16)
                    }
                    )
                }
                return t.prototype.update = function(t, i) {
                    if (null == t)
                        throw new Error("skeleton cannot be null.");
                    var n = this.boundingBoxes
                      , r = this.polygons
                      , s = this.polygonPool
                      , a = t.slots
                      , o = a.length;
                    n.length = 0,
                    s.freeAll(r),
                    r.length = 0;
                    for (var l = 0; l < o; l++) {
                        var c = a[l]
                          , h = c.getAttachment();
                        if (h instanceof e.BoundingBoxAttachment) {
                            var u = h;
                            n.push(u);
                            var p = s.obtain();
                            p.length != u.worldVerticesLength && (p = e.Utils.newFloatArray(u.worldVerticesLength)),
                            r.push(p),
                            u.computeWorldVertices(c, 0, u.worldVerticesLength, p, 0, 2)
                        }
                    }
                    i ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY,
                    this.minY = Number.POSITIVE_INFINITY,
                    this.maxX = Number.NEGATIVE_INFINITY,
                    this.maxY = Number.NEGATIVE_INFINITY)
                }
                ,
                t.prototype.aabbCompute = function() {
                    for (var e = Number.POSITIVE_INFINITY, t = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY, n = Number.NEGATIVE_INFINITY, r = this.polygons, s = 0, a = r.length; s < a; s++)
                        for (var o = r[s], l = o, c = 0, h = o.length; c < h; c += 2) {
                            var u = l[c]
                              , p = l[c + 1];
                            e = Math.min(e, u),
                            t = Math.min(t, p),
                            i = Math.max(i, u),
                            n = Math.max(n, p)
                        }
                    this.minX = e,
                    this.minY = t,
                    this.maxX = i,
                    this.maxY = n
                }
                ,
                t.prototype.aabbContainsPoint = function(e, t) {
                    return e >= this.minX && e <= this.maxX && t >= this.minY && t <= this.maxY
                }
                ,
                t.prototype.aabbIntersectsSegment = function(e, t, i, n) {
                    var r = this.minX
                      , s = this.minY
                      , a = this.maxX
                      , o = this.maxY;
                    if (e <= r && i <= r || t <= s && n <= s || e >= a && i >= a || t >= o && n >= o)
                        return !1;
                    var l = (n - t) / (i - e)
                      , c = l * (r - e) + t;
                    if (c > s && c < o)
                        return !0;
                    if ((c = l * (a - e) + t) > s && c < o)
                        return !0;
                    var h = (s - t) / l + e;
                    return h > r && h < a || (h = (o - t) / l + e) > r && h < a
                }
                ,
                t.prototype.aabbIntersectsSkeleton = function(e) {
                    return this.minX < e.maxX && this.maxX > e.minX && this.minY < e.maxY && this.maxY > e.minY
                }
                ,
                t.prototype.containsPoint = function(e, t) {
                    for (var i = this.polygons, n = 0, r = i.length; n < r; n++)
                        if (this.containsPointPolygon(i[n], e, t))
                            return this.boundingBoxes[n];
                    return null
                }
                ,
                t.prototype.containsPointPolygon = function(e, t, i) {
                    for (var n = e, r = e.length, s = r - 2, a = !1, o = 0; o < r; o += 2) {
                        var l = n[o + 1]
                          , c = n[s + 1];
                        if (l < i && c >= i || c < i && l >= i) {
                            var h = n[o];
                            h + (i - l) / (c - l) * (n[s] - h) < t && (a = !a)
                        }
                        s = o
                    }
                    return a
                }
                ,
                t.prototype.intersectsSegment = function(e, t, i, n) {
                    for (var r = this.polygons, s = 0, a = r.length; s < a; s++)
                        if (this.intersectsSegmentPolygon(r[s], e, t, i, n))
                            return this.boundingBoxes[s];
                    return null
                }
                ,
                t.prototype.intersectsSegmentPolygon = function(e, t, i, n, r) {
                    for (var s = e, a = e.length, o = t - n, l = i - r, c = t * r - i * n, h = s[a - 2], u = s[a - 1], p = 0; p < a; p += 2) {
                        var d = s[p]
                          , f = s[p + 1]
                          , m = h * f - u * d
                          , g = h - d
                          , v = u - f
                          , y = o * v - l * g
                          , b = (c * g - o * m) / y;
                        if ((b >= h && b <= d || b >= d && b <= h) && (b >= t && b <= n || b >= n && b <= t)) {
                            var x = (c * v - l * m) / y;
                            if ((x >= u && x <= f || x >= f && x <= u) && (x >= i && x <= r || x >= r && x <= i))
                                return !0
                        }
                        h = d,
                        u = f
                    }
                    return !1
                }
                ,
                t.prototype.getPolygon = function(e) {
                    if (null == e)
                        throw new Error("boundingBox cannot be null.");
                    var t = this.boundingBoxes.indexOf(e);
                    return -1 == t ? null : this.polygons[t]
                }
                ,
                t.prototype.getWidth = function() {
                    return this.maxX - this.minX
                }
                ,
                t.prototype.getHeight = function() {
                    return this.maxY - this.minY
                }
                ,
                t
            }();
            e.SkeletonBounds = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t() {
                    this.triangulator = new e.Triangulator,
                    this.clippingPolygon = new Array,
                    this.clipOutput = new Array,
                    this.clippedVertices = new Array,
                    this.clippedTriangles = new Array,
                    this.scratch = new Array
                }
                return t.prototype.clipStart = function(i, n) {
                    if (null != this.clipAttachment)
                        return 0;
                    this.clipAttachment = n;
                    var r = n.worldVerticesLength
                      , s = e.Utils.setArraySize(this.clippingPolygon, r);
                    n.computeWorldVertices(i, 0, r, s, 0, 2);
                    var a = this.clippingPolygon;
                    t.makeClockwise(a);
                    for (var o = this.clippingPolygons = this.triangulator.decompose(a, this.triangulator.triangulate(a)), l = 0, c = o.length; l < c; l++) {
                        var h = o[l];
                        t.makeClockwise(h),
                        h.push(h[0]),
                        h.push(h[1])
                    }
                    return o.length
                }
                ,
                t.prototype.clipEndWithSlot = function(e) {
                    null != this.clipAttachment && this.clipAttachment.endSlot == e.data && this.clipEnd()
                }
                ,
                t.prototype.clipEnd = function() {
                    null != this.clipAttachment && (this.clipAttachment = null,
                    this.clippingPolygons = null,
                    this.clippedVertices.length = 0,
                    this.clippedTriangles.length = 0,
                    this.clippingPolygon.length = 0)
                }
                ,
                t.prototype.isClipping = function() {
                    return null != this.clipAttachment
                }
                ,
                t.prototype.clipTriangles = function(t, i, n, r, s, a, o, l) {
                    var c = this.clipOutput
                      , h = this.clippedVertices
                      , u = this.clippedTriangles
                      , p = this.clippingPolygons
                      , d = this.clippingPolygons.length
                      , f = l ? 12 : 8
                      , m = 0;
                    h.length = 0,
                    u.length = 0;
                    e: for (var g = 0; g < r; g += 3)
                        for (var v = n[g] << 1, y = t[v], b = t[v + 1], x = s[v], w = s[v + 1], _ = t[v = n[g + 1] << 1], T = t[v + 1], M = s[v], S = s[v + 1], A = t[v = n[g + 2] << 1], P = t[v + 1], C = s[v], L = s[v + 1], k = 0; k < d; k++) {
                            var E = h.length;
                            if (!this.clip(y, b, _, T, A, P, p[k], c)) {
                                (B = e.Utils.setArraySize(h, E + 3 * f))[E] = y,
                                B[E + 1] = b,
                                B[E + 2] = a.r,
                                B[E + 3] = a.g,
                                B[E + 4] = a.b,
                                B[E + 5] = a.a,
                                l ? (B[E + 6] = x,
                                B[E + 7] = w,
                                B[E + 8] = o.r,
                                B[E + 9] = o.g,
                                B[E + 10] = o.b,
                                B[E + 11] = o.a,
                                B[E + 12] = _,
                                B[E + 13] = T,
                                B[E + 14] = a.r,
                                B[E + 15] = a.g,
                                B[E + 16] = a.b,
                                B[E + 17] = a.a,
                                B[E + 18] = M,
                                B[E + 19] = S,
                                B[E + 20] = o.r,
                                B[E + 21] = o.g,
                                B[E + 22] = o.b,
                                B[E + 23] = o.a,
                                B[E + 24] = A,
                                B[E + 25] = P,
                                B[E + 26] = a.r,
                                B[E + 27] = a.g,
                                B[E + 28] = a.b,
                                B[E + 29] = a.a,
                                B[E + 30] = C,
                                B[E + 31] = L,
                                B[E + 32] = o.r,
                                B[E + 33] = o.g,
                                B[E + 34] = o.b,
                                B[E + 35] = o.a) : (B[E + 6] = x,
                                B[E + 7] = w,
                                B[E + 8] = _,
                                B[E + 9] = T,
                                B[E + 10] = a.r,
                                B[E + 11] = a.g,
                                B[E + 12] = a.b,
                                B[E + 13] = a.a,
                                B[E + 14] = M,
                                B[E + 15] = S,
                                B[E + 16] = A,
                                B[E + 17] = P,
                                B[E + 18] = a.r,
                                B[E + 19] = a.g,
                                B[E + 20] = a.b,
                                B[E + 21] = a.a,
                                B[E + 22] = C,
                                B[E + 23] = L),
                                E = u.length,
                                (Q = e.Utils.setArraySize(u, E + 3))[E] = m,
                                Q[E + 1] = m + 1,
                                Q[E + 2] = m + 2,
                                m += 3;
                                continue e
                            }
                            var I = c.length;
                            if (0 != I) {
                                for (var F = T - P, O = A - _, R = y - A, z = P - b, N = 1 / (F * R + O * (b - P)), D = I >> 1, U = this.clipOutput, B = e.Utils.setArraySize(h, E + D * f), j = 0; j < I; j += 2) {
                                    var V = U[j]
                                      , G = U[j + 1];
                                    B[E] = V,
                                    B[E + 1] = G,
                                    B[E + 2] = a.r,
                                    B[E + 3] = a.g,
                                    B[E + 4] = a.b,
                                    B[E + 5] = a.a;
                                    var X = V - A
                                      , Y = G - P
                                      , W = (F * X + O * Y) * N
                                      , q = (z * X + R * Y) * N
                                      , H = 1 - W - q;
                                    B[E + 6] = x * W + M * q + C * H,
                                    B[E + 7] = w * W + S * q + L * H,
                                    l && (B[E + 8] = o.r,
                                    B[E + 9] = o.g,
                                    B[E + 10] = o.b,
                                    B[E + 11] = o.a),
                                    E += f
                                }
                                E = u.length;
                                var Q = e.Utils.setArraySize(u, E + 3 * (D - 2));
                                for (D--,
                                j = 1; j < D; j++)
                                    Q[E] = m,
                                    Q[E + 1] = m + j,
                                    Q[E + 2] = m + j + 1,
                                    E += 3;
                                m += D + 1
                            }
                        }
                }
                ,
                t.prototype.clip = function(e, t, i, n, r, s, a, o) {
                    var l = o
                      , c = !1
                      , h = null;
                    a.length % 4 >= 2 ? (h = o,
                    o = this.scratch) : h = this.scratch,
                    h.length = 0,
                    h.push(e),
                    h.push(t),
                    h.push(i),
                    h.push(n),
                    h.push(r),
                    h.push(s),
                    h.push(e),
                    h.push(t),
                    o.length = 0;
                    for (var u = a, p = a.length - 4, d = 0; ; d += 2) {
                        for (var f = u[d], m = u[d + 1], g = u[d + 2], v = u[d + 3], y = f - g, b = m - v, x = h, w = h.length - 2, _ = o.length, T = 0; T < w; T += 2) {
                            var M = x[T]
                              , S = x[T + 1]
                              , A = x[T + 2]
                              , P = x[T + 3]
                              , C = y * (P - v) - b * (A - g) > 0;
                            if (y * (S - v) - b * (M - g) > 0) {
                                if (C) {
                                    o.push(A),
                                    o.push(P);
                                    continue
                                }
                                var L = (E = P - S) * (g - f) - (I = A - M) * (v - m);
                                if (Math.abs(L) > 1e-6) {
                                    var k = (I * (m - S) - E * (f - M)) / L;
                                    o.push(f + (g - f) * k),
                                    o.push(m + (v - m) * k)
                                } else
                                    o.push(f),
                                    o.push(m)
                            } else if (C) {
                                var E, I;
                                L = (E = P - S) * (g - f) - (I = A - M) * (v - m),
                                Math.abs(L) > 1e-6 ? (k = (I * (m - S) - E * (f - M)) / L,
                                o.push(f + (g - f) * k),
                                o.push(m + (v - m) * k)) : (o.push(f),
                                o.push(m)),
                                o.push(A),
                                o.push(P)
                            }
                            c = !0
                        }
                        if (_ == o.length)
                            return l.length = 0,
                            !0;
                        if (o.push(o[0]),
                        o.push(o[1]),
                        d == p)
                            break;
                        var F = o;
                        (o = h).length = 0,
                        h = F
                    }
                    if (l != o) {
                        l.length = 0,
                        d = 0;
                        for (var O = o.length - 2; d < O; d++)
                            l[d] = o[d]
                    } else
                        l.length = l.length - 2;
                    return c
                }
                ,
                t.makeClockwise = function(e) {
                    for (var t = e, i = e.length, n = t[i - 2] * t[1] - t[0] * t[i - 1], r = 0, s = 0, a = 0, o = 0, l = i - 3; o < l; o += 2)
                        r = t[o],
                        s = t[o + 1],
                        a = t[o + 2],
                        n += r * t[o + 3] - a * s;
                    if (!(n < 0)) {
                        o = 0;
                        var c = i - 2;
                        for (l = i >> 1; o < l; o += 2) {
                            var h = t[o]
                              , u = t[o + 1]
                              , p = c - o;
                            t[o] = t[p],
                            t[o + 1] = t[p + 1],
                            t[p] = h,
                            t[p + 1] = u
                        }
                    }
                }
                ,
                t
            }();
            e.SkeletonClipping = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function e() {
                    this.bones = new Array,
                    this.slots = new Array,
                    this.skins = new Array,
                    this.events = new Array,
                    this.animations = new Array,
                    this.ikConstraints = new Array,
                    this.transformConstraints = new Array,
                    this.pathConstraints = new Array,
                    this.fps = 0
                }
                return e.prototype.findBone = function(e) {
                    if (null == e)
                        throw new Error("boneName cannot be null.");
                    for (var t = this.bones, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.name == e)
                            return r
                    }
                    return null
                }
                ,
                e.prototype.findBoneIndex = function(e) {
                    if (null == e)
                        throw new Error("boneName cannot be null.");
                    for (var t = this.bones, i = 0, n = t.length; i < n; i++)
                        if (t[i].name == e)
                            return i;
                    return -1
                }
                ,
                e.prototype.findSlot = function(e) {
                    if (null == e)
                        throw new Error("slotName cannot be null.");
                    for (var t = this.slots, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.name == e)
                            return r
                    }
                    return null
                }
                ,
                e.prototype.findSlotIndex = function(e) {
                    if (null == e)
                        throw new Error("slotName cannot be null.");
                    for (var t = this.slots, i = 0, n = t.length; i < n; i++)
                        if (t[i].name == e)
                            return i;
                    return -1
                }
                ,
                e.prototype.findSkin = function(e) {
                    if (null == e)
                        throw new Error("skinName cannot be null.");
                    for (var t = this.skins, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.name == e)
                            return r
                    }
                    return null
                }
                ,
                e.prototype.findEvent = function(e) {
                    if (null == e)
                        throw new Error("eventDataName cannot be null.");
                    for (var t = this.events, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.name == e)
                            return r
                    }
                    return null
                }
                ,
                e.prototype.findAnimation = function(e) {
                    if (null == e)
                        throw new Error("animationName cannot be null.");
                    for (var t = this.animations, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.name == e)
                            return r
                    }
                    return null
                }
                ,
                e.prototype.findIkConstraint = function(e) {
                    if (null == e)
                        throw new Error("constraintName cannot be null.");
                    for (var t = this.ikConstraints, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.name == e)
                            return r
                    }
                    return null
                }
                ,
                e.prototype.findTransformConstraint = function(e) {
                    if (null == e)
                        throw new Error("constraintName cannot be null.");
                    for (var t = this.transformConstraints, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.name == e)
                            return r
                    }
                    return null
                }
                ,
                e.prototype.findPathConstraint = function(e) {
                    if (null == e)
                        throw new Error("constraintName cannot be null.");
                    for (var t = this.pathConstraints, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        if (r.name == e)
                            return r
                    }
                    return null
                }
                ,
                e.prototype.findPathConstraintIndex = function(e) {
                    if (null == e)
                        throw new Error("pathConstraintName cannot be null.");
                    for (var t = this.pathConstraints, i = 0, n = t.length; i < n; i++)
                        if (t[i].name == e)
                            return i;
                    return -1
                }
                ,
                e
            }();
            e.SkeletonData = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(e) {
                    this.scale = 1,
                    this.linkedMeshes = new Array,
                    this.attachmentLoader = e
                }
                return t.prototype.readSkeletonData = function(i) {
                    var n = this.scale
                      , r = new e.SkeletonData
                      , s = "string" == typeof i ? JSON.parse(i) : i
                      , a = s.skeleton;
                    if (null != a && (r.hash = a.hash,
                    r.version = a.spine,
                    r.width = a.width,
                    r.height = a.height,
                    r.fps = a.fps,
                    r.imagesPath = a.images),
                    s.bones)
                        for (var o = 0; o < s.bones.length; o++) {
                            var l = s.bones[o]
                              , c = null
                              , h = this.getValue(l, "parent", null);
                            if (null != h && null == (c = r.findBone(h)))
                                throw new Error("Parent bone not found: " + h);
                            (f = new e.BoneData(r.bones.length,l.name,c)).length = this.getValue(l, "length", 0) * n,
                            f.x = this.getValue(l, "x", 0) * n,
                            f.y = this.getValue(l, "y", 0) * n,
                            f.rotation = this.getValue(l, "rotation", 0),
                            f.scaleX = this.getValue(l, "scaleX", 1),
                            f.scaleY = this.getValue(l, "scaleY", 1),
                            f.shearX = this.getValue(l, "shearX", 0),
                            f.shearY = this.getValue(l, "shearY", 0),
                            f.transformMode = t.transformModeFromString(this.getValue(l, "transform", "normal")),
                            r.bones.push(f)
                        }
                    if (s.slots)
                        for (o = 0; o < s.slots.length; o++) {
                            var u = (S = s.slots[o]).name
                              , p = S.bone
                              , d = r.findBone(p);
                            if (null == d)
                                throw new Error("Slot bone not found: " + p);
                            var f = new e.SlotData(r.slots.length,u,d)
                              , m = this.getValue(S, "color", null);
                            null != m && f.color.setFromString(m);
                            var g = this.getValue(S, "dark", null);
                            null != g && (f.darkColor = new e.Color(1,1,1,1),
                            f.darkColor.setFromString(g)),
                            f.attachmentName = this.getValue(S, "attachment", null),
                            f.blendMode = t.blendModeFromString(this.getValue(S, "blend", "normal")),
                            r.slots.push(f)
                        }
                    if (s.ik)
                        for (o = 0; o < s.ik.length; o++) {
                            var v = s.ik[o];
                            (f = new e.IkConstraintData(v.name)).order = this.getValue(v, "order", 0);
                            for (var y = 0; y < v.bones.length; y++) {
                                if (p = v.bones[y],
                                null == (x = r.findBone(p)))
                                    throw new Error("IK bone not found: " + p);
                                f.bones.push(x)
                            }
                            var b = v.target;
                            if (f.target = r.findBone(b),
                            null == f.target)
                                throw new Error("IK target bone not found: " + b);
                            f.mix = this.getValue(v, "mix", 1),
                            f.bendDirection = this.getValue(v, "bendPositive", !0) ? 1 : -1,
                            f.compress = this.getValue(v, "compress", !1),
                            f.stretch = this.getValue(v, "stretch", !1),
                            f.uniform = this.getValue(v, "uniform", !1),
                            r.ikConstraints.push(f)
                        }
                    if (s.transform)
                        for (o = 0; o < s.transform.length; o++) {
                            for (v = s.transform[o],
                            (f = new e.TransformConstraintData(v.name)).order = this.getValue(v, "order", 0),
                            y = 0; y < v.bones.length; y++) {
                                if (p = v.bones[y],
                                null == (x = r.findBone(p)))
                                    throw new Error("Transform constraint bone not found: " + p);
                                f.bones.push(x)
                            }
                            if (b = v.target,
                            f.target = r.findBone(b),
                            null == f.target)
                                throw new Error("Transform constraint target bone not found: " + b);
                            f.local = this.getValue(v, "local", !1),
                            f.relative = this.getValue(v, "relative", !1),
                            f.offsetRotation = this.getValue(v, "rotation", 0),
                            f.offsetX = this.getValue(v, "x", 0) * n,
                            f.offsetY = this.getValue(v, "y", 0) * n,
                            f.offsetScaleX = this.getValue(v, "scaleX", 0),
                            f.offsetScaleY = this.getValue(v, "scaleY", 0),
                            f.offsetShearY = this.getValue(v, "shearY", 0),
                            f.rotateMix = this.getValue(v, "rotateMix", 1),
                            f.translateMix = this.getValue(v, "translateMix", 1),
                            f.scaleMix = this.getValue(v, "scaleMix", 1),
                            f.shearMix = this.getValue(v, "shearMix", 1),
                            r.transformConstraints.push(f)
                        }
                    if (s.path)
                        for (o = 0; o < s.path.length; o++) {
                            for (v = s.path[o],
                            (f = new e.PathConstraintData(v.name)).order = this.getValue(v, "order", 0),
                            y = 0; y < v.bones.length; y++) {
                                var x;
                                if (p = v.bones[y],
                                null == (x = r.findBone(p)))
                                    throw new Error("Transform constraint bone not found: " + p);
                                f.bones.push(x)
                            }
                            if (b = v.target,
                            f.target = r.findSlot(b),
                            null == f.target)
                                throw new Error("Path target slot not found: " + b);
                            f.positionMode = t.positionModeFromString(this.getValue(v, "positionMode", "percent")),
                            f.spacingMode = t.spacingModeFromString(this.getValue(v, "spacingMode", "length")),
                            f.rotateMode = t.rotateModeFromString(this.getValue(v, "rotateMode", "tangent")),
                            f.offsetRotation = this.getValue(v, "rotation", 0),
                            f.position = this.getValue(v, "position", 0),
                            f.positionMode == e.PositionMode.Fixed && (f.position *= n),
                            f.spacing = this.getValue(v, "spacing", 0),
                            f.spacingMode != e.SpacingMode.Length && f.spacingMode != e.SpacingMode.Fixed || (f.spacing *= n),
                            f.rotateMix = this.getValue(v, "rotateMix", 1),
                            f.translateMix = this.getValue(v, "translateMix", 1),
                            r.pathConstraints.push(f)
                        }
                    if (s.skins)
                        for (var w in s.skins) {
                            var _ = s.skins[w]
                              , T = new e.Skin(w);
                            for (var u in _) {
                                var M = r.findSlotIndex(u);
                                if (-1 == M)
                                    throw new Error("Slot not found: " + u);
                                var S = _[u];
                                for (var A in S) {
                                    var P = this.readAttachment(S[A], T, M, A, r);
                                    null != P && T.addAttachment(M, A, P)
                                }
                            }
                            r.skins.push(T),
                            "default" == T.name && (r.defaultSkin = T)
                        }
                    o = 0;
                    for (var C = this.linkedMeshes.length; o < C; o++) {
                        var L = this.linkedMeshes[o];
                        if (null == (T = null == L.skin ? r.defaultSkin : r.findSkin(L.skin)))
                            throw new Error("Skin not found: " + L.skin);
                        var k = T.getAttachment(L.slotIndex, L.parent);
                        if (null == k)
                            throw new Error("Parent mesh not found: " + L.parent);
                        L.mesh.setParentMesh(k),
                        L.mesh.updateUVs()
                    }
                    if (this.linkedMeshes.length = 0,
                    s.events)
                        for (var E in s.events) {
                            var I = s.events[E];
                            (f = new e.EventData(E)).intValue = this.getValue(I, "int", 0),
                            f.floatValue = this.getValue(I, "float", 0),
                            f.stringValue = this.getValue(I, "string", ""),
                            f.audioPath = this.getValue(I, "audio", null),
                            null != f.audioPath && (f.volume = this.getValue(I, "volume", 1),
                            f.balance = this.getValue(I, "balance", 0)),
                            r.events.push(f)
                        }
                    if (s.animations)
                        for (var F in s.animations) {
                            var O = s.animations[F];
                            this.readAnimation(O, F, r)
                        }
                    return r
                }
                ,
                t.prototype.readAttachment = function(t, n, r, s, a) {
                    var o = this.scale;
                    switch (s = this.getValue(t, "name", s),
                    this.getValue(t, "type", "region")) {
                    case "region":
                        var l = this.getValue(t, "path", s)
                          , c = this.attachmentLoader.newRegionAttachment(n, s, l);
                        return null == c ? null : (c.path = l,
                        c.x = this.getValue(t, "x", 0) * o,
                        c.y = this.getValue(t, "y", 0) * o,
                        c.scaleX = this.getValue(t, "scaleX", 1),
                        c.scaleY = this.getValue(t, "scaleY", 1),
                        c.rotation = this.getValue(t, "rotation", 0),
                        c.width = t.width * o,
                        c.height = t.height * o,
                        null != (b = this.getValue(t, "color", null)) && c.color.setFromString(b),
                        c.updateOffset(),
                        c);
                    case "boundingbox":
                        var h = this.attachmentLoader.newBoundingBoxAttachment(n, s);
                        return null == h ? null : (this.readVertices(t, h, t.vertexCount << 1),
                        null != (b = this.getValue(t, "color", null)) && h.color.setFromString(b),
                        h);
                    case "mesh":
                    case "linkedmesh":
                        l = this.getValue(t, "path", s);
                        var u = this.attachmentLoader.newMeshAttachment(n, s, l);
                        if (null == u)
                            return null;
                        u.path = l,
                        null != (b = this.getValue(t, "color", null)) && u.color.setFromString(b);
                        var p = this.getValue(t, "parent", null);
                        if (null != p)
                            return u.inheritDeform = this.getValue(t, "deform", !0),
                            this.linkedMeshes.push(new i(u,this.getValue(t, "skin", null),r,p)),
                            u;
                        var d = t.uvs;
                        return this.readVertices(t, u, d.length),
                        u.triangles = t.triangles,
                        u.regionUVs = d,
                        u.updateUVs(),
                        u.hullLength = 2 * this.getValue(t, "hull", 0),
                        u;
                    case "path":
                        if (null == (l = this.attachmentLoader.newPathAttachment(n, s)))
                            return null;
                        l.closed = this.getValue(t, "closed", !1),
                        l.constantSpeed = this.getValue(t, "constantSpeed", !0);
                        var f = t.vertexCount;
                        this.readVertices(t, l, f << 1);
                        for (var m = e.Utils.newArray(f / 3, 0), g = 0; g < t.lengths.length; g++)
                            m[g] = t.lengths[g] * o;
                        return l.lengths = m,
                        null != (b = this.getValue(t, "color", null)) && l.color.setFromString(b),
                        l;
                    case "point":
                        var v = this.attachmentLoader.newPointAttachment(n, s);
                        return null == v ? null : (v.x = this.getValue(t, "x", 0) * o,
                        v.y = this.getValue(t, "y", 0) * o,
                        v.rotation = this.getValue(t, "rotation", 0),
                        null != (b = this.getValue(t, "color", null)) && v.color.setFromString(b),
                        v);
                    case "clipping":
                        var y = this.attachmentLoader.newClippingAttachment(n, s);
                        if (null == y)
                            return null;
                        var b, x = this.getValue(t, "end", null);
                        if (null != x) {
                            var w = a.findSlot(x);
                            if (null == w)
                                throw new Error("Clipping end slot not found: " + x);
                            y.endSlot = w
                        }
                        return f = t.vertexCount,
                        this.readVertices(t, y, f << 1),
                        null != (b = this.getValue(t, "color", null)) && y.color.setFromString(b),
                        y
                    }
                    return null
                }
                ,
                t.prototype.readVertices = function(t, i, n) {
                    var r = this.scale;
                    i.worldVerticesLength = n;
                    var s = t.vertices;
                    if (n != s.length) {
                        var a = new Array
                          , o = new Array;
                        for (u = 0,
                        p = s.length; u < p; ) {
                            var l = s[u++];
                            o.push(l);
                            for (var c = u + 4 * l; u < c; u += 4)
                                o.push(s[u]),
                                a.push(s[u + 1] * r),
                                a.push(s[u + 2] * r),
                                a.push(s[u + 3])
                        }
                        i.bones = o,
                        i.vertices = e.Utils.toFloatArray(a)
                    } else {
                        var h = e.Utils.toFloatArray(s);
                        if (1 != r)
                            for (var u = 0, p = s.length; u < p; u++)
                                h[u] *= r;
                        i.vertices = h
                    }
                }
                ,
                t.prototype.readAnimation = function(t, i, n) {
                    var r = this.scale
                      , s = new Array
                      , a = 0;
                    if (t.slots)
                        for (var o in t.slots) {
                            var l = t.slots[o];
                            if (-1 == (Q = n.findSlotIndex(o)))
                                throw new Error("Slot not found: " + o);
                            for (var c in l) {
                                var h = l[c];
                                if ("attachment" == c) {
                                    (x = new e.AttachmentTimeline(h.length)).slotIndex = Q;
                                    for (var u = 0, p = 0; p < h.length; p++) {
                                        var d = h[p];
                                        x.setFrame(u++, d.time, d.name)
                                    }
                                    s.push(x),
                                    a = Math.max(a, x.frames[x.getFrameCount() - 1])
                                } else if ("color" == c) {
                                    for ((x = new e.ColorTimeline(h.length)).slotIndex = Q,
                                    u = 0,
                                    p = 0; p < h.length; p++) {
                                        d = h[p];
                                        var f = new e.Color;
                                        f.setFromString(d.color),
                                        x.setFrame(u, d.time, f.r, f.g, f.b, f.a),
                                        this.readCurve(d, x, u),
                                        u++
                                    }
                                    s.push(x),
                                    a = Math.max(a, x.frames[(x.getFrameCount() - 1) * e.ColorTimeline.ENTRIES])
                                } else {
                                    if ("twoColor" != c)
                                        throw new Error("Invalid timeline type for a slot: " + c + " (" + o + ")");
                                    for ((x = new e.TwoColorTimeline(h.length)).slotIndex = Q,
                                    u = 0,
                                    p = 0; p < h.length; p++) {
                                        d = h[p];
                                        var m = new e.Color
                                          , g = new e.Color;
                                        m.setFromString(d.light),
                                        g.setFromString(d.dark),
                                        x.setFrame(u, d.time, m.r, m.g, m.b, m.a, g.r, g.g, g.b),
                                        this.readCurve(d, x, u),
                                        u++
                                    }
                                    s.push(x),
                                    a = Math.max(a, x.frames[(x.getFrameCount() - 1) * e.TwoColorTimeline.ENTRIES])
                                }
                            }
                        }
                    if (t.bones)
                        for (var v in t.bones) {
                            var y = t.bones[v]
                              , b = n.findBoneIndex(v);
                            if (-1 == b)
                                throw new Error("Bone not found: " + v);
                            for (var c in y)
                                if (h = y[c],
                                "rotate" === c) {
                                    for ((x = new e.RotateTimeline(h.length)).boneIndex = b,
                                    u = 0,
                                    p = 0; p < h.length; p++)
                                        d = h[p],
                                        x.setFrame(u, d.time, d.angle),
                                        this.readCurve(d, x, u),
                                        u++;
                                    s.push(x),
                                    a = Math.max(a, x.frames[(x.getFrameCount() - 1) * e.RotateTimeline.ENTRIES])
                                } else {
                                    if ("translate" !== c && "scale" !== c && "shear" !== c)
                                        throw new Error("Invalid timeline type for a bone: " + c + " (" + v + ")");
                                    var x = null
                                      , w = 1;
                                    for ("scale" === c ? x = new e.ScaleTimeline(h.length) : "shear" === c ? x = new e.ShearTimeline(h.length) : (x = new e.TranslateTimeline(h.length),
                                    w = r),
                                    x.boneIndex = b,
                                    u = 0,
                                    p = 0; p < h.length; p++) {
                                        d = h[p];
                                        var _ = this.getValue(d, "x", 0)
                                          , T = this.getValue(d, "y", 0);
                                        x.setFrame(u, d.time, _ * w, T * w),
                                        this.readCurve(d, x, u),
                                        u++
                                    }
                                    s.push(x),
                                    a = Math.max(a, x.frames[(x.getFrameCount() - 1) * e.TranslateTimeline.ENTRIES])
                                }
                        }
                    if (t.ik)
                        for (var M in t.ik) {
                            var S = t.ik[M]
                              , A = n.findIkConstraint(M);
                            for ((x = new e.IkConstraintTimeline(S.length)).ikConstraintIndex = n.ikConstraints.indexOf(A),
                            u = 0,
                            p = 0; p < S.length; p++)
                                d = S[p],
                                x.setFrame(u, d.time, this.getValue(d, "mix", 1), this.getValue(d, "bendPositive", !0) ? 1 : -1, this.getValue(d, "compress", !1), this.getValue(d, "stretch", !1)),
                                this.readCurve(d, x, u),
                                u++;
                            s.push(x),
                            a = Math.max(a, x.frames[(x.getFrameCount() - 1) * e.IkConstraintTimeline.ENTRIES])
                        }
                    if (t.transform)
                        for (var M in t.transform) {
                            for (S = t.transform[M],
                            A = n.findTransformConstraint(M),
                            (x = new e.TransformConstraintTimeline(S.length)).transformConstraintIndex = n.transformConstraints.indexOf(A),
                            u = 0,
                            p = 0; p < S.length; p++)
                                d = S[p],
                                x.setFrame(u, d.time, this.getValue(d, "rotateMix", 1), this.getValue(d, "translateMix", 1), this.getValue(d, "scaleMix", 1), this.getValue(d, "shearMix", 1)),
                                this.readCurve(d, x, u),
                                u++;
                            s.push(x),
                            a = Math.max(a, x.frames[(x.getFrameCount() - 1) * e.TransformConstraintTimeline.ENTRIES])
                        }
                    if (t.paths)
                        for (var M in t.paths) {
                            S = t.paths[M];
                            var P = n.findPathConstraintIndex(M);
                            if (-1 == P)
                                throw new Error("Path constraint not found: " + M);
                            var C = n.pathConstraints[P];
                            for (var c in S)
                                if (h = S[c],
                                "position" === c || "spacing" === c) {
                                    for (x = null,
                                    w = 1,
                                    "spacing" === c ? (x = new e.PathConstraintSpacingTimeline(h.length),
                                    C.spacingMode != e.SpacingMode.Length && C.spacingMode != e.SpacingMode.Fixed || (w = r)) : (x = new e.PathConstraintPositionTimeline(h.length),
                                    C.positionMode == e.PositionMode.Fixed && (w = r)),
                                    x.pathConstraintIndex = P,
                                    u = 0,
                                    p = 0; p < h.length; p++)
                                        d = h[p],
                                        x.setFrame(u, d.time, this.getValue(d, c, 0) * w),
                                        this.readCurve(d, x, u),
                                        u++;
                                    s.push(x),
                                    a = Math.max(a, x.frames[(x.getFrameCount() - 1) * e.PathConstraintPositionTimeline.ENTRIES])
                                } else if ("mix" === c) {
                                    for ((x = new e.PathConstraintMixTimeline(h.length)).pathConstraintIndex = P,
                                    u = 0,
                                    p = 0; p < h.length; p++)
                                        d = h[p],
                                        x.setFrame(u, d.time, this.getValue(d, "rotateMix", 1), this.getValue(d, "translateMix", 1)),
                                        this.readCurve(d, x, u),
                                        u++;
                                    s.push(x),
                                    a = Math.max(a, x.frames[(x.getFrameCount() - 1) * e.PathConstraintMixTimeline.ENTRIES])
                                }
                        }
                    if (t.deform)
                        for (var L in t.deform) {
                            var k = t.deform[L]
                              , E = n.findSkin(L);
                            if (null == E)
                                throw new Error("Skin not found: " + L);
                            for (var o in k) {
                                if (l = k[o],
                                -1 == (Q = n.findSlotIndex(o)))
                                    throw new Error("Slot not found: " + l.name);
                                for (var c in l) {
                                    h = l[c];
                                    var I = E.getAttachment(Q, c);
                                    if (null == I)
                                        throw new Error("Deform attachment not found: " + h.name);
                                    var F = null != I.bones
                                      , O = I.vertices
                                      , R = F ? O.length / 3 * 2 : O.length;
                                    (x = new e.DeformTimeline(h.length)).slotIndex = Q,
                                    x.attachment = I,
                                    u = 0;
                                    for (var z = 0; z < h.length; z++) {
                                        d = h[z];
                                        var N = void 0
                                          , D = this.getValue(d, "vertices", null);
                                        if (null == D)
                                            N = F ? e.Utils.newFloatArray(R) : O;
                                        else {
                                            N = e.Utils.newFloatArray(R);
                                            var U = this.getValue(d, "offset", 0);
                                            if (e.Utils.arrayCopy(D, 0, N, U, D.length),
                                            1 != r)
                                                for (var B = (p = U) + D.length; p < B; p++)
                                                    N[p] *= r;
                                            if (!F)
                                                for (p = 0; p < R; p++)
                                                    N[p] += O[p]
                                        }
                                        x.setFrame(u, d.time, N),
                                        this.readCurve(d, x, u),
                                        u++
                                    }
                                    s.push(x),
                                    a = Math.max(a, x.frames[x.getFrameCount() - 1])
                                }
                            }
                        }
                    var j = t.drawOrder;
                    if (null == j && (j = t.draworder),
                    null != j) {
                        x = new e.DrawOrderTimeline(j.length);
                        var V = n.slots.length;
                        for (u = 0,
                        z = 0; z < j.length; z++) {
                            var G = j[z]
                              , X = null
                              , Y = this.getValue(G, "offsets", null);
                            if (null != Y) {
                                X = e.Utils.newArray(V, -1);
                                var W = e.Utils.newArray(V - Y.length, 0)
                                  , q = 0
                                  , H = 0;
                                for (p = 0; p < Y.length; p++) {
                                    var Q, J = Y[p];
                                    if (-1 == (Q = n.findSlotIndex(J.slot)))
                                        throw new Error("Slot not found: " + J.slot);
                                    for (; q != Q; )
                                        W[H++] = q++;
                                    X[q + J.offset] = q++
                                }
                                for (; q < V; )
                                    W[H++] = q++;
                                for (p = V - 1; p >= 0; p--)
                                    -1 == X[p] && (X[p] = W[--H])
                            }
                            x.setFrame(u++, G.time, X)
                        }
                        s.push(x),
                        a = Math.max(a, x.frames[x.getFrameCount() - 1])
                    }
                    if (t.events) {
                        for (x = new e.EventTimeline(t.events.length),
                        u = 0,
                        p = 0; p < t.events.length; p++) {
                            var Z = t.events[p]
                              , $ = n.findEvent(Z.name);
                            if (null == $)
                                throw new Error("Event not found: " + Z.name);
                            var K = new e.Event(e.Utils.toSinglePrecision(Z.time),$);
                            K.intValue = this.getValue(Z, "int", $.intValue),
                            K.floatValue = this.getValue(Z, "float", $.floatValue),
                            K.stringValue = this.getValue(Z, "string", $.stringValue),
                            null != K.data.audioPath && (K.volume = this.getValue(Z, "volume", 1),
                            K.balance = this.getValue(Z, "balance", 0)),
                            x.setFrame(u++, K)
                        }
                        s.push(x),
                        a = Math.max(a, x.frames[x.getFrameCount() - 1])
                    }
                    if (isNaN(a))
                        throw new Error("Error while parsing animation, duration is NaN");
                    n.animations.push(new e.Animation(i,s,a))
                }
                ,
                t.prototype.readCurve = function(e, t, i) {
                    if (e.curve)
                        if ("stepped" === e.curve)
                            t.setStepped(i);
                        else if ("[object Array]" === Object.prototype.toString.call(e.curve)) {
                            var n = e.curve;
                            t.setCurve(i, n[0], n[1], n[2], n[3])
                        }
                }
                ,
                t.prototype.getValue = function(e, t, i) {
                    return void 0 !== e[t] ? e[t] : i
                }
                ,
                t.blendModeFromString = function(t) {
                    if ("normal" == (t = t.toLowerCase()))
                        return e.BlendMode.Normal;
                    if ("additive" == t)
                        return e.BlendMode.Additive;
                    if ("multiply" == t)
                        return e.BlendMode.Multiply;
                    if ("screen" == t)
                        return e.BlendMode.Screen;
                    throw new Error("Unknown blend mode: " + t)
                }
                ,
                t.positionModeFromString = function(t) {
                    if ("fixed" == (t = t.toLowerCase()))
                        return e.PositionMode.Fixed;
                    if ("percent" == t)
                        return e.PositionMode.Percent;
                    throw new Error("Unknown position mode: " + t)
                }
                ,
                t.spacingModeFromString = function(t) {
                    if ("length" == (t = t.toLowerCase()))
                        return e.SpacingMode.Length;
                    if ("fixed" == t)
                        return e.SpacingMode.Fixed;
                    if ("percent" == t)
                        return e.SpacingMode.Percent;
                    throw new Error("Unknown position mode: " + t)
                }
                ,
                t.rotateModeFromString = function(t) {
                    if ("tangent" == (t = t.toLowerCase()))
                        return e.RotateMode.Tangent;
                    if ("chain" == t)
                        return e.RotateMode.Chain;
                    if ("chainscale" == t)
                        return e.RotateMode.ChainScale;
                    throw new Error("Unknown rotate mode: " + t)
                }
                ,
                t.transformModeFromString = function(t) {
                    if ("normal" == (t = t.toLowerCase()))
                        return e.TransformMode.Normal;
                    if ("onlytranslation" == t)
                        return e.TransformMode.OnlyTranslation;
                    if ("norotationorreflection" == t)
                        return e.TransformMode.NoRotationOrReflection;
                    if ("noscale" == t)
                        return e.TransformMode.NoScale;
                    if ("noscaleorreflection" == t)
                        return e.TransformMode.NoScaleOrReflection;
                    throw new Error("Unknown transform mode: " + t)
                }
                ,
                t
            }();
            e.SkeletonJson = t;
            var i = function(e, t, i, n) {
                this.mesh = e,
                this.skin = t,
                this.slotIndex = i,
                this.parent = n
            }
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function e(e) {
                    if (this.attachments = new Array,
                    null == e)
                        throw new Error("name cannot be null.");
                    this.name = e
                }
                return e.prototype.addAttachment = function(e, t, i) {
                    if (null == i)
                        throw new Error("attachment cannot be null.");
                    var n = this.attachments;
                    e >= n.length && (n.length = e + 1),
                    n[e] || (n[e] = {}),
                    n[e][t] = i
                }
                ,
                e.prototype.getAttachment = function(e, t) {
                    var i = this.attachments[e];
                    return i ? i[t] : null
                }
                ,
                e.prototype.attachAll = function(e, t) {
                    for (var i = 0, n = 0; n < e.slots.length; n++) {
                        var r = e.slots[n]
                          , s = r.getAttachment();
                        if (s && i < t.attachments.length) {
                            var a = t.attachments[i];
                            for (var o in a)
                                if (s == a[o]) {
                                    var l = this.getAttachment(i, o);
                                    null != l && r.setAttachment(l);
                                    break
                                }
                        }
                        i++
                    }
                }
                ,
                e
            }();
            e.Skin = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(t, i) {
                    if (this.attachmentVertices = new Array,
                    null == t)
                        throw new Error("data cannot be null.");
                    if (null == i)
                        throw new Error("bone cannot be null.");
                    this.data = t,
                    this.bone = i,
                    this.color = new e.Color,
                    this.darkColor = null == t.darkColor ? null : new e.Color,
                    this.setToSetupPose()
                }
                return t.prototype.getAttachment = function() {
                    return this.attachment
                }
                ,
                t.prototype.setAttachment = function(e) {
                    this.attachment != e && (this.attachment = e,
                    this.attachmentTime = this.bone.skeleton.time,
                    this.attachmentVertices.length = 0)
                }
                ,
                t.prototype.setAttachmentTime = function(e) {
                    this.attachmentTime = this.bone.skeleton.time - e
                }
                ,
                t.prototype.getAttachmentTime = function() {
                    return this.bone.skeleton.time - this.attachmentTime
                }
                ,
                t.prototype.setToSetupPose = function() {
                    this.color.setFromColor(this.data.color),
                    null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor),
                    null == this.data.attachmentName ? this.attachment = null : (this.attachment = null,
                    this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)))
                }
                ,
                t
            }();
            e.Slot = t
        }(n || (n = {})),
        function(e) {
            var t = function(t, i, n) {
                if (this.color = new e.Color(1,1,1,1),
                t < 0)
                    throw new Error("index must be >= 0.");
                if (null == i)
                    throw new Error("name cannot be null.");
                if (null == n)
                    throw new Error("boneData cannot be null.");
                this.index = t,
                this.name = i,
                this.boneData = n
            };
            e.SlotData = t
        }(n || (n = {})),
        function(e) {
            var t, i, n = function() {
                function e(e) {
                    this._image = e
                }
                return e.prototype.getImage = function() {
                    return this._image
                }
                ,
                e.filterFromString = function(e) {
                    switch (e.toLowerCase()) {
                    case "nearest":
                        return t.Nearest;
                    case "linear":
                        return t.Linear;
                    case "mipmap":
                        return t.MipMap;
                    case "mipmapnearestnearest":
                        return t.MipMapNearestNearest;
                    case "mipmaplinearnearest":
                        return t.MipMapLinearNearest;
                    case "mipmapnearestlinear":
                        return t.MipMapNearestLinear;
                    case "mipmaplinearlinear":
                        return t.MipMapLinearLinear;
                    default:
                        throw new Error("Unknown texture filter " + e)
                    }
                }
                ,
                e.wrapFromString = function(e) {
                    switch (e.toLowerCase()) {
                    case "mirroredtepeat":
                        return i.MirroredRepeat;
                    case "clamptoedge":
                        return i.ClampToEdge;
                    case "repeat":
                        return i.Repeat;
                    default:
                        throw new Error("Unknown texture wrap " + e)
                    }
                }
                ,
                e
            }();
            e.Texture = n,
            function(e) {
                e[e.Nearest = 9728] = "Nearest",
                e[e.Linear = 9729] = "Linear",
                e[e.MipMap = 9987] = "MipMap",
                e[e.MipMapNearestNearest = 9984] = "MipMapNearestNearest",
                e[e.MipMapLinearNearest = 9985] = "MipMapLinearNearest",
                e[e.MipMapNearestLinear = 9986] = "MipMapNearestLinear",
                e[e.MipMapLinearLinear = 9987] = "MipMapLinearLinear"
            }(t = e.TextureFilter || (e.TextureFilter = {})),
            function(e) {
                e[e.MirroredRepeat = 33648] = "MirroredRepeat",
                e[e.ClampToEdge = 33071] = "ClampToEdge",
                e[e.Repeat = 10497] = "Repeat"
            }(i = e.TextureWrap || (e.TextureWrap = {}));
            var s = function() {
                this.u = 0,
                this.v = 0,
                this.u2 = 0,
                this.v2 = 0,
                this.width = 0,
                this.height = 0,
                this.rotate = !1,
                this.offsetX = 0,
                this.offsetY = 0,
                this.originalWidth = 0,
                this.originalHeight = 0
            };
            e.TextureRegion = s;
            var a = function(e) {
                function t() {
                    return null !== e && e.apply(this, arguments) || this
                }
                return r(t, e),
                t.prototype.setFilters = function(e, t) {}
                ,
                t.prototype.setWraps = function(e, t) {}
                ,
                t.prototype.dispose = function() {}
                ,
                t
            }(n);
            e.FakeTexture = a
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(e, t) {
                    this.pages = new Array,
                    this.regions = new Array,
                    this.load(e, t)
                }
                return t.prototype.load = function(t, r) {
                    if (null == r)
                        throw new Error("textureLoader cannot be null.");
                    for (var a = new i(t), o = new Array(4), l = null; ; ) {
                        var c = a.readLine();
                        if (null == c)
                            break;
                        if (0 == (c = c.trim()).length)
                            l = null;
                        else if (l) {
                            var h = new s;
                            h.name = c,
                            h.page = l,
                            h.rotate = "true" == a.readValue(),
                            a.readTuple(o);
                            var u = parseInt(o[0])
                              , p = parseInt(o[1]);
                            a.readTuple(o);
                            var d = parseInt(o[0])
                              , f = parseInt(o[1]);
                            h.u = u / l.width,
                            h.v = p / l.height,
                            h.rotate ? (h.u2 = (u + f) / l.width,
                            h.v2 = (p + d) / l.height) : (h.u2 = (u + d) / l.width,
                            h.v2 = (p + f) / l.height),
                            h.x = u,
                            h.y = p,
                            h.width = Math.abs(d),
                            h.height = Math.abs(f),
                            4 == a.readTuple(o) && 4 == a.readTuple(o) && a.readTuple(o),
                            h.originalWidth = parseInt(o[0]),
                            h.originalHeight = parseInt(o[1]),
                            a.readTuple(o),
                            h.offsetX = parseInt(o[0]),
                            h.offsetY = parseInt(o[1]),
                            h.index = parseInt(a.readValue()),
                            h.texture = l.texture,
                            this.regions.push(h)
                        } else {
                            (l = new n).name = c,
                            2 == a.readTuple(o) && (l.width = parseInt(o[0]),
                            l.height = parseInt(o[1]),
                            a.readTuple(o)),
                            a.readTuple(o),
                            l.minFilter = e.Texture.filterFromString(o[0]),
                            l.magFilter = e.Texture.filterFromString(o[1]);
                            var m = a.readValue();
                            l.uWrap = e.TextureWrap.ClampToEdge,
                            l.vWrap = e.TextureWrap.ClampToEdge,
                            "x" == m ? l.uWrap = e.TextureWrap.Repeat : "y" == m ? l.vWrap = e.TextureWrap.Repeat : "xy" == m && (l.uWrap = l.vWrap = e.TextureWrap.Repeat),
                            l.texture = r(c),
                            l.texture.setFilters(l.minFilter, l.magFilter),
                            l.texture.setWraps(l.uWrap, l.vWrap),
                            l.width = l.texture.getImage().width,
                            l.height = l.texture.getImage().height,
                            this.pages.push(l)
                        }
                    }
                }
                ,
                t.prototype.findRegion = function(e) {
                    for (var t = 0; t < this.regions.length; t++)
                        if (this.regions[t].name == e)
                            return this.regions[t];
                    return null
                }
                ,
                t.prototype.dispose = function() {
                    for (var e = 0; e < this.pages.length; e++)
                        this.pages[e].texture.dispose()
                }
                ,
                t
            }();
            e.TextureAtlas = t;
            var i = function() {
                function e(e) {
                    this.index = 0,
                    this.lines = e.split(/\r\n|\r|\n/)
                }
                return e.prototype.readLine = function() {
                    return this.index >= this.lines.length ? null : this.lines[this.index++]
                }
                ,
                e.prototype.readValue = function() {
                    var e = this.readLine()
                      , t = e.indexOf(":");
                    if (-1 == t)
                        throw new Error("Invalid line: " + e);
                    return e.substring(t + 1).trim()
                }
                ,
                e.prototype.readTuple = function(e) {
                    var t = this.readLine()
                      , i = t.indexOf(":");
                    if (-1 == i)
                        throw new Error("Invalid line: " + t);
                    for (var n = 0, r = i + 1; n < 3; n++) {
                        var s = t.indexOf(",", r);
                        if (-1 == s)
                            break;
                        e[n] = t.substr(r, s - r).trim(),
                        r = s + 1
                    }
                    return e[n] = t.substring(r).trim(),
                    n + 1
                }
                ,
                e
            }()
              , n = function() {};
            e.TextureAtlasPage = n;
            var s = function(e) {
                function t() {
                    return null !== e && e.apply(this, arguments) || this
                }
                return r(t, e),
                t
            }(e.TextureRegion);
            e.TextureAtlasRegion = s
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(t, i) {
                    if (this.rotateMix = 0,
                    this.translateMix = 0,
                    this.scaleMix = 0,
                    this.shearMix = 0,
                    this.temp = new e.Vector2,
                    null == t)
                        throw new Error("data cannot be null.");
                    if (null == i)
                        throw new Error("skeleton cannot be null.");
                    this.data = t,
                    this.rotateMix = t.rotateMix,
                    this.translateMix = t.translateMix,
                    this.scaleMix = t.scaleMix,
                    this.shearMix = t.shearMix,
                    this.bones = new Array;
                    for (var n = 0; n < t.bones.length; n++)
                        this.bones.push(i.findBone(t.bones[n].name));
                    this.target = i.findBone(t.target.name)
                }
                return t.prototype.apply = function() {
                    this.update()
                }
                ,
                t.prototype.update = function() {
                    this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld()
                }
                ,
                t.prototype.applyAbsoluteWorld = function() {
                    for (var t = this.rotateMix, i = this.translateMix, n = this.scaleMix, r = this.shearMix, s = this.target, a = s.a, o = s.b, l = s.c, c = s.d, h = a * c - o * l > 0 ? e.MathUtils.degRad : -e.MathUtils.degRad, u = this.data.offsetRotation * h, p = this.data.offsetShearY * h, d = this.bones, f = 0, m = d.length; f < m; f++) {
                        var g = d[f]
                          , v = !1;
                        if (0 != t) {
                            var y = g.a
                              , b = g.b
                              , x = g.c
                              , w = g.d;
                            (P = Math.atan2(l, a) - Math.atan2(x, y) + u) > e.MathUtils.PI ? P -= e.MathUtils.PI2 : P < -e.MathUtils.PI && (P += e.MathUtils.PI2),
                            P *= t;
                            var _ = Math.cos(P)
                              , T = Math.sin(P);
                            g.a = _ * y - T * x,
                            g.b = _ * b - T * w,
                            g.c = T * y + _ * x,
                            g.d = T * b + _ * w,
                            v = !0
                        }
                        if (0 != i) {
                            var M = this.temp;
                            s.localToWorld(M.set(this.data.offsetX, this.data.offsetY)),
                            g.worldX += (M.x - g.worldX) * i,
                            g.worldY += (M.y - g.worldY) * i,
                            v = !0
                        }
                        if (n > 0) {
                            var S = Math.sqrt(g.a * g.a + g.c * g.c)
                              , A = Math.sqrt(a * a + l * l);
                            S > 1e-5 && (S = (S + (A - S + this.data.offsetScaleX) * n) / S),
                            g.a *= S,
                            g.c *= S,
                            S = Math.sqrt(g.b * g.b + g.d * g.d),
                            A = Math.sqrt(o * o + c * c),
                            S > 1e-5 && (S = (S + (A - S + this.data.offsetScaleY) * n) / S),
                            g.b *= S,
                            g.d *= S,
                            v = !0
                        }
                        if (r > 0) {
                            b = g.b,
                            w = g.d;
                            var P, C = Math.atan2(w, b);
                            (P = Math.atan2(c, o) - Math.atan2(l, a) - (C - Math.atan2(g.c, g.a))) > e.MathUtils.PI ? P -= e.MathUtils.PI2 : P < -e.MathUtils.PI && (P += e.MathUtils.PI2),
                            P = C + (P + p) * r,
                            S = Math.sqrt(b * b + w * w),
                            g.b = Math.cos(P) * S,
                            g.d = Math.sin(P) * S,
                            v = !0
                        }
                        v && (g.appliedValid = !1)
                    }
                }
                ,
                t.prototype.applyRelativeWorld = function() {
                    for (var t = this.rotateMix, i = this.translateMix, n = this.scaleMix, r = this.shearMix, s = this.target, a = s.a, o = s.b, l = s.c, c = s.d, h = a * c - o * l > 0 ? e.MathUtils.degRad : -e.MathUtils.degRad, u = this.data.offsetRotation * h, p = this.data.offsetShearY * h, d = this.bones, f = 0, m = d.length; f < m; f++) {
                        var g, v = d[f], y = !1;
                        if (0 != t) {
                            var b = v.a
                              , x = v.b
                              , w = v.c
                              , _ = v.d;
                            (g = Math.atan2(l, a) + u) > e.MathUtils.PI ? g -= e.MathUtils.PI2 : g < -e.MathUtils.PI && (g += e.MathUtils.PI2),
                            g *= t;
                            var T = Math.cos(g)
                              , M = Math.sin(g);
                            v.a = T * b - M * w,
                            v.b = T * x - M * _,
                            v.c = M * b + T * w,
                            v.d = M * x + T * _,
                            y = !0
                        }
                        if (0 != i) {
                            var S = this.temp;
                            s.localToWorld(S.set(this.data.offsetX, this.data.offsetY)),
                            v.worldX += S.x * i,
                            v.worldY += S.y * i,
                            y = !0
                        }
                        if (n > 0) {
                            var A = (Math.sqrt(a * a + l * l) - 1 + this.data.offsetScaleX) * n + 1;
                            v.a *= A,
                            v.c *= A,
                            A = (Math.sqrt(o * o + c * c) - 1 + this.data.offsetScaleY) * n + 1,
                            v.b *= A,
                            v.d *= A,
                            y = !0
                        }
                        if (r > 0)
                            (g = Math.atan2(c, o) - Math.atan2(l, a)) > e.MathUtils.PI ? g -= e.MathUtils.PI2 : g < -e.MathUtils.PI && (g += e.MathUtils.PI2),
                            x = v.b,
                            _ = v.d,
                            g = Math.atan2(_, x) + (g - e.MathUtils.PI / 2 + p) * r,
                            A = Math.sqrt(x * x + _ * _),
                            v.b = Math.cos(g) * A,
                            v.d = Math.sin(g) * A,
                            y = !0;
                        y && (v.appliedValid = !1)
                    }
                }
                ,
                t.prototype.applyAbsoluteLocal = function() {
                    var e = this.rotateMix
                      , t = this.translateMix
                      , i = this.scaleMix
                      , n = this.shearMix
                      , r = this.target;
                    r.appliedValid || r.updateAppliedTransform();
                    for (var s = this.bones, a = 0, o = s.length; a < o; a++) {
                        var l = s[a];
                        l.appliedValid || l.updateAppliedTransform();
                        var c = l.arotation;
                        if (0 != e) {
                            var h = r.arotation - c + this.data.offsetRotation;
                            c += (h -= 360 * (16384 - (16384.499999999996 - h / 360 | 0))) * e
                        }
                        var u = l.ax
                          , p = l.ay;
                        0 != t && (u += (r.ax - u + this.data.offsetX) * t,
                        p += (r.ay - p + this.data.offsetY) * t);
                        var d = l.ascaleX
                          , f = l.ascaleY;
                        0 != i && (d > 1e-5 && (d = (d + (r.ascaleX - d + this.data.offsetScaleX) * i) / d),
                        f > 1e-5 && (f = (f + (r.ascaleY - f + this.data.offsetScaleY) * i) / f));
                        var m = l.ashearY;
                        0 != n && (h = r.ashearY - m + this.data.offsetShearY,
                        h -= 360 * (16384 - (16384.499999999996 - h / 360 | 0)),
                        l.shearY += h * n),
                        l.updateWorldTransformWith(u, p, c, d, f, l.ashearX, m)
                    }
                }
                ,
                t.prototype.applyRelativeLocal = function() {
                    var e = this.rotateMix
                      , t = this.translateMix
                      , i = this.scaleMix
                      , n = this.shearMix
                      , r = this.target;
                    r.appliedValid || r.updateAppliedTransform();
                    for (var s = this.bones, a = 0, o = s.length; a < o; a++) {
                        var l = s[a];
                        l.appliedValid || l.updateAppliedTransform();
                        var c = l.arotation;
                        0 != e && (c += (r.arotation + this.data.offsetRotation) * e);
                        var h = l.ax
                          , u = l.ay;
                        0 != t && (h += (r.ax + this.data.offsetX) * t,
                        u += (r.ay + this.data.offsetY) * t);
                        var p = l.ascaleX
                          , d = l.ascaleY;
                        0 != i && (p > 1e-5 && (p *= (r.ascaleX - 1 + this.data.offsetScaleX) * i + 1),
                        d > 1e-5 && (d *= (r.ascaleY - 1 + this.data.offsetScaleY) * i + 1));
                        var f = l.ashearY;
                        0 != n && (f += (r.ashearY + this.data.offsetShearY) * n),
                        l.updateWorldTransformWith(h, u, c, p, d, l.ashearX, f)
                    }
                }
                ,
                t.prototype.getOrder = function() {
                    return this.data.order
                }
                ,
                t
            }();
            e.TransformConstraint = t
        }(n || (n = {})),
        function(e) {
            var t = function(e) {
                if (this.order = 0,
                this.bones = new Array,
                this.rotateMix = 0,
                this.translateMix = 0,
                this.scaleMix = 0,
                this.shearMix = 0,
                this.offsetRotation = 0,
                this.offsetX = 0,
                this.offsetY = 0,
                this.offsetScaleX = 0,
                this.offsetScaleY = 0,
                this.offsetShearY = 0,
                this.relative = !1,
                this.local = !1,
                null == e)
                    throw new Error("name cannot be null.");
                this.name = e
            };
            e.TransformConstraintData = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t() {
                    this.convexPolygons = new Array,
                    this.convexPolygonsIndices = new Array,
                    this.indicesArray = new Array,
                    this.isConcaveArray = new Array,
                    this.triangles = new Array,
                    this.polygonPool = new e.Pool(function() {
                        return new Array
                    }
                    ),
                    this.polygonIndicesPool = new e.Pool(function() {
                        return new Array
                    }
                    )
                }
                return t.prototype.triangulate = function(e) {
                    var i = e
                      , n = e.length >> 1
                      , r = this.indicesArray;
                    r.length = 0;
                    for (var s = 0; s < n; s++)
                        r[s] = s;
                    var a = this.isConcaveArray;
                    a.length = 0,
                    s = 0;
                    for (var o = n; s < o; ++s)
                        a[s] = t.isConcave(s, n, i, r);
                    var l = this.triangles;
                    for (l.length = 0; n > 3; ) {
                        for (var c = n - 1, h = (s = 0,
                        1); ; ) {
                            e: if (!a[s]) {
                                for (var u = r[c] << 1, p = r[s] << 1, d = r[h] << 1, f = i[u], m = i[u + 1], g = i[p], v = i[p + 1], y = i[d], b = i[d + 1], x = (h + 1) % n; x != c; x = (x + 1) % n)
                                    if (a[x]) {
                                        var w = r[x] << 1
                                          , _ = i[w]
                                          , T = i[w + 1];
                                        if (t.positiveArea(y, b, f, m, _, T) && t.positiveArea(f, m, g, v, _, T) && t.positiveArea(g, v, y, b, _, T))
                                            break e
                                    }
                                break
                            }
                            if (0 == h) {
                                do {
                                    if (!a[s])
                                        break;
                                    s--
                                } while (s > 0);
                                break
                            }
                            c = s,
                            s = h,
                            h = (h + 1) % n
                        }
                        l.push(r[(n + s - 1) % n]),
                        l.push(r[s]),
                        l.push(r[(s + 1) % n]),
                        r.splice(s, 1),
                        a.splice(s, 1);
                        var M = (--n + s - 1) % n
                          , S = s == n ? 0 : s;
                        a[M] = t.isConcave(M, n, i, r),
                        a[S] = t.isConcave(S, n, i, r)
                    }
                    return 3 == n && (l.push(r[2]),
                    l.push(r[0]),
                    l.push(r[1])),
                    l
                }
                ,
                t.prototype.decompose = function(e, i) {
                    var n = e
                      , r = this.convexPolygons;
                    this.polygonPool.freeAll(r),
                    r.length = 0;
                    var s = this.convexPolygonsIndices;
                    this.polygonIndicesPool.freeAll(s),
                    s.length = 0;
                    var a = this.polygonIndicesPool.obtain();
                    a.length = 0;
                    var o = this.polygonPool.obtain();
                    o.length = 0;
                    for (var l = -1, c = 0, h = 0, u = i.length; h < u; h += 3) {
                        var p = i[h] << 1
                          , d = i[h + 1] << 1
                          , f = i[h + 2] << 1
                          , m = n[p]
                          , g = n[p + 1]
                          , v = n[d]
                          , y = n[d + 1]
                          , b = n[f]
                          , x = n[f + 1]
                          , w = !1;
                        if (l == p) {
                            var _ = o.length - 4
                              , T = t.winding(o[_], o[_ + 1], o[_ + 2], o[_ + 3], b, x)
                              , M = t.winding(b, x, o[0], o[1], o[2], o[3]);
                            T == c && M == c && (o.push(b),
                            o.push(x),
                            a.push(f),
                            w = !0)
                        }
                        w || (o.length > 0 ? (r.push(o),
                        s.push(a)) : (this.polygonPool.free(o),
                        this.polygonIndicesPool.free(a)),
                        (o = this.polygonPool.obtain()).length = 0,
                        o.push(m),
                        o.push(g),
                        o.push(v),
                        o.push(y),
                        o.push(b),
                        o.push(x),
                        (a = this.polygonIndicesPool.obtain()).length = 0,
                        a.push(p),
                        a.push(d),
                        a.push(f),
                        c = t.winding(m, g, v, y, b, x),
                        l = p)
                    }
                    for (o.length > 0 && (r.push(o),
                    s.push(a)),
                    h = 0,
                    u = r.length; h < u; h++)
                        if (0 != (a = s[h]).length)
                            for (var S = a[0], A = a[a.length - 1], P = (o = r[h])[_ = o.length - 4], C = o[_ + 1], L = o[_ + 2], k = o[_ + 3], E = o[0], I = o[1], F = o[2], O = o[3], R = t.winding(P, C, L, k, E, I), z = 0; z < u; z++)
                                if (z != h) {
                                    var N = s[z];
                                    if (3 == N.length) {
                                        var D = N[0]
                                          , U = N[1]
                                          , B = N[2]
                                          , j = r[z];
                                        b = j[j.length - 2],
                                        x = j[j.length - 1],
                                        D == S && U == A && (T = t.winding(P, C, L, k, b, x),
                                        M = t.winding(b, x, E, I, F, O),
                                        T == R && M == R && (j.length = 0,
                                        N.length = 0,
                                        o.push(b),
                                        o.push(x),
                                        a.push(B),
                                        P = L,
                                        C = k,
                                        L = b,
                                        k = x,
                                        z = 0))
                                    }
                                }
                    for (h = r.length - 1; h >= 0; h--)
                        0 == (o = r[h]).length && (r.splice(h, 1),
                        this.polygonPool.free(o),
                        a = s[h],
                        s.splice(h, 1),
                        this.polygonIndicesPool.free(a));
                    return r
                }
                ,
                t.isConcave = function(e, t, i, n) {
                    var r = n[(t + e - 1) % t] << 1
                      , s = n[e] << 1
                      , a = n[(e + 1) % t] << 1;
                    return !this.positiveArea(i[r], i[r + 1], i[s], i[s + 1], i[a], i[a + 1])
                }
                ,
                t.positiveArea = function(e, t, i, n, r, s) {
                    return e * (s - n) + i * (t - s) + r * (n - t) >= 0
                }
                ,
                t.winding = function(e, t, i, n, r, s) {
                    var a = i - e
                      , o = n - t;
                    return r * o - s * a + a * t - e * o >= 0 ? 1 : -1
                }
                ,
                t
            }();
            e.Triangulator = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function e() {
                    this.array = new Array
                }
                return e.prototype.add = function(e) {
                    var t = this.contains(e);
                    return this.array[0 | e] = 0 | e,
                    !t
                }
                ,
                e.prototype.contains = function(e) {
                    return null != this.array[0 | e]
                }
                ,
                e.prototype.remove = function(e) {
                    this.array[0 | e] = void 0
                }
                ,
                e.prototype.clear = function() {
                    this.array.length = 0
                }
                ,
                e
            }();
            e.IntSet = t;
            var i = function() {
                function e(e, t, i, n) {
                    void 0 === e && (e = 0),
                    void 0 === t && (t = 0),
                    void 0 === i && (i = 0),
                    void 0 === n && (n = 0),
                    this.r = e,
                    this.g = t,
                    this.b = i,
                    this.a = n
                }
                return e.prototype.set = function(e, t, i, n) {
                    return this.r = e,
                    this.g = t,
                    this.b = i,
                    this.a = n,
                    this.clamp(),
                    this
                }
                ,
                e.prototype.setFromColor = function(e) {
                    return this.r = e.r,
                    this.g = e.g,
                    this.b = e.b,
                    this.a = e.a,
                    this
                }
                ,
                e.prototype.setFromString = function(e) {
                    return e = "#" == e.charAt(0) ? e.substr(1) : e,
                    this.r = parseInt(e.substr(0, 2), 16) / 255,
                    this.g = parseInt(e.substr(2, 2), 16) / 255,
                    this.b = parseInt(e.substr(4, 2), 16) / 255,
                    this.a = (8 != e.length ? 255 : parseInt(e.substr(6, 2), 16)) / 255,
                    this
                }
                ,
                e.prototype.add = function(e, t, i, n) {
                    return this.r += e,
                    this.g += t,
                    this.b += i,
                    this.a += n,
                    this.clamp(),
                    this
                }
                ,
                e.prototype.clamp = function() {
                    return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1),
                    this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1),
                    this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1),
                    this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1),
                    this
                }
                ,
                e.WHITE = new e(1,1,1,1),
                e.RED = new e(1,0,0,1),
                e.GREEN = new e(0,1,0,1),
                e.BLUE = new e(0,0,1,1),
                e.MAGENTA = new e(1,0,1,1),
                e
            }();
            e.Color = i;
            var n = function() {
                function e() {}
                return e.clamp = function(e, t, i) {
                    return e < t ? t : e > i ? i : e
                }
                ,
                e.cosDeg = function(t) {
                    return Math.cos(t * e.degRad)
                }
                ,
                e.sinDeg = function(t) {
                    return Math.sin(t * e.degRad)
                }
                ,
                e.signum = function(e) {
                    return e > 0 ? 1 : e < 0 ? -1 : 0
                }
                ,
                e.toInt = function(e) {
                    return e > 0 ? Math.floor(e) : Math.ceil(e)
                }
                ,
                e.cbrt = function(e) {
                    var t = Math.pow(Math.abs(e), 1 / 3);
                    return e < 0 ? -t : t
                }
                ,
                e.randomTriangular = function(t, i) {
                    return e.randomTriangularWith(t, i, .5 * (t + i))
                }
                ,
                e.randomTriangularWith = function(e, t, i) {
                    var n = Math.random()
                      , r = t - e;
                    return n <= (i - e) / r ? e + Math.sqrt(n * r * (i - e)) : t - Math.sqrt((1 - n) * r * (t - i))
                }
                ,
                e.PI = 3.1415927,
                e.PI2 = 2 * e.PI,
                e.radiansToDegrees = 180 / e.PI,
                e.radDeg = e.radiansToDegrees,
                e.degreesToRadians = e.PI / 180,
                e.degRad = e.degreesToRadians,
                e
            }();
            e.MathUtils = n;
            var s = function() {
                function e() {}
                return e.prototype.apply = function(e, t, i) {
                    return e + (t - e) * this.applyInternal(i)
                }
                ,
                e
            }();
            e.Interpolation = s;
            var a = function(e) {
                function t(t) {
                    var i = e.call(this) || this;
                    return i.power = 2,
                    i.power = t,
                    i
                }
                return r(t, e),
                t.prototype.applyInternal = function(e) {
                    return e <= .5 ? Math.pow(2 * e, this.power) / 2 : Math.pow(2 * (e - 1), this.power) / (this.power % 2 == 0 ? -2 : 2) + 1
                }
                ,
                t
            }(s);
            e.Pow = a;
            var o = function(e) {
                function t(t) {
                    return e.call(this, t) || this
                }
                return r(t, e),
                t.prototype.applyInternal = function(e) {
                    return Math.pow(e - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1
                }
                ,
                t
            }(a);
            e.PowOut = o;
            var l = function() {
                function e() {}
                return e.arrayCopy = function(e, t, i, n, r) {
                    for (var s = t, a = n; s < t + r; s++,
                    a++)
                        i[a] = e[s]
                }
                ,
                e.setArraySize = function(e, t, i) {
                    void 0 === i && (i = 0);
                    var n = e.length;
                    if (n == t)
                        return e;
                    if (e.length = t,
                    n < t)
                        for (var r = n; r < t; r++)
                            e[r] = i;
                    return e
                }
                ,
                e.ensureArrayCapacity = function(t, i, n) {
                    return void 0 === n && (n = 0),
                    t.length >= i ? t : e.setArraySize(t, i, n)
                }
                ,
                e.newArray = function(e, t) {
                    for (var i = new Array(e), n = 0; n < e; n++)
                        i[n] = t;
                    return i
                }
                ,
                e.newFloatArray = function(t) {
                    if (e.SUPPORTS_TYPED_ARRAYS)
                        return new Float32Array(t);
                    for (var i = new Array(t), n = 0; n < i.length; n++)
                        i[n] = 0;
                    return i
                }
                ,
                e.newShortArray = function(t) {
                    if (e.SUPPORTS_TYPED_ARRAYS)
                        return new Int16Array(t);
                    for (var i = new Array(t), n = 0; n < i.length; n++)
                        i[n] = 0;
                    return i
                }
                ,
                e.toFloatArray = function(t) {
                    return e.SUPPORTS_TYPED_ARRAYS ? new Float32Array(t) : t
                }
                ,
                e.toSinglePrecision = function(t) {
                    return e.SUPPORTS_TYPED_ARRAYS ? Math.fround(t) : t
                }
                ,
                e.webkit602BugfixHelper = function(e, t) {}
                ,
                e.SUPPORTS_TYPED_ARRAYS = "undefined" != typeof Float32Array,
                e
            }();
            e.Utils = l;
            var c = function() {
                function e() {}
                return e.logBones = function(e) {
                    for (var t = 0; t < e.bones.length; t++)
                        e.bones[t]
                }
                ,
                e
            }();
            e.DebugUtils = c;
            var h = function() {
                function e(e) {
                    this.items = new Array,
                    this.instantiator = e
                }
                return e.prototype.obtain = function() {
                    return this.items.length > 0 ? this.items.pop() : this.instantiator()
                }
                ,
                e.prototype.free = function(e) {
                    e.reset && e.reset(),
                    this.items.push(e)
                }
                ,
                e.prototype.freeAll = function(e) {
                    for (var t = 0; t < e.length; t++)
                        e[t].reset && e[t].reset(),
                        this.items[t] = e[t]
                }
                ,
                e.prototype.clear = function() {
                    this.items.length = 0
                }
                ,
                e
            }();
            e.Pool = h;
            var u = function() {
                function e(e, t) {
                    void 0 === e && (e = 0),
                    void 0 === t && (t = 0),
                    this.x = e,
                    this.y = t
                }
                return e.prototype.set = function(e, t) {
                    return this.x = e,
                    this.y = t,
                    this
                }
                ,
                e.prototype.length = function() {
                    var e = this.x
                      , t = this.y;
                    return Math.sqrt(e * e + t * t)
                }
                ,
                e.prototype.normalize = function() {
                    var e = this.length();
                    return 0 != e && (this.x /= e,
                    this.y /= e),
                    this
                }
                ,
                e
            }();
            e.Vector2 = u;
            var p = function() {
                function e() {
                    this.maxDelta = .064,
                    this.framesPerSecond = 0,
                    this.delta = 0,
                    this.totalTime = 0,
                    this.lastTime = Date.now() / 1e3,
                    this.frameCount = 0,
                    this.frameTime = 0
                }
                return e.prototype.update = function() {
                    var e = Date.now() / 1e3;
                    this.delta = e - this.lastTime,
                    this.frameTime += this.delta,
                    this.totalTime += this.delta,
                    this.delta > this.maxDelta && (this.delta = this.maxDelta),
                    this.lastTime = e,
                    this.frameCount++,
                    this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime,
                    this.frameTime = 0,
                    this.frameCount = 0)
                }
                ,
                e
            }();
            e.TimeKeeper = p;
            var d = function() {
                function e(e) {
                    void 0 === e && (e = 32),
                    this.addedValues = 0,
                    this.lastValue = 0,
                    this.mean = 0,
                    this.dirty = !0,
                    this.values = new Array(e)
                }
                return e.prototype.hasEnoughData = function() {
                    return this.addedValues >= this.values.length
                }
                ,
                e.prototype.addValue = function(e) {
                    this.addedValues < this.values.length && this.addedValues++,
                    this.values[this.lastValue++] = e,
                    this.lastValue > this.values.length - 1 && (this.lastValue = 0),
                    this.dirty = !0
                }
                ,
                e.prototype.getMean = function() {
                    if (this.hasEnoughData()) {
                        if (this.dirty) {
                            for (var e = 0, t = 0; t < this.values.length; t++)
                                e += this.values[t];
                            this.mean = e / this.values.length,
                            this.dirty = !1
                        }
                        return this.mean
                    }
                    return 0
                }
                ,
                e
            }();
            e.WindowedMean = d
        }(n || (n = {})),
        Math.fround || (Math.fround = (i = new Float32Array(1),
        function(e) {
            return i[0] = e,
            i[0]
        }
        )),
        function(e) {
            var t = function(e) {
                if (null == e)
                    throw new Error("name cannot be null.");
                this.name = e
            };
            e.Attachment = t;
            var i = function(e) {
                function t(i) {
                    var n = e.call(this, i) || this;
                    return n.id = (65535 & t.nextID++) << 11,
                    n.worldVerticesLength = 0,
                    n
                }
                return r(t, e),
                t.prototype.computeWorldVertices = function(e, t, i, n, r, s) {
                    i = r + (i >> 1) * s;
                    var a = e.bone.skeleton
                      , o = e.attachmentVertices
                      , l = this.vertices
                      , c = this.bones;
                    if (null != c) {
                        for (var h = 0, u = 0, p = 0; p < t; p += 2)
                            h += (g = c[h]) + 1,
                            u += g;
                        var d = a.bones;
                        if (0 == o.length)
                            for (C = r,
                            M = 3 * u; C < i; C += s) {
                                var f = 0
                                  , m = 0
                                  , g = c[h++];
                                for (g += h; h < g; h++,
                                M += 3) {
                                    x = d[c[h]],
                                    L = l[M],
                                    k = l[M + 1];
                                    var v = l[M + 2];
                                    f += (L * x.a + k * x.b + x.worldX) * v,
                                    m += (L * x.c + k * x.d + x.worldY) * v
                                }
                                n[C] = f,
                                n[C + 1] = m
                            }
                        else
                            for (var y = o, b = (C = r,
                            M = 3 * u,
                            u << 1); C < i; C += s) {
                                for (f = 0,
                                m = 0,
                                g = c[h++],
                                g += h; h < g; h++,
                                M += 3,
                                b += 2)
                                    x = d[c[h]],
                                    L = l[M] + y[b],
                                    k = l[M + 1] + y[b + 1],
                                    v = l[M + 2],
                                    f += (L * x.a + k * x.b + x.worldX) * v,
                                    m += (L * x.c + k * x.d + x.worldY) * v;
                                n[C] = f,
                                n[C + 1] = m
                            }
                    } else {
                        o.length > 0 && (l = o);
                        for (var x, w = (x = e.bone).worldX, _ = x.worldY, T = x.a, M = x.b, S = x.c, A = x.d, P = t, C = r; C < i; P += 2,
                        C += s) {
                            var L = l[P]
                              , k = l[P + 1];
                            n[C] = L * T + k * M + w,
                            n[C + 1] = L * S + k * A + _
                        }
                    }
                }
                ,
                t.prototype.applyDeform = function(e) {
                    return this == e
                }
                ,
                t.nextID = 0,
                t
            }(t);
            e.VertexAttachment = i
        }(n || (n = {})),
        function(e) {
            !function(e) {
                e[e.Region = 0] = "Region",
                e[e.BoundingBox = 1] = "BoundingBox",
                e[e.Mesh = 2] = "Mesh",
                e[e.LinkedMesh = 3] = "LinkedMesh",
                e[e.Path = 4] = "Path",
                e[e.Point = 5] = "Point"
            }(e.AttachmentType || (e.AttachmentType = {}))
        }(n || (n = {})),
        function(e) {
            var t = function(t) {
                function i(i) {
                    var n = t.call(this, i) || this;
                    return n.color = new e.Color(1,1,1,1),
                    n
                }
                return r(i, t),
                i
            }(e.VertexAttachment);
            e.BoundingBoxAttachment = t
        }(n || (n = {})),
        function(e) {
            var t = function(t) {
                function i(i) {
                    var n = t.call(this, i) || this;
                    return n.color = new e.Color(.2275,.2275,.8078,1),
                    n
                }
                return r(i, t),
                i
            }(e.VertexAttachment);
            e.ClippingAttachment = t
        }(n || (n = {})),
        function(e) {
            var t = function(t) {
                function i(i) {
                    var n = t.call(this, i) || this;
                    return n.color = new e.Color(1,1,1,1),
                    n.inheritDeform = !1,
                    n.tempColor = new e.Color(0,0,0,0),
                    n
                }
                return r(i, t),
                i.prototype.updateUVs = function() {
                    var t = this.regionUVs;
                    null != this.uvs && this.uvs.length == t.length || (this.uvs = e.Utils.newFloatArray(t.length));
                    var i = this.uvs
                      , n = 0
                      , r = 0
                      , s = 0
                      , a = 0;
                    if (this.region instanceof e.TextureAtlasRegion) {
                        var o = this.region
                          , l = o.texture.getImage().width
                          , c = o.texture.getImage().height;
                        if (o.rotate) {
                            n = o.u - (o.originalHeight - o.offsetY - o.height) / l,
                            r = o.v - (o.originalWidth - o.offsetX - o.width) / c,
                            s = o.originalHeight / l,
                            a = o.originalWidth / c;
                            for (var h = 0, u = i.length; h < u; h += 2)
                                i[h] = n + t[h + 1] * s,
                                i[h + 1] = r + a - t[h] * a;
                            return
                        }
                        n = o.u - o.offsetX / l,
                        r = o.v - (o.originalHeight - o.offsetY - o.height) / c,
                        s = o.originalWidth / l,
                        a = o.originalHeight / c
                    } else
                        null == this.region ? (n = r = 0,
                        s = a = 1) : (n = this.region.u,
                        r = this.region.v,
                        s = this.region.u2 - n,
                        a = this.region.v2 - r);
                    for (h = 0,
                    u = i.length; h < u; h += 2)
                        i[h] = n + t[h] * s,
                        i[h + 1] = r + t[h + 1] * a
                }
                ,
                i.prototype.applyDeform = function(e) {
                    return this == e || this.inheritDeform && this.parentMesh == e
                }
                ,
                i.prototype.getParentMesh = function() {
                    return this.parentMesh
                }
                ,
                i.prototype.setParentMesh = function(e) {
                    this.parentMesh = e,
                    null != e && (this.bones = e.bones,
                    this.vertices = e.vertices,
                    this.worldVerticesLength = e.worldVerticesLength,
                    this.regionUVs = e.regionUVs,
                    this.triangles = e.triangles,
                    this.hullLength = e.hullLength,
                    this.worldVerticesLength = e.worldVerticesLength)
                }
                ,
                i
            }(e.VertexAttachment);
            e.MeshAttachment = t
        }(n || (n = {})),
        function(e) {
            var t = function(t) {
                function i(i) {
                    var n = t.call(this, i) || this;
                    return n.closed = !1,
                    n.constantSpeed = !1,
                    n.color = new e.Color(1,1,1,1),
                    n
                }
                return r(i, t),
                i
            }(e.VertexAttachment);
            e.PathAttachment = t
        }(n || (n = {})),
        function(e) {
            var t = function(t) {
                function i(i) {
                    var n = t.call(this, i) || this;
                    return n.color = new e.Color(.38,.94,0,1),
                    n
                }
                return r(i, t),
                i.prototype.computeWorldPosition = function(e, t) {
                    return t.x = this.x * e.a + this.y * e.b + e.worldX,
                    t.y = this.x * e.c + this.y * e.d + e.worldY,
                    t
                }
                ,
                i.prototype.computeWorldRotation = function(t) {
                    var i = e.MathUtils.cosDeg(this.rotation)
                      , n = e.MathUtils.sinDeg(this.rotation)
                      , r = i * t.a + n * t.b
                      , s = i * t.c + n * t.d;
                    return Math.atan2(s, r) * e.MathUtils.radDeg
                }
                ,
                i
            }(e.VertexAttachment);
            e.PointAttachment = t
        }(n || (n = {})),
        function(e) {
            var t = function(t) {
                function i(i) {
                    var n = t.call(this, i) || this;
                    return n.x = 0,
                    n.y = 0,
                    n.scaleX = 1,
                    n.scaleY = 1,
                    n.rotation = 0,
                    n.width = 0,
                    n.height = 0,
                    n.color = new e.Color(1,1,1,1),
                    n.offset = e.Utils.newFloatArray(8),
                    n.uvs = e.Utils.newFloatArray(8),
                    n.tempColor = new e.Color(1,1,1,1),
                    n
                }
                return r(i, t),
                i.prototype.updateOffset = function() {
                    var e = this.width / this.region.originalWidth * this.scaleX
                      , t = this.height / this.region.originalHeight * this.scaleY
                      , n = -this.width / 2 * this.scaleX + this.region.offsetX * e
                      , r = -this.height / 2 * this.scaleY + this.region.offsetY * t
                      , s = n + this.region.width * e
                      , a = r + this.region.height * t
                      , o = this.rotation * Math.PI / 180
                      , l = Math.cos(o)
                      , c = Math.sin(o)
                      , h = n * l + this.x
                      , u = n * c
                      , p = r * l + this.y
                      , d = r * c
                      , f = s * l + this.x
                      , m = s * c
                      , g = a * l + this.y
                      , v = a * c
                      , y = this.offset;
                    y[i.OX1] = h - d,
                    y[i.OY1] = p + u,
                    y[i.OX2] = h - v,
                    y[i.OY2] = g + u,
                    y[i.OX3] = f - v,
                    y[i.OY3] = g + m,
                    y[i.OX4] = f - d,
                    y[i.OY4] = p + m
                }
                ,
                i.prototype.setRegion = function(e) {
                    this.region = e;
                    var t = this.uvs;
                    e.rotate ? (t[2] = e.u,
                    t[3] = e.v2,
                    t[4] = e.u,
                    t[5] = e.v,
                    t[6] = e.u2,
                    t[7] = e.v,
                    t[0] = e.u2,
                    t[1] = e.v2) : (t[0] = e.u,
                    t[1] = e.v2,
                    t[2] = e.u,
                    t[3] = e.v,
                    t[4] = e.u2,
                    t[5] = e.v,
                    t[6] = e.u2,
                    t[7] = e.v2)
                }
                ,
                i.prototype.computeWorldVertices = function(e, t, n, r) {
                    var s = this.offset
                      , a = e.worldX
                      , o = e.worldY
                      , l = e.a
                      , c = e.b
                      , h = e.c
                      , u = e.d
                      , p = 0
                      , d = 0;
                    p = s[i.OX1],
                    d = s[i.OY1],
                    t[n] = p * l + d * c + a,
                    t[n + 1] = p * h + d * u + o,
                    n += r,
                    p = s[i.OX2],
                    d = s[i.OY2],
                    t[n] = p * l + d * c + a,
                    t[n + 1] = p * h + d * u + o,
                    n += r,
                    p = s[i.OX3],
                    d = s[i.OY3],
                    t[n] = p * l + d * c + a,
                    t[n + 1] = p * h + d * u + o,
                    n += r,
                    p = s[i.OX4],
                    d = s[i.OY4],
                    t[n] = p * l + d * c + a,
                    t[n + 1] = p * h + d * u + o
                }
                ,
                i.OX1 = 0,
                i.OY1 = 1,
                i.OX2 = 2,
                i.OY2 = 3,
                i.OX3 = 4,
                i.OY3 = 5,
                i.OX4 = 6,
                i.OY4 = 7,
                i.X1 = 0,
                i.Y1 = 1,
                i.C1R = 2,
                i.C1G = 3,
                i.C1B = 4,
                i.C1A = 5,
                i.U1 = 6,
                i.V1 = 7,
                i.X2 = 8,
                i.Y2 = 9,
                i.C2R = 10,
                i.C2G = 11,
                i.C2B = 12,
                i.C2A = 13,
                i.U2 = 14,
                i.V2 = 15,
                i.X3 = 16,
                i.Y3 = 17,
                i.C3R = 18,
                i.C3G = 19,
                i.C3B = 20,
                i.C3A = 21,
                i.U3 = 22,
                i.V3 = 23,
                i.X4 = 24,
                i.Y4 = 25,
                i.C4R = 26,
                i.C4G = 27,
                i.C4B = 28,
                i.C4A = 29,
                i.U4 = 30,
                i.V4 = 31,
                i
            }(e.Attachment);
            e.RegionAttachment = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(e, t) {
                    this.jitterX = 0,
                    this.jitterY = 0,
                    this.jitterX = e,
                    this.jitterY = t
                }
                return t.prototype.begin = function(e) {}
                ,
                t.prototype.transform = function(t, i, n, r) {
                    t.x += e.MathUtils.randomTriangular(-this.jitterX, this.jitterY),
                    t.y += e.MathUtils.randomTriangular(-this.jitterX, this.jitterY)
                }
                ,
                t.prototype.end = function() {}
                ,
                t
            }();
            e.JitterEffect = t
        }(n || (n = {})),
        function(e) {
            var t = function() {
                function t(e) {
                    this.centerX = 0,
                    this.centerY = 0,
                    this.radius = 0,
                    this.angle = 0,
                    this.worldX = 0,
                    this.worldY = 0,
                    this.radius = e
                }
                return t.prototype.begin = function(e) {
                    this.worldX = e.x + this.centerX,
                    this.worldY = e.y + this.centerY
                }
                ,
                t.prototype.transform = function(i, n, r, s) {
                    var a = this.angle * e.MathUtils.degreesToRadians
                      , o = i.x - this.worldX
                      , l = i.y - this.worldY
                      , c = Math.sqrt(o * o + l * l);
                    if (c < this.radius) {
                        var h = t.interpolation.apply(0, a, (this.radius - c) / this.radius)
                          , u = Math.cos(h)
                          , p = Math.sin(h);
                        i.x = u * o - p * l + this.worldX,
                        i.y = p * o + u * l + this.worldY
                    }
                }
                ,
                t.prototype.end = function() {}
                ,
                t.interpolation = new e.PowOut(2),
                t
            }();
            e.SwirlEffect = t
        }(n || (n = {})),
        function(e) {
            !function(t) {
                var i = function(e) {
                    function i(i) {
                        return void 0 === i && (i = ""),
                        e.call(this, function(e) {
                            return new t.ThreeJsTexture(e)
                        }, i) || this
                    }
                    return r(i, e),
                    i
                }(e.AssetManager);
                t.AssetManager = i
            }(e.threejs || (e.threejs = {}))
        }(n || (n = {})),
        function(t) {
            !function(t) {
                var i = function(t) {
                    function i(n) {
                        void 0 === n && (n = 10920);
                        var r = t.call(this) || this;
                        if (r.verticesLength = 0,
                        r.indicesLength = 0,
                        n > 10920)
                            throw new Error("Can't have more than 10920 triangles per batch: " + n);
                        var s = r.vertices = new Float32Array(n * i.VERTEX_SIZE)
                          , a = r.indices = new Uint16Array(3 * n)
                          , o = new e.BufferGeometry
                          , l = r.vertexBuffer = new e.InterleavedBuffer(s,i.VERTEX_SIZE);
                        return l.dynamic = !0,
                        o.addAttribute("position", new e.InterleavedBufferAttribute(l,3,0,!1)),
                        o.addAttribute("color", new e.InterleavedBufferAttribute(l,4,3,!1)),
                        o.addAttribute("uv", new e.InterleavedBufferAttribute(l,2,7,!1)),
                        o.setIndex(new e.BufferAttribute(a,1)),
                        o.getIndex().dynamic = !0,
                        o.drawRange.start = 0,
                        o.drawRange.count = 0,
                        r.geometry = o,
                        r.material = u.get(),
                        r
                    }
                    return r(i, t),
                    i.prototype.clear = function() {
                        var e = this.geometry;
                        e.drawRange.start = 0,
                        e.drawRange.count = 0,
                        this.material.uniforms.map.value = null
                    }
                    ,
                    i.prototype.begin = function() {
                        this.verticesLength = 0,
                        this.indicesLength = 0
                    }
                    ,
                    i.prototype.canBatch = function(e, t) {
                        return !(this.indicesLength + t >= this.indices.byteLength / 2 || this.verticesLength + e >= this.vertices.byteLength / 2)
                    }
                    ,
                    i.prototype.batch = function(e, t, n, r, s) {
                        void 0 === s && (s = 0);
                        for (var a = this.verticesLength / i.VERTEX_SIZE, o = this.vertices, l = this.verticesLength, c = 0; c < t; )
                            o[l++] = e[c++],
                            o[l++] = e[c++],
                            o[l++] = s,
                            o[l++] = e[c++],
                            o[l++] = e[c++],
                            o[l++] = e[c++],
                            o[l++] = e[c++],
                            o[l++] = e[c++],
                            o[l++] = e[c++];
                        this.verticesLength = l;
                        var h = this.indices;
                        for (l = this.indicesLength,
                        c = 0; c < r; l++,
                        c++)
                            h[l] = n[c] + a;
                        this.indicesLength += r
                    }
                    ,
                    i.prototype.end = function() {
                        this.vertexBuffer.needsUpdate = !0,
                        this.vertexBuffer.updateRange.offset = 0,
                        this.vertexBuffer.updateRange.count = this.verticesLength;
                        var e = this.geometry;
                        e.getIndex().needsUpdate = !0,
                        e.getIndex().updateRange.offset = 0,
                        e.getIndex().updateRange.count = this.indicesLength,
                        e.drawRange.start = 0,
                        e.drawRange.count = this.indicesLength
                    }
                    ,
                    i.VERTEX_SIZE = 9,
                    i
                }(e.Mesh);
                t.MeshBatcher = i
            }(t.threejs || (t.threejs = {}))
        }(n || (n = {})),
        function(t) {
            !function(i) {
                i.SkeletonMeshMaterial = u;
                var n = function(e) {
                    function n(i) {
                        var n = e.call(this) || this;
                        n.tempPos = new t.Vector2,
                        n.tempUv = new t.Vector2,
                        n.tempLight = new t.Color,
                        n.tempDark = new t.Color,
                        n.zOffset = .1,
                        n.batches = new Array,
                        n.nextBatchIndex = 0,
                        n.clipper = new t.SkeletonClipping,
                        n.vertices = t.Utils.newFloatArray(1024),
                        n.tempColor = new t.Color,
                        n.skeleton = new t.Skeleton(i);
                        var r = new t.AnimationStateData(i);
                        return n.state = new t.AnimationState(r),
                        n
                    }
                    return r(n, e),
                    n.prototype.update = function(e) {
                        var t = this.state
                          , i = this.skeleton;
                        t.update(e),
                        t.apply(i),
                        i.updateWorldTransform(),
                        this.updateGeometry()
                    }
                    ,
                    n.prototype.clearBatches = function() {
                        for (var e = 0; e < this.batches.length; e++)
                            this.batches[e].clear(),
                            this.batches[e].visible = !1;
                        this.nextBatchIndex = 0
                    }
                    ,
                    n.prototype.nextBatch = function() {
                        if (this.batches.length == this.nextBatchIndex) {
                            var e = new i.MeshBatcher;
                            this.add(e),
                            this.batches.push(e)
                        }
                        var t = this.batches[this.nextBatchIndex++];
                        return t.visible = !0,
                        t
                    }
                    ,
                    n.prototype.updateGeometry = function() {
                        this.clearBatches();
                        var e = this.tempPos
                          , i = this.tempUv
                          , r = this.tempLight
                          , s = this.tempDark
                          , a = this.clipper
                          , o = this.vertices
                          , l = null
                          , c = null
                          , h = this.skeleton.drawOrder
                          , u = this.nextBatch();
                        u.begin();
                        for (var p = 0, d = this.zOffset, f = 0, m = h.length; f < m; f++) {
                            var g = a.isClipping() ? 2 : n.VERTEX_SIZE
                              , v = h[f]
                              , y = v.getAttachment()
                              , b = null
                              , x = null
                              , w = 0;
                            if (y instanceof t.RegionAttachment) {
                                var _ = y;
                                b = _.color,
                                o = this.vertices,
                                w = 4 * g,
                                _.computeWorldVertices(v.bone, o, 0, g),
                                l = n.QUAD_TRIANGLES,
                                c = _.uvs,
                                x = _.region.renderObject.texture
                            } else {
                                if (!(y instanceof t.MeshAttachment)) {
                                    if (y instanceof t.ClippingAttachment) {
                                        var T = y;
                                        a.clipStart(v, T);
                                        continue
                                    }
                                    continue
                                }
                                var M = y;
                                b = M.color,
                                o = this.vertices,
                                (w = (M.worldVerticesLength >> 1) * g) > o.length && (o = this.vertices = t.Utils.newFloatArray(w)),
                                M.computeWorldVertices(v, 0, M.worldVerticesLength, o, 0, g),
                                l = M.triangles,
                                c = M.uvs,
                                x = M.region.renderObject.texture
                            }
                            if (null != x) {
                                var S = v.bone.skeleton.color
                                  , A = v.color
                                  , P = S.a * A.a * b.a
                                  , C = this.tempColor;
                                C.set(S.r * A.r * b.r, S.g * A.g * b.g, S.b * A.b * b.b, P);
                                var L = void 0
                                  , k = void 0
                                  , E = void 0
                                  , I = void 0;
                                if (a.isClipping()) {
                                    a.clipTriangles(o, w, l, l.length, c, C, null, !1);
                                    var F = a.clippedVertices
                                      , O = a.clippedTriangles;
                                    if (null != this.vertexEffect)
                                        for (var R = this.vertexEffect, z = F, N = 0, D = F.length; N < D; N += g)
                                            e.x = z[N],
                                            e.y = z[N + 1],
                                            r.setFromColor(C),
                                            s.set(0, 0, 0, 0),
                                            i.x = z[N + 6],
                                            i.y = z[N + 7],
                                            R.transform(e, i, r, s),
                                            z[N] = e.x,
                                            z[N + 1] = e.y,
                                            z[N + 2] = r.r,
                                            z[N + 3] = r.g,
                                            z[N + 4] = r.b,
                                            z[N + 5] = r.a,
                                            z[N + 6] = i.x,
                                            z[N + 7] = i.y;
                                    L = F,
                                    k = F.length,
                                    E = O,
                                    I = O.length
                                } else {
                                    if (z = o,
                                    null != this.vertexEffect) {
                                        R = this.vertexEffect,
                                        N = 0;
                                        for (var U = 0, B = w; N < B; N += g,
                                        U += 2)
                                            e.x = z[N],
                                            e.y = z[N + 1],
                                            r.setFromColor(C),
                                            s.set(0, 0, 0, 0),
                                            i.x = c[U],
                                            i.y = c[U + 1],
                                            R.transform(e, i, r, s),
                                            z[N] = e.x,
                                            z[N + 1] = e.y,
                                            z[N + 2] = r.r,
                                            z[N + 3] = r.g,
                                            z[N + 4] = r.b,
                                            z[N + 5] = r.a,
                                            z[N + 6] = i.x,
                                            z[N + 7] = i.y
                                    } else {
                                        N = 2,
                                        U = 0;
                                        for (var j = w; N < j; N += g,
                                        U += 2)
                                            z[N] = C.r,
                                            z[N + 1] = C.g,
                                            z[N + 2] = C.b,
                                            z[N + 3] = C.a,
                                            z[N + 4] = c[U],
                                            z[N + 5] = c[U + 1]
                                    }
                                    L = o,
                                    k = w,
                                    E = l,
                                    I = l.length
                                }
                                if (0 == k || 0 == I)
                                    continue;
                                u.canBatch(k, I) || (u.end(),
                                (u = this.nextBatch()).begin());
                                var V = u.material;
                                null == V.uniforms.map.value && (V.uniforms.map.value = x.texture),
                                V.uniforms.map.value != x.texture && (u.end(),
                                (u = this.nextBatch()).begin(),
                                (V = u.material).uniforms.map.value = x.texture),
                                V.needsUpdate = !0,
                                u.batch(L, k, E, I, p),
                                p += d
                            }
                            a.clipEndWithSlot(v)
                        }
                        a.clipEnd(),
                        u.end()
                    }
                    ,
                    n.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0],
                    n.VERTEX_SIZE = 8,
                    n
                }(e.Object3D);
                i.SkeletonMesh = n
            }(t.threejs || (t.threejs = {}))
        }(n || (n = {})),
        function(t) {
            !function(i) {
                var n = function(i) {
                    function n(t) {
                        const n = {
                            width: t.image ? t.image.width : t.dimensions ? t.dimensions.width : t.compressed.width,
                            height: t.image ? t.image.height : t.dimensions ? t.dimensions.height : t.compressed.height
                        };
                        var r = i.call(this, n) || this;
                        if (t.compressed)
                            r.texture = s.a.createTexture(t.compressed),
                            r.texture.isCompressed = !0,
                            r.texture.needsUpdate = !0;
                        else if (t.image)
                            return r.texture = new e.Texture(t.image),
                            r.texture.isCompressed = !1,
                            r.texture.flipY = !1,
                            r.texture.needsUpdate = !0,
                            r
                    }
                    return r(n, i),
                    n.prototype.setFilters = function(e, t) {
                        this.texture.minFilter = n.toThreeJsTextureFilter(e),
                        this.texture.magFilter = n.toThreeJsTextureFilter(t)
                    }
                    ,
                    n.prototype.setWraps = function(e, t) {
                        this.texture.wrapS = n.toThreeJsTextureWrap(e),
                        this.texture.wrapT = n.toThreeJsTextureWrap(t)
                    }
                    ,
                    n.prototype.dispose = function() {
                        this.texture.dispose()
                    }
                    ,
                    n.toThreeJsTextureFilter = function(i) {
                        if (i === t.TextureFilter.Linear)
                            return e.LinearFilter;
                        if (i === t.TextureFilter.MipMap)
                            return e.LinearMipMapLinearFilter;
                        if (i === t.TextureFilter.MipMapLinearNearest)
                            return e.LinearMipMapNearestFilter;
                        if (i === t.TextureFilter.MipMapNearestLinear)
                            return e.NearestMipMapLinearFilter;
                        if (i === t.TextureFilter.MipMapNearestNearest)
                            return e.NearestMipMapNearestFilter;
                        if (i === t.TextureFilter.Nearest)
                            return e.NearestFilter;
                        throw new Error("Unknown texture filter: " + i)
                    }
                    ,
                    n.toThreeJsTextureWrap = function(i) {
                        if (i === t.TextureWrap.ClampToEdge)
                            return e.ClampToEdgeWrapping;
                        if (i === t.TextureWrap.MirroredRepeat)
                            return e.MirroredRepeatWrapping;
                        if (i === t.TextureWrap.Repeat)
                            return e.RepeatWrapping;
                        throw new Error("Unknown texture wrap: " + i)
                    }
                    ,
                    n
                }(t.Texture);
                i.ThreeJsTexture = n
            }(t.threejs || (t.threejs = {}))
        }(n || (n = {})),
        n
    }({
        BufferGeometry: a.i,
        InterleavedBuffer: a.r,
        InterleavedBufferAttribute: a.s,
        BufferAttribute: a.h,
        Mesh: a.x,
        DoubleSide: a.m,
        ShaderMaterial: a.R,
        Object3D: a.F,
        Texture: a.S,
        LinearFilter: a.t,
        LinearMipMapLinearFilter: a.u,
        LinearMipMapNearestFilter: a.v,
        NearestMipMapLinearFilter: a.B,
        NearestMipMapNearestFilter: a.C,
        NearestFilter: a.A,
        ClampToEdgeWrapping: a.j,
        MirroredRepeatWrapping: a.y,
        RepeatWrapping: a.O
    })
      , d = {};
    class f extends p.threejs.AssetManager {
        loadTexture(e, t, i) {
            const r = e.split("/")[0];
            if ("tempAtlas" === r || "tempSkeleton" === r) {
                const i = p.__temp.image
                  , n = this.textureLoader(i);
                return this.assets[e] = n,
                void t(e, i)
            }
            e = e.replace(/\.data\.pack/, ".tex.pack");
            const a = s.a.canImageBeCompressed(e)
              , o = s.a.getOriginalSize(e);
            a && (e = s.a.replacePath(e));
            const l = n.a.files.get(e, !0);
            if (l) {
                const i = {
                    dimensions: o
                };
                a ? i.compressed = s.a.parseKTX(l, !0) : i.image = l.node;
                const n = d[e] || this.textureLoader(i);
                return d[e] = n,
                this.assets[e] = n,
                void t(e, i)
            }
            super.loadTexture(e, t, i)
        }
        loadTextureAtlas(e, t, i) {
            const n = this;
            void 0 === t && (t = null),
            void 0 === i && (i = null);
            let r = e.lastIndexOf("/") >= 0 ? e.substring(0, e.lastIndexOf("/")) : "";
            r = r.replace(/\.data\.pack/, ".tex.pack"),
            r = s.a.replacePath(r),
            e = this.pathPrefix + e,
            this.toLoad++,
            f.downloadText(e, function(a) {
                const o = {
                    count: 0
                }
                  , l = new Array;
                try {
                    new p.TextureAtlas(a,function(e) {
                        l.push(r + "/" + e);
                        const t = document.createElement("img");
                        return t.width = 16,
                        t.height = 16,
                        new p.FakeTexture(t)
                    }
                    )
                } catch (t) {
                    const r = t;
                    return n.errors[e] = "Couldn't load texture atlas " + e + ": " + r.message,
                    i && i(e, "Couldn't load texture atlas " + e + ": " + r.message),
                    n.toLoad--,
                    void n.loaded++
                }
                const c = function(c) {
                    let h = !1;
                    n.loadTexture(c, function(c, u) {
                        if (o.count++,
                        o.count == l.length)
                            if (h)
                                n.errors[e] = "Couldn't load texture atlas page " + c + "} of atlas " + e,
                                i && i(e, "Couldn't load texture atlas page " + c + " of atlas " + e),
                                n.toLoad--,
                                n.loaded++;
                            else
                                try {
                                    const o = new p.TextureAtlas(a,function(e) {
                                        return e = s.a.replaceImagePath(e),
                                        n.get(r + "/" + e)
                                    }
                                    );
                                    n.assets[e] = o,
                                    t && t(e, o),
                                    n.toLoad--,
                                    n.loaded++
                                } catch (t) {
                                    const r = t;
                                    n.errors[e] = "Couldn't load texture atlas " + e + ": " + r.message,
                                    i && i(e, "Couldn't load texture atlas " + e + ": " + r.message),
                                    n.toLoad--,
                                    n.loaded++
                                }
                    }, function(t, r) {
                        h = !0,
                        o.count++,
                        o.count == l.length && (n.errors[e] = "Couldn't load texture atlas page " + t + "} of atlas " + e,
                        i && i(e, "Couldn't load texture atlas page " + t + " of atlas " + e),
                        n.toLoad--,
                        n.loaded++)
                    })
                };
                for (let e = 0, t = l; e < t.length; e++) {
                    c(t[e])
                }
            }, function(t, r) {
                n.errors[e] = "Couldn't load texture atlas " + e + ": status " + status + ", " + r,
                i && i(e, "Couldn't load texture atlas " + e + ": status " + status + ", " + r),
                n.toLoad--,
                n.loaded++
            })
        }
    }
    p.threejs.AssetManager = f;
    const m = p.AssetManager.downloadText;
    p.AssetManager.downloadText = function(e, t, i) {
        const r = e.split("/")[0];
        if ("tempAtlas" === r)
            return t(p.__temp.atlas);
        if ("tempSkeleton" === r)
            return t(p.__temp.skeleton);
        const s = n.a.files.get(e, !0);
        s ? t(s) : m(e, t, i)
    }
    ,
    p.datasForMesh = {},
    p.loadFromPack = function({pack: e, pathPrefix: t, name: i}) {
        if (!i || !e)
            throw new Error("Need name and pack");
        if (void 0 === t && (t = ""),
        p.datasForMesh[i])
            return;
        const s = e + "/" + t + i
          , a = s + ".atlas.txt"
          , o = s + ".json"
          , l = new f;
        if (!n.a.files.get(o, !0))
            return;
        if (!n.a.files.get(a, !0))
            return;
        l.loadText(o),
        l.loadTextureAtlas(a);
        const c = l.get(a)
          , h = new p.AtlasAttachmentLoader(c);
        p.skeletonJsons || (p.skeletonJsons = {}),
        p.skeletonDatas || (p.skeletonDatas = {});
        const u = {};
        u.atlasLoader = h,
        u.skeletonFile = l.get(o),
        u.skeletonJson = new p.SkeletonJson(u.atlasLoader),
        u.skeletonJson.scale = r.a.spinePrescale.current,
        u.skeletonData = u.skeletonJson.readSkeletonData(u.skeletonFile),
        p.datasForMesh[i] = u
    }
    ,
    p.loadFromFiles = function(e, t, i) {
        const n = new f;
        p.__temp = {
            atlas: e,
            skeleton: t,
            image: i
        };
        const s = "tempAtlas/" + Date.now() + "/text.txt"
          , a = "tempSkeleton/" + Date.now() + "/json.json";
        n.loadText(a),
        n.loadTextureAtlas(s),
        p.__temp = null;
        const o = n.get(s)
          , l = new p.AtlasAttachmentLoader(o)
          , c = {};
        return c.atlasLoader = l,
        c.skeletonFile = n.get(a),
        c.skeletonJson = new p.SkeletonJson(c.atlasLoader),
        c.skeletonJson.scale = r.a.spinePrescale.current,
        c.skeletonData = c.skeletonJson.readSkeletonData(c.skeletonFile),
        p.createMesh(c)
    }
    ,
    p.fileExists = function(e) {
        return !!p.datasForMesh[e]
    }
    ,
    p.createMesh = function(e) {
        const t = "string" == typeof e ? p.datasForMesh[e] : e;
        if (!t)
            return;
        let i;
        try {
            i = new p.threejs.SkeletonMesh(t.skeletonData)
        } catch (e) {}
        return i
    }
    ;
    t.a = p
}
, , , , function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return n
    });
    class n {
        constructor() {
            this.listeners = {}
        }
        addEventListener(e, t) {
            return this.listeners[e] || (this.listeners[e] = []),
            -1 === this.listeners[e].indexOf(t) && this.listeners[e].push(t),
            this
        }
        hasEventListener(e, t) {
            return void 0 !== this.listeners[e] && -1 !== this.listeners[e].indexOf(t)
        }
        removeEventListener(e, t) {
            const i = this.listeners[e];
            if (void 0 !== i) {
                const e = i.indexOf(t);
                -1 !== e && i.splice(e, 1)
            }
            return this
        }
        dispatchEvent(e) {
            const t = this.listeners[e.type] || [];
            e.target = this;
            for (let i = 0, n = t.length; i < n; i++)
                t[i].call(this, e);
            return this
        }
    }
}
, , function(e, t, i) {
    "use strict";
    var n = i(5)
      , r = i(34)
      , s = i(24)
      , a = i(17)
      , o = i(19)
      , l = i(55)
      , c = i(13);
    Object(a.a)("PLAYER", "black", "#fce566", 0).log;
    function h(e) {
        s.a.playTime.set(e - s.a.startDate.current)
    }
    function u(e, t) {
        const i = r.a.rules.current.games[e]
          , s = Object(n.clamp)(Object(n.norm)(t, 0, i.score_max), 0, 1);
        return Math.ceil(i.resources_max * s)
    }
    t.a = {
        init: function() {
            r.a.date.subscribe(h)
        },
        update: function(e=Object(o.a)()) {
            const t = Object(l.a)();
            t > s.a.lastDay.current && (s.a.daysCount.update(e => e + 1),
            s.a.lastDay.set(t),
            c.a.requestSave());
            const i = r.a.rules.current.refills;
            for (const t in s.a.resources) {
                const n = s.a.resources[t]
                  , r = i[t];
                let a = n.lastRefill.current;
                const o = Math.max(e - a, 0)
                  , l = Math.floor(o / r.delay);
                a += Math.floor(l * r.delay),
                n.lastRefill.set(a);
                let c = n.amount.current;
                l <= 0 || c >= r.limit || (c = Math.floor(Math.min(c + l * r.amount, r.limit)),
                n.amount.set(c))
            }
        },
        playGame: function() {
            const e = r.a.rules.current.refills.game.limit
              , t = s.a.resources.game.amount.current;
            t < 1 || (s.a.resources.game.amount.update(e => Math.max(0, e - 1)),
            s.a.resources.game.amount.current < e && t >= e && s.a.resources.game.lastRefill.set(Math.ceil(Object(o.a)(!0))),
            c.a.requestSave())
        },
        resetGameTime: function() {
            s.a.resources.game.amount.current >= 4 || (s.a.resources.game.lastRefill.set(Math.ceil(Object(o.a)(!0))),
            s.a.resources.game.amount.set(0))
        },
        saveCurrentScore: function(e) {
            if (!e)
                return !1;
            const t = s.a.scores[e];
            let i = !1;
            const n = s.a.highScores[e];
            t.current > n.current && (i = !0,
            n.set(t.current),
            c.a.requestSave());
            const a = r.a.rules.current.games[e]
              , o = u(e, t.current)
              , l = s.a.resources;
            return a.water && l.water.collectable.update(e => e + o),
            a.sun && l.sun.collectable.update(e => e + o),
            i
        },
        scoreToResources: u,
        addResource: function(e, t, i) {
            if (0 === (t = Math.floor(t)))
                return 0;
            const n = s.a.resources[e]
              , a = r.a.rules.current.refills[e];
            if (!n || !a)
                return 0;
            const o = a.limit
              , l = n.amount.current;
            let c = Math.max(0, l + t);
            if (r.a.disableResourceOverflow.current) {
                if (t > 0 && l >= o)
                    return 0;
                c = Math.min(c, o)
            }
            return i ? n.amount.current = c : n.amount.set(c),
            c
        },
        isResourceFull: function(e) {
            if (!r.a.disableResourceOverflow.current)
                return !1;
            const t = s.a.resources[e]
              , i = r.a.rules.current.resources.refills[e];
            if (!t || !i)
                return 0;
            const n = i.limit;
            return t.amount.current >= n
        }
    }
}
, function(e, t, i) {
    "use strict";
    const n = {
        default: i(79).default,
        amandier: i(79).default,
        cedrat: i(169).default,
        cerisier: i(170).default,
        immortelle: i(171).default,
        karite: i(172).default,
        lavande: i(173).default,
        rose: i(174).default,
        verveine: i(175).default
    };
    t.a = n
}
, function(e) {
    e.exports = JSON.parse('{"refills":{"sun":{"delay":15,"amount":2,"limit":10},"water":{"delay":14,"amount":1,"limit":10},"game":{"delay":30,"amount":1,"limit":1}},"games":{"bucket":{"score_max":200,"resources_max":18,"water":true,"sun":false},"caterpillars":{"score_max":150,"resources_max":25,"water":true,"sun":true},"spiders":{"score_max":200,"resources_max":18,"water":false,"sun":true}},"firstDelay":{"tuto":4,"lvl1":6,"lvl2":6,"lvl3":6},"seeds":[{"id":"amandier","starter":true,"unlock_conditions":[{"lvl2_seed":"lavande"}],"message_rewards":{"lvl2":{"count":5,"sun":true,"water":true},"lvl3":{"count":10,"sun":true,"water":true}},"lvl1":{"water":{"needed":12,"ask":[11,11],"delay":[20,20]},"sun":{"needed":8,"ask":[4,4],"delay":[5,5]},"love":{"needed":2,"ask":[1,1],"delay":[20,20]}},"lvl2":{"water":{"needed":18,"ask":[10,10],"delay":[45,49]},"sun":{"needed":22,"ask":[12,12],"delay":[35,35]},"love":{"needed":3,"ask":[1,1],"delay":[25,25]}},"lvl3":{"water":{"needed":27,"ask":[22,22],"delay":[49,65]},"sun":{"needed":32,"ask":[18,18],"delay":[45,60]},"love":{"needed":5,"ask":[1,1],"delay":[30,30]}}},{"id":"immortelle","starter":true,"unlock_conditions":[{"lvl2_seed":"amandier"}],"message_rewards":{"lvl2":{"count":5,"sun":true,"water":true},"lvl3":{"count":10,"sun":true,"water":true}},"lvl1":{"water":{"needed":12,"ask":[11,11],"delay":[20,20]},"sun":{"needed":8,"ask":[4,4],"delay":[5,5]},"love":{"needed":2,"ask":[1,1],"delay":[20,20]}},"lvl2":{"water":{"needed":18,"ask":[10,10],"delay":[45,49]},"sun":{"needed":22,"ask":[12,12],"delay":[35,35]},"love":{"needed":3,"ask":[1,1],"delay":[30,30]}},"lvl3":{"water":{"needed":27,"ask":[22,22],"delay":[49,65]},"sun":{"needed":32,"ask":[18,18],"delay":[45,60]},"love":{"needed":5,"ask":[1,1],"delay":[30,30]}}},{"id":"lavande","starter":true,"unlock_conditions":[{"lvl2_seed":"immortelle"}],"message_rewards":{"lvl2":{"count":5,"sun":true,"water":true},"lvl3":{"count":10,"sun":true,"water":true}},"lvl1":{"water":{"needed":12,"ask":[11,11],"delay":[20,20]},"sun":{"needed":8,"ask":[4,4],"delay":[5,5]},"love":{"needed":2,"ask":[1,1],"delay":[20,20]}},"lvl2":{"water":{"needed":18,"ask":[10,10],"delay":[45,49]},"sun":{"needed":22,"ask":[12,12],"delay":[35,35]},"love":{"needed":3,"ask":[1,1],"delay":[30,30]}},"lvl3":{"water":{"needed":27,"ask":[22,22],"delay":[49,65]},"sun":{"needed":32,"ask":[18,18],"delay":[45,60]},"love":{"needed":5,"ask":[1,1],"delay":[30,30]}}},{"id":"rose","unlock_conditions":[{"completed_seeds":3}],"message_rewards":{"lvl2":{"count":5,"sun":true,"water":true},"lvl3":{"count":10,"sun":true,"water":true}},"lvl1":{"water":{"needed":11,"ask":[10,10],"delay":[20,20]},"sun":{"needed":13,"ask":[6,6],"delay":[10,10]},"love":{"needed":3,"ask":[1,1],"delay":[20,20]}},"lvl2":{"water":{"needed":26,"ask":[12,12],"delay":[35,40]},"sun":{"needed":30,"ask":[10,10],"delay":[45,45]},"love":{"needed":5,"ask":[1,1],"delay":[30,30]}},"lvl3":{"water":{"needed":45,"ask":[22,22],"delay":[50,80]},"sun":{"needed":50,"ask":[15,15],"delay":[50,70]},"love":{"needed":7,"ask":[1,1],"delay":[30,45]}}},{"id":"cerisier","unlock_conditions":[{"game_score":["bucket",100]}],"message_rewards":{"lvl2":{"count":5,"sun":true,"water":true},"lvl3":{"count":10,"sun":true,"water":true}},"lvl1":{"water":{"needed":11,"ask":[10,10],"delay":[20,20]},"sun":{"needed":13,"ask":[6,6],"delay":[10,10]},"love":{"needed":3,"ask":[1,1],"delay":[20,20]}},"lvl2":{"water":{"needed":26,"ask":[12,12],"delay":[35,40]},"sun":{"needed":30,"ask":[10,10],"delay":[45,45]},"love":{"needed":5,"ask":[1,1],"delay":[30,30]}},"lvl3":{"water":{"needed":45,"ask":[22,22],"delay":[50,80]},"sun":{"needed":50,"ask":[15,15],"delay":[50,70]},"love":{"needed":7,"ask":[1,1],"delay":[30,45]}}},{"id":"cedrat","unlock_conditions":[{"days_count":2}],"message_rewards":{"lvl2":{"count":5,"sun":true,"water":true},"lvl3":{"count":10,"sun":true,"water":true}},"lvl1":{"water":{"needed":15,"ask":[10,10],"delay":[20,20]},"sun":{"needed":16,"ask":[8,8],"delay":[10,10]},"love":{"needed":3,"ask":[1,1],"delay":[20,20]}},"lvl2":{"water":{"needed":30,"ask":[9,9],"delay":[35,40]},"sun":{"needed":35,"ask":[10,10],"delay":[45,45]},"love":{"needed":6,"ask":[1,1],"delay":[30,30]}},"lvl3":{"water":{"needed":45,"ask":[15,15],"delay":[50,70]},"sun":{"needed":50,"ask":[10,10],"delay":[50,75]},"love":{"needed":8,"ask":[1,1],"delay":[30,70]}}},{"id":"verveine","unlock_conditions":[{"completed_seeds":2}],"message_rewards":{"lvl2":{"count":5,"sun":true,"water":true},"lvl3":{"count":10,"sun":true,"water":true}},"lvl1":{"water":{"needed":15,"ask":[10,10],"delay":[20,20]},"sun":{"needed":16,"ask":[8,8],"delay":[10,10]},"love":{"needed":3,"ask":[1,1],"delay":[20,20]}},"lvl2":{"water":{"needed":30,"ask":[9,9],"delay":[35,40]},"sun":{"needed":35,"ask":[10,10],"delay":[45,45]},"love":{"needed":6,"ask":[1,1],"delay":[30,30]}},"lvl3":{"water":{"needed":45,"ask":[15,15],"delay":[50,70]},"sun":{"needed":50,"ask":[10,10],"delay":[50,75]},"love":{"needed":8,"ask":[1,1],"delay":[30,70]}}},{"id":"karite","unlock_conditions":[{"completed_seeds":1}],"message_rewards":{"lvl2":{"count":5,"sun":true,"water":true},"lvl3":{"count":10,"sun":true,"water":true}},"lvl1":{"water":{"needed":11,"ask":[10,10],"delay":[20,20]},"sun":{"needed":13,"ask":[6,6],"delay":[10,10]},"love":{"needed":3,"ask":[1,1],"delay":[20,20]}},"lvl2":{"water":{"needed":26,"ask":[12,12],"delay":[35,40]},"sun":{"needed":30,"ask":[10,10],"delay":[45,45]},"love":{"needed":5,"ask":[1,1],"delay":[30,30]}},"lvl3":{"water":{"needed":45,"ask":[22,22],"delay":[50,80]},"sun":{"needed":50,"ask":[15,15],"delay":[50,70]},"love":{"needed":7,"ask":[1,1],"delay":[30,45]}}}]}')
}
, , , function(e, t, i) {
    "use strict";
    var n = i(19);
    t.a = function() {
        return 86400 * Math.floor(Object(n.a)() / 86400)
    }
}
, function(e, t, i) {
    "use strict";
    var n = i(41)
      , r = i.n(n);
    function s(e, t) {
        const i = {};
        return e.forEach( (e, n) => i[e] = t[n]),
        i
    }
    var a = i(48)
      , o = i(25)
      , l = i(8)
      , c = i(20);
    class h extends a.a {
        constructor() {
            super(),
            Object(o.a)(this),
            this.routes = [],
            this.history = {},
            this.locale = l.a.data.locale,
            this.add(l.a.data.routes),
            this._updateBrowserHistory = !0
        }
        addEventListeners() {
            this.eventListenersAdded || (this.eventListenersAdded = !0,
            window.addEventListener("popstate", this._onPopState),
            window.addEventListener("click", this._captureClickEvent))
        }
        add(e, t, i, n, s={}) {
            if ("object" == typeof e) {
                for (const t in e) {
                    const i = e[t];
                    this.add(t, i.expression, i.sampleExpression, i.module, i.options)
                }
                return
            }
            (!this.redirectionRoute && "default" === e || "error" === e) && (this.redirectionRoute = t);
            let a = [];
            const o = r()(t, a);
            return a = a.map(e => e.name),
            this.routes.push({
                id: e,
                expression: t,
                sampleExpression: i,
                regex: o,
                keys: a,
                module: n,
                options: s
            }),
            this.routes.sort(function(e, t) {
                return t.id.length - e.id.length
            }),
            this
        }
        start() {
            let e = window.location.pathname;
            return 0 === (e = e.replace(new RegExp(this.locale + "/?","i"), "")).length && (e = "."),
            this.navigate(e),
            this
        }
        navigate(e) {
            const t = this._check(e);
            if (!t.same)
                return t.match ? this.dispatchEvent({
                    type: "routeMatched",
                    route: t.route,
                    path: t.path,
                    params: t.params
                }) : this.navigate(this.redirectionRoute),
                this
        }
        replaceState(e, t) {
            this.history.previous = this.history.current,
            this.history.current = e.replace(".", "/");
            const i = this._lastRoute ? "pushState" : "replaceState"
              , n = "default" !== t.id ? "/" : ""
              , r = this.locale + n + this.history.current + window.location.search;
            this._lastRoute = this.history.current,
            t.options.silent || (this._updateBrowserHistory && history[i](this.history, "", r),
            this._updateBrowserHistory = !0)
        }
        _check(e) {
            (e = e.replace(`${this.locale}/`, "")).length || (e = ".");
            for (const t of this.routes) {
                if (t.options.restricted && "production" === c.a.env.current)
                    continue;
                const i = t.regex.exec(e);
                if (i) {
                    return i.shift(),
                    {
                        match: !0,
                        same: "default" === t.id && "/" === this._lastRoute || e === this._lastRoute,
                        route: t,
                        path: e,
                        params: s(t.keys, i)
                    }
                }
            }
            return {
                match: !1
            }
        }
        _onPopState(e) {
            e.state && (this._updateBrowserHistory = !1,
            this.navigate(e.state.current))
        }
        _captureClickEvent(e) {
            if (e.metaKey || e.ctrlKey || e.shiftKey)
                return;
            const t = e.target;
            "internal" === t.getAttribute("rel") && (e.preventDefault(),
            e.stopPropagation(),
            this.navigate(t.getAttribute("href")))
        }
    }
    var u = i(6);
    t.a = new class extends h {
        constructor() {
            super(),
            this.initialized = !1,
            this.started = !1,
            this.frozen = !0,
            this.frozenPath = null
        }
        init() {
            return this.initialized = !0,
            this.locale = l.a.data.locale,
            this.origin = window.location.origin,
            this.add(l.a.data.routes),
            this.addUrls(),
            this.freeze(),
            this
        }
        freeze() {
            this.frozen = !0
        }
        unfreeze() {
            this.started,
            this.frozen = !1,
            this.frozenPath && (this.navigate(this.frozenPath),
            this.frozenPath = null)
        }
        add(e, t, i, n, r={}) {
            if (this.initialized)
                return super.add(e, t, i, n, r),
                this
        }
        addUrls() {
            for (let e = 0, t = this.routes.length; e < t; e++) {
                const t = this.routes[e]
                  , i = t.expression;
                t.url = r.a.compile(i)
            }
        }
        url(e, t, i=!1) {
            for (let n = 0, r = this.routes.length; n < r; n++)
                if (this.routes[n].id === e)
                    return this.routes[n].url(t, i)
        }
        createUrlMethod(e) {
            const t = this;
            return function(i={}, n=!1) {
                let r = "";
                for (let t = 0, n = e.length; t < n; t++)
                    if ("." !== e[t].value)
                        if (e[t].raw)
                            r += e[t].value;
                        else if (e[t].param) {
                            const n = i[e[t].name];
                            r += void 0 !== n ? n : ":" + e[t].name
                        }
                return n ? t.origin + t.locale + "/" + r : t.locale + "/" + r
            }
        }
        start() {
            if (this.started)
                return this;
            if (!this.frozenPath) {
                let e = window.location.pathname;
                0 === (e = e.replace(new RegExp(this.locale + "/?","i"), "")).length && (e = "."),
                this.navigate(e)
            }
            return this.started = !0,
            this.unfreeze(),
            this
        }
        navigate(e) {
            if (this.frozen)
                return this.frozenPath = e,
                this;
            super.navigate(e)
        }
        navigateById(e, t={}) {
            this.navigate(this.url(e, t))
        }
        redirect({market: e, lang: t, path: i=""}) {
            if ("/" === i.charAt(0) && (i = i.substring(1)),
            c.a.demoMode.current) {
                const e = `${window.location.origin}/${t}/${i}`;
                window.location.href = e + window.location.search
            } else if (c.a.useMarketDomain.current) {
                const n = `${Object(u.a)(`markets.${e}.domain`)}/${t}/${i}`;
                window.location.href = `//${n}${window.location.search}`
            } else {
                const n = `${window.location.origin}/${e}/${t}/${i}`;
                window.location.href = n + window.location.search
            }
        }
    }
}
, , , , , function(e, t, i) {
    "use strict";
    var n = i(34)
      , r = i(52);
    const s = "sod_rules";
    t.a = {
        loadRules: function() {
            let e = window.localStorage.getItem(s);
            const t = !!e;
            (e = t ? JSON.parse(e) : r).seeds = e.seeds.reduce( (e, t) => (e[t.id] = t) && e, {}),
            e.isCustom = t,
            n.a.rules.set(e, !0)
        },
        saveCustomRules: function(e) {
            window.localStorage.setItem(s, JSON.stringify(e)),
            document.location.reload(!0)
        },
        removeCustomRules: function() {
            window.localStorage.removeItem(s),
            document.location.reload(!0)
        }
    }
}
, function(e, t, i) {
    "use strict";
    var n = i(3)
      , r = i(14);
    const s = Object.freeze({
        removePreloaderDelay: Object(r.b)(!1),
        bypassRouteRestriction: Object(r.b)(!1),
        noGameOver: Object(r.b)(!1),
        useResourceParticles: Object(n.a)(!1),
        useOneClick: Object(n.a)(!1),
        forceSeedMesh: Object(n.a)(null),
        debug: Object(n.a)(0),
        debugCanvas: Object(n.a)(!1),
        debugCamera: Object(n.a)(!1),
        orbitCameraStats: Object(r.b)({
            position: null,
            rotation: null
        }),
        forceQuality: Object(n.a)(!1),
        mockApi: Object(r.b)(!1),
        showStats: Object(r.b)(!1),
        useGui: Object(r.b)(!1),
        openGui: Object(r.b)(!1),
        timeOffset: Object(n.a)(0),
        useLocalSaveState: Object(n.a)(!1)
    });
    t.a = s
}
, , , , function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return r
    });
    var n = i(8);
    class r {
        constructor() {
            this.log = !1,
            this.clear();
            const e = [];
            this.getFilesData(n.a.data.manifest, e);
            for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t];
                if (!i.directoryID.match(/static/g))
                    continue;
                const r = i.directoryID.replace(".static", "")
                  , s = i.path.split(".static").pop()
                  , a = `${i.directoryID}${s}`
                  , o = `${n.a.data.paths.assets}/static/${r}${s}`;
                this.files[a] = {
                    source: o
                }
            }
        }
        getAssetPaths() {
            const e = {};
            for (const t in this.files) {
                const i = this.files[t];
                e[t] = i.source || i.string
            }
            return {
                assets: e
            }
        }
        getFilesData(e, t=[]) {
            if (e.hasOwnProperty("mime"))
                t.push(e);
            else
                for (const i in e)
                    this.getFilesData(e[i], t)
        }
        add(e, t, i) {
            this.files[e] = t,
            i && (this.packs[i] || (this.packs[i] = {}),
            this.packs[i][e] = t)
        }
        get(e, t) {
            if (this.files[e])
                return this.files[e];
            if (this.packs[e])
                return this.packs[e];
            if (!t)
                return;
            const i = {};
            for (const t in this.files)
                t.match(e) && (i[t] = this.files[t]);
            const n = Object.keys(i);
            return n.length > 1 ? i : i[n[0]]
        }
        clear() {
            this.packs = {},
            this.files = {}
        }
    }
}
, , function(e, t, i) {
    i(179);
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<button\n\tclass="header__button  header__button--'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "name",
                match: ["name"]
            }, {
                type: "Twig.expression.type.filter",
                value: "lower",
                match: ["|lower", "lower"]
            }]
        }, {
            type: "raw",
            value: '"\n\tref="headerButton"\n\tdata-event="mousedown->toggleStore"\n\taria-label="'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "name",
                match: ["name"]
            }]
        }, {
            type: "raw",
            value: '"\n>\n\t<span\n\t\tclass="header__button-icon"\n\t\tref="headerOpenIcon"\n\t>\n\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.block",
                block: "innerOpenIcon",
                output: []
            }
        }, {
            type: "raw",
            value: "\n\t\t"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "icon",
                    match: ["icon"]
                }, {
                    type: "Twig.expression.type.string",
                    value: "icon_garden"
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "==",
                    precidence: 9,
                    associativity: "leftToRight",
                    operator: "=="
                }],
                output: [{
                    type: "raw",
                    value: "\t\t\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.include",
                        only: !1,
                        ignoreMissing: !1,
                        stack: [{
                            type: "Twig.expression.type.string",
                            value: "src/app/components/svg/icon_garden.twig"
                        }]
                    }
                }, {
                    type: "raw",
                    value: "\t\t"
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.else",
                match: ["else"],
                output: [{
                    type: "raw",
                    value: '\t\t\t<svg>\n\t\t\t\t<use xlink:href="#'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "icon",
                        match: ["icon"]
                    }]
                }, {
                    type: "raw",
                    value: '" />\n\t\t\t</svg>\n\t\t'
                }]
            }
        }, {
            type: "raw",
            value: '\n\t</span>\n\t<span\n\t\tclass="header__button-icon"\n\t\tref="headerCloseIcon"\n\t>\n\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.block",
                block: "innerCloseIcon",
                output: []
            }
        }, {
            type: "raw",
            value: '\n\t\t<svg>\n\t\t\t<use xlink:href="#'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "icon",
                match: ["icon"]
            }, {
                type: "Twig.expression.type.string",
                value: "icon_sound"
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "==",
                precidence: 9,
                associativity: "leftToRight",
                operator: "=="
            }, {
                type: "Twig.expression.type.string",
                value: "icon_mute"
            }, {
                type: "Twig.expression.type.string",
                value: "icon_close"
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: '" />\n\t\t</svg>\n\t</span>\n\t<span\n\t\tclass="header__button-border"\n\t\tref="headerButtonBorder"\n\t></span>\n</button>\n'
        }],
        id: "src/app/components/header-button/header-button.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/header-button/header-button.twig",
    e.exports.default = e.exports
}
, , , , , , function(e, t) {
    e.exports = {
        packs: {
            default: {},
            "spritesheets.tex.pack": {
                noCompression: !0
            }
        }
    }
}
, function(e, t, i) {
    "use strict";
    i.d(t, "a", function() {
        return l
    });
    var n = i(8)
      , r = i(28)
      , s = i(25)
      , a = i(6);
    const o = {
        cantMount: "Can't mount View without parentNode"
    };
    class l extends r.a {
        constructor(e) {
            e.isView = !0,
            void 0 !== e.title && void 0 === e.name && (e.name = e.title),
            super(e),
            Object(s.a)(this),
            this.title = e.title,
            this.params = e.params,
            this.id = e.id,
            this.routeParams = e.routeParams,
            this.loaded = !1,
            this.files = [],
            Object.assign(this.data, {
                routeParams: this.routeParams
            })
        }
        beforeLoad() {}
        afterLoad() {}
        load() {
            return this.destroyed || this.loaded ? Promise.resolve() : new Promise( (e, t) => Promise.resolve().then( () => this.beforeLoad()).then( () => this.logger.log("Loading")).then( () => n.a.fileLoader.load(this.files)).then( () => this.loaded = !0).then( () => this.afterLoad()).then(e).catch(t))
        }
        beforeExit() {}
        render(e=!1) {
            if (this.loaded)
                return super.render(e)
        }
        mount(e, t=!1) {
            if (!t && !e)
                return this.logger.error(o.cantMount);
            if (this.destroyed || !this.loaded || !this.rendered || this.mounted)
                return;
            const i = t || this.mounted;
            this.beforeMount(this.props, i),
            this.logger.log("Mount"),
            t || ("function" == typeof e ? e(this.nodes.main) : e.appendChild(this.nodes.main)),
            document.documentElement.setAttribute("data-view", `${this.id}`),
            document.body.scrollTop = 0,
            document.title = this.title ? `${this.title} - ${Object(a.a)("interface.meta.title")}` : Object(a.a)("interface.meta.title"),
            this.mounted = !0,
            this.afterMount(this.props, i),
            this.enter(),
            l.current = this
        }
        enter() {
            this.logger.log("Enter"),
            l.current && l.current.exit()
        }
        exit() {
            this.logger.log("Exit"),
            this.destroy()
        }
        destroy() {
            super.destroy(),
            this.params = null,
            this.routeParams = null,
            this.files = null
        }
    }
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="750px" height="641px" viewBox="275 0 750 641">\n\t<path fill-rule="evenodd"  fill="rgb(230, 213, 182)"\n\td="M-0.000,272.000 L-0.000,641.000 L1300.000,641.000 L1300.000,272.000 C1300.000,272.000 1314.649,176.984 1179.000,143.000 C1095.390,122.053 983.999,66.300 983.999,66.300 C835.085,-22.111 589.442,3.547 504.439,30.174 C405.680,61.111 314.565,36.935 275.000,33.677 C36.546,14.040 -0.000,272.000 -0.000,272.000 Z"/>\n\t<path fill-rule="evenodd"  fill="rgb(234, 184, 124)"  style="fill-opacity: 0;"\n\td="M218.979,139.017 C183.717,161.908 150.470,187.605 78.000,198.000 C9.341,207.848 0.000,272.000 0.000,272.000 L0.000,641.000 L1300.000,641.000 L1300.000,272.000 C1300.000,272.000 1304.369,215.365 1250.000,190.000 C1162.129,149.006 1084.896,88.301 1084.896,88.301 C961.482,0.469 690.374,25.547 605.381,52.174 C506.630,83.111 413.640,73.677 377.964,73.677 C314.666,73.677 218.979,139.017 218.979,139.017 Z"/>\n\t<path fill-rule="evenodd"  fill="rgb(245, 239, 228)"\n\td="M1025.001,69.000 L1025.001,640.999 L275.000,640.999 L275.000,69.000 C423.916,-19.373 645.499,-15.619 754.561,42.507 C918.454,129.855 1025.001,69.000 1025.001,69.000 Z"/>\n</svg>\n'
        }],
        id: "src/app/components/svg/notification.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/svg/notification.twig",
    e.exports.default = e.exports
}
, , function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1301 641"><path fill-rule="evenodd" clip-rule="evenodd" fill="#E6D5B6" d="M0 272v369h1300V272s14.6-95-121-129c-83.6-20.9-195-76.7-195-76.7C835.1-22.1 589.4 3.5 504.4 30.2 405.6 61.1 314.5 37 275 33.7 36.5 14 0 272 0 272z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#EAB87C" d="M219 139c-35.3 22.9-68.5 48.6-141 59-68.7 9.8-78 74-78 74v369h1300V272s4.4-56.6-50-82c-87.9-41-165.1-101.7-165.1-101.7C961.5.5 690.4 25.5 605.4 52.2 506.6 83.1 413.6 73.7 378 73.7c-63.3 0-159 65.3-159 65.3z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#F5EFE4" d="M1025 69v572H275V69c148.9-88.4 370.5-84.6 479.6-26.5C918.5 129.9 1025 69 1025 69z"/></svg>\n'
        }],
        id: "src/app/components/svg/popin_bg.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/svg/popin_bg.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {hideCamera: r, commonCamera: s, commonScene: a} = n.a
      , o = {
        id: "amandier",
        palette: "blue",
        prngSeed: 1,
        hideCamera: r,
        seedPresets: {
            lvl1: {
                seedPosition: [0, -.4, .115],
                seedScale: .25,
                cameraPositionPortrait: s.lvl1.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl1.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl1.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl1.cameraRotationLandscape.slice(),
                animations: {
                    roll: {
                        from: "idle",
                        mix: .7,
                        delay: 3,
                        chance: 12,
                        step: 3
                    },
                    "idle-2": {
                        from: "idle",
                        mix: .6,
                        delay: 4,
                        chance: 30,
                        step: 2
                    }
                }
            },
            lvl2: {
                seedPosition: [0, -.3, -.1],
                seedScale: .6,
                cameraPositionPortrait: s.lvl2.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl2.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl2.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl2.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .7
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 30,
                        step: 3
                    },
                    "idle-2": {
                        from: "idle",
                        mix: .75,
                        chance: 10,
                        delay: 3,
                        step: 4
                    },
                    crying: {
                        from: "sad",
                        mix: .85,
                        chance: 10,
                        delay: 3,
                        step: 2
                    }
                }
            },
            lvl3: {
                seedPosition: [0, -1, -.5],
                seedScale: 1.8,
                cameraPositionPortrait: s.lvl3.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl3.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl3.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl3.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .75
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 25,
                        step: 3
                    }
                }
            },
            lvl4: {
                seedPosition: [0, -.8, -.9],
                seedScale: 2.5,
                cameraPositionPortrait: s.lvl4.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl4.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl4.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl4.cameraRotationLandscape.slice(),
                animations: {}
            }
        },
        scene: JSON.parse(JSON.stringify(a))
    };
    t.default = o
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div class="field-frame" ref="fieldFrame">\n\t<svg focusable="false">\n\t\t<use xlink:href="#element_draw" />\n\t</svg>\n\t<svg focusable="false">\n\t\t<use xlink:href="#element_draw" />\n\t</svg>\n\t<svg focusable="false">\n\t\t<use xlink:href="#element_draw" />\n\t</svg>\n\t<svg focusable="false">\n\t\t<use xlink:href="#element_draw" />\n\t</svg>\n</div>\n'
        }],
        id: "src/app/components/field-frame/field-frame.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/field-frame/field-frame.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {
    "use strict";
    var n = i(187)
      , r = i(20)
      , s = i(27);
    const {visibilityEventName: a, visibilityHiddenProp: o} = function() {
        const e = {
            visbilityEventName: null,
            visibilityHiddenProp: null
        };
        void 0 !== document.hidden ? (e.visibilityEventName = "visibilitychange",
        e.visibilityHiddenProp = "hidden") : void 0 !== document.msHidden ? (e.visibilityEventName = "msvisibilitychange",
        e.visibilityHiddenProp = "msHidden") : void 0 !== document.webkitHidden && (e.visibilityEventName = "webkitvisibilitychange",
        e.visibilityHiddenProp = "webkitHidden");
        return e
    }()
      , l = document.getElementsByTagName("html")[0];
    let c, h = {};
    function u(e=!1) {
        const t = "android" === r.a.device.current.os && r.a.device.current.type.mobile
          , {availHeight: i, availWidth: n} = window.screen
          , a = window.innerWidth
          , o = window.innerHeight
          , c = (t ? n / i : a / o) > 1 ? "landscape" : "portrait"
          , h = "portrait" === c
          , u = Math[h ? "min" : "max"](screen.width, screen.height)
          , p = Math[h ? "max" : "min"](screen.width, screen.height);
        r.a.screenOrientation.set(c, e),
        l.classList.toggle("portrait", "portrait" === c),
        l.classList.toggle("landscape", "landscape" === c);
        const d = r.a.screenSize.get();
        let f = !1;
        (e || u !== d[0] || p !== d[1]) && (d[0] = u,
        d[1] = p,
        f = !0);
        const m = r.a.viewportSize.get();
        let g = !1;
        (e || a !== m[0] || o !== m[1]) && (m[0] = a,
        m[1] = o,
        r.a.viewportRatio.set(a / o, !0),
        g = !0),
        f && r.a.viewportSize.set(d, !0),
        g && r.a.viewportSize.set(m, !0),
        g && s.a.recomputeDOMObjects.dispatch()
    }
    function p() {
        r.a.screenPixelRatio.current !== window.devicePixelRatio && r.a.screenPixelRatio.set(window.devicePixelRatio || 1)
    }
    function d() {
        u()
    }
    function f() {
        const e = document[o];
        r.a.siteVisible.set(!e),
        s.a.recomputeDOMObjects.dispatch()
    }
    function m() {
        u(),
        window.clearTimeout(c),
        c = window.setTimeout( () => {
            u(),
            "portrait" === r.a.screenOrientation.current && setTimeout( () => window.scrollTo(0, -1), 100)
        }
        , 250)
    }
    t.a = {
        init: function(e={}) {
            document.addEventListener(a, f, !1),
            window.addEventListener("orientationchange", m, !1),
            window.addEventListener("resize", Object(n.a)(d, 100), !1),
            h = Object.assign(h, e.breakpoints),
            u(!0),
            setTimeout( () => u(!0), 300),
            setTimeout( () => u(!0), 500),
            p(),
            r.a.device.current.type.desktop && window.setInterval(p, 5e3),
            r.a.currentView.subscribe( () => s.a.recomputeDOMObjects.dispatch())
        },
        update: u,
        mq: function({from: e=!1, until: t=!1, mediaType: i="all"}={}) {
            let n = "";
            return e && (n = ` and (min-width: ${h[e]})`),
            t && (n = `${n} and (max-width: ${t = parseInt(h[t]) - 1}px)`),
            window.matchMedia(i + n).matches
        },
        isFullscreen: function() {
            const e = r.a.viewportSize.current
              , t = r.a.screenSize.current;
            return e[0] >= t[0] && e[1] >= t[1]
        }
    }
}
, , function(e, t, i) {
    i(76),
    i(78),
    i(168);
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "modifiers",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "split",
                    match: ["|split", "split"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: ", "
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "classNames",
                expression: [{
                    type: "Twig.expression.type.array.start",
                    value: "[",
                    match: ["["]
                }, {
                    type: "Twig.expression.type.array.end",
                    value: "]",
                    match: ["]"]
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.for",
                key_var: null,
                value_var: "item",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }],
                output: [{
                    type: "raw",
                    value: "\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.set",
                        key: "classNames",
                        expression: [{
                            type: "Twig.expression.type.variable",
                            value: "classNames",
                            match: ["classNames"]
                        }, {
                            type: "Twig.expression.type.filter",
                            value: "merge",
                            match: ["|merge", "merge"],
                            params: [{
                                type: "Twig.expression.type.parameter.start",
                                value: "(",
                                match: ["("]
                            }, {
                                type: "Twig.expression.type.array.start",
                                value: "[",
                                match: ["["]
                            }, {
                                type: "Twig.expression.type.string",
                                value: "  notification--"
                            }, {
                                type: "Twig.expression.type.variable",
                                value: "item",
                                match: ["item"]
                            }, {
                                type: "Twig.expression.type.operator.binary",
                                value: "~",
                                precidence: 6,
                                associativity: "leftToRight",
                                operator: "~"
                            }, {
                                type: "Twig.expression.type.array.end",
                                value: "]",
                                match: ["]"]
                            }, {
                                type: "Twig.expression.type.parameter.end",
                                value: ")",
                                match: [")"],
                                expression: !1
                            }]
                        }]
                    }
                }]
            }
        }, {
            type: "raw",
            value: '\n<div\n\tclass="notification'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "classNames",
                match: ["classNames"]
            }, {
                type: "Twig.expression.type.filter",
                value: "join",
                match: ["|join", "join"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: ""
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "raw",
            value: " "
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "game_over",
                    match: ["game_over"]
                }],
                output: [{
                    type: "raw",
                    value: "notification--collectable"
                }]
            }
        }, {
            type: "raw",
            value: '"\n\tref="notification"\n>\n\n\t<div\n\t\tclass="notification__container"\n\t\tref="container"\n\t>\n\n\t\t<div class="notification__bg  notification__bg--mobile">\n\t\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.include",
                only: !1,
                ignoreMissing: !1,
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "src/app/components/svg/notification.twig"
                }]
            }
        }, {
            type: "raw",
            value: '\t\t</div>\n\n\t\t<div class="notification__bg  notification__bg--desktop" ref="bg">\n\t\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.include",
                only: !1,
                ignoreMissing: !1,
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "src/app/components/svg/popin_bg.twig"
                }]
            }
        }, {
            type: "raw",
            value: "\n\t\t\t"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.include",
                only: !1,
                ignoreMissing: !1,
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "src/app/components/svg/popin_stars.twig"
                }]
            }
        }, {
            type: "raw",
            value: '</div>\n\n\t\t<div class="notification__inner" ref="inner">\n\t\t\t<div\n\t\t\t\tclass="notification__content"\n\t\t\t\tref ="notificationContent"\n\t\t\t>'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "text",
                    match: ["text"]
                }],
                output: [{
                    type: "raw",
                    value: '<div class="notification__text">'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "text",
                        match: ["text"]
                    }]
                }, {
                    type: "raw",
                    value: "</div>"
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "game_over",
                    match: ["game_over"]
                }],
                output: [{
                    type: "raw",
                    value: '<div class="notification__game_over">\n\t\t\t\t\t\t<div class="notification__score">'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "game_over",
                        match: ["game_over"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "score"
                    }]
                }, {
                    type: "raw",
                    value: "<span>"
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "game_over",
                        match: ["game_over"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "points"
                    }]
                }, {
                    type: "raw",
                    value: '</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class="notification__best_score">'
                }, {
                    type: "output_whitespace_pre",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "game_over",
                        match: ["game_over"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "best_score_text"
                    }]
                }, {
                    type: "raw",
                    value: " "
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "game_over",
                        match: ["game_over"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "best_score"
                    }]
                }, {
                    type: "raw",
                    value: "<span>"
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "game_over",
                        match: ["game_over"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "points"
                    }]
                }, {
                    type: "raw",
                    value: "</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>"
                }]
            }
        }, {
            type: "raw",
            value: "\t\t\t</div>\n\n\t\t\t"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "button",
                    match: ["button"]
                }],
                output: [{
                    type: "raw",
                    value: '\t\t\t\t<div\n\t\t\t\t\tclass="notification__button"\n\t\t\t\t\tref="notificationButton"\n\t\t\t\t>\n\t\t\t\t\t'
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.if",
                        stack: [{
                            type: "Twig.expression.type.variable",
                            value: "game_over",
                            match: ["game_over"]
                        }],
                        output: [{
                            type: "raw",
                            value: '\n\t\t\t\t\t\t<div class="notification__resources">\n\n\t\t\t\t\t\t\t<div class="notification__resources-icons">\n\t\t\t\t\t\t\t\t'
                        }, {
                            type: "logic",
                            token: {
                                type: "Twig.logic.type.if",
                                stack: [{
                                    type: "Twig.expression.type.variable",
                                    value: "game_over",
                                    match: ["game_over"]
                                }, {
                                    type: "Twig.expression.type.key.period",
                                    key: "sun"
                                }],
                                output: [{
                                    type: "raw",
                                    value: '\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tclass="notification__resources-icon  notification__resources-icon--sun"\n\t\t\t\t\t\t\t\t\t\tref="sun"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<svg>\n\t\t\t\t\t\t\t\t\t\t\t<use xlink:href="#element_sun" />\n\t\t\t\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t'
                                }]
                            }
                        }, {
                            type: "raw",
                            value: "\n\t\t\t\t\t\t\t\t"
                        }, {
                            type: "logic",
                            token: {
                                type: "Twig.logic.type.if",
                                stack: [{
                                    type: "Twig.expression.type.variable",
                                    value: "game_over",
                                    match: ["game_over"]
                                }, {
                                    type: "Twig.expression.type.key.period",
                                    key: "water"
                                }],
                                output: [{
                                    type: "raw",
                                    value: '\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tclass="notification__resources-icon  notification__resources-icon--water"\n\t\t\t\t\t\t\t\t\t\tref="water"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<svg>\n\t\t\t\t\t\t\t\t\t\t\t<use xlink:href="#element_water_drop" />\n\t\t\t\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t'
                                }]
                            }
                        }, {
                            type: "raw",
                            value: '\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclass="notification__resources-won"\n\t\t\t\t\t\t\t\tref="won"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<div class="notification__resources-number">\n\t\t\t\t\t\t\t\t\t<span>\n\t\t\t\t\t\t\t\t\t\t&#215;\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t'
                        }, {
                            type: "output",
                            stack: [{
                                type: "Twig.expression.type.variable",
                                value: "game_over",
                                match: ["game_over"]
                            }, {
                                type: "Twig.expression.type.key.period",
                                key: "resources_won"
                            }]
                        }, {
                            type: "raw",
                            value: "\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t</div>\n\t\t\t\t\t"
                        }]
                    }
                }, {
                    type: "raw",
                    value: "\n\t\t\t\t</div>\n\t\t\t"
                }]
            }
        }, {
            type: "raw",
            value: '\t\t</div>\n\t</div>\n\n\t<div\n\t\tclass="notification__close"\n\t\tref="close"\n\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "prevent_overlay_close",
                    match: ["prevent_overlay_close"]
                }, {
                    type: "Twig.expression.type.operator.unary",
                    value: "not",
                    precidence: 3,
                    associativity: "rightToLeft",
                    operator: "not"
                }],
                output: [{
                    type: "raw",
                    value: '\t\t\tdata-event="click->close"\n\t\t\tdata-bypass-touch\n\t\t'
                }]
            }
        }, {
            type: "raw",
            value: "\t></div>\n</div>\n"
        }],
        id: "src/app/components/notification/notification.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/notification/notification.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "modifiers",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "default",
                    match: ["|default", "default"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: "blue"
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "split",
                    match: ["|split", "split"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: ", "
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "classNames",
                expression: [{
                    type: "Twig.expression.type.array.start",
                    value: "[",
                    match: ["["]
                }, {
                    type: "Twig.expression.type.array.end",
                    value: "]",
                    match: ["]"]
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.for",
                key_var: null,
                value_var: "item",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }],
                output: [{
                    type: "raw",
                    value: "\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.set",
                        key: "classNames",
                        expression: [{
                            type: "Twig.expression.type.variable",
                            value: "classNames",
                            match: ["classNames"]
                        }, {
                            type: "Twig.expression.type.filter",
                            value: "merge",
                            match: ["|merge", "merge"],
                            params: [{
                                type: "Twig.expression.type.parameter.start",
                                value: "(",
                                match: ["("]
                            }, {
                                type: "Twig.expression.type.array.start",
                                value: "[",
                                match: ["["]
                            }, {
                                type: "Twig.expression.type.string",
                                value: "  title--"
                            }, {
                                type: "Twig.expression.type.variable",
                                value: "item",
                                match: ["item"]
                            }, {
                                type: "Twig.expression.type.operator.binary",
                                value: "~",
                                precidence: 6,
                                associativity: "leftToRight",
                                operator: "~"
                            }, {
                                type: "Twig.expression.type.array.end",
                                value: "]",
                                match: ["]"]
                            }, {
                                type: "Twig.expression.type.parameter.end",
                                value: ")",
                                match: [")"],
                                expression: !1
                            }]
                        }]
                    }
                }]
            }
        }, {
            type: "raw",
            value: '\n<div\n\tclass="title'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "classNames",
                match: ["classNames"]
            }, {
                type: "Twig.expression.type.filter",
                value: "join",
                match: ["|join", "join"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: ""
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "raw",
            value: '"\n\tref="title"\n>\n\t<span\n\t\tclass="title__text"\n\t\t'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "store",
                match: ["store"]
            }, {
                type: "Twig.expression.type.string",
                value: 'data-store="titleText"'
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: ">"
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "text",
                match: ["text"]
            }]
        }, {
            type: "raw",
            value: "</span>"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "underline",
                    match: ["underline"]
                }, {
                    type: "Twig.expression.type.bool",
                    value: !1
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "!=",
                    precidence: 9,
                    associativity: "leftToRight",
                    operator: "!="
                }],
                output: [{
                    type: "raw",
                    value: '\t\t<div class="title__underline">\n\t\t\t<svg>\n\t\t\t\t<use xlink:href="#element_underline" />\n\t\t\t</svg>\n\t\t</div>\n\t'
                }]
            }
        }, {
            type: "raw",
            value: "</div>\n"
        }],
        id: "src/app/components/title/title.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/title/title.twig",
    e.exports.default = e.exports
}
, , function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "modifiers",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "default",
                    match: ["|default", "default"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: "blue"
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "split",
                    match: ["|split", "split"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: ", "
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "ref",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "ref",
                    match: ["ref"]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "split",
                    match: ["|split", "split"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: ", "
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "classNames",
                expression: [{
                    type: "Twig.expression.type.array.start",
                    value: "[",
                    match: ["["]
                }, {
                    type: "Twig.expression.type.array.end",
                    value: "]",
                    match: ["]"]
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "references",
                expression: [{
                    type: "Twig.expression.type.array.start",
                    value: "[",
                    match: ["["]
                }, {
                    type: "Twig.expression.type.array.end",
                    value: "]",
                    match: ["]"]
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.for",
                key_var: null,
                value_var: "item",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }],
                output: [{
                    type: "raw",
                    value: "\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.set",
                        key: "classNames",
                        expression: [{
                            type: "Twig.expression.type.variable",
                            value: "classNames",
                            match: ["classNames"]
                        }, {
                            type: "Twig.expression.type.filter",
                            value: "merge",
                            match: ["|merge", "merge"],
                            params: [{
                                type: "Twig.expression.type.parameter.start",
                                value: "(",
                                match: ["("]
                            }, {
                                type: "Twig.expression.type.array.start",
                                value: "[",
                                match: ["["]
                            }, {
                                type: "Twig.expression.type.string",
                                value: "  cta--"
                            }, {
                                type: "Twig.expression.type.variable",
                                value: "item",
                                match: ["item"]
                            }, {
                                type: "Twig.expression.type.operator.binary",
                                value: "~",
                                precidence: 6,
                                associativity: "leftToRight",
                                operator: "~"
                            }, {
                                type: "Twig.expression.type.array.end",
                                value: "]",
                                match: ["]"]
                            }, {
                                type: "Twig.expression.type.parameter.end",
                                value: ")",
                                match: [")"],
                                expression: !1
                            }]
                        }]
                    }
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.for",
                key_var: null,
                value_var: "item",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "ref",
                    match: ["ref"]
                }],
                output: [{
                    type: "raw",
                    value: "\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.set",
                        key: "references",
                        expression: [{
                            type: "Twig.expression.type.variable",
                            value: "references",
                            match: ["references"]
                        }, {
                            type: "Twig.expression.type.filter",
                            value: "merge",
                            match: ["|merge", "merge"],
                            params: [{
                                type: "Twig.expression.type.parameter.start",
                                value: "(",
                                match: ["("]
                            }, {
                                type: "Twig.expression.type.array.start",
                                value: "[",
                                match: ["["]
                            }, {
                                type: "Twig.expression.type.string",
                                value: ", "
                            }, {
                                type: "Twig.expression.type.variable",
                                value: "item",
                                match: ["item"]
                            }, {
                                type: "Twig.expression.type.operator.binary",
                                value: "~",
                                precidence: 6,
                                associativity: "leftToRight",
                                operator: "~"
                            }, {
                                type: "Twig.expression.type.array.end",
                                value: "]",
                                match: ["]"]
                            }, {
                                type: "Twig.expression.type.parameter.end",
                                value: ")",
                                match: [")"],
                                expression: !1
                            }]
                        }]
                    }
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "url",
                    match: ["url"]
                }],
                output: [{
                    type: "raw",
                    value: '\t<a\n\t\tclass="cta'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "classNames",
                        match: ["classNames"]
                    }, {
                        type: "Twig.expression.type.filter",
                        value: "join",
                        match: ["|join", "join"],
                        params: [{
                            type: "Twig.expression.type.parameter.start",
                            value: "(",
                            match: ["("]
                        }, {
                            type: "Twig.expression.type.string",
                            value: ""
                        }, {
                            type: "Twig.expression.type.parameter.end",
                            value: ")",
                            match: [")"],
                            expression: !1
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\thref="'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "url",
                        match: ["url"]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\t'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.string",
                        value: "http"
                    }, {
                        type: "Twig.expression.type.variable",
                        value: "url",
                        match: ["url"]
                    }, {
                        type: "Twig.expression.type.operator.binary",
                        value: "in",
                        precidence: 8,
                        associativity: "leftToRight",
                        operator: "in"
                    }, {
                        type: "Twig.expression.type.string",
                        value: 'target="_blank" rel="noopener"'
                    }, {
                        type: "Twig.expression.type.string",
                        value: 'rel="internal"'
                    }, {
                        type: "Twig.expression.type.operator.binary",
                        value: "?",
                        precidence: 16,
                        associativity: "rightToLeft",
                        operator: "?"
                    }]
                }, {
                    type: "raw",
                    value: '\n\t\tref="callToAction'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "references",
                        match: ["references"]
                    }, {
                        type: "Twig.expression.type.filter",
                        value: "join",
                        match: ["|join", "join"],
                        params: [{
                            type: "Twig.expression.type.parameter.start",
                            value: "(",
                            match: ["("]
                        }, {
                            type: "Twig.expression.type.string",
                            value: ""
                        }, {
                            type: "Twig.expression.type.parameter.end",
                            value: ")",
                            match: [")"],
                            expression: !1
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\taria-label="'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "text",
                        match: ["text"]
                    }, {
                        type: "Twig.expression.type.filter",
                        value: "default",
                        match: ["|default", "default"],
                        params: [{
                            type: "Twig.expression.type.parameter.start",
                            value: "(",
                            match: ["("]
                        }, {
                            type: "Twig.expression.type.string",
                            value: "Button text"
                        }, {
                            type: "Twig.expression.type.parameter.end",
                            value: ")",
                            match: [")"],
                            expression: !1
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"'
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.if",
                        stack: [{
                            type: "Twig.expression.type.variable",
                            value: "onClick",
                            match: ["onClick"]
                        }],
                        output: [{
                            type: "raw",
                            value: '\t\t\tdata-event="click->onClick"\n\t\t'
                        }]
                    }
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.elseif",
                        stack: [{
                            type: "Twig.expression.type.variable",
                            value: "copyToClipboard",
                            match: ["copyToClipboard"]
                        }],
                        output: [{
                            type: "raw",
                            value: 'data-event="click->copyToClipboard"\n\t\t\tdata-copy-text="'
                        }, {
                            type: "output_whitespace_both",
                            stack: [{
                                type: "Twig.expression.type.variable",
                                value: "copyText",
                                match: ["copyText"]
                            }, {
                                type: "Twig.expression.type.filter",
                                value: "default",
                                match: ["|default", "default"],
                                params: [{
                                    type: "Twig.expression.type.parameter.start",
                                    value: "(",
                                    match: ["("]
                                }, {
                                    type: "Twig.expression.type.variable",
                                    value: "text",
                                    match: ["text"]
                                }, {
                                    type: "Twig.expression.type.parameter.end",
                                    value: ")",
                                    match: [")"],
                                    expression: !1
                                }]
                            }]
                        }, {
                            type: "raw",
                            value: '"'
                        }]
                    }
                }, {
                    type: "raw",
                    value: "\t>\n"
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.else",
                match: ["else"],
                output: [{
                    type: "raw",
                    value: '\t<button\n\t\tclass="cta'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "classNames",
                        match: ["classNames"]
                    }, {
                        type: "Twig.expression.type.filter",
                        value: "join",
                        match: ["|join", "join"],
                        params: [{
                            type: "Twig.expression.type.parameter.start",
                            value: "(",
                            match: ["("]
                        }, {
                            type: "Twig.expression.type.string",
                            value: ""
                        }, {
                            type: "Twig.expression.type.parameter.end",
                            value: ")",
                            match: [")"],
                            expression: !1
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\tref="callToAction'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "references",
                        match: ["references"]
                    }, {
                        type: "Twig.expression.type.filter",
                        value: "join",
                        match: ["|join", "join"],
                        params: [{
                            type: "Twig.expression.type.parameter.start",
                            value: "(",
                            match: ["("]
                        }, {
                            type: "Twig.expression.type.string",
                            value: ""
                        }, {
                            type: "Twig.expression.type.parameter.end",
                            value: ")",
                            match: [")"],
                            expression: !1
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\trole="button"\n\t\taria-label="'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "text",
                        match: ["text"]
                    }, {
                        type: "Twig.expression.type.filter",
                        value: "default",
                        match: ["|default", "default"],
                        params: [{
                            type: "Twig.expression.type.parameter.start",
                            value: "(",
                            match: ["("]
                        }, {
                            type: "Twig.expression.type.string",
                            value: "Button text"
                        }, {
                            type: "Twig.expression.type.parameter.end",
                            value: ")",
                            match: [")"],
                            expression: !1
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "type",
                        match: ["type"]
                    }, {
                        type: "Twig.expression.type.string",
                        value: 'type="'
                    }, {
                        type: "Twig.expression.type.variable",
                        value: "type",
                        match: ["type"]
                    }, {
                        type: "Twig.expression.type.operator.binary",
                        value: "~",
                        precidence: 6,
                        associativity: "leftToRight",
                        operator: "~"
                    }, {
                        type: "Twig.expression.type.string",
                        value: '"'
                    }, {
                        type: "Twig.expression.type.operator.binary",
                        value: "~",
                        precidence: 6,
                        associativity: "leftToRight",
                        operator: "~"
                    }, {
                        type: "Twig.expression.type.operator.binary",
                        value: "?",
                        precidence: 16,
                        associativity: "rightToLeft",
                        operator: "?"
                    }]
                }, {
                    type: "raw",
                    value: "\n\t\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.if",
                        stack: [{
                            type: "Twig.expression.type.variable",
                            value: "onClick",
                            match: ["onClick"]
                        }],
                        output: [{
                            type: "raw",
                            value: '\t\t\tdata-event="click->onClick"\n\t\t'
                        }]
                    }
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.elseif",
                        stack: [{
                            type: "Twig.expression.type.variable",
                            value: "copyToClipboard",
                            match: ["copyToClipboard"]
                        }],
                        output: [{
                            type: "raw",
                            value: 'data-event="click->copyToClipboard"\n\t\t\tdata-copy-text="'
                        }, {
                            type: "output_whitespace_both",
                            stack: [{
                                type: "Twig.expression.type.variable",
                                value: "copyText",
                                match: ["copyText"]
                            }, {
                                type: "Twig.expression.type.filter",
                                value: "default",
                                match: ["|default", "default"],
                                params: [{
                                    type: "Twig.expression.type.parameter.start",
                                    value: "(",
                                    match: ["("]
                                }, {
                                    type: "Twig.expression.type.variable",
                                    value: "text",
                                    match: ["text"]
                                }, {
                                    type: "Twig.expression.type.parameter.end",
                                    value: ")",
                                    match: [")"],
                                    expression: !1
                                }]
                            }]
                        }, {
                            type: "raw",
                            value: '"'
                        }]
                    }
                }, {
                    type: "raw",
                    value: "\t>\n"
                }]
            }
        }, {
            type: "raw",
            value: '<span class="cta__text">'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "text",
                match: ["text"]
            }, {
                type: "Twig.expression.type.filter",
                value: "default",
                match: ["|default", "default"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: "Button text"
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "raw",
            value: "</span>"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "icon",
                    match: ["icon"]
                }, {
                    type: "Twig.expression.type.bool",
                    value: !1
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "!=",
                    precidence: 9,
                    associativity: "leftToRight",
                    operator: "!="
                }],
                output: [{
                    type: "raw",
                    value: '\t\t<span class="cta__icon">\n\t\t\t<svg>\n\t\t\t\t<use xlink:href="'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.string",
                        value: "#"
                    }, {
                        type: "Twig.expression.type.variable",
                        value: "icon",
                        match: ["icon"]
                    }, {
                        type: "Twig.expression.type.filter",
                        value: "default",
                        match: ["|default", "default"],
                        params: [{
                            type: "Twig.expression.type.parameter.start",
                            value: "(",
                            match: ["("]
                        }, {
                            type: "Twig.expression.type.string",
                            value: "icon_arrow"
                        }, {
                            type: "Twig.expression.type.parameter.end",
                            value: ")",
                            match: [")"],
                            expression: !1
                        }]
                    }, {
                        type: "Twig.expression.type.operator.binary",
                        value: "~",
                        precidence: 6,
                        associativity: "leftToRight",
                        operator: "~"
                    }]
                }, {
                    type: "raw",
                    value: '">\n\t\t\t</svg>\n\n\t\t\t'
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.if",
                        stack: [{
                            type: "Twig.expression.type.variable",
                            value: "copyToClipboard",
                            match: ["copyToClipboard"]
                        }],
                        output: [{
                            type: "raw",
                            value: '<span class="cta__tooltip" ref="callToActionTooltip">'
                        }, {
                            type: "output_whitespace_both",
                            stack: [{
                                type: "Twig.expression.type.variable",
                                value: "copyText",
                                match: ["copyText"]
                            }, {
                                type: "Twig.expression.type.filter",
                                value: "default",
                                match: ["|default", "default"],
                                params: [{
                                    type: "Twig.expression.type.parameter.start",
                                    value: "(",
                                    match: ["("]
                                }, {
                                    type: "Twig.expression.type.variable",
                                    value: "text",
                                    match: ["text"]
                                }, {
                                    type: "Twig.expression.type.parameter.end",
                                    value: ")",
                                    match: [")"],
                                    expression: !1
                                }]
                            }]
                        }, {
                            type: "raw",
                            value: "</span>"
                        }]
                    }
                }, {
                    type: "raw",
                    value: "\t\t</span>\n\n\t"
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "url",
                    match: ["url"]
                }],
                output: [{
                    type: "raw",
                    value: "\t</a>\n"
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.else",
                match: ["else"],
                output: [{
                    type: "raw",
                    value: "\t</button>\n"
                }]
            }
        }],
        id: "src/app/components/call-to-action/call-to-action.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/call-to-action/call-to-action.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "events",
                expression: [{
                    type: "Twig.expression.type.string",
                    value: "mouseenter->playAnim"
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "unlocked",
                    match: ["unlocked"]
                }],
                output: [{
                    type: "raw",
                    value: "\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.set",
                        key: "events",
                        expression: [{
                            type: "Twig.expression.type.string",
                            value: "click->close, mouseenter->playAnim"
                        }]
                    }
                }]
            }
        }, {
            type: "raw",
            value: '\n<a\n\tclass="game-entry'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "unlocked",
                match: ["unlocked"]
            }, {
                type: "Twig.expression.type.string",
                value: "  game-entry--unlocked"
            }, {
                type: "Twig.expression.type.string",
                value: "  game-entry--locked"
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: "  game-entry--"
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "gameName",
                match: ["gameName"]
            }]
        }, {
            type: "raw",
            value: '"\n\tref="gameEntry"\n\tdata-event="'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "events",
                match: ["events"]
            }]
        }, {
            type: "raw",
            value: '"\n\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "unlocked",
                    match: ["unlocked"]
                }],
                output: [{
                    type: "raw",
                    value: '\t\thref="game/'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "gameName",
                        match: ["gameName"]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\trel="internal"\n\t'
                }]
            }
        }, {
            type: "raw",
            value: '>\n\n\t<div class="game-entry__anim">\n\t\t<div class="game-entry__anim-inner" ref="gameAnim"></div>\n\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "unlocked",
                    match: ["unlocked"]
                }, {
                    type: "Twig.expression.type.operator.unary",
                    value: "not",
                    precidence: 3,
                    associativity: "rightToLeft",
                    operator: "not"
                }],
                output: [{
                    type: "raw",
                    value: '\t\t\t<span class="game-entry__lock">\n\t\t\t\t<svg focusable="false">\n\t\t\t\t\t<use xlink:href="#element_lock" />\n\t\t\t\t</svg>\n\t\t\t</span>\n\t\t'
                }]
            }
        }, {
            type: "raw",
            value: '\t</div>\n\n\t<div class="game-entry__content">\n\n\t\t<div class="game-entry__title" ref="gameEntryTitle"></div>\n\n\t\t<div class="game-entry__infos">\n\n\t\t\t<div class="game-entry__icons">\n\t\t\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "water",
                    match: ["water"]
                }],
                output: [{
                    type: "raw",
                    value: '\t\t\t\t\t<div class="game-entry__icon  game-entry__icon--drop">\n\t\t\t\t\t\t<svg >\n\t\t\t\t\t\t\t<use xlink:href="#element_water_drop">\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</div>\n\t\t\t\t'
                }]
            }
        }, {
            type: "raw",
            value: "\n\t\t\t\t"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "sun",
                    match: ["sun"]
                }],
                output: [{
                    type: "raw",
                    value: '\t\t\t\t\t<div class="game-entry__icon  game-entry__icon--sun">\n\t\t\t\t\t\t<svg >\n\t\t\t\t\t\t\t<use xlink:href="#element_sun">\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</div>\n\t\t\t\t'
                }]
            }
        }, {
            type: "raw",
            value: '\t\t\t</div>\n\n\t\t\t<p class="game-entry__infos-label">\n\t\t\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "unlocked",
                    match: ["unlocked"]
                }],
                output: [{
                    type: "raw",
                    value: "\t\t\t\t\t"
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "content",
                        match: ["content"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "interface"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "game"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "best_score"
                    }]
                }, {
                    type: "raw",
                    value: ": "
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "best_score",
                        match: ["best_score"]
                    }]
                }, {
                    type: "raw",
                    value: " "
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "content",
                        match: ["content"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "interface"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "game"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "point"
                    }]
                }, {
                    type: "raw",
                    value: "\n\t\t\t\t"
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.else",
                match: ["else"],
                output: [{
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "unlock_guide",
                        match: ["unlock_guide"]
                    }]
                }]
            }
        }, {
            type: "raw",
            value: "\t\t\t</p>\n\t\t</div>\n\t</div>\n\n\t"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "unlocked",
                    match: ["unlocked"]
                }],
                output: [{
                    type: "raw",
                    value: '\t\t<div class="game-entry__play">\n\t\t\t<svg >\n\t\t\t\t<use xlink:href="#icon_play">\n\t\t\t</svg>\n\t\t</div>\n\t'
                }]
            }
        }, {
            type: "raw",
            value: "\n</a>\n"
        }],
        id: "src/app/components/game-entry/game-entry.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/game-entry/game-entry.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, , function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "modifiers",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "split",
                    match: ["|split", "split"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: ", "
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "classNames",
                expression: [{
                    type: "Twig.expression.type.array.start",
                    value: "[",
                    match: ["["]
                }, {
                    type: "Twig.expression.type.array.end",
                    value: "]",
                    match: ["]"]
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.for",
                key_var: null,
                value_var: "item",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }],
                output: [{
                    type: "raw",
                    value: "\n\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.if",
                        stack: [{
                            type: "Twig.expression.type.variable",
                            value: "item",
                            match: ["item"]
                        }, {
                            type: "Twig.expression.type.test",
                            filter: "empty",
                            modifier: "not"
                        }],
                        output: [{
                            type: "raw",
                            value: "\t\t"
                        }, {
                            type: "logic",
                            token: {
                                type: "Twig.logic.type.set",
                                key: "classNames",
                                expression: [{
                                    type: "Twig.expression.type.variable",
                                    value: "classNames",
                                    match: ["classNames"]
                                }, {
                                    type: "Twig.expression.type.filter",
                                    value: "merge",
                                    match: ["|merge", "merge"],
                                    params: [{
                                        type: "Twig.expression.type.parameter.start",
                                        value: "(",
                                        match: ["("]
                                    }, {
                                        type: "Twig.expression.type.array.start",
                                        value: "[",
                                        match: ["["]
                                    }, {
                                        type: "Twig.expression.type.string",
                                        value: "  bodymovin--"
                                    }, {
                                        type: "Twig.expression.type.variable",
                                        value: "item",
                                        match: ["item"]
                                    }, {
                                        type: "Twig.expression.type.operator.binary",
                                        value: "~",
                                        precidence: 6,
                                        associativity: "leftToRight",
                                        operator: "~"
                                    }, {
                                        type: "Twig.expression.type.array.end",
                                        value: "]",
                                        match: ["]"]
                                    }, {
                                        type: "Twig.expression.type.parameter.end",
                                        value: ")",
                                        match: [")"],
                                        expression: !1
                                    }]
                                }]
                            }
                        }, {
                            type: "raw",
                            value: "\t"
                        }]
                    }
                }, {
                    type: "raw",
                    value: "\n"
                }]
            }
        }, {
            type: "raw",
            value: '\n<div\n\tclass="bodymovin'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "classNames",
                match: ["classNames"]
            }, {
                type: "Twig.expression.type.filter",
                value: "join",
                match: ["|join", "join"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: ""
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "raw",
            value: '"\n\tref="bodymovin"\n></div>\n'
        }],
        id: "src/app/components/bodymovin/bodymovin.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/bodymovin/bodymovin.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e) {
    e.exports = JSON.parse('{"transition_whoosh":{"files":[[0,2.3736961451247165]]},"transition_left_close":{"files":[[3.5,0.5180725623582765],[5,0.4474376417233561],[6.5,0.41634920634920647]]},"transition_left_open":{"files":[[8,0.4366666666666674],[9.5,0.4014058956916102],[11,0.42716553287981895]]},"transition_right_close":{"files":[[12.5,0.4626530612244899],[14,0.46353741496598566],[15.5,0.5]]},"transition_right_open":{"files":[[17,0.38866213151927553],[18.5,0.4680272108843546],[20,0.3718367346938791]]},"game_menu_open":{"files":[[21.5,0.5608163265306132]]},"game_menu_close":{"files":[[23,0.3186167800453532]]},"game_menu_validate":{"files":[[24.5,0.644240362811793]]},"panel_left_open":{"files":[[26,0.549863945578231],[27.5,0.39950113378684904],[29,0.41841269841269835]]},"panel_left_close":{"files":[[30.5,0.41210884353741406],[32,0.46766439909296764],[33.5,0.41063492063491935]]},"panel_right_open":{"files":[[35,0.38698412698412454],[36.5,0.5],[38,0.4012018140589575]]},"panel_right_close":{"files":[[39.5,0.4133106575963694],[41,0.3799092970521514],[42.5,0.4460770975056718]]},"mouse_hover":{"files":[[44,0.12501133786847873]]},"gift_click":{"files":[[45.5,1.1577551020408166]]},"bag_open":{"files":[[48,1.6092743764172326]]},"bag_unlock":{"files":[[50.5,0.9032879818594068]]},"level_up":{"files":[[52,1.309682539682541]]},"seed_hitground":{"files":[[54.5,0.24616780045351305]]},"game_end":{"files":[[56,2.5562585034013594]]},"bubble_need_love":{"files":[[59.5,0.39857142857142946]]},"bubble_need_sun":{"files":[[61,0.9264172335600875]]},"bubble_need_water":{"files":[[62.5,0.7908843537414967]]},"bubble_pop":{"files":[[64,0.5300000000000011],[65.5,0.49997732426304253],[67,0.47789115646259006]]},"give_love":{"files":[[68.5,0.9663718820861646]]},"give_sun":{"files":[[70,2.881564625850345],[73.5,3.2803628117913775],[78,2.992721088435374]]},"give_water":{"files":[[81.5,2.718888888888884],[85,3.4823129251700635],[89.5,3.5682312925170123],[94,3.767505668934234]]},"give_empty":{"files":[[98.5,0.2833786848072606],[100,0.29165532879818556],[101.5,0.2600907029478492],[103,0.2901814058956944],[104.5,0.26891156462585286],[106,0.28718820861678296]]},"get_sun":{"files":[[107.5,1.0214965986394589],[110,1.0214965986394589],[112.5,1.0214965986394589]]},"get_water":{"files":[[115,0.8841269841269792],[116.5,0.8841269841269792],[118,0.8841269841269792]]},"minigame_whoosh":{"files":[[119.5,2.3554875283446677]]},"bucket_waterdrop":{"files":[[123,0.3455328798185917],[124.5,0.47691609977324845],[126,0.5875736961451281]]},"cater_appear":{"files":[[127.5,0.45392290249432676],[129,0.4646031746031838],[130.5,0.45392290249432676]]},"cater_click":{"files":[[132,0.6035147392290128],[133.5,0.6035147392290128],[135,0.6833786848072521]]},"spider_click":{"files":[[136.5,1.054852607709762],[139,1.017233560090716],[141.5,1.2001360544217619]]},"music_loop":{"loop":true,"files":["music_loop"]},"bucket_rain_loop":{"loop":true,"files":["bucket_rain_loop"]},"amandier1_action":{"files":[[144,0.5],[145.5,0.5],[147,0.5]]},"amandier1_request":{"files":[[144,0.5],[145.5,0.5],[147,0.5]]},"amandier2_action":{"files":[[148.5,0.5],[150,0.5],[151.5,1]]},"amandier2_request":{"files":[[153,0.7334693877550933]]},"amandier3_action":{"files":[[154.5,0.5],[156,0.5330839002267567],[157.5,0.5330839002267567]]},"amandier3_request":{"files":[[159,0.5]]},"immortelle1_action":{"files":[[160.5,0.4344897959183811],[162,0.45653061224490443],[163.5,0.5116780045351561]]},"immortelle1_request":{"files":[[160.5,0.4344897959183811],[162,0.45653061224490443],[163.5,0.5116780045351561]]},"immortelle2_action":{"files":[[165,0.42111111111111654],[166.5,0.45401360544218505],[168,0.4209297052154284]]},"immortelle2_request":{"files":[[169.5,0.4344897959183811]]},"immortelle3_action":{"files":[[171,0.6868480725623556],[172.5,0.6049433106576032],[174,0.7309523809523739]]},"immortelle3_request":{"files":[[175.5,0.7316099773242684]]},"rose1_action":{"files":[[177,0.4668480725623567],[178.5,0.5591836734693914],[180,0.765124716553288]]},"rose1_request":{"files":[[177,0.4668480725623567],[178.5,0.5591836734693914],[180,0.765124716553288]]},"rose2_action":{"files":[[181.5,0.8769614512471549],[183,0.5829024943310799],[184.5,0.6172335600907104]]},"rose2_request":{"files":[[186,0.736848072562367]]},"rose3_action":{"files":[[187.5,0.8897052154194967],[189,0.6239682539682576],[190.5,0.8921768707483011]]},"rose3_request":{"files":[[192,0.8585941043083949]]},"cerisier1_action":{"files":[[193.5,0.4480498866213054],[195,0.44916099773243445],[196.5,0.3788435374149799]]},"cerisier1_request":{"files":[[193.5,0.4480498866213054],[195,0.44916099773243445],[196.5,0.3788435374149799]]},"cerisier2_action":{"files":[[198,0.5826530612244767],[199.5,0.5580045351474041],[201,0.4971201814059043]]},"cerisier2_request":{"files":[[202.5,0.5249886621315056]]},"cerisier3_action":{"files":[[204,0.6047845804988583],[205.5,0.6777324263038622],[207,0.5]]},"cerisier3_request":{"files":[[208.5,1]]},"verveine1_action":{"files":[[210,0.4678684807256275],[211.5,0.438594104308379],[213,0.5204761904761881]]},"verveine1_request":{"files":[[210,0.4678684807256275],[211.5,0.438594104308379],[213,0.5204761904761881]]},"verveine2_action":{"files":[[214.5,0.41306122448980886],[216,0.37537414965987637],[217.5,0.39857142857141525]]},"verveine2_request":{"files":[[219,0.560022675736974]]},"verveine3_action":{"files":[[220.5,0.5822448979591854],[222,0.4940136054421771],[223.5,0.539387755102041]]},"verveine3_request":{"files":[[225,0.8861224489795916]]},"karite1_action":{"files":[[226.5,0.3226984126984007],[228,0.5],[229.5,0.5]]},"karite1_request":{"files":[[226.5,0.3226984126984007],[228,0.5],[229.5,0.5]]},"karite2_action":{"files":[[231,0.5673242630385573],[232.5,0.6736507936508076],[234,0.5]]},"karite2_request":{"files":[[235.5,1]]},"karite3_action":{"files":[[237,0.9451927437641814],[238.5,1.5],[241,1.5293197278911634]]},"karite3_request":{"files":[[243.5,1.3157142857142787]]},"starter_navigate":{"files":[[246,0.534172335600914],[247.5,0.5070748299319803]]},"starter_validate":{"files":[[249,0.47714285714286575]]},"intro_validate":{"files":[[250.5,0.4618820861678046]]},"intro_fall":{"files":[[252,3.667641723356013]]},"intro_impact":{"files":[[256.5,2.940907029478467]]}}')
}
, function(e, t, i) {
    const n = i(52)
      , r = .05 * Math.log(10);
    function s(e) {
        return Math.exp(e * r)
    }
    const a = n.seeds.map(e => e.id)
      , o = {
        transition_whoosh: {
            file: "UI_toFirstSeedSelection_Whoosh",
            volume: s(8)
        },
        transition_left_close: {
            file: "transition_left_close",
            volume: s(2)
        },
        transition_left_open: {
            file: "transition_left_open",
            volume: s(2)
        },
        transition_right_close: {
            file: "transition_right_close",
            volume: s(2)
        },
        transition_right_open: {
            file: "transition_right_open",
            volume: s(2)
        },
        game_menu_open: {
            file: "UI_gameMenu_open",
            volume: s(2)
        },
        game_menu_close: {
            file: "UI_gameMenu_close",
            volume: s(2)
        },
        game_menu_validate: {
            file: "UI_gameMenu_validate",
            volume: s(2)
        },
        panel_left_open: {
            file: "UI_sideMenu_left_open",
            volume: s(6)
        },
        panel_left_close: {
            file: "UI_sideMenu_left_close",
            volume: s(6)
        },
        panel_right_open: {
            file: "UI_sideMenu_right_open",
            volume: s(6)
        },
        panel_right_close: {
            file: "UI_sideMenu_right_close",
            volume: s(6)
        },
        mouse_hover: {
            file: "UI_mouseOver",
            randomPitch: [-.05, .15],
            volume: s(8)
        }
    }
      , l = {
        gift_click: {
            file: "UI_gift_click",
            volume: s(8)
        },
        bag_open: {
            file: "bag_open",
            volume: s(4)
        },
        bag_unlock: {
            file: "bag_unlock",
            volume: s(8)
        },
        level_up: {
            file: "levelUp",
            volume: s(8)
        },
        seed_hitground: {
            file: "seed_hitground",
            volume: s(8)
        },
        game_end: {
            file: "miniGame_end",
            volume: s(8)
        }
    }
      , c = {
        bubble_need_love: {
            file: "bubble_need_love",
            volume: s(6)
        },
        bubble_need_sun: {
            file: "bubble_need_sun",
            volume: s(6)
        },
        bubble_need_water: {
            file: "bubble_need_water",
            volume: s(6)
        },
        bubble_pop: {
            file: "bubble_pop",
            volume: s(6)
        },
        give_love: {
            file: "give_love",
            volume: s(8)
        },
        give_sun: {
            file: "give_sun",
            volume: s(8)
        },
        give_water: {
            file: "give_water",
            volume: s(8)
        },
        give_empty: {
            file: "UI_ressources_empty",
            volume: s(8)
        },
        get_sun: {
            file: "UI_ressources_getSun",
            randomPitch: [-.025, .025],
            maxCount: 3,
            volume: s(8)
        },
        get_water: {
            file: "UI_ressources_getWater",
            randomPitch: [-.025, .025],
            maxCount: 3,
            volume: s(8)
        }
    }
      , h = {
        minigame_whoosh: {
            file: "miniGame_whoosh_transition",
            maxCount: 1,
            volume: s(8)
        },
        bucket_waterdrop: {
            file: "bucket_waterDrop",
            randomPitch: [.5, 1.5],
            volume: s(-2),
            maxCount: 3
        },
        cater_appear: {
            file: "cater_appear",
            maxCount: 3,
            volume: s(8)
        },
        cater_click: {
            file: "cater_click",
            maxCount: 3,
            volume: s(8)
        },
        spider_click: {
            file: "spider_click",
            maxCount: 3,
            volume: s(8)
        }
    }
      , u = {
        music_loop: {
            file: "music_loop",
            loop: !0,
            volume: s(4)
        },
        bucket_rain_loop: {
            file: "bucket_rain_loop",
            loop: !0,
            volume: s(5)
        }
    }
      , p = {
        starter_navigate: {
            file: "UI_firstSeed_navigate",
            maxCount: 2,
            volume: s(8)
        },
        starter_validate: {
            file: "UI_firstSeed_validate",
            volume: s(8)
        },
        intro_validate: {
            file: "UI_toFirstSeedSelection_Validate",
            volume: s(8)
        },
        intro_fall: {
            file: "intro_seed_fall",
            volume: s(8)
        },
        intro_impact: {
            file: "intro_seed_Impact",
            volume: s(8)
        }
    }
      , d = a.reduce( (e, t) => {
        const i = t;
        if ("lavande" === i || "cedrat" === i)
            return e;
        const n = {};
        for (let e = 1; e < 4; e++) {
            const t = i + e;
            n[t + "_action"] = {
                file: t + "_action",
                volume: s(5)
            },
            n[t + "_request"] = {
                file: e > 1 ? t + "_request" : t + "_action",
                volume: s(5)
            }
        }
        return Object.assign(e, n)
    }
    , {});
    e.exports = Object.assign({}, o, l, c, h, u, d, p)
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<header class="header" ref="header">\n\t<div class="wrapper">\n\t\t<div class="header__inner" ref="headerInner"></div>\n\t</div>\n</header>\n'
        }],
        id: "src/app/blocks/header/header.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/blocks/header/header.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {}
, function(e, t, i) {
    i(68);
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "logic",
            token: {
                type: "Twig.logic.type.extends",
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "src/app/components/header-button/header-button.twig"
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.block",
                block: "innerOpenIcon",
                output: [{
                    type: "raw",
                    value: '<div\n\t\tclass="header__button-notification"\n\t\tdata-store="unlockedSeeds->updateNotif"\n\t\tref="notif"\n\t>'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.string",
                        value: "1"
                    }]
                }, {
                    type: "raw",
                    value: "</div>"
                }]
            }
        }],
        id: "src/app/components/header-garden-button/header-garden-button.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/header-garden-button/header-garden-button.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    i(180),
    i(181),
    i(78),
    i(182);
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "modifiers",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "split",
                    match: ["|split", "split"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: ", "
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "classNames",
                expression: [{
                    type: "Twig.expression.type.array.start",
                    value: "[",
                    match: ["["]
                }, {
                    type: "Twig.expression.type.array.end",
                    value: "]",
                    match: ["]"]
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "references",
                expression: [{
                    type: "Twig.expression.type.array.start",
                    value: "[",
                    match: ["["]
                }, {
                    type: "Twig.expression.type.array.end",
                    value: "]",
                    match: ["]"]
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.for",
                key_var: null,
                value_var: "item",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }],
                output: [{
                    type: "raw",
                    value: "\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.set",
                        key: "classNames",
                        expression: [{
                            type: "Twig.expression.type.variable",
                            value: "classNames",
                            match: ["classNames"]
                        }, {
                            type: "Twig.expression.type.filter",
                            value: "merge",
                            match: ["|merge", "merge"],
                            params: [{
                                type: "Twig.expression.type.parameter.start",
                                value: "(",
                                match: ["("]
                            }, {
                                type: "Twig.expression.type.array.start",
                                value: "[",
                                match: ["["]
                            }, {
                                type: "Twig.expression.type.string",
                                value: "  panel--"
                            }, {
                                type: "Twig.expression.type.variable",
                                value: "item",
                                match: ["item"]
                            }, {
                                type: "Twig.expression.type.operator.binary",
                                value: "~",
                                precidence: 6,
                                associativity: "leftToRight",
                                operator: "~"
                            }, {
                                type: "Twig.expression.type.array.end",
                                value: "]",
                                match: ["]"]
                            }, {
                                type: "Twig.expression.type.parameter.end",
                                value: ")",
                                match: [")"],
                                expression: !1
                            }]
                        }]
                    }
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.for",
                key_var: null,
                value_var: "item",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "ref",
                    match: ["ref"]
                }],
                output: [{
                    type: "raw",
                    value: "\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.set",
                        key: "references",
                        expression: [{
                            type: "Twig.expression.type.variable",
                            value: "references",
                            match: ["references"]
                        }, {
                            type: "Twig.expression.type.filter",
                            value: "merge",
                            match: ["|merge", "merge"],
                            params: [{
                                type: "Twig.expression.type.parameter.start",
                                value: "(",
                                match: ["("]
                            }, {
                                type: "Twig.expression.type.array.start",
                                value: "[",
                                match: ["["]
                            }, {
                                type: "Twig.expression.type.string",
                                value: ", "
                            }, {
                                type: "Twig.expression.type.variable",
                                value: "item",
                                match: ["item"]
                            }, {
                                type: "Twig.expression.type.operator.binary",
                                value: "~",
                                precidence: 6,
                                associativity: "leftToRight",
                                operator: "~"
                            }, {
                                type: "Twig.expression.type.array.end",
                                value: "]",
                                match: ["]"]
                            }, {
                                type: "Twig.expression.type.parameter.end",
                                value: ")",
                                match: [")"],
                                expression: !1
                            }]
                        }]
                    }
                }]
            }
        }, {
            type: "raw",
            value: '\n<div\n\tclass="panel'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "classNames",
                match: ["classNames"]
            }, {
                type: "Twig.expression.type.filter",
                value: "join",
                match: ["|join", "join"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: ""
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "raw",
            value: '"\n\tref="panel'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "references",
                match: ["references"]
            }, {
                type: "Twig.expression.type.filter",
                value: "join",
                match: ["|join", "join"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: ""
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "raw",
            value: '"\n>\n\n\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "left"
                }, {
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "in",
                    precidence: 8,
                    associativity: "leftToRight",
                    operator: "in"
                }],
                output: [{
                    type: "raw",
                    value: '\t\t<div class="panel__logo">\n\t\t\t<svg class="footer__logo">\n\t\t\t\t<use xlink:href="#logo_loccitane" />\n\t\t\t</svg>\n\t\t</div>\n\t'
                }]
            }
        }, {
            type: "raw",
            value: '\n\t<div class="panel__bg  panel__bg--'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.string",
                value: "left"
            }, {
                type: "Twig.expression.type.variable",
                value: "modifiers",
                match: ["modifiers"]
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "in",
                precidence: 8,
                associativity: "leftToRight",
                operator: "in"
            }, {
                type: "Twig.expression.type.string",
                value: "left"
            }, {
                type: "Twig.expression.type.string",
                value: "right"
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: '" ref="panelBg">\n\t\t<div class="panel__bg-image" ref="panelBgImg">\n\t\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.include",
                only: !1,
                ignoreMissing: !1,
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "src/app/components/svg/bg_top.twig"
                }]
            }
        }, {
            type: "raw",
            value: "\t\t</div>\n\n\t\t"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "left"
                }, {
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "in",
                    precidence: 8,
                    associativity: "leftToRight",
                    operator: "in"
                }],
                output: [{
                    type: "raw",
                    value: "\t\t\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.include",
                        only: !1,
                        ignoreMissing: !1,
                        stack: [{
                            type: "Twig.expression.type.string",
                            value: "src/app/components/svg/wave_left.twig"
                        }]
                    }
                }, {
                    type: "raw",
                    value: '\n\t\t\t<div class="panel__bg-voucher" ref="voucherBg">\n\t\t\t\t<div class="panel__bg-voucher-inner">\n\t\t\t\t\t'
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.include",
                        only: !1,
                        ignoreMissing: !1,
                        stack: [{
                            type: "Twig.expression.type.string",
                            value: "src/app/components/svg/popin_bg.twig"
                        }]
                    }
                }, {
                    type: "raw",
                    value: "\t\t\t\t</div>\n\t\t\t</div>\n\t\t"
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.else",
                match: ["else"],
                output: [{
                    type: "raw",
                    value: "\t\t\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.include",
                        only: !1,
                        ignoreMissing: !1,
                        stack: [{
                            type: "Twig.expression.type.string",
                            value: "src/app/components/svg/wave_right.twig"
                        }]
                    }
                }, {
                    type: "raw",
                    value: "\t\t"
                }]
            }
        }, {
            type: "raw",
            value: '\n\t</div>\n\n\t<div class="panel__content" ref="panelContent"></div>\n\t<div\n\t\tclass="panel__close"\n\t\tref="panelClose"\n\t\tdata-event="click->closePanel"\n\t\tdata-bypass-touch\n\t></div>\n\n</div>\n'
        }],
        id: "src/app/blocks/panel/panel.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/blocks/panel/panel.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, , function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div class="scroll" ref="scroll">\n\t<div class="scroll__inner" ref="scrollInner"></div>\n</div>\n'
        }],
        id: "src/app/components/scroll/scroll.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/scroll/scroll.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div class="challenge" ref="challenge">\n\t<div class="challenge__text" ref="challengeText">'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "text",
                match: ["text"]
            }, {
                type: "Twig.expression.type.filter",
                value: "default",
                match: ["|default", "default"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: "Challenge text"
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "raw",
            value: "</div>\n</div>"
        }],
        id: "src/app/components/challenge/challenge.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/challenge/challenge.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div\n\tclass="voucher"\n\tref="voucher"\n\tdata-event="click->goToVoucher, mouseenter->playOnRollover"\n\tdata-bypass-touch\n>\n\n\t<div class="voucher__anim" ref="voucherAnim">\n\t\t<div class="voucher__anim-bg"></div>\n\t</div>\n\n\t<div class="voucher__content" ref="voucherContent">\n\t\t<span class="voucher__code" ref="voucherCode">'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "voucherCode",
                match: ["voucherCode"]
            }, {
                type: "Twig.expression.type.filter",
                value: "default",
                match: ["|default", "default"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: "XXXX XXX"
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "raw",
            value: "</span>\n\t</div>\n</div>"
        }],
        id: "src/app/components/voucher/voucher.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/voucher/voucher.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    i(183);
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div class="voucher-details" ref="voucherDetails">\n\t<div class="voucher-details__header">\n\t\t<div class="voucher-details__picture">\n\t\t\t<img\n\t\t\t\tdata-src="'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "voucher",
                match: ["voucher"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "image"
            }, {
                type: "Twig.expression.type.variable",
                value: "voucher",
                match: ["voucher"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "image"
            }, {
                type: "Twig.expression.type.variable",
                value: "assets",
                match: ["assets"]
            }, {
                type: "Twig.expression.type.key.brackets",
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "app.static/images/product_image.jpg"
                }]
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: '"\n\t\t\t\talt="'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "voucher",
                match: ["voucher"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "title"
            }]
        }, {
            type: "raw",
            value: '"\n\t\t\t\tref="voucherImage"\n\t\t\t>\n\n\t\t\t<svg width="58.79" height="61.969">\n\t\t\t\t<clipPath id="bubble">\n\t\t\t\t\t<path d="M18.09 6.825S3.35 12.602.48 29.102a26.843 26.843 0 0 0 17.07 30.233c8.84 3.2 22.21 6.15 34.16-8.486s9.79-37.4-13.88-46.146c0 0-12.26-2.55-19.74 2.122z" fill-rule="evenodd"/>\n\t\t\t\t</clipPath>\n\t\t\t</svg>\n\t\t</div>\n\t\t<div class="voucher-details__infos" ref="voucherInfos">\n\t\t\t<p class="voucher-details__title">'
        }, {
            type: "output_whitespace_pre",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "voucher",
                match: ["voucher"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "title"
            }]
        }, {
            type: "raw",
            value: " <span>"
        }, {
            type: "output_whitespace_post",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "voucher",
                match: ["voucher"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "description"
            }]
        }, {
            type: "raw",
            value: '</span>\n\t\t\t</p>\n\t\t</div>\n\t</div>\n\t<div class="voucher-details__content">\n\t\t<div class="voucher-details__seed">\n\t\t\t<div class="voucher-details__seed-anim" ref="seedAnim"></div>\n\t\t\t<div class="voucher-details__seed-bg">'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.include",
                only: !1,
                ignoreMissing: !1,
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "src/app/components/svg/feuille.twig"
                }]
            }
        }, {
            type: "raw",
            value: '</div>\n\t\t</div>\n\t\t<div class="voucher-details__desc" ref="voucherDesc">\n\t\t\t<p>'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "seedDescription",
                match: ["seedDescription"]
            }]
        }, {
            type: "raw",
            value: "</p>\n\t\t</div>\n\t</div>\n</div>"
        }],
        id: "src/app/components/voucher-details/voucher-details.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/voucher-details/voucher-details.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div class="login" ref="login">'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "fb_connect",
                    match: ["fb_connect"]
                }, {
                    type: "Twig.expression.type.variable",
                    value: "line_connect",
                    match: ["line_connect"]
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "or",
                    precidence: 14,
                    associativity: "leftToRight",
                    operator: "or"
                }],
                output: [{
                    type: "raw",
                    value: '<div class="login__social" ref="socialButtons"></div>\n\n\t\t<p class="login__social-error">'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "content",
                        match: ["content"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "interface"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "form"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "social_connect_error"
                    }]
                }, {
                    type: "raw",
                    value: '</p>\n\n\t\t<div class="login__separator">\n\t\t\t<span>'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "content",
                        match: ["content"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "interface"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "connection"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "or"
                    }, {
                        type: "Twig.expression.type.filter",
                        value: "default",
                        match: ["|default", "default"],
                        params: [{
                            type: "Twig.expression.type.parameter.start",
                            value: "(",
                            match: ["("]
                        }, {
                            type: "Twig.expression.type.string",
                            value: "or"
                        }, {
                            type: "Twig.expression.type.parameter.end",
                            value: ")",
                            match: [")"],
                            expression: !1
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '</span>\n\t\t\t<div class="login__separator-line">\n\t\t\t\t<svg focusable="false">\n\t\t\t\t\t<use xlink:href="#element_draw" />\n\t\t\t\t</svg>\n\t\t\t</div>\n\t\t</div>'
                }]
            }
        }, {
            type: "raw",
            value: '<form\n\t\tclass="login__form"\n\t\tref="form"\n\t\tnoValidate\n\t\tdata-event="submit->onAskLoginEmail"\n\t>\n\t\t<div ref="formFields"></div>\n\n\t\t<div class="login__form-error" ref="formError">'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "interface"
            }, {
                type: "Twig.expression.type.key.period",
                key: "form"
            }, {
                type: "Twig.expression.type.key.period",
                key: "form_error"
            }]
        }, {
            type: "raw",
            value: "</div>\n\t</form>\n</div>"
        }],
        id: "src/app/components/login/login.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/login/login.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    i(80);
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div\n\tclass="input  input--'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "type",
                match: ["type"]
            }, {
                type: "Twig.expression.type.filter",
                value: "default",
                match: ["|default", "default"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: "text"
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.string",
                value: "hidden"
            }, {
                type: "Twig.expression.type.variable",
                value: "type",
                match: ["type"]
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "in",
                precidence: 8,
                associativity: "leftToRight",
                operator: "in"
            }, {
                type: "Twig.expression.type.string",
                value: "  input--hidden"
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: '"\n\tref="inputText"\n>\n\t<input\n\t\tid="'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "name",
                match: ["name"]
            }]
        }, {
            type: "raw",
            value: '"\n\t\tname="'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "name",
                match: ["name"]
            }]
        }, {
            type: "raw",
            value: '"\n\t\ttype="'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "type",
                match: ["type"]
            }, {
                type: "Twig.expression.type.filter",
                value: "default",
                match: ["|default", "default"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: "text"
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "raw",
            value: '"\n\t\tplaceholder="'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "placeholder",
                match: ["placeholder"]
            }]
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "required",
                match: ["required"]
            }, {
                type: "Twig.expression.type.string",
                value: " *"
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: '"\n\t\t'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "required",
                match: ["required"]
            }, {
                type: "Twig.expression.type.string",
                value: "required"
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: "\n\t\t"
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "type",
                match: ["type"]
            }, {
                type: "Twig.expression.type.string",
                value: "email"
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "==",
                precidence: 9,
                associativity: "leftToRight",
                operator: "=="
            }, {
                type: "Twig.expression.type.string",
                value: 'pattern="[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,10}"'
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: '\n\t\tref="'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "name",
                match: ["name"]
            }]
        }, {
            type: "raw",
            value: '"\n\t>\n\n\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.include",
                only: !1,
                ignoreMissing: !1,
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "src/app/components/field-frame/field-frame.twig"
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "type",
                    match: ["type"]
                }, {
                    type: "Twig.expression.type.string",
                    value: "checkbox"
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "==",
                    precidence: 9,
                    associativity: "leftToRight",
                    operator: "=="
                }],
                output: [{
                    type: "raw",
                    value: '\t\t<div class="input__tick">\n\t\t\t<svg focusable="false">\n\t\t\t\t<use xlink:href="#icon_check" />\n\t\t\t</svg>\n\t\t</div>\n\n\t\t<label\n\t\t\tclass="input__label"\n\t\t\tfor="'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "name",
                        match: ["name"]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\t\tdata-bypass-touch\n\t\t>'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "label",
                        match: ["label"]
                    }, {
                        type: "Twig.expression.type.filter",
                        value: "raw",
                        match: ["|raw", "raw"]
                    }]
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "required",
                        match: ["required"]
                    }, {
                        type: "Twig.expression.type.string",
                        value: " *"
                    }, {
                        type: "Twig.expression.type.operator.binary",
                        value: "?",
                        precidence: 16,
                        associativity: "rightToLeft",
                        operator: "?"
                    }]
                }, {
                    type: "raw",
                    value: "\n\t\t</label>\n\t"
                }]
            }
        }, {
            type: "raw",
            value: "\n</div>\n"
        }],
        id: "src/app/components/input/input.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/input/input.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div class="register" ref="register">\n\n\t<form\n\t\tclass="register__form"\n\t\tnoValidate\n\t\tdata-event="submit->onFormSubmit"\n\t>\n\t\t<div class="register__form-fields" ref="formFields"></div>'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "content",
                    match: ["content"]
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "interface"
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "form"
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "mandatory_fields"
                }],
                output: [{
                    type: "raw",
                    value: '<div class="register__form-mention  register__form-mention--mandatory">'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.string",
                        value: "* "
                    }, {
                        type: "Twig.expression.type.variable",
                        value: "content",
                        match: ["content"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "interface"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "form"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "mandatory_fields"
                    }, {
                        type: "Twig.expression.type.operator.binary",
                        value: "~",
                        precidence: 6,
                        associativity: "leftToRight",
                        operator: "~"
                    }]
                }, {
                    type: "raw",
                    value: "</div>"
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "content",
                    match: ["content"]
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "interface"
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "form"
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "form_error"
                }],
                output: [{
                    type: "raw",
                    value: '<div class="register__form-error" ref="formError">\n\t\t\t\t<p>'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "content",
                        match: ["content"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "interface"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "form"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "form_error"
                    }]
                }, {
                    type: "raw",
                    value: "</p>\n\t\t\t</div>"
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "content",
                    match: ["content"]
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "interface"
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "form"
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "mention"
                }],
                output: [{
                    type: "raw",
                    value: '<div class="register__form-mention  register__form-mention--legals">'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "content",
                        match: ["content"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "interface"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "form"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "mention"
                    }]
                }, {
                    type: "raw",
                    value: "</div>"
                }]
            }
        }, {
            type: "raw",
            value: "\t</form>\n\n</div>\n"
        }],
        id: "src/app/components/register/register.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/register/register.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    i(80);
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div class="select" ref="select">\n\n\t<select\n\t\tclass="select__select"\n\t\t'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "name",
                match: ["name"]
            }, {
                type: "Twig.expression.type.string",
                value: 'name="'
            }, {
                type: "Twig.expression.type.variable",
                value: "name",
                match: ["name"]
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "~",
                precidence: 6,
                associativity: "leftToRight",
                operator: "~"
            }, {
                type: "Twig.expression.type.string",
                value: '"'
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "~",
                precidence: 6,
                associativity: "leftToRight",
                operator: "~"
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: '\n\t\tdata-event="change->onChange"\n\t\t'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "required",
                match: ["required"]
            }, {
                type: "Twig.expression.type.string",
                value: "required"
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: ">"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.for",
                key_var: null,
                value_var: "item",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "options",
                    match: ["options"]
                }],
                output: [{
                    type: "raw",
                    value: "\n\t\t\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.set",
                        key: "isSelected",
                        expression: [{
                            type: "Twig.expression.type.variable",
                            value: "item",
                            match: ["item"]
                        }, {
                            type: "Twig.expression.type.key.period",
                            key: "value"
                        }, {
                            type: "Twig.expression.type.variable",
                            value: "defaultValue",
                            match: ["defaultValue"]
                        }, {
                            type: "Twig.expression.type.operator.binary",
                            value: "==",
                            precidence: 9,
                            associativity: "leftToRight",
                            operator: "=="
                        }, {
                            type: "Twig.expression.type.string",
                            value: " selected"
                        }, {
                            type: "Twig.expression.type.operator.binary",
                            value: "?",
                            precidence: 16,
                            associativity: "rightToLeft",
                            operator: "?"
                        }]
                    }
                }, {
                    type: "raw",
                    value: "\n\t\t\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.if",
                        stack: [{
                            type: "Twig.expression.type.variable",
                            value: "loop",
                            match: ["loop"]
                        }, {
                            type: "Twig.expression.type.key.period",
                            key: "first"
                        }],
                        output: [{
                            type: "raw",
                            value: "\n\t\t\t\t"
                        }, {
                            type: "logic",
                            token: {
                                type: "Twig.logic.type.set",
                                key: "isSelected",
                                expression: [{
                                    type: "Twig.expression.type.variable",
                                    value: "placeholder",
                                    match: ["placeholder"]
                                }, {
                                    type: "Twig.expression.type.variable",
                                    value: "defaultValue",
                                    match: ["defaultValue"]
                                }, {
                                    type: "Twig.expression.type.operator.binary",
                                    value: "==",
                                    precidence: 9,
                                    associativity: "leftToRight",
                                    operator: "=="
                                }, {
                                    type: "Twig.expression.type.string",
                                    value: " selected"
                                }, {
                                    type: "Twig.expression.type.operator.binary",
                                    value: "?",
                                    precidence: 16,
                                    associativity: "rightToLeft",
                                    operator: "?"
                                }]
                            }
                        }, {
                            type: "raw",
                            value: '\t\t\t\t<option disabled value="" '
                        }, {
                            type: "output",
                            stack: [{
                                type: "Twig.expression.type.variable",
                                value: "isSelected",
                                match: ["isSelected"]
                            }]
                        }, {
                            type: "raw",
                            value: ">"
                        }, {
                            type: "output_whitespace_both",
                            stack: [{
                                type: "Twig.expression.type.variable",
                                value: "placeholder",
                                match: ["placeholder"]
                            }]
                        }, {
                            type: "output",
                            stack: [{
                                type: "Twig.expression.type.variable",
                                value: "required",
                                match: ["required"]
                            }, {
                                type: "Twig.expression.type.string",
                                value: " *"
                            }, {
                                type: "Twig.expression.type.operator.binary",
                                value: "?",
                                precidence: 16,
                                associativity: "rightToLeft",
                                operator: "?"
                            }]
                        }, {
                            type: "raw",
                            value: '\n\t\t\t\t</option>\n\t\t\t\t<option disabled value="">\n\t\t\t\t\t<br>\n\t\t\t\t</option>\n\n\t\t\t\t'
                        }, {
                            type: "logic",
                            token: {
                                type: "Twig.logic.type.set",
                                key: "isSelected",
                                expression: [{
                                    type: "Twig.expression.type.string",
                                    value: ""
                                }]
                            }
                        }, {
                            type: "raw",
                            value: "\t\t\t"
                        }]
                    }
                }, {
                    type: "raw",
                    value: '\n\t\t\t<option value="'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "item",
                        match: ["item"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "value"
                    }]
                }, {
                    type: "raw",
                    value: '" '
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "isSelected",
                        match: ["isSelected"]
                    }]
                }, {
                    type: "raw",
                    value: ">"
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "item",
                        match: ["item"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "title"
                    }]
                }, {
                    type: "raw",
                    value: "</option>"
                }]
            }
        }, {
            type: "raw",
            value: '\t</select>\n\n\t<div class="select__icon">\n\t\t<svg>\n\t\t\t<use xlink:href="#icon_arrow" />\n\t\t</svg>\n\t</div>\n\n\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.include",
                only: !1,
                ignoreMissing: !1,
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "src/app/components/field-frame/field-frame.twig"
                }]
            }
        }, {
            type: "raw",
            value: "</div>\n"
        }],
        id: "src/app/components/select/select.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/select/select.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<nav\n\tclass="menu-nav"\n\tref="menuNav"\n\trole="navigation"\n>\n\n\t<div class="menu-nav__logo">\n\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "market",
                    match: ["market"]
                }, {
                    type: "Twig.expression.type.string",
                    value: "kr"
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "==",
                    precidence: 9,
                    associativity: "leftToRight",
                    operator: "=="
                }],
                output: [{
                    type: "raw",
                    value: '\t\t\t<img\n\t\t\t\tclass="menu-nav__logo-image"\n\t\t\t\tsrc="'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "assets",
                        match: ["assets"]
                    }, {
                        type: "Twig.expression.type.key.brackets",
                        stack: [{
                            type: "Twig.expression.type.string",
                            value: "app.pack/images/logo_sod-"
                        }, {
                            type: "Twig.expression.type.variable",
                            value: "market",
                            match: ["market"]
                        }, {
                            type: "Twig.expression.type.operator.binary",
                            value: "~",
                            precidence: 6,
                            associativity: "leftToRight",
                            operator: "~"
                        }, {
                            type: "Twig.expression.type.string",
                            value: ".png"
                        }, {
                            type: "Twig.expression.type.operator.binary",
                            value: "~",
                            precidence: 6,
                            associativity: "leftToRight",
                            operator: "~"
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\t\t\talt="Seeds of Dreams"\n\t\t\t>\n\t\t'
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.elseif",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "language",
                    match: ["language"]
                }, {
                    type: "Twig.expression.type.string",
                    value: "fr"
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "==",
                    precidence: 9,
                    associativity: "leftToRight",
                    operator: "=="
                }],
                output: [{
                    type: "raw",
                    value: '\t\t\t<img\n\t\t\t\tclass="menu-nav__logo-image"\n\t\t\t\tsrc="'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "assets",
                        match: ["assets"]
                    }, {
                        type: "Twig.expression.type.key.brackets",
                        stack: [{
                            type: "Twig.expression.type.string",
                            value: "app.pack/images/logo_sod-fr.png"
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\t\t\talt="Seeds of Dreams"\n\t\t\t>\n\t\t'
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.else",
                match: ["else"],
                output: [{
                    type: "raw",
                    value: '\t\t\t<img\n\t\t\t\tclass="menu-nav__logo-image"\n\t\t\t\tsrc="'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "assets",
                        match: ["assets"]
                    }, {
                        type: "Twig.expression.type.key.brackets",
                        stack: [{
                            type: "Twig.expression.type.string",
                            value: "app.pack/images/logo_sod.png"
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\t\t\talt="Seeds of Dreams"\n\t\t\t>\n\t\t'
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "content",
                    match: ["content"]
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "interface"
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "menu"
                }, {
                    type: "Twig.expression.type.key.period",
                    key: "logo"
                }],
                output: [{
                    type: "raw",
                    value: '<sup>*</sup>\n\t\t\t<div class="menu-nav__logo-translation">\n\t\t\t\t<sup>*</sup>'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "content",
                        match: ["content"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "interface"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "menu"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "logo"
                    }]
                }, {
                    type: "raw",
                    value: "</div>"
                }]
            }
        }, {
            type: "raw",
            value: '</div>\n\n\t<div class="menu-nav__text">\n\t\t<p>'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "interface"
            }, {
                type: "Twig.expression.type.key.period",
                key: "menu"
            }, {
                type: "Twig.expression.type.key.period",
                key: "description"
            }]
        }, {
            type: "raw",
            value: '</p>\n\t</div>\n\n\t<ul class="menu-nav__links">'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "userIsLogged",
                    match: ["userIsLogged"]
                }],
                output: [{
                    type: "raw",
                    value: '<li class="menu-nav__item">\n\t\t\t\t<a\n\t\t\t\t\tclass="menu-nav__link"\n\t\t\t\t\thref="/logout"\n\t\t\t\t\tdata-event="click->logout"\n\t\t\t\t>'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "content",
                        match: ["content"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "interface"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "menu"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "log_out"
                    }]
                }, {
                    type: "raw",
                    value: '</a>\n\n\t\t\t\t<div class="menu-nav__separator">\n\t\t\t\t\t<svg>\n\t\t\t\t\t\t<use xlink:href="#element_draw" />\n\t\t\t\t\t</svg>\n\t\t\t\t</div>\n\t\t\t</li>\n\t\t\t<li class="menu-nav__item">\n\t\t\t\t<a\n\t\t\t\t\tclass="menu-nav__link"\n\t\t\t\t\thref="/vouchers"\n\t\t\t\t\tdata-event="click->openVouchers"\n\t\t\t\t>'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "content",
                        match: ["content"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "interface"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "menu"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "all_vouchers"
                    }]
                }, {
                    type: "raw",
                    value: '</a>\n\t\t\t\t<div class="menu-nav__separator">\n\t\t\t\t\t<svg>\n\t\t\t\t\t\t<use xlink:href="#element_draw" />\n\t\t\t\t\t</svg>\n\t\t\t\t</div>\n\t\t\t</li>'
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.elseif",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "demoMode",
                    match: ["demoMode"]
                }, {
                    type: "Twig.expression.type.operator.unary",
                    value: "not",
                    precidence: 3,
                    associativity: "rightToLeft",
                    operator: "not"
                }],
                output: [{
                    type: "raw",
                    value: '<li class="menu-nav__item">\n\t\t\t\t<a\n\t\t\t\t\tclass="menu-nav__link"\n\t\t\t\t\thref="/login"\n\t\t\t\t\tdata-event="click->openLogin"\n\t\t\t\t>'
                }, {
                    type: "output_whitespace_both",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "content",
                        match: ["content"]
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "interface"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "connection"
                    }, {
                        type: "Twig.expression.type.key.period",
                        key: "title"
                    }]
                }, {
                    type: "raw",
                    value: '</a>\n\n\t\t\t\t<div class="menu-nav__separator">\n\t\t\t\t\t<svg>\n\t\t\t\t\t\t<use xlink:href="#element_draw" />\n\t\t\t\t\t</svg>\n\t\t\t\t</div>\n\t\t\t</li>'
                }]
            }
        }, {
            type: "raw",
            value: "\n\t</ul>\n</nav>\n"
        }],
        id: "src/app/components/menu-nav/menu-nav.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/menu-nav/menu-nav.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<ul class="share" ref="share">\n\n\t<li class="share__item">\n\t\t<button\n\t\t\tclass="share__link  share__link--twitter"\n\t\t\tref="twitter"\n\t\t\tdata-event="click->openShare"\n\t\t\taria-label="twitter"\n\t\t>\n\t\t\t<svg focusable="false" aria-label="Share on twitter">\n\t\t\t\t<use xlink:href="#logo_social_twitter"/>\n\t\t\t</svg>\n\t\t</button>\n\t</li>\n\n\t<li class="share__item">\n\t\t<button\n\t\t\tclass="share__link  share__link--facebook"\n\t\t\tref="facebook"\n\t\t\tdata-event="click->openShare"\n\t\t\taria-label="facebook"\n\t\t>\n\t\t\t<svg focusable="false" aria-label="Share on Facebook">\n\t\t\t\t<use xlink:href="#logo_social_fb"/>\n\t\t\t</svg>\n\t\t</button>\n\t</li>\n\n</ul>\n'
        }],
        id: "src/app/components/share/share.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/share/share.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div class="menu-footer" ref="menuFooter">\n\n\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "userIsLogged",
                    match: ["userIsLogged"]
                }, {
                    type: "Twig.expression.type.operator.unary",
                    value: "not",
                    precidence: 3,
                    associativity: "rightToLeft",
                    operator: "not"
                }],
                output: [{
                    type: "raw",
                    value: '\t\t<div class="menu-footer__select" ref="menuSelect"></div>\n\t'
                }]
            }
        }, {
            type: "raw",
            value: '<ul class="menu-footer__links">\n\t\t<li class="menu-footer__item">\n\t\t\t<a\n\t\t\t\tclass="menu-footer__link"\n\t\t\t\thref="'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "interface"
            }, {
                type: "Twig.expression.type.key.period",
                key: "menu"
            }, {
                type: "Twig.expression.type.key.period",
                key: "christmas_garden_url"
            }]
        }, {
            type: "raw",
            value: '"\n\t\t\t\ttarget="_blank"\n\t\t\t\trel="noopener"\n\t\t\t\tdata-event="click->onClick"\n\t\t\t\tdata-index="0"\n\t\t\t>'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "interface"
            }, {
                type: "Twig.expression.type.key.period",
                key: "menu"
            }, {
                type: "Twig.expression.type.key.period",
                key: "christmas_garden"
            }]
        }, {
            type: "raw",
            value: '</a>\n\t\t</li>\n\t\t<li class="menu-footer__item">\n\t\t\t<a\n\t\t\t\tclass="menu-footer__link"\n\t\t\t\thref="'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "interface"
            }, {
                type: "Twig.expression.type.key.period",
                key: "menu"
            }, {
                type: "Twig.expression.type.key.period",
                key: "occ_website_url"
            }]
        }, {
            type: "raw",
            value: '"\n\t\t\t\ttarget="_blank"\n\t\t\t\trel="noopener"\n\t\t\t\tdata-event="click->onClick"\n\t\t\t\tdata-index="1"\n\t\t\t>'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "interface"
            }, {
                type: "Twig.expression.type.key.period",
                key: "menu"
            }, {
                type: "Twig.expression.type.key.period",
                key: "occ_website"
            }]
        }, {
            type: "raw",
            value: '</a>\n\t\t</li>\n\t</ul>\n\t<ul class="menu-footer__links">\n\t\t<li class="menu-footer__item">\n\t\t\t<a\n\t\t\t\tclass="menu-footer__link"\n\t\t\t\thref="'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "interface"
            }, {
                type: "Twig.expression.type.key.period",
                key: "menu"
            }, {
                type: "Twig.expression.type.key.period",
                key: "privacy_policy_url"
            }]
        }, {
            type: "raw",
            value: '"\n\t\t\t\ttarget="_blank"\n\t\t\t\trel="noopener"\n\t\t\t\tdata-event="click->onClick"\n\t\t\t\tdata-index="2"\n\t\t\t>'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "interface"
            }, {
                type: "Twig.expression.type.key.period",
                key: "menu"
            }, {
                type: "Twig.expression.type.key.period",
                key: "privacy_policy"
            }]
        }, {
            type: "raw",
            value: '</a>\n\t\t</li>\n\t\t<li class="menu-footer__item">\n\t\t\t<a\n\t\t\t\tclass="menu-footer__link"\n\t\t\t\thref="'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "api"
            }, {
                type: "Twig.expression.type.key.period",
                key: "legal"
            }]
        }, {
            type: "raw",
            value: '"\n\t\t\t\ttarget="_blank"\n\t\t\t\trel="noopener"\n\t\t\t\tdata-event="click->onClick"\n\t\t\t\tdata-index="3"\n\t\t\t>'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "interface"
            }, {
                type: "Twig.expression.type.key.period",
                key: "menu"
            }, {
                type: "Twig.expression.type.key.period",
                key: "legals"
            }]
        }, {
            type: "raw",
            value: "</a>\n\t\t</li>\n\t</ul>\n</div>"
        }],
        id: "src/app/components/menu-footer/menu-footer.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/menu-footer/menu-footer.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<ul class="garden" ref="garden"></ul>\n'
        }],
        id: "src/app/components/garden/garden.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/garden/garden.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<li\n\tclass="garden-seed"\n\tref="gardenSeed"\n>\n\t<button\n\t\tclass="garden-seed__inner"\n\t\tdata-event="click->goToSeed, mouseenter->playOnRollover, touchstart->activeState"\n\t\tref="gardenSeedInner"\n\t\taria-label="Garden seed"\n\t>\n\t\t<div class="garden-seed__floor">\n\t\t\t<svg focusable="false">\n\t\t\t\t<use xlink:href="#element_garden_'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "locked",
                match: ["locked"]
            }, {
                type: "Twig.expression.type.string",
                value: "closed"
            }, {
                type: "Twig.expression.type.string",
                value: "opened"
            }, {
                type: "Twig.expression.type.operator.binary",
                value: "?",
                precidence: 16,
                associativity: "rightToLeft",
                operator: "?"
            }]
        }, {
            type: "raw",
            value: '" />\n\t\t\t</svg>\n\t\t</div>'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "locked",
                    match: ["locked"]
                }],
                output: [{
                    type: "raw",
                    value: '\t\t\t<span class="garden-seed__lock">\n\t\t\t\t<svg focusable="false">\n\t\t\t\t\t<use xlink:href="#element_lock" />\n\t\t\t\t</svg>\n\t\t\t</span>\n\t\t'
                }]
            }
        }, {
            type: "raw",
            value: "\n\t\t"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "locked",
                    match: ["locked"]
                }, {
                    type: "Twig.expression.type.operator.unary",
                    value: "not",
                    precidence: 3,
                    associativity: "rightToLeft",
                    operator: "not"
                }, {
                    type: "Twig.expression.type.variable",
                    value: "planted",
                    match: ["planted"]
                }, {
                    type: "Twig.expression.type.operator.unary",
                    value: "not",
                    precidence: 3,
                    associativity: "rightToLeft",
                    operator: "not"
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "and",
                    precidence: 13,
                    associativity: "leftToRight",
                    operator: "and"
                }],
                output: [{
                    type: "raw",
                    value: '\t\t\t<span class="garden-seed__notif"></span>\n\t\t'
                }]
            }
        }, {
            type: "raw",
            value: "\n\t</button>\n</li>\n"
        }],
        id: "src/app/components/garden-seed/garden-seed.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/garden-seed/garden-seed.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "modifiers",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "default",
                    match: ["|default", "default"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: "blue"
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "split",
                    match: ["|split", "split"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: ", "
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "ref",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "ref",
                    match: ["ref"]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "default",
                    match: ["|default", "default"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: "blue"
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }, {
                    type: "Twig.expression.type.filter",
                    value: "split",
                    match: ["|split", "split"],
                    params: [{
                        type: "Twig.expression.type.parameter.start",
                        value: "(",
                        match: ["("]
                    }, {
                        type: "Twig.expression.type.string",
                        value: ", "
                    }, {
                        type: "Twig.expression.type.parameter.end",
                        value: ")",
                        match: [")"],
                        expression: !1
                    }]
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "classNames",
                expression: [{
                    type: "Twig.expression.type.array.start",
                    value: "[",
                    match: ["["]
                }, {
                    type: "Twig.expression.type.array.end",
                    value: "]",
                    match: ["]"]
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.set",
                key: "references",
                expression: [{
                    type: "Twig.expression.type.array.start",
                    value: "[",
                    match: ["["]
                }, {
                    type: "Twig.expression.type.array.end",
                    value: "]",
                    match: ["]"]
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.for",
                key_var: null,
                value_var: "item",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "modifiers",
                    match: ["modifiers"]
                }],
                output: [{
                    type: "raw",
                    value: "\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.set",
                        key: "classNames",
                        expression: [{
                            type: "Twig.expression.type.variable",
                            value: "classNames",
                            match: ["classNames"]
                        }, {
                            type: "Twig.expression.type.filter",
                            value: "merge",
                            match: ["|merge", "merge"],
                            params: [{
                                type: "Twig.expression.type.parameter.start",
                                value: "(",
                                match: ["("]
                            }, {
                                type: "Twig.expression.type.array.start",
                                value: "[",
                                match: ["["]
                            }, {
                                type: "Twig.expression.type.string",
                                value: "  seeds-button--"
                            }, {
                                type: "Twig.expression.type.variable",
                                value: "item",
                                match: ["item"]
                            }, {
                                type: "Twig.expression.type.operator.binary",
                                value: "~",
                                precidence: 6,
                                associativity: "leftToRight",
                                operator: "~"
                            }, {
                                type: "Twig.expression.type.array.end",
                                value: "]",
                                match: ["]"]
                            }, {
                                type: "Twig.expression.type.parameter.end",
                                value: ")",
                                match: [")"],
                                expression: !1
                            }]
                        }]
                    }
                }]
            }
        }, {
            type: "raw",
            value: "\n"
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.for",
                key_var: null,
                value_var: "item",
                expression: [{
                    type: "Twig.expression.type.variable",
                    value: "ref",
                    match: ["ref"]
                }],
                output: [{
                    type: "raw",
                    value: "\t"
                }, {
                    type: "logic",
                    token: {
                        type: "Twig.logic.type.set",
                        key: "references",
                        expression: [{
                            type: "Twig.expression.type.variable",
                            value: "references",
                            match: ["references"]
                        }, {
                            type: "Twig.expression.type.filter",
                            value: "merge",
                            match: ["|merge", "merge"],
                            params: [{
                                type: "Twig.expression.type.parameter.start",
                                value: "(",
                                match: ["("]
                            }, {
                                type: "Twig.expression.type.array.start",
                                value: "[",
                                match: ["["]
                            }, {
                                type: "Twig.expression.type.string",
                                value: ", "
                            }, {
                                type: "Twig.expression.type.variable",
                                value: "item",
                                match: ["item"]
                            }, {
                                type: "Twig.expression.type.operator.binary",
                                value: "~",
                                precidence: 6,
                                associativity: "leftToRight",
                                operator: "~"
                            }, {
                                type: "Twig.expression.type.array.end",
                                value: "]",
                                match: ["]"]
                            }, {
                                type: "Twig.expression.type.parameter.end",
                                value: ")",
                                match: [")"],
                                expression: !1
                            }]
                        }]
                    }
                }]
            }
        }, {
            type: "raw",
            value: '\n<button\n\tclass="seeds-button'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "classNames",
                match: ["classNames"]
            }, {
                type: "Twig.expression.type.filter",
                value: "join",
                match: ["|join", "join"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: ""
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "raw",
            value: '"\n\tref="seedsButton'
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "references",
                match: ["references"]
            }, {
                type: "Twig.expression.type.filter",
                value: "join",
                match: ["|join", "join"],
                params: [{
                    type: "Twig.expression.type.parameter.start",
                    value: "(",
                    match: ["("]
                }, {
                    type: "Twig.expression.type.string",
                    value: ""
                }, {
                    type: "Twig.expression.type.parameter.end",
                    value: ")",
                    match: [")"],
                    expression: !1
                }]
            }]
        }, {
            type: "raw",
            value: '"\n\tdata-event="click->goToSeed"\n\taria-label="Switch seed"\n>\n\n\t\t<div class="seeds-button__icon" ref="seedsButtonIcon">\n\t\t\t<svg>\n\t\t\t\t<use xlink:href="#icon_arrow" />\n\t\t\t</svg>\n\t\t</div>\n\n\t\t<div class="seeds-button__anim" ref="seedsButtonAnim">\n\t\t\t<div\n\t\t\t\tclass="seeds-button__bg  seeds-button__bg--light"\n\t\t\t\tref="seedsButtonBg"\n\t\t\t></div>\n\t\t\t<div\n\t\t\t\tclass="seeds-button__bg  seeds-button__bg--dark"\n\t\t\t></div>\n\t\t</div>\n\n</button>\n'
        }],
        id: "src/app/components/seeds-button/seeds-button.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/seeds-button/seeds-button.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<aside class="resources-buttons">\n\n\t<div class="resources-buttons__active">\n\t\t<div\n\t\t\tclass="resources-buttons__item  resources-buttons__item--sun"\n\t\t\tref="buttons, give, resources"\n\t\t\tdata-type="sun"\n\t\t\tdata-bypass-touch\n\t\t></div>\n\n\t\t<div\n\t\t\tclass="resources-buttons__item  resources-buttons__item--game"\n\t\t\tref="buttons, give, game"\n\t\t\tdata-type="game"\n\t\t\tdata-bypass-touch\n\t\t></div>\n\n\t\t<div\n\t\t\tclass="resources-buttons__item  resources-buttons__item--water"\n\t\t\tref="buttons, give, resources"\n\t\t\tdata-type="water"\n\t\t\tdata-bypass-touch\n\t\t></div>\n\t</div>\n\n\t<div class="resources-buttons__gift">\n\t\t<div\n\t\t\tclass="resources-buttons__item  resources-buttons__item--gift"\n\t\t\tref="buttons, give, gift"\n\t\t\tdata-type="gift"\n\t\t\tdata-bypass-touch\n\t\t></div>\n\t</div>\n</aside>\n'
        }],
        id: "src/app/components/resources-buttons/resources-buttons.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/resources-buttons/resources-buttons.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, , , function(e) {
    e.exports = JSON.parse('{"amandier_lvl1.png":{"width":2048,"height":1024},"amandier_lvl2.png":{"width":2048,"height":1024},"amandier_lvl3.png":{"width":2048,"height":512},"amandier_lvl4.png":{"width":2048,"height":2048},"bag.png":{"width":1024,"height":1024},"amandier.png":{"width":2048,"height":2048},"cedrat.png":{"width":2048,"height":2048},"cerisier.png":{"width":2048,"height":2048},"immortelle.png":{"width":2048,"height":2048},"karite.png":{"width":2048,"height":2048},"lavande.png":{"width":2048,"height":2048},"rose.png":{"width":2048,"height":2048},"verveine.png":{"width":2048,"height":2048},"game.png":{"width":1024,"height":1024}}')
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div class="resources-button-timer">\n\t<div ref="visibility" class="resources-button-timer__visibility-wrapper">\n\n\t\t<span class="resources-button-timer__time" ref="time">02:59:10</span>\n\n\t</div>\n</div>\n'
        }],
        id: "src/app/components/resources-button-timer/resources-button-timer.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/resources-button-timer/resources-button-timer.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div class="resources-button-overflow">\n\t<div ref="visibility" class="resources-button-overflow__visibility-wrapper">\n\n\t<div class="resources-button-overflow__bubble" ref="bubble"></div>\n\t<div class="resources-button-overflow__border" ref="border"></div>\n\n\t<div class="resources-button-overflow__wrapper" ref="wrapper">\n\t\t<div class="resources-button-overflow__inner" ref="inner">\n\t\t\t<div class="resources-button-overflow__count">+&#8239;<span ref="count" class="resources-button-overflow__number">6</span></div>\n\t\t</div>\n\t</div>\n\n\t</div>\n</div>\n'
        }],
        id: "src/app/components/resources-button-overflow/resources-button-overflow.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/resources-button-overflow/resources-button-overflow.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<aside class="progress-bar">\n\t<button class="progress-bar__gift" ref="giftButton" aria-label="Gift"></button>\n\t<figure class="progress-bar__bar"></figure>\n</aside>\n'
        }],
        id: "src/app/components/progress-bar/progress-bar.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/progress-bar/progress-bar.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div\n\tclass="rotate"\n\tstyle="background-image: url('
        }, {
            type: "output",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "assets",
                match: ["assets"]
            }, {
                type: "Twig.expression.type.key.brackets",
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "app.static/images/bg.jpg"
                }]
            }]
        }, {
            type: "raw",
            value: ')"\n\tref="rotate"\n>\n\n\t<img\n\t\tclass="rotate__logo"\n\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.if",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "market",
                    match: ["market"]
                }, {
                    type: "Twig.expression.type.string",
                    value: "kr"
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "==",
                    precidence: 9,
                    associativity: "leftToRight",
                    operator: "=="
                }],
                output: [{
                    type: "raw",
                    value: '\t\t\tsrc="'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "assets",
                        match: ["assets"]
                    }, {
                        type: "Twig.expression.type.key.brackets",
                        stack: [{
                            type: "Twig.expression.type.string",
                            value: "app.static/images/logo_sod-"
                        }, {
                            type: "Twig.expression.type.variable",
                            value: "market",
                            match: ["market"]
                        }, {
                            type: "Twig.expression.type.operator.binary",
                            value: "~",
                            precidence: 6,
                            associativity: "leftToRight",
                            operator: "~"
                        }, {
                            type: "Twig.expression.type.string",
                            value: ".png"
                        }, {
                            type: "Twig.expression.type.operator.binary",
                            value: "~",
                            precidence: 6,
                            associativity: "leftToRight",
                            operator: "~"
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\t'
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.elseif",
                stack: [{
                    type: "Twig.expression.type.variable",
                    value: "language",
                    match: ["language"]
                }, {
                    type: "Twig.expression.type.string",
                    value: "fr"
                }, {
                    type: "Twig.expression.type.operator.binary",
                    value: "==",
                    precidence: 9,
                    associativity: "leftToRight",
                    operator: "=="
                }],
                output: [{
                    type: "raw",
                    value: '\t\t\tsrc="'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "assets",
                        match: ["assets"]
                    }, {
                        type: "Twig.expression.type.key.brackets",
                        stack: [{
                            type: "Twig.expression.type.string",
                            value: "app.static/images/logo_sod-fr.png"
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\t'
                }]
            }
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.else",
                match: ["else"],
                output: [{
                    type: "raw",
                    value: '\t\t\tsrc="'
                }, {
                    type: "output",
                    stack: [{
                        type: "Twig.expression.type.variable",
                        value: "assets",
                        match: ["assets"]
                    }, {
                        type: "Twig.expression.type.key.brackets",
                        stack: [{
                            type: "Twig.expression.type.string",
                            value: "app.static/images/logo_sod.png"
                        }]
                    }]
                }, {
                    type: "raw",
                    value: '"\n\t\t'
                }]
            }
        }, {
            type: "raw",
            value: 'alt="'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "interface"
            }, {
                type: "Twig.expression.type.key.period",
                key: "meta"
            }, {
                type: "Twig.expression.type.key.period",
                key: "title"
            }]
        }, {
            type: "raw",
            value: '"\n\t\titemprop="logo"\n\t>\n\n\t<p class="rotate__desc">'
        }, {
            type: "output_whitespace_both",
            stack: [{
                type: "Twig.expression.type.variable",
                value: "content",
                match: ["content"]
            }, {
                type: "Twig.expression.type.key.period",
                key: "interface"
            }, {
                type: "Twig.expression.type.key.period",
                key: "mobile"
            }, {
                type: "Twig.expression.type.key.period",
                key: "rotate"
            }]
        }, {
            type: "raw",
            value: "</p>\n\n</div>"
        }],
        id: "src/app/components/rotate/rotate.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/rotate/rotate.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<footer\n\tclass="footer"\n\tref="footer"\n>\n\t<div class="wrapper">\n\t\t<div\n\t\t\tclass="footer__link"\n\t\t\t'
        }, {
            type: "raw",
            value: '\n\t\t>\n\t\t\t<svg class="footer__logo">\n\t\t\t\t<use xlink:href="#logo_loccitane" />\n\t\t\t</svg>\n\t\t</div>\n\t</div>\n</footer>\n'
        }],
        id: "src/app/blocks/footer/footer.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/blocks/footer/footer.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div class="guide" ref="guide">\n\t<div class="wrapper" ref="wrapper"></div>\n</div>\n'
        }],
        id: "src/app/components/guide-text/guide-text.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/guide-text/guide-text.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, function(e, t, i) {
    i(76),
    i(159);
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<div\n\tclass="newmessage  newmessage--bottom"\n\tref="message"\n\tdata-event="click->open"\n>\n\t<div\n\t\tclass="newmessage__bg  newmessage__bg--mobile"\n\t\tref="messageBg"\n\t>\n\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.include",
                only: !1,
                ignoreMissing: !1,
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "src/app/components/svg/notification.twig"
                }]
            }
        }, {
            type: "raw",
            value: '\t</div>\n\n\t<div\n\t\tclass="newmessage__bg  newmessage__bg--desktop"\n\t\tref="messageBg"\n\t>\n\t\t'
        }, {
            type: "logic",
            token: {
                type: "Twig.logic.type.include",
                only: !1,
                ignoreMissing: !1,
                stack: [{
                    type: "Twig.expression.type.string",
                    value: "src/app/components/svg/notification_desktop.twig"
                }]
            }
        }, {
            type: "raw",
            value: '\t</div>\n\n\t<div class="newmessage__content" ref="content">\n\t</div>\n\n</div>\n'
        }],
        id: "src/app/components/message-new/message-new.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/message-new/message-new.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {}
, , function(e, t, i) {
    e.exports = function(e) {
        i.e(3).then(function(t) {
            e(i(192))
        }
        .bind(null, i)).catch(i.oe)
    }
}
, function(e, t, i) {
    e.exports = function(e) {
        i.e(5).then(function(t) {
            e(i(189))
        }
        .bind(null, i)).catch(i.oe)
    }
}
, function(e, t, i) {
    e.exports = function(e) {
        i.e(1).then(function(t) {
            e(i(190))
        }
        .bind(null, i)).catch(i.oe)
    }
}
, function(e, t, i) {
    e.exports = function(e) {
        i.e(6).then(function(t) {
            e(i(193))
        }
        .bind(null, i)).catch(i.oe)
    }
}
, function(e, t, i) {
    e.exports = function(e) {
        i.e(4).then(function(t) {
            e(i(194))
        }
        .bind(null, i)).catch(i.oe)
    }
}
, function(e, t, i) {
    e.exports = function(e) {
        i.e(2).then(function(t) {
            e(i(191))
        }
        .bind(null, i)).catch(i.oe)
    }
}
, function(e, t, i) {}
, function(e, t, i) {
    "use strict";
    var n = i(34)
      , r = i(3)
      , s = i(14);
    const a = () => ({
        amount: Object(r.a)(0),
        goal: Object(r.a)(0),
        query: Object(r.a)(null),
        visibleQuery: Object(r.a)(null),
        nextQueryDate: Object(r.a)(0)
    })
      , o = {
        palette: "blue",
        scene: []
    };
    var l = function({settings: e, sceneData: t}) {
        (t = JSON.parse(JSON.stringify(t || o))).scene = t.scene.reverse();
        const i = {
            id: Object(s.b)(e.id),
            view: Object(r.a)(null),
            scene: Object(r.a)(null),
            settings: Object(s.b)(e),
            sceneData: Object(r.a)(t),
            seedPresets: Object(r.a)(t.seedPresets),
            palette: Object(r.a)(n.a.palettes.current[t.palette]),
            level: Object(r.a)(0),
            unlocked: Object(r.a)(!1),
            visibleLevel: Object(r.a)(0),
            muteResources: Object(r.a)(!1),
            resources: {
                water: a(),
                sun: a(),
                love: a(),
                message: a()
            },
            emit: (e, t, n) => {
                i.scene.current && i.scene.current.emitter && i.scene.current.emitter.emit(e, t, n)
            }
            ,
            getPreset: e => {
                const t = void 0 !== e ? e : i.level.current;
                return i.seedPresets.current["lvl" + (t > 0 ? t : 1)] || {}
            }
            ,
            bubbleInitialized: Object(r.a)(!1)
        };
        return Object.freeze(i)
    }
      , c = i(24)
      , h = i(20)
      , u = i(13)
      , p = i(51)
      , d = i(19)
      , f = i(56)
      , m = i(42);
    var g = [{
        needed: 0,
        ask: [0, 0],
        delay: [1, 1]
    }, {
        needed: 0,
        ask: [0, 0],
        delay: [1, 1]
    }, {
        needed: 1,
        ask: [1, 1],
        delay: [1, 1]
    }, {
        needed: 1,
        ask: [1, 1],
        delay: [1, 1]
    }, {
        needed: 0,
        ask: [0, 0],
        delay: [1, 1]
    }]
      , v = i(5)
      , y = i(18)
      , b = i(29);
    function x(e, t) {
        const i = "message" === t
          , n = "water" === t
          , r = "sun" === t
          , s = "love" === t
          , {gaveSun: a, gaveLove: o, gaveWater: l, openGame: h} = c.a.flags.current
          , u = function(e) {
            const t = e.level.current
              , i = e.resources.message;
            return 2 !== t && 3 !== t || i.amount.current >= i.goal.current
        }(e);
        if (!h && a && o && l)
            return !1;
        if (u && a && o && l)
            return !0;
        if (i)
            return !0;
        if (u) {
            if (!a && r)
                return !0;
            if (a && !o && s)
                return !0;
            if (a && o && !l && n)
                return !0
        }
        return !1
    }
    function w(e, t) {
        const i = n.a.rules.current
          , r = c.a.getSeedById(e)
          , s = i.seeds[e];
        if (!r)
            return;
        const a = s["lvl" + r.level.current];
        if (!a)
            return;
        const o = r.resources[t]
          , l = "message" === t ? g[r.level.current] : a[t];
        if (!l)
            return;
        const h = o.amount
          , u = o.nextQueryDate
          , p = l.needed || 0;
        if (!x(r, t) || h.current >= p)
            return void u.set(0);
        const f = Object(d.a)()
          , m = Object(v.clamp)(h.current / l.needed, 0, 1)
          , y = f + Math.ceil(Object(v.lerp)(l.delay[0], l.delay[1], m));
        u.set(y)
    }
    const _ = {
        sun: "gaveSun",
        water: "gaveWater",
        love: "gaveLove"
    };
    function T(e) {
        const {seedStore: t, seedSettings: i, rules: n} = Object(y.a)(e);
        if (!t || !i)
            return;
        let r = null;
        for (const i in t.resources) {
            const n = t.resources[i];
            w(e, i),
            "message" !== i && ((null === r || n.nextQueryDate.current > 0 && n.nextQueryDate.current < r) && (r = n.nextQueryDate.current))
        }
        const s = Object(d.a)();
        r || (r = s);
        const a = n.firstDelay["lvl" + Object(v.clamp)(t.level.current, 1, 3)]
          , o = n.firstDelay.tuto
          , l = s + a - r;
        for (const e in t.resources) {
            const i = t.resources[e]
              , n = _[e];
            if (i.nextQueryDate.current) {
                if ("message" === e)
                    i.nextQueryDate.set(s + o);
                else if (n && !c.a.flags.current[n])
                    i.nextQueryDate.set(s + o);
                else {
                    const e = i.nextQueryDate.current;
                    let t = i.nextQueryDate.current + l;
                    t < 0 && (t = s + a),
                    e > 0 && t > e && (t = e),
                    i.nextQueryDate.set(t)
                }
                Object(b.a)(`${e} will be query in ${i.nextQueryDate.current - s} seconds`)
            }
        }
    }
    function M(e) {
        if (e)
            return T(e);
        const t = c.a.seedsArray.current;
        for (let e = 0, i = t.length; e < i; e++)
            T(t[e].id.current)
    }
    function S(e) {
        const {seedStore: t, seedSettings: i} = Object(y.a)(e);
        if (!t || !i)
            return;
        const n = t.level.current
          , r = i["lvl" + n];
        for (const e in t.resources) {
            const i = t.resources[e];
            "message" !== e ? (i.amount.set(0),
            i.query.set(null),
            i.goal.set(r ? r[e].needed : 0)) : (i.amount.set(0),
            i.query.set(null),
            i.goal.set(2 === n || 3 === n ? 1 : 0))
        }
        M(e),
        u.a.requestSave()
    }
    function A(e, t) {
        const {seedStore: i, lvlSettings: n} = Object(y.a)(e);
        if (!n)
            return;
        const r = i.resources[t]
          , s = "message" === t ? g[i.level.current] : n[t];
        if (!s)
            return;
        const a = r.amount
          , o = r.query
          , l = Object(v.clamp)(0, 1, a.current / s.needed);
        if (l >= 1)
            return;
        if (!x(i, t))
            return;
        Object(b.a)("Create query for " + t);
        const c = s.needed - a.current
          , h = Math.min(c, Math.round(Object(v.lerp)(s.ask[0], s.ask[1], l)))
          , u = h > 0 ? {
            asked: h,
            received: 0
        } : null;
        o.set(u)
    }
    var P = i(158)
      , C = i(30);
    function L(e) {
        const {seedStore: t, seedSettings: i} = Object(y.a)(e);
        t && i && (t.level.current < 0 || t.level.current >= 4 || (S(e),
        t.level.update(e => e + 1),
        S(e),
        u.a.requestSave(),
        P.a.event({
            type: "mmEvent",
            category: "plant",
            action: `level_up_${Object(C.a)(e)}`,
            label: `${t.level.current}`
        })))
    }
    function k(e) {
        const {seedStore: t, seedSettings: i} = Object(y.a)(e);
        if (!t || !i)
            return !1;
        const n = i["lvl" + t.level.current];
        if (!n)
            return !1;
        for (const e in t.resources) {
            const i = t.resources[e];
            if (("message" === e ? g[t.level.current] : n[e]).needed > i.amount.current)
                return !1
        }
        return !0
    }
    const E = {
        sun: "gaveSun",
        love: "gaveLove",
        water: "gaveWater"
    };
    function I(e, t) {
        Object(b.a)(`Complete ${t} query for ${e}`);
        const {seedStore: i, seedSettings: n} = Object(y.a)(e);
        if (!i)
            return;
        const r = n["lvl" + i.level.current];
        if (!r)
            return;
        const s = i.resources[t]
          , a = "message" === t ? g[i.level.current] : r[t];
        if (!a)
            return;
        const o = s.amount
          , l = a.needed || 0
          , h = s.query.current;
        h && (o.update(e => Math.min(l, e + h.asked)),
        function(e, t) {
            const i = E[t];
            if (i) {
                const t = c.a.flags.current;
                if (t[i])
                    return;
                Object(b.a)(`Update player flags: ${i} => true`),
                t[i] = !0,
                M(e),
                c.a.flags.set(t, !0),
                u.a.requestSave()
            } else if ("message" === t) {
                const t = c.a.flags.current
                  , n = !t.openMessage;
                n && Object(b.a)(`Update player flags: ${i} => true`),
                t.openMessage = !0,
                M(e),
                n && c.a.flags.set(t, !0),
                u.a.requestSave()
            }
        }(e, t),
        s.query.set(null),
        o.current < l && w(e, t),
        k(e) && L(e),
        u.a.requestSave())
    }
    function F(e) {
        return "love" === e || "message" === e
    }
    function O(e, t) {
        const {rules: i, seedStore: n} = Object(y.a)(e);
        if (n.level.current < 1)
            return !1;
        const r = F(t)
          , s = c.a.pooledResources.current
          , a = n.resources[t]
          , o = c.a.resources[t];
        if (!a || !r && !o)
            return !1;
        const l = a.query
          , h = a.amount
          , u = a.goal
          , p = o && o.amount
          , f = o && o.lastRefill;
        if (!l.current || h.current >= u.current || !r && p.current <= 0)
            return !1;
        if (!r) {
            const e = l.current;
            if (e.asked - e.received - s[t] <= 0)
                return !1;
            const n = p.current
              , r = Math.max(0, n - 1)
              , a = i.refills[t].limit;
            p.set(r),
            n >= a && r < a && f.set(Math.ceil(Object(d.a)(!0)))
        }
        return s[t]++,
        !0
    }
    function R(e) {
        const {seedStore: t, seedSettings: i} = Object(y.a)(e);
        if (!t || !i)
            return !1;
        if (!t.unlocked.current)
            return Object(b.a)(`Cannot plant ${e} (not unlocked)`);
        if (t.level.current > 0)
            return Object(b.a)(`Plant ${e} already unlocked`);
        Object(b.a)(`Plant ${e}`);
        const n = c.a.flags.current;
        !n.openBag && function() {
            const e = c.a.seedsArray.current;
            for (let t = 0, i = e.length; t < i; t++)
                if (e[t].level.current > 0)
                    return !0;
            return !1
        }() && (n.openBag = !0,
        c.a.flags.set(n, !0)),
        L(e),
        u.a.requestSave(),
        P.a.event({
            type: "mmEvent",
            category: "plant",
            action: "plant_seed",
            label: `${Object(C.a)(e)}`
        })
    }
    function z() {
        u.a.saveCurrentSeed()
    }
    function N(e, t, i=!1) {
        if (4 !== e || !c.a.id.current)
            return;
        !c.a.vouchers.current[t] && u.a.isLogged() && u.a.requestVouchers()
    }
    let D = !0;
    function U(e) {
        if (!e || "seed" !== e.to.id)
            return;
        const t = c.a.getSeedById(e.to.params.id);
        t && 1 === e.status ? c.a.requestedSeed.set(t) : t && 2 === e.status && D && (c.a.currentSeed.set(t),
        D = !1)
    }
    function B(e, t=Object(d.a)()) {
        k(e) ? L(e) : function(e, t=Object(d.a)()) {
            const {seedStore: i, lvlSettings: n} = Object(y.a)(e);
            if (n)
                for (const r in i.resources) {
                    const s = "message" === r ? g[i.level.current] : n[r]
                      , a = i.resources[r]
                      , o = a.amount
                      , l = a.query
                      , c = a.nextQueryDate;
                    if (void 0 === a || s.needed <= 0 || o.current >= s.needed)
                        continue;
                    const h = l.current;
                    h && h.received >= h.asked && I(e, r),
                    t < c.current || l.current || o.current >= s.needed || A(e, r)
                }
            else
                for (const t in i.resources)
                    if (i.resources[t].query.current)
                        return void S(e)
        }(e, t)
    }
    t.a = {
        init: function() {
            const e = n.a.rules.current
              , t = Object.values(e.seeds)
              , i = {}
              , r = [];
            for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e]
                  , s = l({
                    settings: n,
                    sceneData: p.a[n.id] || p.a.default
                });
                r.push(s),
                i[n.id] = s,
                s.level.subscribe(e => N(e, n.id))
            }
            c.a.seedsArray.set(r, !0),
            c.a.seeds.set(i, !0),
            h.a.routeStatus.subscribe(U),
            c.a.currentSeed.subscribe(z)
        },
        ready: function() {
            Object.values(c.a.seeds.current).forEach(e => {
                N(e.level.current, e.id.current, !0)
            }
            )
        },
        update: function(e=Object(d.a)()) {
            const t = [];
            c.a.seedsArray.current.forEach(i => {
                if (!i.unlocked.current)
                    return t.push(i);
                B(i.id.current, e)
            }
            ),
            t.forEach(t => {
                (function(e, t=Object(d.a)()) {
                    const {seedStore: i, seedSettings: n} = Object(y.a)(e);
                    if (!i || !n)
                        return;
                    let r = !1
                      , s = 0;
                    c.a.seedsArray.current.forEach(e => {
                        e.level.current >= 4 && s++
                    }
                    );
                    for (let e = 0, i = n.unlock_conditions.length; e < i; e++) {
                        const i = n.unlock_conditions[e]
                          , a = "object" == typeof i ? {
                            type: Object.keys(i)[0],
                            value: Object.values(i)[0]
                        } : {
                            type: i,
                            value: null
                        };
                        if ("lvl2_seed" === a.type) {
                            const e = c.a.getSeedById(a.value);
                            e && e.level.current >= 2 && (r |= !0)
                        } else if ("completed_seeds" === a.type)
                            s >= a.value && (r |= !0);
                        else if ("playtime" === a.type)
                            t - c.a.startDate.current >= a.value && (r |= !0);
                        else if ("days_count" === a.type)
                            c.a.daysCount.current >= a.value && (r |= !0);
                        else if ("game_score" === a.type) {
                            const e = a.value[0]
                              , t = a.value[1];
                            ((c.a.highScores[e] || {}).current || 0) >= t ? r |= !0 : s >= 7 && (r |= !0)
                        }
                    }
                    return r
                }
                )(t.id.current, e) && Object(m.a)(t.id.current)
            }
            )
        },
        plant: R,
        chooseStarter: function(e) {
            const {seedSettings: t} = Object(y.a)(e);
            t && t.starter && !c.a.starterChosen.current && (Object(b.a)(`Choose starter ${e}`),
            Object(m.a)(e),
            R(e),
            u.a.requestSave())
        },
        prepareResource: O,
        giveResource: function(e, t) {
            const {seedStore: i} = Object(y.a)(e);
            if (i.level < 1)
                return;
            const n = c.a.pooledResources.current
              , r = i.resources[t]
              , s = c.a.resources[t];
            if (!r || !F(t) && !s)
                return;
            const a = r.query;
            let o = a.current;
            if (!o)
                return;
            if (!F(t)) {
                if (n[t] || O(e, t),
                !n[t])
                    return;
                n[t]--
            }
            const l = {
                asked: (o = a.current).asked,
                received: o.received + 1
            };
            l.received >= l.asked ? I(e, t) : a.set(l),
            u.a.requestSave()
        },
        evolveSeed: L,
        regressSeed: function(e) {
            const {seedStore: t, seedSettings: i} = Object(y.a)(e);
            t && i && (t.level.current <= 1 || t.level.current > 4 || (t.level.update(e => e - 1),
            S(e),
            u.a.requestSave()))
        },
        unlock: m.a,
        replanQueries: M,
        checkUnlockableSeedUrl: function() {
            if (!h.a.unlockSeed.current)
                return !1;
            const e = window.location.pathname.replace(h.a.language.current.locale, "");
            return !(h.a.unlockSeedPath.current !== e || (Object(m.a)(h.a.unlockSeed.current),
            window.history.replaceState({}, "", f.a.url("default")),
            0))
        }
    }
}
, function(e, t, i) {
    "use strict";
    t.a = {
        event: function({type: e, value: t, category: i="", action: n="", label: r=""}) {
            e && (window.dataLayer = window.dataLayer || [],
            e.match(/pageview/i) && window.dataLayer.push({
                event: e,
                mmPage: t
            }),
            e.match(/event/i) && window.dataLayer.push({
                event: e,
                mmCategory: i,
                mmAction: n,
                mmLabel: r
            }))
        }
    }
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"\n\t x="0px" y="0px" viewBox="0 0 1034 155" enable-background="new 0 0 1034 155" xml:space="preserve">\n\t<path fill="#80CAF1" style="fill-opacity: 0;" d="M982,160H432c0,0,42-7.4,65.7-43.6C512.6,93.6,528.8,72,528.8,72c81.7-102.4,214-61.8,259.6-26.1\n\t\tc52.9,41.5,44.9,38.7,86.4,65.5C913.7,136.5,982,160,982,160z"/>\n\t<path fill="#3964AB" style="fill-opacity: 0;" d="M462,156l572-0.6C932.9,155.4,833.1,61,729,61c-96.6,0-141.9,42.1-165,56.1C517.7,145,462,156,462,156z"/>\n\t<path fill="#3964AB" style="fill-opacity: 0;" d="M572,156L0,155.4c101.1,0,200.9-94.4,305-94.4c96.6,0,141.9,42.1,165,56.1C516.3,145,572,156,572,156z"/>\n\t<path fill="#161D6E" d="M93,155c88.3,0,159-67,205.3-94.2C386.5,8.8,426,0.1,516.4,0l0,0h1.1l0,0C608,0.1,647.5,8.8,735.7,60.8\n\t\tC782,88,852.7,155,941,155H93z"/>\n</svg>\n'
        }],
        id: "src/app/components/svg/notification_desktop.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/svg/notification_desktop.twig",
    e.exports.default = e.exports
}
, , , , , , , , function(e, t) {}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 659.5 113.4"><path fill-rule="evenodd" clip-rule="evenodd" fill="#FFF" d="M254.7 98.6s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zm204-57.2s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.2-.9-.7-.9-1.3zM284.6 0s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-1-.6-.9-1.3zm89.6 56.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3 0 .1 0 .1 0 0zm124.7-37.1s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3zM335.7 26s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3 0 .1 0 .1 0 0zm200.2 14.7s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-1-.7-.9-1.3zM443.1 7.3s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm-91.2 24.1s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm6.4 20.7s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.2-.9-.7-.9-1.3zm-39.2-9.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.7-.9-1.3-.1 0-.1 0 0 0zm-16.4-8.3s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm213.5 7.7s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0-.1-1.2-.1-1.3-1.8zm-270-14.5s-.2 2-1.4 2c.8.3 1.4 1.1 1.4 2 0 0 .2-2.1 1.5-2.1 0 .1-1.4.1-1.5-1.9zm29.6-7.8s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm203.9 9.6s-.2 2.5-1.7 2.5c1 .4 1.7 1.4 1.7 2.5 0 0 .3-2.6 1.9-2.6-.1 0-1.8 0-1.9-2.4zM297 .7s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0-.1-1.2-.1-1.3-1.8zm167.8 4s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8.1-.1-1.2-.1-1.3-1.8zM344.3 22.5s-.1 1.5-1 1.5c.6.3 1 .9 1 1.5 0 0 .2-1.6 1.1-1.6 0 0-1.1 0-1.1-1.4zm89.9-3.9s-.2 2-1.4 2c.8.3 1.4 1.1 1.4 2 0 0 .2-2.1 1.5-2.1-.1 0-1.5 0-1.5-1.9zM420 30s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zM364.2 4.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zM409.7 3s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0 0-1.2 0-1.3-1.8zM396.7 98.6s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zm204-57.2s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.2-.9-.7-.9-1.3zM426.6 0s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-1-.6-.9-1.3zm89.6 56.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3 0 .1 0 .1 0 0zm124.7-37.1s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3zM477.7 26s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3 0 .1 0 .1 0 0zM585.1 7.3s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm-91.2 24.1s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm6.4 20.7s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.2-.9-.7-.9-1.3zm-39.2-9.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.7-.9-1.3-.1 0-.1 0 0 0zm-16.4-8.3s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm213.5 7.7s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0-.1-1.2-.1-1.3-1.8zm-270-14.5s-.2 2-1.4 2c.8.3 1.4 1.1 1.4 2 0 0 .2-2.1 1.5-2.1 0 .1-1.4.1-1.5-1.9zm29.6-7.8s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm203.9 9.6s-.2 2.5-1.7 2.5c1 .4 1.7 1.4 1.7 2.5 0 0 .3-2.6 1.9-2.6-.1 0-1.8 0-1.9-2.4zM439 .7s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0-.1-1.2-.1-1.3-1.8zm167.8 4s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8.1-.1-1.2-.1-1.3-1.8zM486.3 22.5s-.1 1.5-1 1.5c.6.3 1 .9 1 1.5 0 0 .2-1.6 1.1-1.6 0 0-1.1 0-1.1-1.4zm89.9-3.9s-.2 2-1.4 2c.8.3 1.4 1.1 1.4 2 0 0 .2-2.1 1.5-2.1-.1 0-1.5 0-1.5-1.9zM562 30s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zM506.2 4.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zM551.7 3s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0 0-1.2 0-1.3-1.8zM183.7 41.4s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.2-.9-.7-.9-1.3zM9.6 0s-.1 1.3-.8 1.3c.5.2.8.7.8 1.2 0 0 .1-1.3.9-1.3-.5 0-1-.5-.9-1.2zm89.6 56.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3 0 .1 0 .1 0 0zm124.7-37.1s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3zM60.7 26s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3 0 .1 0 .1 0 0zm200.2 14.7s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-1-.7-.9-1.3zM168.1 7.3s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zM76.9 31.4s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm6.4 20.7s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.2-.9-.7-.9-1.3zm-39.2-9.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.7-.9-1.3-.1 0-.1 0 0 0zm-16.4-8.3s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm213.5 7.7s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0-.1-1.2-.1-1.3-1.8zM.8 19.3s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm203.9 9.6s-.2 2.5-1.7 2.5c1 .4 1.7 1.4 1.7 2.5 0 0 .3-2.6 1.9-2.6-.1 0-1.8 0-1.9-2.4zM22 .7s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0-.1-1.2-.1-1.3-1.8zm167.8 4s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8.1-.1-1.2-.1-1.3-1.8zM69.3 22.5s-.1 1.5-1 1.5c.6.3 1 .9 1 1.5 0 0 .2-1.6 1.1-1.6 0 0-1.1 0-1.1-1.4zm89.9-3.9s-.2 2-1.4 2c.8.3 1.4 1.1 1.4 2 0 0 .2-2.1 1.5-2.1-.1 0-1.5 0-1.5-1.9zM145 30s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zM89.2 4.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zM134.7 3s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0 0-1.2 0-1.3-1.8zM499.7 95.4s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.2-.9-.7-.9-1.3zM325.6 54s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-1-.6-.9-1.3zm89.6 56.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3 0 .1 0 .1 0 0zm124.7-37.1s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3zM376.7 80s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3 0 .1 0 .1 0 0zm200.2 14.7s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-1-.7-.9-1.3zm-92.8-33.4s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm-91.2 24.1s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm6.4 20.7s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.2-.9-.7-.9-1.3zm-39.2-9.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.7-.9-1.3-.1 0-.1 0 0 0zm-16.4-8.3s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm213.5 7.7s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0-.1-1.2-.1-1.3-1.8zm-270-14.5s-.2 2-1.4 2c.8.3 1.4 1.1 1.4 2 0 0 .2-2.1 1.5-2.1 0 .1-1.4.1-1.5-1.9zm29.6-7.8s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm203.9 9.6s-.2 2.5-1.7 2.5c1 .4 1.7 1.4 1.7 2.5 0 0 .3-2.6 1.9-2.6-.1 0-1.8 0-1.9-2.4zM338 54.7s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0-.1-1.2-.1-1.3-1.8zm167.8 4s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8.1-.1-1.2-.1-1.3-1.8zM385.3 76.5s-.1 1.5-1 1.5c.6.3 1 .9 1 1.5 0 0 .2-1.6 1.1-1.6 0 0-1.1 0-1.1-1.4zm89.9-3.9s-.2 2-1.4 2c.8.3 1.4 1.1 1.4 2 0 0 .2-2.1 1.5-2.1-.1 0-1.5 0-1.5-1.9zM461 84s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zm-55.8-25.1s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zm45.5-1.9s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0 0-1.2 0-1.3-1.8zM257.7 49.4s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.2-.9-.7-.9-1.3zM83.6 8s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-1-.6-.9-1.3zm89.6 56.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3 0 .1 0 .1 0 0zm124.7-37.1s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3zM134.7 34s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.6-.9-1.3 0 .1 0 .1 0 0zm200.2 14.7s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-1-.7-.9-1.3zm-92.8-33.4s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm-91.2 24.1s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm6.4 20.7s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.2-.9-.7-.9-1.3zm-39.2-9.9s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.1-1-.7-.9-1.3-.1 0-.1 0 0 0zm-16.4-8.3s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm213.5 7.7s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0-.1-1.2-.1-1.3-1.8zm-270-14.5s-.2 2-1.4 2c.8.3 1.4 1.1 1.4 2 0 0 .2-2.1 1.5-2.1 0 .1-1.4.1-1.5-1.9zm29.6-7.8s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.5-.1-.9-.6-.9-1.3 0 .1 0 0 0 0zm203.9 9.6s-.2 2.5-1.7 2.5c1 .4 1.7 1.4 1.7 2.5 0 0 .3-2.6 1.9-2.6-.1 0-1.8 0-1.9-2.4zM96 8.7s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0-.1-1.2-.1-1.3-1.8zm167.8 4s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8.1-.1-1.2-.1-1.3-1.8zM143.3 30.5s-.1 1.5-1 1.5c.6.3 1 .9 1 1.5 0 0 .2-1.6 1.1-1.6 0 0-1.1 0-1.1-1.4zm89.9-3.9s-.2 2-1.4 2c.8.3 1.4 1.1 1.4 2 0 0 .2-2.1 1.5-2.1-.1 0-1.5 0-1.5-1.9zM219 38s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zm-55.8-25.1s-.1 1.3-.8 1.3c.5.2.8.7.8 1.3 0 0 .1-1.3.9-1.3-.6-.2-1-.7-.9-1.3zm45.5-1.9s-.2 1.8-1.2 1.8c.7.3 1.2 1 1.2 1.8 0 0 .2-1.8 1.3-1.8 0 0-1.2 0-1.3-1.8z"/></svg>\n'
        }],
        id: "src/app/components/svg/popin_stars.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/svg/popin_stars.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {hideCamera: r, commonCamera: s, commonScene: a} = n.a
      , o = {
        id: "cedrat",
        palette: "red",
        prngSeed: 2,
        hideCamera: r,
        seedPresets: {
            lvl1: {
                seedPosition: [0, -.4, .115],
                seedScale: .35,
                cameraPositionPortrait: s.lvl1.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl1.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl1.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl1.cameraRotationLandscape.slice(),
                animations: {
                    request: {
                        mix: .3,
                        delay: 5,
                        chance: 25,
                        step: 3
                    },
                    "idle-2": {
                        from: "idle",
                        mix: .3,
                        delay: 3,
                        chance: 10,
                        step: 3
                    },
                    "idle-3": {
                        from: "idle",
                        mix: .3,
                        delay: 3,
                        chance: 10,
                        step: 3
                    }
                }
            },
            lvl2: {
                seedPosition: [0, -.9, -.1],
                seedScale: .7,
                cameraPositionPortrait: s.lvl2.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl2.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl2.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl2.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .5
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 33,
                        step: 3
                    },
                    "sad-2": {
                        from: "sad",
                        mix: .15,
                        endMix: .4,
                        chance: 14,
                        delay: 3,
                        step: 4
                    },
                    "idle-2": {
                        from: "idle",
                        mix: .75,
                        endMix: .7,
                        chance: 13,
                        delay: 3,
                        step: 3
                    }
                }
            },
            lvl3: {
                seedPosition: [0, -.8, -.5],
                seedScale: 1.8,
                cameraPositionPortrait: s.lvl3.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl3.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl3.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl3.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .7,
                        endMix: .6
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 22,
                        step: 3
                    },
                    "idle-2": {
                        from: "idle",
                        mix: .4,
                        endMix: .65,
                        chance: 11,
                        delay: 4,
                        step: 3
                    }
                }
            },
            lvl4: {
                seedPosition: [0, -.8, -.9],
                seedScale: 2.3,
                cameraPositionPortrait: s.lvl4.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl4.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl4.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl4.cameraRotationLandscape.slice()
            }
        },
        scene: JSON.parse(JSON.stringify(a))
    };
    t.default = o
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {hideCamera: r, commonCamera: s, commonScene: a} = n.a
      , o = {
        id: "cerisier",
        palette: "blue",
        prngSeed: 3,
        hideCamera: r,
        seedPresets: {
            lvl1: {
                seedPosition: [0, -.4, .115],
                seedScale: .25,
                cameraPositionPortrait: s.lvl1.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl1.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl1.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl1.cameraRotationLandscape.slice(),
                animations: {
                    request: {
                        mix: .3,
                        delay: 5,
                        chance: 25,
                        step: 3
                    },
                    "idle-2": {
                        from: "idle",
                        mix: .4,
                        delay: 3,
                        chance: 15,
                        step: 4
                    }
                }
            },
            lvl2: {
                seedPosition: [0, -.2, -.1],
                seedScale: .6,
                cameraPositionPortrait: s.lvl2.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl2.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl2.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl2.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .45
                    },
                    request: {
                        mix: .4,
                        delay: 4,
                        chance: 12,
                        step: 4
                    }
                }
            },
            lvl3: {
                seedPosition: [0, -1, -.5],
                seedScale: 1.8,
                cameraPositionPortrait: s.lvl3.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl3.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl3.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl3.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .7
                    },
                    request: {
                        mix: .4,
                        delay: 4,
                        chance: 12,
                        step: 4
                    },
                    check: {
                        from: "idle",
                        mix: .3,
                        delay: 3,
                        chance: 15,
                        step: 4
                    }
                }
            },
            lvl4: {
                seedPosition: [0, -.8, -.9],
                seedScale: 2.4,
                cameraPositionPortrait: s.lvl4.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl4.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl4.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl4.cameraRotationLandscape.slice()
            }
        },
        scene: JSON.parse(JSON.stringify(a))
    };
    t.default = o
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {hideCamera: r, commonCamera: s, commonScene: a} = n.a
      , o = {
        id: "immortelle",
        palette: "red",
        prngSeed: 4,
        hideCamera: r,
        seedPresets: {
            lvl1: {
                seedPosition: [0, -.5, .115],
                seedScale: .3,
                cameraPositionPortrait: s.lvl1.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl1.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl1.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl1.cameraRotationLandscape.slice(),
                animations: {
                    request: {
                        mix: .3,
                        delay: 3,
                        chance: 10,
                        step: 2
                    },
                    "bounce-up": {
                        from: "idle",
                        mix: .75,
                        delay: 4,
                        chance: 25,
                        step: 3
                    }
                }
            },
            lvl2: {
                seedPosition: [0, -.4, -.1],
                seedScale: .5,
                cameraPositionPortrait: s.lvl2.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl2.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl2.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl2.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .75
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 25,
                        step: 3
                    },
                    dance: {
                        from: "idle",
                        mix: .75,
                        chance: 10,
                        delay: 3,
                        step: 3
                    },
                    enigmatic: {
                        from: "sad",
                        mix: .4,
                        chance: 13,
                        delay: 3,
                        step: 3
                    }
                }
            },
            lvl3: {
                seedPosition: [0, -1, -.5],
                seedScale: 1.6,
                cameraPositionPortrait: s.lvl3.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl3.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl3.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl3.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .9
                    }
                }
            },
            lvl4: {
                seedPosition: [0, -.8, -.9],
                seedScale: 2.2,
                cameraPositionPortrait: s.lvl4.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl4.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl4.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl4.cameraRotationLandscape.slice()
            }
        },
        scene: JSON.parse(JSON.stringify(a))
    };
    t.default = o
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {hideCamera: r, commonCamera: s, commonScene: a} = n.a
      , o = {
        id: "karite",
        palette: "safari",
        prngSeed: 5,
        hideCamera: r,
        seedPresets: {
            lvl1: {
                seedPosition: [0, -.4, .115],
                seedScale: .3,
                cameraPositionPortrait: s.lvl1.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl1.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl1.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl1.cameraRotationLandscape.slice(),
                animations: {
                    request: {
                        mix: .3,
                        delay: 5,
                        chance: 13,
                        step: 3
                    }
                }
            },
            lvl2: {
                seedPosition: [0, -.6, .2],
                seedScale: .6,
                cameraPositionPortrait: s.lvl2.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl2.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl2.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl2.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .7
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 26,
                        step: 2
                    },
                    "idle-2": {
                        from: "idle",
                        mix: .75,
                        chance: 16,
                        delay: 3,
                        step: 3
                    }
                }
            },
            lvl3: {
                seedPosition: [0, -1, -.5],
                seedScale: 1.6,
                cameraPositionPortrait: s.lvl3.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl3.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl3.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl3.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .63
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 25,
                        step: 2
                    },
                    "idle-2": {
                        from: "idle",
                        mix: .75,
                        endMix: .6,
                        chance: 17,
                        delay: 3,
                        step: 3
                    }
                }
            },
            lvl4: {
                seedPosition: [0, -.8, -.9],
                seedScale: 2.3,
                cameraPositionPortrait: s.lvl4.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl4.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl4.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl4.cameraRotationLandscape.slice(),
                animations: {
                    "idle-2": {
                        from: "idle",
                        mix: .75,
                        endMix: .6,
                        chance: 16,
                        delay: 3,
                        step: 3
                    }
                }
            }
        },
        scene: JSON.parse(JSON.stringify(a))
    };
    t.default = o
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {hideCamera: r, commonCamera: s, commonScene: a} = n.a
      , o = {
        id: "lavande",
        palette: "tchern",
        prngSeed: 6,
        hideCamera: r,
        seedPresets: {
            lvl1: {
                seedPosition: [0, -.4, .115],
                seedScale: .3,
                cameraPositionPortrait: s.lvl1.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl1.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl1.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl1.cameraRotationLandscape.slice(),
                animations: {
                    request: {
                        mix: .3,
                        delay: 3,
                        chance: 10,
                        step: 2
                    },
                    bounce: {
                        from: "idle",
                        mix: .75,
                        chance: 13,
                        delay: 4,
                        step: 3
                    }
                }
            },
            lvl2: {
                seedPosition: [0, -.5, .2],
                seedScale: .5,
                cameraPositionPortrait: s.lvl2.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl2.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl2.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl2.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .75
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 25,
                        step: 3
                    }
                }
            },
            lvl3: {
                seedPosition: [0, -.6, -1.5],
                seedScale: 1.6,
                cameraPositionPortrait: s.lvl3.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl3.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl3.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl3.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .75
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 25,
                        step: 3
                    }
                }
            },
            lvl4: {
                seedPosition: [0, -.8, -.9],
                seedScale: 2.3,
                cameraPositionPortrait: s.lvl4.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl4.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl4.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl4.cameraRotationLandscape.slice()
            }
        },
        scene: JSON.parse(JSON.stringify(a))
    };
    t.default = o
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {hideCamera: r, commonCamera: s, commonScene: a} = n.a
      , o = {
        id: "rose",
        palette: "safari",
        prngSeed: 7,
        hideCamera: r,
        seedPresets: {
            lvl1: {
                seedPosition: [0, -.4, .115],
                seedScale: .3,
                cameraPositionPortrait: s.lvl1.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl1.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl1.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl1.cameraRotationLandscape.slice(),
                animations: {
                    request: {
                        mix: .3,
                        delay: 5,
                        chance: 25,
                        step: 3
                    },
                    atchoum: {
                        from: "idle",
                        mix: .75,
                        delay: 3,
                        chance: 9,
                        step: 4
                    }
                }
            },
            lvl2: {
                seedPosition: [0, -.4, 0],
                seedScale: .5,
                cameraPositionPortrait: s.lvl2.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl2.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl2.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl2.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .85
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 25,
                        step: 3
                    }
                }
            },
            lvl3: {
                seedPosition: [0, -1, -.5],
                seedScale: 1.5,
                cameraPositionPortrait: s.lvl3.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl3.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl3.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl3.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .85
                    },
                    sad2: {
                        from: "sad",
                        mix: .8,
                        chance: 10,
                        delay: 3,
                        step: 4
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 15,
                        step: 2
                    }
                }
            },
            lvl4: {
                seedPosition: [0, -1.2, -.9],
                seedScale: 2.2,
                cameraPositionPortrait: s.lvl4.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl4.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl4.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl4.cameraRotationLandscape.slice()
            }
        },
        scene: JSON.parse(JSON.stringify(a))
    };
    t.default = o
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {hideCamera: r, commonCamera: s, commonScene: a} = n.a
      , o = {
        id: "verveine",
        palette: "tchern",
        prngSeed: 8,
        hideCamera: r,
        seedPresets: {
            lvl1: {
                seedPosition: [0, -.4, .115],
                seedScale: .25,
                cameraPositionPortrait: s.lvl1.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl1.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl1.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl1.cameraRotationLandscape.slice(),
                animations: {
                    request: {
                        mix: .3,
                        delay: 5,
                        chance: 21,
                        step: 3
                    },
                    hair: {
                        from: "idle",
                        mix: .3,
                        delay: 3,
                        chance: 11,
                        step: 3
                    }
                }
            },
            lvl2: {
                seedPosition: [0, -.4, -.1],
                seedScale: .5,
                cameraPositionPortrait: s.lvl2.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl2.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl2.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl2.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .7,
                        endMix: .4
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 20,
                        step: 3
                    }
                }
            },
            lvl3: {
                seedPosition: [0, -.4, -.5],
                seedScale: 1.5,
                cameraPositionPortrait: s.lvl3.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl3.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl3.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl3.cameraRotationLandscape.slice(),
                animations: {
                    sad: {
                        mix: .7,
                        endMix: .4
                    },
                    request: {
                        mix: .4,
                        delay: 5,
                        chance: 20,
                        step: 3
                    }
                }
            },
            lvl4: {
                seedPosition: [0, -.8, -.9],
                seedScale: 2.3,
                cameraPositionPortrait: s.lvl4.cameraPositionPortrait.slice(),
                cameraRotationPortrait: s.lvl4.cameraRotationPortrait.slice(),
                cameraPositionLandscape: s.lvl4.cameraPositionLandscape.slice(),
                cameraRotationLandscape: s.lvl4.cameraRotationLandscape.slice()
            }
        },
        scene: JSON.parse(JSON.stringify(a))
    };
    t.default = o
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {commonScene: r} = n.a;
    t.default = {
        id: "bucket",
        palette: "safari",
        prngSeed: 10,
        camera: {
            cameraPositionHide: [-.7160562652342296, -3.613606680936024, 4.047986396086092],
            cameraRotationHide: [.186796817873539, -.040407700961518904, .007634837640536723],
            cameraHideColor: 4,
            cameraPositionPortrait: [.49053314826549527, 1.0252747916577072, 6.767667374438315],
            cameraRotationPortrait: [-.0401632481622802, .05203586799052559, .0020901073660476535],
            cameraPositionLandscape: [.49053314826549527, 1.0252747916577072, 6.767667374438315],
            cameraRotationLandscape: [-.0401632481622802, .05203586799052559, .0020901073660476535]
        },
        scene: [{
            id: "ground_c",
            pos: [-5.5, -.438, -2.5],
            size: [13.5, 10.5],
            ang: 0,
            color: 6,
            children: [{
                id: "plant_medium_q",
                pos: [-.1, -.07, -.1],
                size: [2, 2],
                ang: -.3,
                color: 4
            }, {
                id: "plant_medium_h",
                pos: [-.04, -.025, -.1],
                size: [1, 1],
                ang: 0,
                color: 4
            }, {
                id: "plant_big_c",
                pos: [.05, -.02, -.1],
                size: [.8, .8],
                ang: 0,
                color: 6
            }]
        }, {
            id: "ground_f",
            pos: [-12, -.5, -3.2],
            size: [16, 16],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_big_c",
                pos: [.15, -.015, 0],
                size: [.65, .65],
                ang: .3,
                color: 4
            }]
        }, {
            id: "ground_a",
            pos: [7.5, -.276, -3.5],
            size: [17.5, 19.5],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_big_d",
                pos: [-.08, -.01, 0],
                size: [1.5, 1.5],
                ang: -.1,
                color: 4
            }, {
                id: "bush_a",
                pos: [-.17, -.034, -.1],
                size: [1.2, 1.2],
                ang: -.1,
                color: 3
            }, {
                id: "plant_medium_q",
                pos: [-.01, -.02, -.1],
                size: [1.5, 1.5],
                ang: -.1,
                color: 6
            }, {
                id: "plant_medium_i",
                pos: [.1, -.045, -.2],
                size: [1.5, 1.5],
                ang: .2,
                color: 4
            }]
        }, {
            id: "ground_i",
            pos: [4, -1.3, -8],
            size: [10, 8],
            ang: 0,
            color: 10,
            children: [{
                id: "plant_small_e",
                pos: [.25, -.06, 0],
                size: [1.2, 1.2],
                ang: .3,
                color: 10
            }, {
                id: "plant_small_e",
                pos: [.243, -.06, 0],
                size: [1.2, 1.2],
                ang: -.1,
                color: 10
            }, {
                id: "plant_big_c",
                pos: [.15, -.07, 0],
                size: [1, 1],
                ang: 0,
                color: 10
            }, {
                id: "plant_big_a",
                pos: [-.15, -.07, 0],
                size: [1, 1],
                ang: 0,
                color: 10
            }, {
                id: "plant_small_e",
                pos: [.01, -.045, 0],
                size: [1.2, 1.2],
                ang: .3,
                color: 10
            }, {
                id: "plant_small_e",
                pos: [0, -.038, 0],
                size: [1.2, 1.2],
                ang: -.1,
                color: 10
            }]
        }, {
            id: "ground_e",
            pos: [.5, -.6, .1],
            size: [25, 5],
            ang: 0,
            color: 3,
            children: [{
                id: "bush_c",
                pos: [-.06, -.05, -.01],
                size: [1.8, 1.8],
                ang: -.4,
                color: 5
            }, {
                id: "plant_medium_o",
                pos: [-.145, -.16, -.01],
                size: [1, 1],
                ang: -.2,
                color: 3
            }, {
                id: "plant_medium_o",
                pos: [.12, -.18, .01],
                size: [1, 1],
                ang: .7,
                color: 3
            }, {
                id: "plant_big_c",
                pos: [-.04, -.05, -.1],
                size: [.4, .4],
                ang: 0,
                color: 5
            }]
        }, {
            id: "ground_f",
            pos: [2, -1, 1.5],
            size: [12, 10],
            ang: 0,
            color: 6,
            children: [{
                id: "plant_small_d",
                pos: [.005, -.03, 0],
                size: [1, 1],
                ang: -.5,
                color: 6
            }, {
                id: "plant_small_d",
                pos: [.007, -.03, 0],
                size: [1, 1],
                ang: 0,
                color: 6
            }, {
                id: "plant_small_d",
                pos: [.009, -.03, 0],
                size: [1, 1],
                ang: .6,
                color: 6
            }, {
                id: "plant_big_c",
                pos: [-.05, -.05, -.1],
                size: [.5, .5],
                ang: -.3,
                color: 6
            }]
        }, {
            id: "ground_e",
            pos: [-1, -.8, 5.1],
            size: [22.5, 6],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_medium_d",
                pos: [-.1, -.07, -.03],
                size: [.5, .5],
                ang: -.3,
                color: 4
            }, {
                id: "plant_medium_e",
                pos: [-.101, -.08, -.08],
                size: [.5, .5],
                ang: -.1,
                color: 2
            }, {
                id: "plant_medium_i",
                pos: [.009, -.02, -.01],
                size: [.5, .5],
                ang: -.1,
                color: 4
            }, {
                id: "bush_a",
                pos: [-.11, -.1, -.09],
                size: [.8, .8],
                ang: -.4,
                color: 5
            }]
        }, {
            id: "ground_ja",
            pos: [4.6, -.02, 3.8],
            size: [5, 5],
            ang: 0,
            color: 3,
            children: [{
                id: "ground_jb",
                pos: [0, -.05, .001],
                size: [5, 5],
                ang: 0,
                color: 4
            }, {
                id: "plant_medium_i",
                pos: [-.12, -.13, -.04],
                size: [1, 1],
                ang: -.3,
                color: 3
            }, {
                id: "plant_small_d",
                pos: [.208, -.03, .001],
                size: [.5, .5],
                ang: -.1,
                color: 3
            }, {
                id: "plant_small_d",
                pos: [.211, -.03, .001],
                size: [.5, .5],
                ang: .3,
                color: 3
            }, {
                id: "plant_small_d",
                pos: [.214, -.03, .001],
                size: [.5, .5],
                ang: .8,
                color: 3
            }]
        }, {
            id: "ground_i",
            pos: [9.5, -.04, 1],
            size: [15, 15],
            ang: 0,
            color: 5,
            children: [{
                id: "plant_small_f",
                pos: [.029, -.043, -.01],
                size: [1, 1],
                ang: -.1,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [.03, -.046, -.01],
                size: [1, 1],
                ang: .3,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [.032, -.045, -.01],
                size: [1, 1],
                ang: .7,
                color: 5
            }]
        }, {
            id: "ground_d",
            pos: [12, .8, 4],
            size: [30, 10],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_small_f",
                pos: [0, -.04, 0],
                size: [1, 1.4],
                ang: -.3,
                color: 4
            }, {
                id: "plant_small_f",
                pos: [.001, -.023, 0],
                size: [1, 1.3],
                ang: .2,
                color: 4
            }]
        }, {
            id: "ground_d",
            pos: [25, 1.8, 3],
            size: [80, 30],
            ang: 0,
            color: 6,
            children: [{
                id: "plant_big_d",
                pos: [0, -.04, 0],
                size: [1.5, 1.5],
                ang: -.1,
                color: 6
            }, {
                id: "plant_big_c",
                pos: [-.05, -.17, .01],
                size: [2.5, 2.5],
                ang: 0,
                color: 2
            }]
        }, {
            id: "ground_b",
            pos: [-11, .9, 4.3],
            size: [20, 10],
            ang: 0,
            color: 1,
            children: [{
                id: "plant_big_f",
                pos: [.05, -.03, -.01],
                size: [.85, .85],
                ang: .1,
                color: 6
            }, {
                id: "bush_a",
                pos: [-.068, -.03, -.01],
                size: [.75, .75],
                ang: -.1,
                color: 1
            }, {
                id: "plant_big_a",
                pos: [-.1, -.32, .01],
                size: [1.5, 1.5],
                ang: -.3,
                color: 4
            }, {
                id: "plant_medium_n",
                pos: [-.23, -.15, .01],
                size: [3, 3],
                ang: -.6,
                color: 1
            }]
        }, {
            id: "ground_d",
            pos: [-5, -.5, 1.98],
            size: [25, 8],
            ang: 0,
            color: 5,
            children: [{
                id: "plant_small_g",
                pos: [-.03, -.02, .01],
                size: [1, 1],
                ang: 0,
                color: 5
            }, {
                id: "bush_c",
                pos: [-.12, -.08, 0],
                size: [1.6, 1.6],
                ang: -.6,
                color: 5
            }, {
                id: "bush_b",
                pos: [.01, -.054, -.1],
                size: [2.5, 2.5],
                ang: .1,
                color: 2
            }, {
                id: "plant_medium_i",
                pos: [-.08, -.035, .1],
                size: [1.5, 1.5],
                ang: -.2,
                color: 3
            }]
        }, {
            id: "ground_d",
            pos: [-14, -1, -1],
            size: [30, 10],
            ang: 0,
            color: 3,
            children: [{
                id: "plant_small_f",
                pos: [-.05, .36 - .38, -.01],
                size: [1, 1.4],
                ang: -.3,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [-.048, .35 - .38, -.01],
                size: [1, 1.3],
                ang: .2,
                color: 5
            }]
        }]
    }
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {commonCamera: r, commonScene: s} = n.a;
    t.default = {
        id: "caterpillars",
        palette: "tchern",
        prngSeed: 11,
        camera: {
            cameraPositionHide: [-1.0954297415473269, -3.430971055088702, 4.492769411802064],
            cameraRotationHide: [.6861428568021931, -.007059405006077008, .005780637400389755],
            cameraHideColor: 7,
            cameraPositionPortrait: [.49053314826549527, 1.0252747916577072, 6.767667374438315],
            cameraRotationPortrait: [-.0401632481622802, .05203586799052559, .0020901073660476535],
            cameraPositionLandscape: [.49053314826549527, 1.0252747916577072, 6.767667374438315],
            cameraRotationLandscape: [-.0401632481622802, .05203586799052559, .0020901073660476535]
        },
        scene: [{
            id: "ground_c",
            pos: [-9.2, -.9, -3],
            size: [18, 10.5],
            ang: 0,
            color: 3,
            children: [{
                id: "plant_medium_q",
                pos: [-.1, -.07, -.1],
                size: [2, 2],
                ang: -.3,
                color: 3
            }, {
                id: "plant_medium_h",
                pos: [-.04, -.025, -.1],
                size: [1, 1],
                ang: 0,
                color: 3
            }, {
                id: "plant_big_c",
                pos: [.05, -.02, -.1],
                size: [.8, .8],
                ang: 0,
                color: 3
            }]
        }, {
            id: "ground_f",
            pos: [-12, 1, -3.2],
            size: [16, 16],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_big_c",
                pos: [.15, -.013, -.01],
                size: [.65, .65],
                ang: .3,
                color: 4
            }]
        }, {
            id: "ground_a",
            pos: [9, -.276, -3.5],
            size: [17.5, 19.5],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_big_d",
                pos: [-.08, -.01, 0],
                size: [1.1, 1.1],
                ang: -.1,
                color: 4
            }, {
                id: "bush_a",
                pos: [-.17, -.034, -.1],
                size: [1.2, 1.2],
                ang: -.1,
                color: 3
            }, {
                id: "plant_medium_q",
                pos: [-.01, -.02, -.1],
                size: [1.5, 1.5],
                ang: -.1,
                color: 4
            }, {
                id: "plant_medium_i",
                pos: [.1, -.045, -.2],
                size: [1.5, 1.5],
                ang: .2,
                color: 4
            }]
        }, {
            id: "ground_g",
            pos: [2, 2.4, -5],
            size: [25, 15],
            ang: 0,
            color: 7,
            children: [{
                id: "bush_c",
                pos: [.04, -.095, -.1],
                size: [2, 2],
                ang: .4,
                color: 7
            }, {
                id: "plant_medium_o",
                pos: [-.345, -.1, .01],
                size: [1, 1],
                ang: -.5,
                color: 7
            }, {
                id: "plant_big_c",
                pos: [-.04, -.04, -.1],
                size: [1, 1],
                ang: 0,
                color: 7
            }, {
                id: "bush_c",
                pos: [-.15, -.325, .05],
                size: [1.5, 1.5],
                ang: -.2,
                color: 7
            }, {
                id: "plant_medium_h",
                pos: [-.1, -.24, .02],
                size: [1, 1],
                ang: .2,
                color: 7
            }]
        }, {
            id: "ground_f",
            pos: [2.7, -.2, 1.5],
            size: [13, 10],
            ang: 0,
            color: 3,
            children: [{
                id: "plant_small_d",
                pos: [.108, .23 - .245, 0],
                size: [1, 1],
                ang: -.5,
                color: 3
            }, {
                id: "plant_small_d",
                pos: [.11, .23 - .245, 0],
                size: [1, 1],
                ang: 0,
                color: 3
            }, {
                id: "plant_small_d",
                pos: [.112, .23 - .245, 0],
                size: [1, 1],
                ang: .6,
                color: 3
            }, {
                id: "plant_big_c",
                pos: [-.1, -.1, -.1],
                size: [.5, .5],
                ang: -.3,
                color: 3
            }]
        }, {
            id: "ground_e",
            pos: [-.2, -.8, 2.5],
            size: [37, 8],
            ang: 0,
            color: 5,
            children: [{
                id: "plant_medium_i",
                pos: [-.06, -.02, -.01],
                size: [.6 * 1.5, .6 * 1.5],
                ang: -.3,
                color: 5
            }, {
                id: "plant_big_k",
                pos: [.06, -.07, -.01],
                size: [.6 * 1.5, .6 * 1.5],
                ang: .3,
                color: 5
            }, {
                id: "plant_small_g",
                pos: [-.035, -.014, -.07],
                size: [.3 * 1.5, .3 * 1.5],
                ang: -.2,
                color: 5
            }, {
                id: "plant_medium_h",
                pos: [-.02, -.017, -.07],
                size: [.6 * 1.5, .6 * 1.5],
                ang: -.2,
                color: 5
            }]
        }, {
            id: "ground_ja",
            pos: [3.6, -.02, 3.8],
            size: [5, 5],
            ang: 0,
            color: 4,
            children: [{
                id: "ground_jb",
                pos: [0, -.05, .001],
                size: [5, 5],
                ang: 0,
                color: 3
            }, {
                id: "plant_medium_i",
                pos: [-.12, -.13, -.04],
                size: [1, 1],
                ang: -.3,
                color: 4
            }, {
                id: "plant_small_d",
                pos: [.208, -.03, .001],
                size: [.5, .5],
                ang: -.1,
                color: 4
            }, {
                id: "plant_small_d",
                pos: [.211, -.03, .001],
                size: [.5, .5],
                ang: .3,
                color: 4
            }, {
                id: "plant_small_d",
                pos: [.214, -.03, .001],
                size: [.5, .5],
                ang: .8,
                color: 4
            }]
        }, {
            id: "ground_i",
            pos: [10, -.04, 1],
            size: [15, 15],
            ang: 0,
            color: 5,
            children: [{
                id: "plant_small_f",
                pos: [.029, -.043, -.01],
                size: [1, 1],
                ang: -.1,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [.03, -.046, -.01],
                size: [1, 1],
                ang: .3,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [.032, -.045, -.01],
                size: [1, 1],
                ang: .7,
                color: 5
            }]
        }, {
            id: "ground_d",
            pos: [-12, 2, -12],
            size: [40, 15],
            ang: 0,
            color: 5,
            children: [{
                id: "plant_small_f",
                pos: [0, -.04, 0],
                size: [1.5, 1.4 * 1.5],
                ang: -.3,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [.001, -.023, 0],
                size: [1.5, 1.3 * 1.5],
                ang: .2,
                color: 5
            }]
        }, {
            id: "ground_d",
            pos: [17.8, 2, -8.5],
            size: [85, 30],
            ang: 0,
            color: 3,
            children: [{
                id: "plant_big_d",
                pos: [0, -.04, 0],
                size: [1.5, 1.5],
                ang: -.1,
                color: 3
            }]
        }, {
            id: "ground_b",
            pos: [-5, .5, 4.3],
            size: [20, 10],
            ang: 0,
            color: 7,
            children: [{
                id: "plant_big_f",
                pos: [.15, -.07, -.01],
                size: [.4, .4],
                ang: .1,
                color: 7
            }, {
                id: "bush_a",
                pos: [-.068, -.03, -.01],
                size: [.75, .75],
                ang: -.1,
                color: 7
            }, {
                id: "plant_big_a",
                pos: [-.1, -.32, .01],
                size: [1.5, 1.5],
                ang: -.3,
                color: 7
            }, {
                id: "plant_medium_n",
                pos: [-.23, -.15, .01],
                size: [3, 3],
                ang: -.6,
                color: 7
            }]
        }, {
            id: "ground_d",
            pos: [6, 4, -13],
            size: [40, 10],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_small_g",
                pos: [-.03, -.01, .01],
                size: [.5, .5],
                ang: 0,
                color: 4
            }, {
                id: "plant_medium_i",
                pos: [-.08, -.032, .1],
                size: [1, 1],
                ang: -.2,
                color: 4
            }]
        }, {
            id: "ground_i",
            pos: [-4, 4, -14],
            size: [20, 10],
            ang: 0,
            color: 3,
            children: [{
                id: "plant_small_e",
                pos: [.25, -.06, 0],
                size: [1.2, 1.2],
                ang: .3,
                color: 3
            }, {
                id: "plant_small_e",
                pos: [.243, -.06, 0],
                size: [1.2, 1.2],
                ang: -.1,
                color: 3
            }, {
                id: "plant_big_c",
                pos: [.15, -.07, 0],
                size: [1, 1],
                ang: 0,
                color: 3
            }, {
                id: "plant_big_a",
                pos: [-.15, -.07, 0],
                size: [1, 1],
                ang: 0,
                color: 3
            }, {
                id: "plant_small_e",
                pos: [.01, -.045, 0],
                size: [1.2, 1.2],
                ang: .3,
                color: 3
            }, {
                id: "plant_small_e",
                pos: [0, -.038, 0],
                size: [1.2, 1.2],
                ang: -.1,
                color: 3
            }]
        }]
    }
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {commonScene: r} = n.a;
    t.default = {
        id: "spiders",
        palette: "blue",
        prngSeed: 10,
        camera: {
            cameraPositionHide: [1.9496457353605072, -2.304883897505669, 4.071118094122123],
            cameraRotationHide: [.3407166390092628, -.010492404498757732, .003719927292966863],
            cameraHideColor: 7,
            cameraPositionPortrait: [.49053314826549527, 1.0252747916577072, 6.767667374438315],
            cameraRotationPortrait: [-.0401632481622802, .05203586799052559, .0020901073660476535],
            cameraPositionLandscape: [.49053314826549527, 1.0252747916577072, 6.767667374438315],
            cameraRotationLandscape: [-.0401632481622802, .05203586799052559, .0020901073660476535]
        },
        scene: [{
            id: "ground_c",
            pos: [-5.5, -.438, -2.5],
            size: [13.5, 10.5],
            ang: 0,
            color: 7,
            children: [{
                id: "plant_medium_q",
                pos: [-.1, -.07, -.1],
                size: [2, 2],
                ang: -.3,
                color: 4
            }, {
                id: "plant_medium_h",
                pos: [-.04, -.025, -.1],
                size: [1, 1],
                ang: 0,
                color: 4
            }, {
                id: "plant_big_c",
                pos: [.05, -.02, -.1],
                size: [.8, .8],
                ang: 0,
                color: 7
            }]
        }, {
            id: "ground_f",
            pos: [-12, -.5, -3.2],
            size: [16, 16],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_big_c",
                pos: [.15, -.015, 0],
                size: [.65, .65],
                ang: .3,
                color: 4
            }]
        }, {
            id: "ground_a",
            pos: [7.5, -.276, -3.5],
            size: [17.5, 19.5],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_big_d",
                pos: [-.08, -.01, 0],
                size: [1.5, 1.5],
                ang: -.1,
                color: 4
            }, {
                id: "bush_a",
                pos: [-.17, -.034, -.1],
                size: [1.2, 1.2],
                ang: -.1,
                color: 3
            }, {
                id: "plant_medium_q",
                pos: [-.01, -.02, -.1],
                size: [1.5, 1.5],
                ang: -.1,
                color: 7
            }, {
                id: "plant_medium_i",
                pos: [.1, -.045, -.2],
                size: [1.5, 1.5],
                ang: .2,
                color: 4
            }]
        }, {
            id: "ground_i",
            pos: [4, -2.3, -8],
            size: [10, 8],
            ang: 0,
            color: 10,
            children: [{
                id: "plant_small_e",
                pos: [.25, -.06, 0],
                size: [1.2, 1.2],
                ang: .3,
                color: 10
            }, {
                id: "plant_small_e",
                pos: [.243, -.06, 0],
                size: [1.2, 1.2],
                ang: -.1,
                color: 10
            }, {
                id: "plant_big_c",
                pos: [.15, -.07, 0],
                size: [1, 1],
                ang: 0,
                color: 10
            }, {
                id: "plant_big_a",
                pos: [-.15, -.07, 0],
                size: [1, 1],
                ang: 0,
                color: 10
            }, {
                id: "plant_small_e",
                pos: [.01, -.045, 0],
                size: [1.2, 1.2],
                ang: .3,
                color: 10
            }, {
                id: "plant_small_e",
                pos: [0, -.038, 0],
                size: [1.2, 1.2],
                ang: -.1,
                color: 10
            }]
        }, {
            id: "ground_e",
            pos: [-.8, -1.3, .01],
            size: [25, 5],
            ang: 0,
            color: 5,
            children: [{
                id: "bush_c",
                pos: [-.06, -.05, -.01],
                size: [1.8, 1.8],
                ang: -.4,
                color: 5
            }, {
                id: "plant_medium_o",
                pos: [-.145, -.16, -.01],
                size: [1, 1],
                ang: -.2,
                color: 5
            }, {
                id: "plant_medium_o",
                pos: [.1, -.13, .01],
                size: [1, 1],
                ang: .7,
                color: 5
            }, {
                id: "plant_big_c",
                pos: [-.04, -.05, -.1],
                size: [.4, .4],
                ang: 0,
                color: 5
            }]
        }, {
            id: "ground_f",
            pos: [3, -.7, 1.5],
            size: [12, 10],
            ang: 0,
            color: 1,
            children: [{
                id: "plant_small_d",
                pos: [.108, .23 - .245, 0],
                size: [1, 1],
                ang: -.5,
                color: 1
            }, {
                id: "plant_small_d",
                pos: [.11, .23 - .245, 0],
                size: [1, 1],
                ang: 0,
                color: 1
            }, {
                id: "plant_small_d",
                pos: [.112, .23 - .245, 0],
                size: [1, 1],
                ang: .6,
                color: 1
            }, {
                id: "plant_big_c",
                pos: [-.05, -.05, -.1],
                size: [.5, .5],
                ang: -.3,
                color: 1
            }]
        }, {
            id: "ground_ka",
            pos: [-5, .02, 4],
            size: [5, 5],
            ang: 0,
            color: 6,
            children: [{
                id: "ground_kb",
                pos: [.03, -.05, .012],
                size: [5, 5],
                ang: 0,
                color: 5
            }, {
                id: "plant_big_k",
                pos: [.45, -.04, -.05],
                size: [.5, .5],
                ang: .2,
                color: 9
            }, {
                id: "plant_medium_f",
                pos: [.56, -.065, -.002],
                size: [.4, .4],
                ang: .5,
                color: 7
            }]
        }, {
            id: "ground_ja",
            pos: [2.6, -.02, 3.8],
            size: [5, 5],
            ang: 0,
            color: 7,
            children: [{
                id: "ground_jb",
                pos: [0, -.05, .001],
                size: [5, 5],
                ang: 0,
                color: 4
            }, {
                id: "plant_medium_i",
                pos: [-.12, -.13, -.04],
                size: [1, 1],
                ang: -.3,
                color: 7
            }, {
                id: "plant_small_d",
                pos: [.208, -.03, .001],
                size: [.5, .5],
                ang: -.1,
                color: 7
            }, {
                id: "plant_small_d",
                pos: [.211, -.03, .001],
                size: [.5, .5],
                ang: .3,
                color: 7
            }, {
                id: "plant_small_d",
                pos: [.214, -.03, .001],
                size: [.5, .5],
                ang: .8,
                color: 7
            }]
        }, {
            id: "ground_i",
            pos: [9.5, -.04, 1],
            size: [15, 15],
            ang: 0,
            color: 5,
            children: [{
                id: "plant_small_f",
                pos: [.029, -.043, -.01],
                size: [1, 1],
                ang: -.1,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [.03, -.046, -.01],
                size: [1, 1],
                ang: .3,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [.032, -.045, -.01],
                size: [1, 1],
                ang: .7,
                color: 5
            }]
        }, {
            id: "ground_d",
            pos: [10, .8, 4],
            size: [30, 10],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_small_f",
                pos: [-.1, -.06, 0],
                size: [1, 1.4],
                ang: -.3,
                color: 4
            }, {
                id: "plant_small_f",
                pos: [-.1, -.07, 0],
                size: [1, 1.3],
                ang: -.4,
                color: 4
            }]
        }, {
            id: "ground_b",
            pos: [-9, .9, 4.3],
            size: [20, 10],
            ang: 0,
            color: 1,
            children: [{
                id: "plant_big_f",
                pos: [.05, -.03, -.01],
                size: [.85, .85],
                ang: .1,
                color: 7
            }, {
                id: "bush_a",
                pos: [-.068, -.03, -.01],
                size: [.75, .75],
                ang: -.1,
                color: 1
            }, {
                id: "plant_big_a",
                pos: [-.1, -.32, .01],
                size: [1.5, 1.5],
                ang: -.3,
                color: 4
            }, {
                id: "plant_medium_n",
                pos: [-.23, -.15, .01],
                size: [3, 3],
                ang: -.6,
                color: 1
            }]
        }, {
            id: "ground_d",
            pos: [-5, -.05, 2],
            size: [25, 8],
            ang: 0,
            color: 3,
            children: [{
                id: "plant_small_g",
                pos: [-.03, -.02, .01],
                size: [1, 1],
                ang: 0,
                color: 3
            }, {
                id: "bush_c",
                pos: [-.12, -.07, 0],
                size: [1.6, 1.6],
                ang: -.6,
                color: 3
            }, {
                id: "bush_b",
                pos: [.01, -.054, -.1],
                size: [2.5, 2.5],
                ang: .1,
                color: 2
            }, {
                id: "plant_medium_i",
                pos: [-.08, -.035, .1],
                size: [1.5, 1.5],
                ang: -.2,
                color: 3
            }]
        }, {
            id: "ground_d",
            pos: [-14, -1, -1],
            size: [30, 10],
            ang: 0,
            color: 5,
            children: [{
                id: "plant_small_f",
                pos: [-.05, .36 - .38, -.01],
                size: [1, 1.4],
                ang: -.3,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [-.048, .35 - .38, -.01],
                size: [1, 1.3],
                ang: .2,
                color: 5
            }]
        }]
    }
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 41.9 55.2"><path class="garden_leaf_one" d="M23.4 18.1l-.9-1C13.1 7.3 16.6.6 16.8.4l.4-.7.7.3c10 4.5 6.2 16.3 6.1 16.8l-.6 1.3zM17.9 1.9c-.5 1.7-1 6.4 4.8 13 .6-2.9 1.2-9.7-4.8-13z"/><path class="garden_leaf_two" d="M27.1 18.9c-1.9 0-3-.5-3.2-.6l-.7-.3.2-.7C27.2 5.9 39.9 9.5 40 9.5l1.3.4-.8 1c-5.6 6.6-10.4 8-13.4 8zM25.4 17c1.8.4 6.6.7 12.8-6.1-3-.6-10-.9-12.8 6.1z"/><path class="garden_head" d="M14.1 55.2c-.8 0-1.6-.1-2.3-.2-3.5-.7-6.6-2.8-8.7-6C.2 44.6-.6 38.7.7 32.7c2.5-11 11.7-18.6 20.5-16.8 3.6.7 6.7 2.9 8.8 6.2 2.9 4.5 3.6 10.6 2.1 16.7-2.6 9.5-10.3 16.4-18 16.4zm4.5-37.6c-7 0-14 6.5-16 15.5-1.2 5.4-.5 10.8 2.1 14.7 1.8 2.8 4.4 4.6 7.4 5.2 7.5 1.4 15.5-5.2 18-14.7 1.4-5.5.8-11.1-1.8-15.1-1.8-2.9-4.4-4.7-7.5-5.3-.8-.2-1.5-.3-2.2-.3z"/><circle class="garden_eye_left" cx="13.6" cy="30.5" r="1.6"/><circle class="garden_eye_right" cx="22.1" cy="33.7" r="1.6"/><path class="garden_mouth" d="M20.2 41.9s-.1 0 0 0C12 41.2 9 37.6 8.9 37.4c-.3-.4-.3-1 .2-1.4.4-.3 1.1-.3 1.4.2 0 .1 2.7 3.1 9.8 3.7.6 0 1 .5.9 1.1 0 .5-.5.9-1 .9z"/></svg>\n'
        }],
        id: "src/app/components/svg/icon_garden.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/svg/icon_garden.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 750 567"><path fill="#01073B" d="M0 0v390.6c145.9-103.7 410.6-77 499.6-49.1C598.3 372.4 727 383 727 383c7.9.8 15.6 1.9 23 3.3V0H0z"/><g fill-rule="evenodd" clip-rule="evenodd"><path fill="#7980AA" d="M637.8 109.8s.4 3.2 2.8 3.2c0 0-2.8.8-2.8 3.2 0 0-.5-3.3-3.1-3.3 1.7 0 3.1-1.4 3.1-3.1z"/><path fill="#8087B5" d="M151.8 215.8s.4 3.2 2.8 3.2c0 0-2.8.8-2.8 3.2 0 0-.4-3.3-3.1-3.3 1.7 0 3.1-1.4 3.1-3.1z"/><path fill="#8E94C4" d="M549.8 132.8s.4 3.2 2.8 3.2c0 0-2.8.8-2.8 3.2 0 0-.5-3.3-3.1-3.3 1.7 0 3.1-1.4 3.1-3.1z"/><path fill="#8D93C5" d="M169.9 166.4s.4 3.2 2.8 3.2c0 0-2.8.8-2.8 3.2 0 0-.4-3.3-3.1-3.3 1.7 0 3.1-1.4 3.1-3.1z"/><path fill="#7F87AE" d="M99.8 38.5s.5 4.5 3.9 4.5c0 0-3.9 1.1-3.9 4.5 0 0-.6-4.6-4.3-4.6 2.4 0 4.3-2 4.3-4.4z"/><path fill="#8890B4" d="M572.9 202.9s.6 5.1 4.5 5.1c0 0-4.5 1.3-4.5 5.1 0 0-.7-5.3-5-5.3 2.7 0 5-2.2 5-4.9z"/><path fill="#725C37" d="M645.8 23.2s.5 3.8 3.4 3.8c0 0-3.4 1-3.4 3.8 0 0-.5-4-3.7-4 2 .1 3.7-1.6 3.7-3.6z"/><path fill="#6D6452" d="M546.8 260.8s.4 3.2 2.8 3.2c0 0-2.8.8-2.8 3.2 0 0-.4-3.3-3.1-3.3 1.7 0 3.1-1.4 3.1-3.1z"/><path fill="#6C594A" d="M235.8 253.8s.4 3.2 2.8 3.2c0 0-2.8.8-2.8 3.2 0 0-.4-3.3-3.1-3.3 1.7 0 3.1-1.4 3.1-3.1z"/><path fill="#7E85B1" d="M87.8 145.8s.4 3.2 2.8 3.2c0 0-2.8.8-2.8 3.2 0 0-.4-3.3-3.1-3.3 1.7 0 3.1-1.4 3.1-3.1z"/></g><path fill-rule="evenodd" clip-rule="evenodd" fill="#0C546C" d="M612.9 255.3c-.4-.6-1.3-15 3.5-21.2 4.9-6.1 0 .7 0 .7s-.4 12.2-1.4 16.3c0 0 5.2-9.7 11.3-12.7 0 0-8.3 15.3-12.7 17.6-.3-.2-.5-.4-.7-.7z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#193672" d="M48 310s.5-3.8 0-5-5.2-5.3-7-7-5.1-4.8-4-6c0 0 .3-.8 3 2l7 5s2.1 2.7 2 1c-.2-1.2-.9-2.3-2-3l-8-8s-1.4-1.8-1-3c0 0 .7-1.4 3 1l6 5 2 2c.6-.4.7-1.2.2-1.8-.1-.1-.1-.2-.2-.2l-8-8s-3.6-3.2-2-5c0 0 1.2.1 5 4l3 2s3.5 2.5 3 0l-5-5-4-5s-2-2.9 0-3c0 0 1.7.7 5 4 0 0 2.9 3.7 3 1-.3-1.5-1-2.9-2-4 0 0-4.6-5.5-3-7 0 0 .8-1.8 3 2l1 2v-8s-1-2.7 1-2c0 0 1.7.4 2 4v7s.8.9 2-1c0 0 1.2-3.6 2-2 0 0 1 .8 0 3l-2 4s-2.7 4.4 0 3l5-3s2.1-.3 2 1-2.1 3.3-3 4-4 3-4 3-1.4 5.2 1 3l4-3s3.8-2.6 4-1c-.1 1.5-.8 3-2 4l-5 4s-3.3 1.9-2 3 1 0 1 0-.3.3 2-1l4-3s3.5-1.4 4 1c0 0-2.2 3.4-4 4l-6 3s-2.8 1.6-2 3c0 0 .2 1.3 3 0l4-2s4.7-1.3 5 0c-1.1 1.3-2.4 2.3-4 3 0 0-5.9 3.8-7 4s-2 1.9-2 4v2h-2c-.4.1-1-1-1-1zM76.4 310.2c.1-1.3.1-2.5 0-3.8-.3-.9-2.5-4-3.3-5.3s-2.4-3.6-1.9-4.6c0 0 .2-.6 1.4 1.5l3.3 3.8s1 2.1 1 .8c-.1-.8-.4-1.6-1-2.3l-3.8-6.1c-.4-.7-.5-1.5-.5-2.3 0 0 .3-1.1 1.4.8l2.9 3.8 1 1.5c.3-.5.3-1.1 0-1.5l-3.8-6.1s-1.7-2.5-1-3.8c0 0 .6.1 2.4 3.1l1.4 1.5s1.7 1.9 1.4 0l-2.4-3.8-1.9-3.8s-.9-2.2 0-2.3c1 .9 1.8 1.9 2.4 3.1 0 0 1.4 2.8 1.4.8-.1-1.1-.4-2.1-1-3.1 0 0-2.2-4.2-1.4-5.3 0 0 .4-1.3 1.4 1.5l.5 1.5v-6.1s-.5-2.1.5-1.5c0 0 .8.3 1 3.1v5.3s.4.7 1-.8c0 0 .6-2.7 1-1.5 0 0 .5.6 0 2.3l-1 3.1s-1.3 3.4 0 2.3l2.4-2.3c.4-.1.8.1.9.5v.3c-.2 1.1-.7 2.2-1.4 3.1-.4.5-1.9 2.3-1.9 2.3s-.7 3.9.5 2.3l1.9-2.3s1.8-2 1.9-.8c0 1.1-.4 2.1-1 3.1l-2.4 3s-1.6 1.4-1 2.3.5 0 .5 0-.1.2 1-.8l1.9-2.3s1.7-1 1.9.8c0 0-1.1 2.6-1.9 3.1l-2.9 2.3s-1.3 1.2-1 2.3c0 0 .1 1 1.4 0l1.9-1.5s2.3-1 2.4 0c-.4.9-1.1 1.7-1.9 2.3-1 1.1-2.1 2.1-3.3 3.1-.5.2-1 1.4-1 3.1v1.5h-1c-.1-.6-.3-.9-.3-1.2zM750 205.5c-26.9 4.1-50.2 14-62 20.5-17.9 9.9-25.3 16.1-50 21-37.2 7.3-38 21-38 21l-17.6 94.2C658 377.3 727 383 727 383c7.9.8 15.6 1.9 23 3.3V205.5z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#193672" d="M.3 321.4c-.1 0-.2.1-.3.1v69.2c57.9-41.1 134.4-61.7 211.2-69.9-71-27.7-155.5-15.1-210.9.6z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#071552" d="M485 286c-54.4 23.2-119 26-119 26-10 .9-19.2 2.7-27.9 5.3 68.4 3.2 127.7 13.6 161.5 24.2C598.3 372.4 727 383 727 383c7.9.8 15.6 1.9 23 3.3V284c-93.6-35.3-220.5-17-265 2z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#1F4F8D" d="M499.6 341.5C598.3 372.4 727 383 727 383c4.1.4 8.1.9 12 1.5-11.7-17.2-25-34.3-40.1-50.5-93.8-100.5-266.7-53.2-321.1-30-12.9 5.5-26.4 9.9-39.5 13.3 68.4 3.2 127.5 13.6 161.3 24.2z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#193672" d="M593.4 338.8c-15.6 6.6-32 11.6-47.5 15.3C634.3 375.4 727 383 727 383c7.9.8 15.6 1.9 23 3.3v-79.1c-65.9.4-127.8 19.4-156.6 31.6z"/></svg>\n'
        }],
        id: "src/app/components/svg/bg_top.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/svg/bg_top.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 596 1200">\n\t<clipPath id="wave_left" clipPathUnits="objectBoundingBox" >\n\t\t<path\n\t\t\td="M0,0v1200l596,0c0-68.1-86-227.1-86-621c0-367.1,69-579,69-579H0z"\n\t\t\tref="wavePath"\n\t\t/>\n\t</clipPath>\n</svg>\n'
        }],
        id: "src/app/components/svg/wave_left.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/svg/wave_left.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 596 1200">\n\t<clipPath id="wave_right" clipPathUnits="objectBoundingBox" >\n\t\t<path\n\t\t\td="M17,0c0,0,69,211.9,69,579c0,393.9-86,552.9-86,621l596,0V0L17,0z"\n\t\t\t'
        }, {
            type: "raw",
            value: "\n\t\t/>\n\t</clipPath>\n</svg>\n"
        }],
        id: "src/app/components/svg/wave_right.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/svg/wave_right.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {
    var n = (0,
    i(10).twig)({
        allowInlineIncludes: !0,
        data: [{
            type: "raw",
            value: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 357.2 158.4"><path fill="#738CBD" d="M55.2 22.8h2.4V126h-2.4z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#58C1C9" d="M58.8 32.4s6.9-10.8 12-14.4c0 0 2.1 5.4-13.2 19.2l1.2-4.8z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#56BFC6" d="M58.2 41.2s8.3-9.8 13.9-12.6c0 0 1.4 5.7-15.7 17.2l1.8-4.6zM57.8 49s9.2-8.9 15-11.2c0 0 .8 5.8-17.3 15.6l2.3-4.4zM58.3 55.2s11.5-5.5 17.8-5.9c0 0-1.1 5.7-21.4 9.3l3.6-3.4z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#4283C1" d="M57 88.8s5.8-5.7 9-6.1c0 0-.5 5.9-10.8 9.6l1.8-3.5z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#4283C1" d="M54.6 88.8s-5.8-5.7-9-6.1c0 0 .5 5.9 10.8 9.6l-1.8-3.5zM57 112.8s5.8-5.7 9-6.1c0 0-.5 5.9-10.8 9.6l1.8-3.5z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#4283C1" d="M54.6 112.8s-5.8-5.7-9-6.1c0 0 .5 5.9 10.8 9.6l-1.8-3.5z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#56BFC6" d="M53.3 55.2s-11.5-5.5-17.8-5.9c0 0 1.1 5.7 21.4 9.3l-3.6-3.4z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#55BCC6" d="M54 32.4S47.1 21.6 42 18c0 0-2.1 5.4 13.2 19.2L54 32.4zM54.6 41.2s-8.3-9.8-13.9-12.6c0 0-1.4 5.7 15.7 17.2l-1.8-4.6z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#56BFC6" d="M55 49s-9.2-8.9-15-11.2c0 0-.8 5.8 17.3 15.6L55 49zM57.6 0S54 5.2 54 15.6c0 0 0 7.7 2.4 12 0 0 4.8-5.9 4.8-12S59.1 4.1 57.6 0z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#FFF" d="M26 116s1.5-4.3 10.8-7.5 16.3-10.9 20.4-13.8 18.6-21.3 50.5-18.8c0 0 109 8.5 139.4 6.3s33.6 6.1 39.7 8.8 25.4 11.8 49.3 16.3c0 0 13.2 0 13.2 10s-23.4 28-97.3 37.7c0 0-144.7 16.9-217.5-23.8-.1-.2-12.4-10.9-8.5-15.2z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#2B6BB7" d="M26.4 114s1.5-4.1 10.8-7.2 16.3-10.4 20.4-13.2 18.6-20.4 50.4-18c0 0 108.8 8.2 139.2 6s33.5 5.8 39.6 8.4 25.4 11.3 49.2 15.6c0 0 13.2 0 13.2 9.6s-23.4 26.7-97.2 36c0 0-144.5 16.2-217.2-22.8 0 0-12.3-10.3-8.4-14.4z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#20559C" d="M30.2 111.7s21-4.6 105.4-.1c79.1 4.2 64.2-13.7 86.6-28.9.7-.5-56.4-3-57-3-18.8-.2-38.3-4.7-72-4-8.9.2-13.6 5.9-23 9-7.8 2.6-18.8 17-40 27z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#6FC9EF" d="M188 109.4s47.7-7.7 81.6 1.2c28.6 7.5 59.6 5.2 77-1.8 3.2-1.3-20.7-5-32.4-9.1 0 0-7-2.5-22-8-8.6-3.2-11.2-10.4-34-11-34.3-.9-45.8 1-62 0-13.5-.8-32.3-2-32.3-2s7.7 18 24.1 30.7z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#356DB0" d="M31.5 46.6l-4.3 10c-.5 1-.8 2.1-1 3.2-.2 1.6-1.2 3.3-1 3.2s-1.5 1.3-1.2 1.7.7-.8.3 1.5c-.4 2.3-1.4 3.6-.7 4.7s2.9 3.4 2.3 4.2c-.7.9-1 2.1-1 3.2.2.7.5.6.5 3s.9 2.5.8 4.5c.1 2 .5 4 1 5.9 0 0-.8.9.5 3s3.5 3.2 4 5.4 1.6 5.9 2.8 7.2 2.1 4.7 3.7 3.9 5-.3 4.2-2.3-.6-1.5-.5-3 2.1-1.6.9-3.2-1.8-1.1-2-2.7.2-2.1-.8-4.5-1.9-3.2-2.5-5.7-.1-2.6-1-5.9c-.5-2-.8-3.9-1-5.9-.3-1.2 1.4-1.2 1-3.2s-1.2-3.2-.8-4.5 1.7-2.4 1-3.2.5-1.3-.5-3c-1.1-1.7-2.4-1.3-2.3-4.2s.1-2.7-.8-4.5.1-2.7-.8-4.5c-.7-1.3-.9-2.8-.8-4.3z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#20559C" d="M77.5 85.3c-.8-.4-9.9-17.4-7.2-27.6s.4.9.4.9 6.2 14.9 7.2 20.4c0 0 1.1-14.6 7.2-21.8 0 0-2 23.2-6.2 28.6-.6-.1-1-.2-1.4-.5z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#65CFC2" d="M328.8 106.8l1.9-1.9 2.2-5.7 9.9-.8c5.4-.9 5.3-2.8 5.3-2.8.7-1.5-1-1.4-1-1.4l-12.4 1.6c-1.8.2 1.4-1 1.4-1l12.6-2.8c3.8-1.2 2.8-2 2.8-2 0-1.5-2.2-1.6-2.2-1.6L338 90.3c-2.2.4.2-1.2.2-1.2l10.1-2c4.5-1 5.3-2.8 5.3-2.8.1-1.5-2.2-1.6-2.2-1.6l-6.3 1.4c-3.9 1.1-4.9.4-4.9.4-.7-1.3 2.8-2 2.8-2l8.9-2.2c3.4-1.2 4.1-3 4.1-3 .4-2.2-3.4-1.8-3.4-1.8l-5.1 1.6c-3.3.4.4-2.4.4-2.4l5.1-1.6c4.4-1 3.9-1.8 3.9-1.8.9-1.7-2.2-1.6-2.2-1.6l-3.7.6 3-3.2c2.7-3.9 2-4.5 2-4.5-1.2-1.6-2.6.8-2.6.8l-3.2 4.3c-2.1 3.2-2.6.8-2.6.8.5-3.8-1.8-3.9-1.8-3.9-2.1-.1-1.2 7.1-1.2 7.1-.1 3.8-2 4.5-2 4.5-1.5 1.1-1.8-3.9-1.8-3.9-.5-3.3-1.8-3.9-1.8-3.9-.6-.1-1.2.2-1.4.8v.2c-.6 2.1.6 11 .6 11 .2 2-1.4 1-1.4 1s-.9-1.9-1.8-3.9-.1-4.8-1.6-5.1-1.7 1.7-1.8 3.4c0 2.2.4 4.3 1.4 6.3 1 1.8 2.6 2.7 1.6 5.1s-2.4-.4-2.4-.4l-2.8-5.3c-2-3.4-3.2-3-3.2-3-2.4 1.8 2.4 7.7 2.4 7.7s3.5 4.5 2.6 6.5c-.3.9-1.1 1.3-2 1.1l-.6-.3-3-4.1c-.8-1.5-1.8-2.9-3-4.1-1.7-.4-1.6 2.2-1.6 2.2 2 5.6 6.7 10.8 6.7 10.8l-.6 7.2 1.7 1.3z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#48A3C2" d="M0 70.6s14.4 3.3 19.5 10.2l3.5 5.6 2.9 2s2 4.7 2.1 4.6 2.9 1.3 3.1 3.2 1.4 2.6 1.9 3.4.9 2.5 1.9 3.4-.1 1.7 1.9 3.4 2.8 1.4 3.1 3.2-3.8 2-4.7 2.1c-2.4.1-3.6 1.5-4.9.9-3.5-1.7-5.6-3.2-5.8-4s1.1-1.6-.7-3.6-2.9-3.9-3.3-4.4c-.6-.7-1.1-1.4-1.7-2.2-.6-.8-.8-1.7-1.7-2.2-2.5-1.5-3-.5-4.3-3s-3.3-5.4-1.9-3.4.1-2.6-.7-3.6-2.6-3.4-1.7-2.2-1.4-.5-1.7-2.2-.9 0-1.7-2.2-.8-1.4-1.9-3.4S0 70.6 0 70.6z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#0E236F" d="M286.3 119.9s-1.9 16.2 2.8 25c0 0 1.8.7 1.1-2.6.1 0-4.2-19.1-3.9-22.4zm10.9-3.7s-6.3 10.3-7.5 17.5c0 0-.7 4.3 1.1 4.6.7-1.1 1.2-2.2 1.5-3.5.1.1 4.1-16.6 4.9-18.6zm4 10s-5.4 4.4-9 13.8c0 0-1.5 4.4-.1 5.1 1.3-1.1 2.2-2.4 2.7-4 .1 0 3.3-10.7 6.4-14.9z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#6FC9EF" d="M301.2 76.7s-4.9 16.9-.7 27c0 0 2 1 1.8-2.6 0 0-2-20.9-1.1-24.4zm13.6-2.3s-9.3 10-11.8 17.6c0 0-1.5 4.5.6 5.1 1-1 1.8-2.2 2.4-3.5 0-.1 7.6-17.2 8.8-19.2zm3.2 11.2s-7.2 3.9-13 13.4c0 0-2.5 4.5-1 5.4 1.6-.9 3-2.2 3.9-3.9.1 0 5.7-10.9 10.1-14.9z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#153180" d="M52.8 98.4s9.1 3.8 14.1 9l-3.5-12.5s10.6 8.5 12.3 21.5l3.5 3.6v-12.5s6.2.2 8.8 17.9c0 0 .3 5.5 1.8 5.4l1.8-12.5s3.6 1 3.5 12.5v7.2s.4 3.5 1.8 1.8l1.8-12.5s1.6-7.1 3.5 3.6V147s-5.2 1.9-15.8 0l-10.5-3.6H88s10.9-1.6 1.8-3.6c0 0-14-2.1-17.6-5.4 0 0-4.5-3.2 1.8-1.8h10.5s2.6-2.5-3.5-3.6c0 0-10.8-1.1-15.8-3.6 0 0-9.1-6.8 0-5.4l12.3 1.8s-2.8-2.7-8.8-3.6c0 0-12.6-2.9-15.8-5.4 1.7-.4 3.5-.4 5.3 0 2.3.4 4.7.4 7 0-.1-.1-10.7-7.4-12.4-14.4z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#3770B3" d="M303.3 58.2s.8 5.3-15.3 14.5v18.5h-2.4V72.6c-16-9.1-15.3-14.5-15.3-14.5 5 2 13 8.9 15.3 11v-3.8c-15.8-11-14.5-16.3-14.5-16.3 4.7 2.4 12.3 9.8 14.5 12.1v-3.5.1c-15.3-13.8-13.2-19.2-13.2-19.2 4.3 3 11.2 12.5 13.2 15.4v-7.4c-1.2-3.3-1.9-6.7-2.1-10.2-.5-10.4 2.9-15.8 2.9-15.8 1.7 4.1 4 9.4 4.3 15.4.2 3.7-1.4 7.4-2.7 9.7v8.1c2.2-3.1 9-12.3 13.2-15.2 0 0 2.1 5.4-13.2 19.2v3.4c2.4-2.4 9.8-9.6 14.5-12 0 0 1.3 5.4-14.5 16.3V69c2.5-2.1 10.4-8.9 15.3-10.8z"/></svg>\n'
        }],
        id: "src/app/components/svg/feuille.twig",
        rethrow: !0
    });
    e.exports = function(e) {
        return n.render(e)
    }
    ,
    e.exports.id = "src/app/components/svg/feuille.twig",
    e.exports.default = e.exports
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(21);
    const {commonScene: r} = n.a;
    t.default = {
        id: "intra",
        palette: "supablue",
        prngSeed: 18,
        camera: {
            cameraPositionHide: [1.9496457353605072, -2.304883897505669, 4.071118094122123],
            cameraRotationHide: [.3407166390092628, -.010492404498757732, .003719927292966863],
            cameraPositionChoiceLandscape: [0, 8.389219708397569, 7.29832521319173],
            cameraRotationChoiceLandscape: [.0330391550009703, 0, .00027247045345180196],
            cameraPositionChoicePortrait: [0, 8.038863150294352, 10.641547819243394],
            cameraRotationChoicePortrait: [.08347027483111377, 0, .00104767343132242],
            cameraPositionPortrait: [0, 1.2706060452770742, 7.703231783493287],
            cameraRotationPortrait: [.044044618490880066, 0, -.003776985002431326],
            cameraPositionLandscape: [0, 1.746319887750029, 7.475264403792982],
            cameraRotationLandscape: [-.013582183329414682, 0, -.0005322698796024272]
        },
        scene: [{
            id: "ground_c",
            pos: [-5.5, -.438, -2.5],
            size: [13.5, 10.5],
            ang: 0,
            color: 10,
            children: [{
                id: "plant_medium_q",
                pos: [-.1, -.07, -.1],
                size: [2, 2],
                ang: -.3,
                color: 2
            }, {
                id: "plant_medium_h",
                pos: [-.04, -.025, -.1],
                size: [1, 1],
                ang: 0,
                color: 10
            }, {
                id: "plant_big_c",
                pos: [.05, -.02, -.1],
                size: [.8, .8],
                ang: 0,
                color: 2
            }]
        }, {
            id: "ground_f",
            pos: [-12, -.5, -3.2],
            size: [16, 16],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_big_c",
                pos: [.15, -.015, 0],
                size: [.65, .65],
                ang: .3,
                color: 4
            }]
        }, {
            id: "ground_a",
            pos: [7.5, -.276, -3.5],
            size: [17.5, 19.5],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_big_d",
                pos: [-.08, -.01, 0],
                size: [1.5, 1.5],
                ang: -.1,
                color: 4
            }, {
                id: "bush_a",
                pos: [-.17, -.034, -.1],
                size: [1.2, 1.2],
                ang: -.1,
                color: 3
            }, {
                id: "plant_medium_q",
                pos: [-.01, -.02, -.1],
                size: [1.5, 1.5],
                ang: -.1,
                color: 7
            }, {
                id: "plant_medium_i",
                pos: [.1, -.045, -.2],
                size: [1.5, 1.5],
                ang: .2,
                color: 4
            }]
        }, {
            id: "ground_i",
            pos: [-7.5, -1.7, -8],
            size: [10, 8],
            ang: 0,
            color: 10,
            children: [{
                id: "plant_small_d",
                pos: [.15, -.08, 0],
                size: [1.2, 1.2],
                ang: .3,
                color: 10
            }, {
                id: "plant_small_d",
                pos: [.143, -.08, 0],
                size: [1.2, 1.2],
                ang: -.1,
                color: 10
            }, {
                id: "plant_big_b",
                pos: [.243, -.07, 0],
                size: [1, 1],
                ang: 0,
                color: 10
            }]
        }, {
            id: "ground_i",
            pos: [4, -1.3, -8],
            size: [10, 8],
            ang: 0,
            color: 10,
            children: [{
                id: "plant_small_e",
                pos: [.25, -.06, 0],
                size: [1.2, 1.2],
                ang: .3,
                color: 10
            }, {
                id: "plant_small_e",
                pos: [.243, -.06, 0],
                size: [1.2, 1.2],
                ang: -.1,
                color: 10
            }, {
                id: "plant_big_c",
                pos: [.15, -.07, 0],
                size: [1, 1],
                ang: 0,
                color: 10
            }, {
                id: "plant_big_a",
                pos: [-.15, -.07, 0],
                size: [1, 1],
                ang: 0,
                color: 10
            }, {
                id: "plant_small_e",
                pos: [.01, -.045, 0],
                size: [1.2, 1.2],
                ang: .3,
                color: 10
            }, {
                id: "plant_small_e",
                pos: [0, -.038, 0],
                size: [1.2, 1.2],
                ang: -.1,
                color: 10
            }]
        }, {
            id: "ground_e",
            pos: [-.7, -.046, .1],
            size: [25, 5],
            ang: 0,
            color: 5,
            children: [{
                id: "bush_c",
                pos: [-.06, -.05, -.01],
                size: [1.8, 1.8],
                ang: -.4,
                color: 5
            }, {
                id: "plant_medium_o",
                pos: [-.145, -.16, -.01],
                size: [1, 1],
                ang: -.2,
                color: 5
            }, {
                id: "plant_medium_o",
                pos: [.1, -.13, .01],
                size: [1, 1],
                ang: .7,
                color: 5
            }, {
                id: "plant_big_c",
                pos: [-.04, -.05, -.1],
                size: [.4, .4],
                ang: 0,
                color: 5
            }]
        }, {
            id: "ground_f",
            pos: [2, -.046, 1.5],
            size: [12, 10],
            ang: 0,
            color: 1,
            children: [{
                id: "plant_small_d",
                pos: [.108, .23 - .245, 0],
                size: [1, 1],
                ang: -.5,
                color: 1
            }, {
                id: "plant_small_d",
                pos: [.11, .23 - .245, 0],
                size: [1, 1],
                ang: 0,
                color: 1
            }, {
                id: "plant_small_d",
                pos: [.112, .23 - .245, 0],
                size: [1, 1],
                ang: .6,
                color: 1
            }, {
                id: "plant_big_c",
                pos: [-.1, -.1, -.1],
                size: [.5, .5],
                ang: -.3,
                color: 1
            }]
        }, {
            id: "ground_e",
            pos: [0, .3, 5.1],
            size: [22.5, 6],
            ang: 0,
            color: 2,
            children: [{
                id: "plant_medium_d",
                pos: [-.1, -.07, -.03],
                size: [.5, .5],
                ang: -.3,
                color: 5
            }, {
                id: "plant_medium_e",
                pos: [-.101, -.08, -.08],
                size: [.5, .5],
                ang: -.1,
                color: 3
            }, {
                id: "plant_medium_i",
                pos: [-.06, -.02, -.01],
                size: [1, 1],
                ang: -.3,
                color: 3
            }, {
                id: "plant_big_k",
                pos: [.06, -.08, -.01],
                size: [1, 1],
                ang: .3,
                color: 7
            }, {
                id: "bush_a",
                pos: [-.11, -.1, -.09],
                size: [.8, .8],
                ang: -.4,
                color: 3
            }, {
                id: "plant_small_g",
                pos: [-.035, -.014, -.07],
                size: [.3, .3],
                ang: -.2,
                color: 3
            }, {
                id: "plant_medium_h",
                pos: [-.02, -.017, -.07],
                size: [.6, .6],
                ang: -.2,
                color: 3
            }]
        }, {
            id: "ground_b",
            pos: [8.6, .5, 5.8],
            size: [18.5, 8],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_big_a",
                pos: [-.1, -.04, -.01],
                size: [.85, .85],
                ang: -.2,
                color: 7
            }, {
                id: "plant_big_j",
                pos: [.2, -.32, .01],
                size: [2.5, 2.5],
                ang: .2,
                color: 7
            }, {
                id: "plant_big_c",
                pos: [-.15, -.3, .01],
                size: [1, 1],
                ang: -.3,
                color: 7
            }]
        }, {
            id: "ground_ka",
            pos: [-7.9, .2, 6],
            size: [6.5, 6.5],
            ang: 0,
            color: 7,
            children: [{
                id: "ground_kb",
                pos: [.03, -.05, .012],
                size: [6.5, 6.5],
                ang: 0,
                color: 4
            }, {
                id: "plant_big_k",
                pos: [.45, -.04, -.05],
                size: [.8, .8],
                ang: .2,
                color: 9
            }, {
                id: "plant_medium_f",
                pos: [.57, -.08, -.001],
                size: [.8, .8],
                ang: .5,
                color: 7
            }]
        }, {
            id: "ground_ja",
            pos: [4.6, -.02, 3.8],
            size: [5, 5],
            ang: 0,
            color: 3,
            children: [{
                id: "ground_jb",
                pos: [0, -.05, .001],
                size: [5, 5],
                ang: 0,
                color: 4
            }, {
                id: "plant_medium_i",
                pos: [-.12, -.13, -.04],
                size: [1, 1],
                ang: -.3,
                color: 4
            }, {
                id: "plant_small_d",
                pos: [.208, -.03, .001],
                size: [.5, .5],
                ang: -.1,
                color: 3
            }, {
                id: "plant_small_d",
                pos: [.211, -.03, .001],
                size: [.5, .5],
                ang: .3,
                color: 3
            }, {
                id: "plant_small_d",
                pos: [.214, -.03, .001],
                size: [.5, .5],
                ang: .8,
                color: 3
            }]
        }, {
            id: "ground_i",
            pos: [9.5, -.04, 1],
            size: [15, 15],
            ang: 0,
            color: 5,
            children: [{
                id: "plant_small_f",
                pos: [.029, -.043, -.01],
                size: [1, 1],
                ang: -.1,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [.03, -.046, -.01],
                size: [1, 1],
                ang: .3,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [.032, -.045, -.01],
                size: [1, 1],
                ang: .7,
                color: 5
            }]
        }, {
            id: "ground_d",
            pos: [12, .8, 4],
            size: [30, 10],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_small_f",
                pos: [0, -.04, 0],
                size: [1, 1.4],
                ang: -.3,
                color: 4
            }, {
                id: "plant_small_f",
                pos: [.001, -.023, 0],
                size: [1, 1.3],
                ang: .2,
                color: 4
            }]
        }, {
            id: "ground_d",
            pos: [25, 1.8, 3],
            size: [80, 30],
            ang: 0,
            color: 7,
            children: [{
                id: "plant_big_d",
                pos: [0, -.04, 0],
                size: [1.5, 1.5],
                ang: -.1,
                color: 7
            }, {
                id: "plant_big_c",
                pos: [-.05, -.17, .01],
                size: [2.5, 2.5],
                ang: 0,
                color: 2
            }]
        }, {
            id: "ground_b",
            pos: [-11, .9, 4.3],
            size: [20, 10],
            ang: 0,
            color: 1,
            children: [{
                id: "plant_big_f",
                pos: [.05, -.03, -.01],
                size: [.85, .85],
                ang: .1,
                color: 7
            }, {
                id: "bush_a",
                pos: [-.068, -.03, -.01],
                size: [.75, .75],
                ang: -.1,
                color: 1
            }, {
                id: "plant_medium_n",
                pos: [-.23, -.15, .01],
                size: [3, 3],
                ang: -.6,
                color: 1
            }, {
                id: "plant_big_a",
                pos: [-.1, -.33, .01],
                size: [1.5, 1.5],
                ang: -.3,
                color: 4
            }, {
                id: "plant_big_e",
                pos: [.05, -.32, .01],
                size: [1.2, 1.2],
                ang: .2,
                color: 4
            }]
        }, {
            id: "ground_d",
            pos: [-5, -.05, 2],
            size: [25, 8],
            ang: 0,
            color: 7,
            children: [{
                id: "plant_small_g",
                pos: [-.03, -.02, .01],
                size: [1, 1],
                ang: 0,
                color: 7
            }, {
                id: "bush_c",
                pos: [-.12, -.07, 0],
                size: [1.6, 1.6],
                ang: -.6,
                color: 7
            }, {
                id: "bush_b",
                pos: [.01, -.054, -.1],
                size: [2.5, 2.5],
                ang: .1,
                color: 7
            }, {
                id: "plant_medium_i",
                pos: [-.08, -.035, .1],
                size: [1.5, 1.5],
                ang: -.2,
                color: 7
            }]
        }, {
            id: "ground_d",
            pos: [-14, -1, -1],
            size: [30, 10],
            ang: 0,
            color: 5,
            children: [{
                id: "plant_small_f",
                pos: [-.05, .36 - .38, -.01],
                size: [1, 1.4],
                ang: -.3,
                color: 5
            }, {
                id: "plant_small_f",
                pos: [-.048, .35 - .38, -.01],
                size: [1, 1.3],
                ang: .2,
                color: 5
            }]
        }, {
            id: "ground_d",
            pos: [-17, .8, 4],
            size: [30, 10],
            ang: 0,
            color: 4,
            children: [{
                id: "plant_small_f",
                pos: [0, -.02, 0],
                size: [1, 1.4],
                ang: -.3,
                color: 4
            }, {
                id: "plant_small_f",
                pos: [.001, -.023, 0],
                size: [1, 1.3],
                ang: .2,
                color: 4
            }]
        }, {
            id: "ground_d",
            pos: [-25, 1.8, 5],
            size: [80, 30],
            ang: 0,
            color: 7,
            children: [{
                id: "plant_big_d",
                pos: [.07, -.06, 0],
                size: [1.5, 1.5],
                ang: .3,
                color: 7
            }, {
                id: "plant_big_i",
                pos: [.04, -.14, .5],
                size: [3, 3],
                ang: 0,
                color: 2
            }]
        }, {
            id: "ground_i",
            pos: [0, -.4, 6.2],
            size: [15, 15],
            ang: 0,
            color: 2,
            children: []
        }, {
            id: "ground_c",
            pos: [.4, -3.6, 7.12],
            size: [2, 1.5],
            ang: 0,
            color: 0,
            children: [{
                id: "plant_medium_k",
                pos: [.1, -.017, .001],
                size: [.12, .12],
                ang: -.2,
                color: 7
            }, {
                id: "plant_medium_l",
                pos: [.01, -.017, .001],
                size: [.12, .12],
                ang: -.2,
                color: 7
            }, {
                id: "plant_big_i",
                pos: [.08, -.27, .001],
                size: [.4, .4],
                ang: -.3,
                color: 7
            }]
        }, {
            id: "ground_c",
            pos: [-.4, -3.63, 7.1],
            size: [2, 1.2],
            ang: 0,
            color: 7,
            children: [{
                id: "plant_medium_i",
                pos: [.1, -.017, .001],
                size: [.12, .12],
                ang: -.2,
                color: 7
            }, {
                id: "plant_medium_c",
                pos: [.156, -.052, .001],
                size: [.12, .12],
                ang: -.2,
                color: 7
            }, {
                id: "plant_medium_b",
                pos: [.16, -.052, .001],
                size: [.12, .12],
                ang: .2,
                color: 7
            }]
        }]
    }
}
, function(e, t, i) {
    "use strict";
    i.r(t);
    var n = i(20)
      , r = i(27);
    let s, a, o = !1;
    const l = {};
    function c() {
        const e = window.devicePixelRatio
          , t = Math.min(window.screen.width, window.screen.height) * e
          , i = Math.max(window.screen.width, window.screen.height) * e
          , n = m(["ipad"]);
        return n && i <= 1024 ? "apple a8 gpu" : n && i >= 2200 ? "apple a10 gpu" : !n && t < 640 ? "apple a6 gpu" : !n && t <= 640 ? "apple a7 gpu" : !n && t <= 750 ? "apple a9 gpu" : !n && t <= 1080 ? "apple a9 gpu" : !n && i >= 2e3 ? "apple a10 gpu" : "apple gpu"
    }
    function h(e) {
        let t = e.toLowerCase();
        return (t = (t = t.replace(/(\(tm\)|\(r\))/g, "")).trim()).includes("angle (") && t.includes("direct3d") && (t = t.replace("angle (", "").split(" direct3d")[0]),
        t.includes("nvidia") && t.includes("gb") && (t = t.split(/\dgb/)[0]),
        t
    }
    function u(e) {
        const t = e.string
          , i = t.split(" ");
        let n = i.length;
        for (; n--; ) {
            const r = i[n].replace(/[\D]/g, "");
            r.length > 0 && (e.version || (e.mobile = "m" === t[t.length - 1],
            e.version = parseFloat(r)),
            e.numbers.unshift(parseFloat(r)))
        }
        return null
    }
    function p(e) {
        const t = {
            "nvidia geforce gtx": "geforce gtx",
            "nvidia geforce rtx": "geforce rtx",
            "nvidia geforce mx": "geforce mx",
            "nvidia titan": "geforce titan",
            "nvidia quadro fx": "quadro fx",
            "nvidia quadro p": "quadro p",
            "nvidia quadro rtx": "quadro rtx",
            "nvidia quadro ": "quadro",
            "nvidia geforce ": "geforce",
            "nvidia tegra ": "tegra",
            "amd radeon vii": "radeon vii",
            "amd radeon r7": "radeon r7",
            "amd radeon r9": "radeon r9",
            "amd radeon r10": "radeon r10",
            "amd radeon rx": "radeon rx",
            "amd radeon pro vega": "radeon pro vega",
            "amd radeon rx vega": "radeon rx vega",
            "amd radeon hd": "radeon hd",
            "amd radeon pro ": "radeon pro",
            "amd radeon ": "radeon",
            "intel iris ": "intel iris",
            "intel iris plus ": "intel iris plus",
            "intel iris pro ": "intel iris pro",
            "intel hd ": "intel hd",
            "intel uhd ": "intel uhd",
            "apple a": "apple gpu",
            adreno: "adreno",
            "mali-t": "mali t",
            "mali-g": "mali g",
            mali: "mali",
            "mesa offscreen": "cpu",
            swiftshader: "cpu"
        }
          , i = {};
        for (const n in t)
            e.indexOf(n) > -1 && (i[t[n]] = !0);
        return i
    }
    function d(e) {
        const t = ["", "WEBKIT_", "MOZ_"];
        let i = null;
        for (const n in t)
            if (i = a.getExtension(t[n] + e))
                break;
        return i
    }
    function f() {
        const e = {
            s3tc: !1,
            astc: !1,
            etc: !1,
            pvrtc: !1
        };
        return a ? (d("WEBGL_compressed_texture_s3tc") && (e.s3tc = !0),
        d("WEBGL_compressed_texture_astc") && (e.astc = !0),
        d("WEBGL_compressed_texture_etc") && (e.etc = !0),
        d("WEBGL_compressed_texture_pvrtc") && (e.pvrtc = !0),
        e) : e
    }
    function m(e) {
        Array.isArray(e) || (e = [e]);
        for (let t = 0; t < e.length; t++)
            if (l.userAgent.match(e[t]))
                return !0;
        return !1
    }
    var g = {
        init: function(e) {
            if (!o) {
                o = !0,
                l.userAgent = e || navigator.userAgent.toLowerCase(),
                s = document.createElement("canvas");
                try {
                    a = s.getContext("webgl") || s.getContext("webgl-experimental") || s.getContext("experimental-webgl")
                } catch (e) {}
                if (l.hasTouch = "ontouchstart"in window,
                l.hasWebGL = !!a,
                l.type = function() {
                    const e = l.hasTouch && m(["ios", "iphone", "ipad", "windows", "android", "blackberry"]);
                    let t, i;
                    return e && (t = Math.max(screen.width, screen.height) > 900,
                    i = !t),
                    {
                        phone: !!i,
                        tablet: !!t,
                        mobile: !!e,
                        desktop: !e
                    }
                }(),
                l.os = function() {
                    const e = l.type.desktop ? [["mac os", "macos"], ["windows", "windows"], ["linux", "linux"]] : [[["ipad", "iphone"], "ios"], [["windows", "iemobile"], "windows"], [["android", "kindle"], "android"], ["blackberry", "blackberry"]];
                    for (const t of e)
                        if (m(t[0]))
                            return t[1];
                    return "Unknown"
                }(),
                l.browser = function() {
                    const e = [[["edge"], "edge"], [["msie", "trident", "rv:"], "ie"], ["chrome", "chrome"], [["safari", "ios"], "safari"], ["firefox", "firefox"]];
                    for (const t of e)
                        if (m(t[0]))
                            return t[1]
                }(),
                l.browserVersion = function() {
                    const e = e => Number(l.userAgent.split(e)[1].split(".")[0]);
                    switch (l.browser) {
                    case "chrome":
                    case "firefox":
                        return e(`${l.browser.toLowerCase()}/`);
                    case "safari":
                        let t = l.userAgent.match(/version\/([.\d]+)/i);
                        return t && t[1] ? parseFloat(t[1]) : (t = l.userAgent.match(/os ([0-9_]+)/i)) && t[1] ? parseFloat(t[1].split("_")[0]) : void 0;
                    case "ie":
                    case "edge":
                        return m("msie") ? e("msie") : m("rv:") ? e("rv:") : e("edge/");
                    default:
                        return
                    }
                }(),
                l.supportedVideoFormats = function() {
                    const e = document.createElement("video");
                    return {
                        ogg: e.canPlayType('video/ogg; codecs="theora"'),
                        h264: e.canPlayType('video/mp4; codecs="avc1.42E01E"'),
                        webm: e.canPlayType('video/webm; codecs="vp8, vorbis"')
                    }
                }(),
                l.gpu = function() {
                    const e = {
                        type: null,
                        series: null,
                        version: null,
                        numbers: [],
                        mobile: null,
                        string: null
                    };
                    if (!a)
                        return e;
                    const t = d("WEBGL_debug_renderer_info")
                      , i = t ? a.getParameter(t.UNMASKED_RENDERER_WEBGL) : ""
                      , n = ["intel", "nvidia", "amd", "adreno", "apple", "mali"];
                    for (let t = 0; t < n.length; t++) {
                        const r = n[t];
                        let s = h(i);
                        if (s.indexOf(r) > -1)
                            return e.type = r.toLowerCase(),
                            "ios" === l.os && "apple gpu" === s && (s = c()),
                            e.string = s,
                            u(e),
                            e.series = p(s),
                            e
                    }
                    return e
                }(),
                l.webGL = {
                    renderer: a && (a.getParameter(a.RENDERER) || "").toLowerCase(),
                    version: a && (a.getParameter(a.VERSION) || "").toLowerCase(),
                    glsl: a && (a.getParameter(a.SHADING_LANGUAGE_VERSION) || "").toLowerCase(),
                    extensions: a && a.getSupportedExtensions(),
                    compressedTextures: f()
                },
                l.gpu.quality = function() {
                    if (!l.gpu || !l.gpu.type)
                        return "firefox" === l.browser && l.type.desktop ? "medium" : "low";
                    const e = l.gpu.mobile
                      , t = l.gpu.type
                      , i = l.gpu.series
                      , n = l.gpu.version || 0
                      , r = l.gpu.numbers
                      , s = r[Math.max(0, r.length - 2)] || 0
                      , a = r[Math.max(0, r.length - 1)] || 0
                      , o = (e, t) => i[e] && n >= t
                      , c = (e, t) => i[e] && n <= t
                      , h = (e, t, n) => i[e] && s >= t && a >= n
                      , u = {
                        ultra: [i["geforce rtx"] || i["geforce titan"] || i["quadro gtx"], e && o("geforce gtx", 780) || !e && o("geforce gtx", 680), o("quadro p", 400), i["radeon vii"] || i["radeon r10"] || i["radeon r9"], o("radeon r7", 370), o("radeon rx", 570), o("radeon rx vega", 56)],
                        high: [i["geforce gtx"], o("geforce mx", 150), o("radeon pro", 450), o("radeon hd", 5570) && !l.gpu.mobile, (o("intel iris plus", 650) || o("intel iris pro", 580)) && c("intel iris", 5e3), o("adreno", 418), o("apple gpu", 9), h("mali g", 71), h("mali t", 760, 8) || h("mali t", 880)],
                        medium: ["nvidia" === t || "amd" === t, i["intel iris plus"] || i["intel iris pro"], o("intel hd", 630) && c("intel hd", 2e3), o("adreno", 430), !l.type.tablet && o("apple gpu", 8), i["mali g"], h("mali t", 800, 2) || h("mali t", 860)],
                        low: ["cpu" === t]
                    };
                    for (const e in u)
                        for (let t = 0, i = u[e].length; t < i; t++)
                            if (u[e][t])
                                return e;
                    return "low"
                }(),
                l.webGL && l.webGL.compressedTextures) {
                    const e = l.webGL.compressedTextures
                      , t = "dev" === n.a.env.current
                      , i = r.a.forceCompressedTextureInDev.current;
                    r.a.useCompressedTexture.current && ((e.pvrtc || e.s3tc || e.astc) && (!t || t && i) ? r.a.useCompressedTexture.set(!0) : r.a.useCompressedTexture.set(!1),
                    r.a.useCompressedTexture.current && (e.astc ? r.a.compressedTextureFormat.set("astc") : e.pvrtc ? r.a.compressedTextureFormat.set("pvrtc") : e.s3tc && r.a.compressedTextureFormat.set("s3tc")))
                }
                a && a.getExtension("WEBGL_lose_context") && a.getExtension("WEBGL_lose_context").loseContext(),
                s = a = null,
                function() {
                    const e = document.getElementsByTagName("html")[0];
                    l.hasTouch && e.classList.add("touch");
                    for (const t in l.type)
                        l.type[t] && e.classList.add(t.toLowerCase());
                    l.browser && l.browser.length > 0 && e.classList.add(l.browser.toLowerCase()),
                    l.os && l.os.length > 0 && "Unknown" !== l.os && e.classList.add(l.os.toLowerCase()),
                    l.gpu.quality && e.classList.add(l.gpu.quality.toLowerCase())
                }(),
                n.a.device.set(l)
            }
        }
    }
      , v = i(81)
      , y = i(12)
      , b = i(5)
      , x = ["default", "none", "context-menu", "help", "pointer", "progress", "wait", "cell", "crosshair", "text", "vertical-text", "alias", "copy", "move", "no-drop", "not-allowed", "all-scroll", "col-resize", "row-resize", "grab", "grabbing", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"];
    const w = {};
    function _(e) {
        x.forEach(t => {
            document.body.classList.toggle(w[t], t === e)
        }
        )
    }
    x.forEach(e => w[e] = "__cursor--" + e);
    var T = {
        appendInlineStyle: function() {
            const e = document.head || document.getElementsByTagName("head")[0]
              , t = document.createElement("style");
            t.type = "text/css";
            let i = "";
            x.forEach(e => {
                i += `body.${w[e]} { ` + `cursor: ${e} !important; ` + `cursor: -webkit-${e}; ` + "}"
            }
            ),
            t.innerHTML = i,
            e.appendChild(t)
        },
        setCursor: _,
        removeCursor: function() {
            _()
        }
    };
    const M = [0, 0]
      , S = [0, 0];
    let A = !0;
    const P = .6
      , C = 10
      , L = 3;
    let k = 0;
    const E = {
        clickIn: !1,
        clickOut: !1,
        pressed: !1,
        pos: new Float32Array([0, 0]),
        relativePos: new Float32Array([0, 0]),
        delta: new Float32Array([0, 0])
    };
    function I(e) {
        e.preventDefault()
    }
    function F() {
        n.a.pressed.set(E.pressed),
        n.a.touch.update(e => (e.pressed = E.pressed,
        e.clickIn = E.clickIn,
        e.clickOut = E.clickOut,
        e.pos[0] = E.pos[0],
        e.pos[1] = E.pos[1],
        e.relativePos[0] = E.relativePos[0],
        e.relativePos[1] = E.relativePos[1],
        e.delta[0] = E.delta[0],
        e.delta[1] = E.delta[1],
        e), !0)
    }
    function O() {
        (E.clickIn || E.clickOut) && (A = !0,
        E.clickOut = E.clickIn = !1),
        E.delta[0] = E.pos[0] - S[0],
        E.delta[1] = E.pos[1] - S[1],
        S[0] = E.pos[0],
        S[1] = E.pos[1];
        const e = n.a.touch.current.delta;
        A || (A = e[0] !== E.delta[0] || e[1] !== E.delta[1]),
        A && (F(),
        A = !1)
    }
    function R(e) {
        if (!e || n.a.scrollable.current)
            return !1;
        if (!e.target)
            return !0;
        return !function e(t) {
            if (!t)
                return !1;
            const i = t.tagName;
            return !!(t.dataset && void 0 !== t.dataset.bypassTouch || "BUTTON" === i || "INPUT" === i || "A" === i || "SELECT" === i) || !(!t.parentNode || t.parentNode === document.body || !t.parentNode.dataset) && e(t.parentNode)
        }(e.target)
    }
    function z(e) {
        if (n.a.menuOpen.current)
            return;
        if (!R(e))
            return !1;
        e.preventDefault(),
        k = Date.now();
        const t = e.changedTouches ? e.changedTouches[0] : e
          , i = t.clientX || 0
          , r = t.clientY || 0;
        E.delta[0] = 0,
        E.delta[1] = 0,
        M[0] = E.pos[0] = S[0] = i,
        M[1] = E.pos[1] = S[1] = r,
        E.relativePos[0] = 0,
        E.relativePos[1] = 0,
        E.pressed = !0,
        E.clickIn = !0,
        E.clickOut = !1,
        A = !0,
        F()
    }
    function N(e) {
        R(e) && e.preventDefault();
        const t = e.changedTouches ? e.changedTouches[0] : e
          , i = t.clientX || 0
          , n = t.clientY || 0;
        E.pos[0] = i,
        E.pos[1] = n,
        E.relativePos[0] = E.pressed ? E.pos[0] - M[0] : 0,
        E.relativePos[1] = E.pressed ? E.pos[1] - M[1] : 0,
        A = !0
    }
    function D(e) {
        if (n.a.menuOpen.current)
            return;
        if (R(e))
            e.preventDefault();
        else if (!E.pressed)
            return;
        const t = E.relativePos[0]
          , i = Math.abs(E.delta[0])
          , r = Math.abs(t)
          , s = e.changedTouches ? e.changedTouches[0] : e
          , a = s.clientX || 0
          , o = s.clientY || 0;
        if (E.pos[0] = a,
        E.pos[1] = o,
        E.clickIn = !1,
        E.pressed && (E.clickOut = !0),
        E.pressed = !1,
        A = !0,
        F(),
        n.a.device.current.hasTouch) {
            2 * Math.abs(Math.abs(Object(b.ang)(0, 0, E.relativePos[0], E.relativePos[1]) / Math.PI) - .5) > P && i >= L && r >= C && (t >= 0 ? n.a.swipeRight.dispatch() : n.a.swipeLeft.dispatch())
        }
        E.relativePos[0] = 0,
        E.relativePos[1] = 0
    }
    var U = {
        init: function() {
            const e = window
              , t = "addEventListener"
              , i = {
                passive: !1
            };
            e[t]("touchstart", z, i),
            e[t]("touchmove", N, i),
            e[t]("touchend", D, i),
            e[t]("touchcancel", D, i),
            e[t]("mousedown", z, i),
            e[t]("mousemove", N, i),
            e[t]("mouseup", D, i),
            e[t]("gesturestart", I, i),
            T.appendInlineStyle(),
            y.b.add(O)
        },
        setCursor: T.setCursor,
        removeCursor: T.removeCursor
    }
      , B = i(195)
      , j = i(157)
      , V = i(50)
      , G = i(3);
    var X = {
        bucket: Object(G.a)(i(176).default),
        caterpillars: Object(G.a)(i(177).default),
        spiders: Object(G.a)(i(178).default)
    }
      , Y = i(51);
    const W = document.body;
    function q(e) {
        if (2 != e.status)
            return;
        const t = e.to.params.id
          , i = n.a.palette.current;
        for (const e in X) {
            const r = X[e].current;
            if (r.id == t) {
                H(i, r.palette),
                n.a.palette.set(r.palette);
                break
            }
        }
        for (const e in Y.a) {
            const r = Y.a[e];
            if (r.id == t) {
                H(i, r.palette),
                n.a.palette.set(r.palette);
                break
            }
        }
    }
    function H(e, t) {
        W.classList.toggle(e + "-palette", !1),
        W.classList.toggle(t + "-palette", !0)
    }
    var Q = {
        init: function() {
            n.a.routeStatus.subscribe(q)
        }
    }
      , J = i(54)
      , Z = i(11)
      , $ = i(43)
      , K = i(28)
      , ee = i(34)
      , te = i(24)
      , ie = i(25)
      , ne = i(138)
      , re = i.n(ne)
      , se = i(139)
      , ae = i.n(se);
    const oe = e => e.split("").map(e => `<span>${e}</span>`).join("");
    class le extends K.a {
        constructor(e) {
            super(Object.assign({
                name: "Resources Button Overflow",
                log: 0,
                template: re.a,
                styles: ae.a
            }, e)),
            Object(ie.a)(this),
            this.rules = ee.a.rules.current.refills[e.type],
            this.resource = te.a.resources[e.type],
            this.localShown = !1,
            this.globalShown = !0
        }
        afterMount() {
            this._setTweens(),
            this._onAmoutUpdate(),
            n.a.viewportSize.subscribe(this._onResize),
            this.resource.amount.subscribe(this._onAmoutUpdate)
        }
        _onAmoutUpdate() {
            const e = this.resource.amount.current
              , t = this.rules.limit;
            this.localShown = e > t,
            this.localShown && (this.nodes.count.innerHTML = oe(Math.max(0, e - t).toString()),
            this._resizeBubble(this._shown)),
            this._updateStatus()
        }
        _setTweens() {
            this.tweens = {},
            this.tweens.hide = $.a.fromTo(this.nodes.visibility, .3, {
                scale: 1
            }, {
                scale: 0,
                ease: Z.a.easeIn
            }).pause(),
            this.tweens.show = $.a.fromTo(this.nodes.visibility, .6, {
                scale: 0
            }, {
                scale: 1,
                ease: Z.d.easeOut.config(1, .75)
            }).pause()
        }
        hide() {
            this.globalShown = !1,
            this._updateStatus()
        }
        show() {
            this.globalShown = !0,
            this._updateStatus()
        }
        _updateStatus() {
            const e = this.globalShown && this.localShown;
            e !== this._shown && (e ? this.tweens.show.restart() : this.tweens.hide.restart(),
            this._shown = e)
        }
        beforeDestroy() {
            this.resource.amount.unsubscribe(this._onAmoutUpdate)
        }
        _resizeBubble(e=!1) {
            const t = Math.round(this.nodes.inner.offsetWidth)
              , i = Math.ceil(this.nodes.inner.offsetHeight);
            if (t === this.lastWidth)
                return;
            const n = Z.d.easeOut.config(3, .5)
              , r = e ? .7 : 0;
            $.a.to(this.nodes.bubble, r, {
                scale: t / 10,
                ease: n
            }),
            $.a.to(this.nodes.border, r, {
                scale: (t + 3) / 10,
                ease: n
            }),
            $.a.to(this.nodes.wrapper, r, {
                y: -i / 2,
                ease: n
            }),
            this.lastWidth = t
        }
        _onResize() {
            this._resizeBubble()
        }
    }
    var ce = i(136)
      , he = i.n(ce)
      , ue = i(137)
      , pe = i.n(ue);
    class de extends K.a {
        constructor(e) {
            super(Object.assign({}, {
                name: "ResourcesButtonTimer",
                log: 0,
                template: he.a,
                styles: pe.a
            }, e)),
            Object(ie.a)(this),
            this.rules = ee.a.rules.current.refills.game,
            this.resource = te.a.resources.game,
            this.localShown = !1,
            this.globalShown = !0
        }
        _setTweens() {
            le.prototype._setTweens.call(this)
        }
        afterMount() {
            this._setTweens(),
            this.resource.amount.subscribe(this._onAmountUpdate),
            this._onAmountUpdate(),
            this._timerUpdate()
        }
        hide() {
            this.globalShown = !1,
            this._updateStatus()
        }
        show() {
            this.globalShown = !0,
            this._updateStatus()
        }
        _updateStatus() {
            const e = this.globalShown && this.localShown;
            e != !!this._shown && (e ? (this.tweens.show.restart(),
            this._startTimer()) : (this.tweens.hide.restart(),
            this._stopTimer()),
            this._shown = e)
        }
        _onAmountUpdate() {
            const e = this.resource.amount.current
              , t = this.rules.limit;
            this.localShown = e < t,
            setTimeout( () => {
                this._updateStatus()
            }
            , this.localShown ? 500 : 0)
        }
        _startTimer() {
            this.interval || (ee.a.date.subscribe(this._timerUpdate),
            this._timerUpdate())
        }
        _stopTimer() {
            ee.a.date.unsubscribe(this._timerUpdate),
            this._timerUpdate()
        }
        _timerUpdate() {
            const e = this.resource.amount.current
              , t = this.rules.limit;
            if (e >= t)
                return;
            const i = this.rules.delay
              , n = ee.a.dateFloat.current
              , r = this.resource.lastRefill.current
              , s = (1 - (e < t ? Object(b.clamp)((n - r) / i, 0, 1) : 0)) * i;
            this.nodes.time.innerHTML = this.convertTime(s)
        }
        spanify(e) {
            return e.split("").map(e => `<span>${e}</span>`).join("")
        }
        convertTime(e) {
            return [(e >>= 0) % 3600 / 60 >> 0, e % 3600 % 60 >> 0].map(e => this.spanify(e.toString().padStart(2, "0"))).join(":")
        }
        beforeDestroy() {
            this._stopTimer(),
            this.resource.amount.unsubscribe(this._onAmountUpdate)
        }
    }
    var fe = i(22)
      , me = i(17)
      , ge = i(0)
      , ve = i(196)
      , ye = i(23)
      , be = i(62)
      , xe = i(56);
    function we() {
        return !(n.a.notificationOpen.current || n.a.menuOpen.current || n.a.seedListOpen.current)
    }
    const _e = Object(me.a)("TRANSITION | BLOB", "black", "#7bd4fb", 1).log
      , Te = () => 50 / r.a.canvasSize.current[0]
      , Me = () => 50 / r.a.canvasSize.current[0];
    let Se = 0;
    const Ae = 500
      , Pe = {
        emptyLeft: [],
        fillLeft: [],
        emptyRight: [],
        fillRight: []
    }
      , Ce = {
        blob: null,
        grabbind: !1,
        duration: 0,
        enabled: !0
    }
      , Le = {
        y: 0,
        progress: 0,
        spring: new ye.a({
            initial: 0,
            tension: .032,
            friction: .114,
            step: 5
        }),
        color: {
            value: new ge.k(0,0,0)
        },
        uniform: {
            value: new Float32Array([0, 0, 0])
        },
        transitioning: !1,
        hidden: !1
    }
      , ke = {
        y: 0,
        progress: 0,
        spring: new ye.a({
            initial: 1,
            tension: .032,
            friction: .114,
            step: 5
        }),
        color: {
            value: new ge.k(0,0,0)
        },
        uniform: {
            value: new Float32Array([1, 1, 0])
        },
        transitioning: !1,
        hidden: !1
    };
    function Ee(e) {
        const t = te.a.currentSeed.current
          , i = te.a.getPreviousSeed(t);
        Le.color.value.copy(e || i.palette.current[0])
    }
    function Ie(e) {
        const t = te.a.currentSeed.current
          , i = te.a.getNextSeed(t);
        ke.color.value.copy(e || i.palette.current[0])
    }
    function Fe(e, t, i) {
        t.uniform.value[0] = Object(b.lerp)(t.uniform.value[0], t === Le ? t.progress : 1 - t.progress, i ? 1 : Ce.blob === t ? .3 : "fill" === t.transitioning ? .21 : .1),
        t.uniform.value[2] = Object(b.lerp)(t.uniform.value[2], t.y, i ? 1 : (t.transitioning,
        .1)),
        t.spring.setTarget(t.uniform.value[0]),
        i && t.spring.setValue(t.uniform.value[0]),
        t.spring.update(e),
        t.uniform.value[1] = t.uniform.value[0] - t.spring.value
    }
    function Oe() {
        return !(Date.now() - Se < Ae) && (we() ? !!Ce.enabled : void 0)
    }
    function Re(e, t) {
        const i = n.a.touch.current
          , r = n.a.viewportSize.current
          , s = i.pressed;
        if (be.a.debugCamera.current)
            return;
        if (t.grabbing && (t.duration += e),
        !t.grabbing && s)
            t.blob = null,
            t.grabbing = !0,
            t.duration = 0;
        else if (t.grabbing && !s)
            return function(e, t) {
                if (!t.blob)
                    return;
                const i = t.blob.progress * n.a.viewportSize.current[0];
                if (Oe() && (t.blob.progress > .5 || i > 50 && t.duration < 200)) {
                    const e = te.a.currentSeed.current
                      , i = t.blob === Le ? te.a.getPreviousSeed(e) : te.a.getNextSeed(e);
                    xe.a.navigate(xe.a.url("seed", {
                        id: i.id.current
                    })),
                    Se = Date.now()
                }
            }(0, t),
            t.blob = null,
            t.grabbing = !1,
            void (t.duration = 0);
        if (!Oe())
            return;
        if (t.blob || (i.relativePos[0] > 10 ? t.blob = Le : i.relativePos[0] < -10 && (t.blob = ke)),
        t.blob !== Le && (Le.progress = 0),
        t.blob !== ke && (ke.progress = 0),
        !t.blob)
            return;
        const a = i.relativePos[0] / r[0]
          , o = 1 - i.pos[1] / r[1];
        t.blob.progress = Math.max(t.blob === Le ? a : -a, 0),
        t.blob.progress > 0 && (t.blob.y = o)
    }
    function ze(e, t) {
        const i = Pe[t];
        for (let e = i.length - 1; e >= 0; e--)
            i[e]();
        Pe[t] = [],
        e.transitioning = !1,
        "emptyRight" !== t && "emptyLeft" !== t || (Ce.enabled = !0)
    }
    var Ne = {
        emptyRight: function() {
            return new Promise(e => {
                Pe.emptyRight.push(e),
                ke.progress = 0 - Me(),
                ke.transitioning = "empty",
                ke.y || (ke.y = .5),
                Pe.fillRight.length && (Pe.fillRight = [])
            }
            )
        },
        emptyLeft: function() {
            return new Promise(e => {
                Pe.emptyLeft.push(e),
                Le.progress = 0 - Me(),
                Le.transitioning = "empty",
                Le.y || (Le.y = .5),
                Pe.fillLeft.length && (Pe.fillLeft = [])
            }
            )
        },
        fillRight: function(e=!1) {
            return new Promise(t => {
                if (Pe.emptyRight.length && (Pe.emptyRight = []),
                ke.progress = 1 + Te(),
                ke.y = .5,
                e)
                    return ke.transitioning = !1,
                    void Fe(0, ke, !0);
                Pe.fillRight.push(t),
                ke.transitioning = "fill"
            }
            )
        },
        fillLeft: function(e=!1) {
            return new Promise(t => {
                if (Pe.emptyLeft.length && (Pe.emptyLeft = []),
                Le.progress = 1 + Te(),
                Le.y = .5,
                e)
                    return Le.transitioning = !1,
                    void Fe(0, Le, !0);
                Pe.fillLeft.push(t),
                Le.transitioning = "fill"
            }
            )
        },
        update: function(e) {
            Ce.enabled && Re(e, Ce);
            const t = Le.progress > ke.progress ? -Le.progress : ke.progress;
            ee.a.panelOffset.set(t),
            Fe(e, Le),
            Fe(e, ke);
            const i = Le.uniform.value[0]
              , r = 1 - ke.uniform.value[0];
            ee.a.blobOffset.set(i > r ? i : -r),
            function() {
                const e = n.a.viewportSize.current[0] * n.a.screenPixelRatio.current
                  , t = -10
                  , i = e - t
                  , r = Le.uniform.value[0] * e
                  , s = Le.uniform.value[1] * e
                  , a = (1 - ke.uniform.value[0]) * e
                  , o = ke.uniform.value[1] * e
                  , l = r < 2 && s > -2
                  , c = a < 2 && o > -2;
                !Le.hidden && l ? (Le.hidden = !0,
                Ee()) : Le.hidden && !l && (Le.hidden = !1),
                !ke.hidden && c ? (ke.hidden = !0,
                Ie()) : ke.hidden && !c && (ke.hidden = !1),
                "empty" === Le.transitioning && r < t && s > 10 ? ze(Le, "emptyLeft") : "fill" === Le.transitioning && r > i && s < 10 && ze(Le, "fillLeft"),
                "empty" === ke.transitioning && a < t && o < t ? ze(ke, "emptyRight") : "fill" === ke.transitioning && a > i && o > t && ze(ke, "fillRight")
            }()
        },
        freezeGrab: function() {
            _e("Freeze grab"),
            Ce.enabled = !1
        },
        unfreezeGrab: function() {
            _e("Unfreeze grab"),
            Ce.enabled = !0
        },
        resetBlobs: function() {
            ke.transitioning = !1,
            Le.transitioning = !1;
            for (const e in Pe)
                Pe[e] = [];
            ke.progress = 0,
            Le.progress = 0,
            Fe(0, Le, !0),
            Fe(0, ke, !0)
        },
        updateBlobColors: function() {
            Ee(),
            Ie()
        },
        updateRightBlobColor: Ie,
        updateLeftBlobColor: Ee,
        blobLeft: Le,
        blobRight: ke,
        toggle: function(e=!1) {
            Ce.enabled = e
        }
    };
    const De = {
        IN: 0,
        OUT: 1
    }
      , Ue = {
        value: [0, 0, 0, 0]
    }
      , Be = {
        color: new ge.k,
        alpha: 0
    };
    let je = null;
    function Ve(e, t=.3, i=De.IN) {
        return new Promise(n => {
            je && je.kill(),
            je = null,
            e && Be.color.copy(e);
            const r = i === De.IN ? 0 : 1
              , s = 1 - r;
            if (Ue.value[0] = Be.color.r,
            Ue.value[1] = Be.color.g,
            Ue.value[2] = Be.color.b,
            Ue.value[3] = r,
            t <= 0)
                return Be.alpha = s,
                Ue.value[3] = Be.alpha,
                n();
            je = $.a.fromTo(Be, t, {
                alpha: r
            }, {
                alpha: s,
                onUpdate: () => {
                    Ue.value[3] = Be.alpha
                }
                ,
                onComplete: () => {
                    je.kill(),
                    n()
                }
            })
        }
        )
    }
    var Ge = {
        uniform: Ue,
        fadeIn: (e, t) => Ve(e, t, De.IN),
        fadeOut: (e, t) => Ve(e, t, De.OUT),
        remove: () => Ve(void 0, !0, De.OUT)
    }
      , Xe = i(2);
    const Ye = {
        color: {
            value: new ge.k(16711680)
        },
        data: {
            value: new Float32Array([0, 1, 1])
        }
    }
      , We = {
        progress: 0
    };
    let qe;
    function He(e, t="easeInOut", i=!1, n=.7, r=0, s=1, a=1) {
        return new Promise(o => {
            e && Ye.color.value.copy(e),
            qe && qe.kill(),
            qe = null;
            const l = 1 - r;
            if (Ye.data.value[0] = r,
            Ye.data.value[1] = s,
            Ye.data.value[2] = a,
            i)
                return Ye.data.value[0] = l,
                o();
            qe = $.a.fromTo(We, n, {
                progress: r
            }, {
                ease: Xe.e[t],
                progress: l,
                onUpdate: () => Ye.data.value[0] = We.progress,
                onComplete: () => {
                    qe.kill(),
                    o()
                }
            })
        }
        )
    }
    var Qe = {
        uniforms: Ye,
        fillFromBottom: (e, t, i, n) => He(e, t, n, i, 0, 1, 1),
        fillFromTop: (e, t, i, n) => He(e, t, n, i, 1, -1, -1),
        emptyFromBottom: (e, t, i, n) => He(e, t, n, i, 0, 1, -1),
        emptyFromTop: (e, t, i, n) => He(e, t, n, i, 1, -1, 1),
        remove: () => He(void 0, void 0, !0, void 0, 1, 1, 1)
    };
    Object(me.a)("TRANSITION", "black", "#7bd4fb", 1).log;
    let Je = !1;
    function Ze(e) {
        if (2 !== e.status)
            return;
        te.a.offsetMultiplier.set(0);
        const t = e.from ? e.from.id : null
          , i = e.to ? e.to.id : null;
        if ("seed" === i ? (Ne.unfreezeGrab(),
        Je || (Ne.updateBlobColors(),
        Je = !0)) : Ne.freezeGrab(),
        t)
            if ("seed" === t && "seed" === i) {
                const t = te.a.getSeedById(e.to.params.id)
                  , i = te.a.getPreviousSeed(te.a.currentSeed.current)
                  , n = t === i
                  , r = n ? "Left" : "Right"
                  , s = n ? "Right" : "Left";
                Promise.resolve().then(Ne.freezeGrab).then( () => {
                    ve.a.play(n ? "transition_right_close" : "transition_left_close")
                }
                ).then(Ne["fill" + r]).then( () => {
                    te.a.offsetMultiplier.set(n ? 1 : -1),
                    te.a.previousSeed.set(te.a.currentSeed.current),
                    te.a.currentSeed.set(t),
                    Ne.unfreezeGrab(),
                    Ne.resetBlobs(),
                    $e(e.to),
                    Ne["update" + s + "BlobColor"](Ne["blob" + r].color.value),
                    Ne["fill" + s](!0),
                    Ne["empty" + s](),
                    ve.a.play(n ? "transition_left_open" : "transition_right_open")
                }
                )
            } else if ("seed" === t && "game" === i) {
                const t = e.to.params.id
                  , i = X[t].current
                  , n = i.camera.cameraHideColor
                  , r = i.palette
                  , s = ee.a.palettes.current[r][n]
                  , a = te.a.getSeedById(e.from.params.id).scene.current.gardenCamera;
                Promise.resolve().then( () => (a.setPanY(-1, .8, "easeInOut"),
                ve.a.play("minigame_whoosh"),
                Qe.fillFromTop(s, "easeIn"))).then( () => $e(e.to)).then( () => Qe.remove())
            } else if ("game" === t && "seed" === i) {
                const t = te.a.getSeedById(e.to.params.id)
                  , i = t.palette.current[0];
                Promise.resolve().then( () => (ve.a.play("minigame_whoosh"),
                Qe.fillFromBottom(i, "easeIn"))).then( () => $e(e.to)).then( () => {
                    const e = t.scene.current && t.scene.current.gardenCamera;
                    e && (e.setPanY(-1, 0),
                    e.setPanY(0, .7, "easeOut"))
                }
                ).then( () => Qe.emptyFromBottom(i, "easeOut"))
            } else if ("choice" === t && "seed" === i) {
                const t = te.a.getSeedById(e.to.params.id)
                  , i = t.palette.current[t.sceneData.current.hideCamera.cameraHideColor];
                Promise.resolve().then( () => (ve.a.play("minigame_whoosh"),
                Qe.fillFromTop(i, "easeIn", .9))).then( () => $e(e.to)).then( () => {
                    const e = t.scene.current;
                    if (!e)
                        return;
                    e.appearSeed();
                    const i = e.gardenCamera;
                    i && i.fromHide()
                }
                ).then( () => Qe.remove())
            } else
                $e(e.to);
        else
            $e(e.to)
    }
    function $e(e) {
        if ("game" === e.id)
            pa.set("game", {
                gameId: e.params.id
            });
        else if ("seed" === e.id) {
            const e = te.a.currentSeed.current;
            if (!e)
                return;
            pa.set("seed", {
                seedId: e.id.current
            })
        } else
            "default" !== e.id && "choice" !== e.id || pa.set("home")
    }
    function Ke(e) {
        Ne.update(e)
    }
    var et = {
        init: function() {
            n.a.routeStatus.subscribe(Ze),
            y.c.add(Ke)
        },
        fillFromTop: Qe.fillFromTop,
        fillFromBottom: Qe.fillFromBottom,
        emptyFromTop: Qe.emptyFromTop,
        emptyFromBottom: Qe.emptyFromBottom,
        fillLeft: Ne.fillLeft,
        emptyLeft: Ne.emptyLeft,
        fillRight: Ne.fillRight,
        emptyRight: Ne.emptyRight,
        freezeGrab: Ne.freezeGrab,
        unfreezeGrab: Ne.unfreezeGrab,
        resetBlobs: Ne.resetBlobs,
        updateBlobColors: Ne.updateBlobColors,
        uniforms: {
            overlay: Ge.uniform,
            blobVertical: Qe.uniforms.data,
            blobVerticalColor: Qe.uniforms.color,
            blobLeftColor: Ne.blobLeft.color,
            blobRightColor: Ne.blobRight.color,
            blobLeft: Ne.blobLeft.uniform,
            blobRight: Ne.blobRight.uniform
        }
    }
      , tt = "precision highp float;\n#define GLSLIFY 1\n\nattribute vec2 position;\nvarying vec2 vUv;\n\nvoid main() {\n  // This works with bigTriangle utils geometry\n  vUv = position;\n  gl_Position =  vec4(2.0 * position - 1.0, 0.,  1);\n}\n"
      , it = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nuniform sampler2D scene;\nuniform sampler2D snapshot;\n\nuniform vec4 res;\n\nuniform vec3 blobLeft;\nuniform vec3 blobRight;\nuniform vec3 blobLeftColor;\nuniform vec3 blobRightColor;\n\nuniform vec3 blobVertical;\nuniform vec3 blobVerticalColor;\n\nuniform float time;\nuniform float ratio;\nuniform float circleFill;\n\nuniform vec4 overlay;\n\nuniform float flash;\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n#include <fxaa> // FXAA 3\n#include <aastep>\n\n#ifndef PI2\n#define PI2 6.283185307\n#endif\n\nconst vec3 overlayColor = vec3(0., 0., 0.);\n\nfloat nd(float n) {\n\treturn 1. - abs(n * 2. - 1.);\n}\n\nfloat circle(vec2 st, float radius, vec2 offset) {\n    return step(radius, length(st + offset));\n}\n\nfloat verticalBlob() {\n\n\tfloat cOff = (1. - blobVertical.z) * .5;\n\tfloat dOff = (1. - blobVertical.y) * .5;\n\n\tfloat y = vUv.y;\n\tfloat progress = blobVertical.x;\n\tfloat dirProgress = blobVertical.y * progress + dOff;\n\n\tfloat m = 1. / res.y;\n\tfloat mx = 1. / res.x;\n\tfloat maxOffset = 90.;\n\tfloat offset = blobVertical.y * maxOffset * m;\n\tfloat bleed = (maxOffset + 5.) * m;\n\tprogress = progress - bleed + progress * bleed * 2.;\n\n\tfloat hp = cos(vUv.x * 0.7 * PI2 + 0.9 );\n\tfloat vp = (1. - dirProgress) * offset;\n\n\ty += hp * vp  + cos(vUv.x * res.x * 0.014) * 0.005;\n\n\tfloat influence = smoothstep(\n\t\tprogress,\n\t\tprogress - 1. * m,\n\t\ty\n\t);\n\n\treturn blobVertical.z * influence + cOff;\n\n}\n\nfloat blobPanel(vec3 blobData, float orientation) {\n\tfloat distMax = max(blobData.z, 1. - blobData.z);\n\n\tfloat y = vUv.y;\n\n\tfloat velocity = abs(blobData.y);\n\tfloat offsetInfluence = smoothstep(\n\t\t0.,\n\t\tmix(distMax + 0.8, distMax + 0.4, velocity),\n\t\tabs(y - blobData.z)\n\t);\n\n\tfloat offset = blobData.y * 0.9;\n\n\tfloat dir = orientation * -2. + 1.;\n\n\t// float noise = velocity * snoise2(vec2(vUv.y * 3. + time, vUv.x)) * 50. * (offsetInfluence + 0.5);\n\n\tfloat jiggle = (\n\t\tdir\n\t\t* ((cos(time * 1.5 + vUv.y * res.y * 0.01 + blobData.z * -10.) + 1.) * 0.5)\n\t\t* (60. * max(0.3 - abs(offset), 0.)) / res.y\n\t\t* abs( offsetInfluence + (1. - smoothstep(0., 1., offset)) * 0.5)\n\t\t// + noise / res.y\n\t);\n\n\treturn orientation + aastep(\n\t\tvUv.x + offset * offsetInfluence + jiggle,\n\t\t0.7 / res.x,\n\t\tblobData.x\n\t) * (1. - 2. * orientation);\n}\n\nvoid main() {\n\tvec2 pxCoords = vUv * res.xy;\n\n\tvec2 uv = vUv;\n\n\t// Doodle\n\t// float detail = 0.16 * ratio;\n\t// float strength = 0.28 * ratio;\n\t// float framerate = 8.;\n\t// float limitedTime = floor(time * framerate) / framerate * 120.;\n\t// float noise1 = snoise2(pxCoords * detail + limitedTime);\n\t// float noise2 = snoise2(pxCoords.yx * detail + limitedTime + 100.);\n\t// uv += vec2(noise1, noise2) * strength * length(res.zw);\n\n\tvec3 texelColor = fxaa(scene, uv, res.zw).rgb;\n\n\tvec3 color = texelColor;\n\n\t// Handle blob shadow\n\tfloat blobInfluence = max(\n\t\tmax(blobLeft.x, 1. - blobRight.x),\n\t\tblobVertical.z * blobVertical.x + (1. - blobVertical.z) * .5\n\t);\n\n\tcolor = mix(color, color * 0.2, blobInfluence);\n\n\t// Draw blobs\n\tcolor = mix(color, blobLeftColor, blobPanel(blobLeft, 0.));\n\tcolor = mix(color, blobRightColor, blobPanel(blobRight, 1.));\n\n\t// color *= 0.;\n\n\tvec2 uvFlash = vUv;\n\tfloat ratio = res.z / res.w;\n\t// uvFlash.y *= 0.4;\n\tfloat flashDist = 1. - length( ( uvFlash - .5 ) * vec2(1., ratio) * ((1. - flash) * 0.01 + 1.5) );\n\tfloat flashOffset = 0.6 * flash * flashDist;\n\tcolor = mix(color, vec3(1.), flashOffset);\n\tcolor = min(vec3(1.), color + flashOffset * 0.2);\n\n\tfloat circ = circle(vUv, circleFill, -vec2(0.5, 0.5));\n\tcolor = mix(color, vec3(0.006, 0.037, 0.312), circ);\n\n\t// Vertical blob\n\tcolor = mix(color, blobVerticalColor, verticalBlob());\n\n\t// Color overlay\n\tcolor = mix(color, overlay.rgb, overlay.a);\n\n\t// add vignette\n\tfloat dist = length( ( vUv - .5 ) * 2. ) * .6;\n\tfloat t = smoothstep(0.2, 1.7, dist);\n\n\tcolor = mix(color, vec3(1.), flash * 0.3);\n\n\tcolor = mix(color, color * color * 0.4, t);\n\n\t// Overlay\n\t// color = mix(color, overlayColor, overlay);\n\n\tgl_FragColor = vec4(color, 1.);\n\n}\n\n";
    function nt({renderer: e, alpha: t, depth: i, stencil: n, alphaOnly: r}) {
        const s = ge.T.get();
        e.getDrawingBufferSize(s);
        const a = new ge.W(s.x,s.y,{
            minFilter: ge.t,
            magFilter: ge.t,
            format: r ? ge.b : t ? ge.K : ge.L,
            depthBuffer: !!i,
            stencilBuffer: !!n
        });
        return ge.T.release(s),
        a.texture.generateMipmaps = !1,
        a
    }
    var rt = new ge.G(-1,1,1,-1,0,1);
    const st = new Float32Array([-2, 0, 0, -2, 2, 2])
      , at = new ge.i;
    at.addAttribute("position", new ge.h(st,2));
    var ot = at;
    const lt = Object(me.a)("PIPELINE", "black", "#e44878", 1).log
      , ct = {}
      , ht = {}
      , ut = {};
    let pt, dt, ft = !1;
    const mt = {}
      , gt = new ge.H(245,1,.001,1e5);
    function vt() {
        const e = pt || ct.scene1
          , t = e === ct.scene1 ? ct.scene2 : ct.scene1;
        ht.postprocess.uniforms.scene.value = t.texture,
        ht.postprocess.uniforms.snapshot.value = e.texture,
        ht.postprocess.uniforms.scene.needsUpdate = !0,
        ht.postprocess.uniforms.snapshot.needsUpdate = !0,
        pt = t
    }
    function yt(e=mt.black, t=0) {
        dt.setClearColor(e, t),
        dt.clear()
    }
    gt.position.z = 80;
    var bt = {
        update: function(e) {
            ee.a.time.update(t => (t + .001 * e) % 3600),
            ee.a.sceneTime.update(t => (t + .001 * e) % 3600),
            ht.postprocess.uniforms.time.value = ee.a.time.current;
            const t = pa.getActive();
            t && t.update(e);
            const i = pa.get("uiBack");
            i && i.update(e);
            const n = pa.get("uiTop");
            n && n.update(e)
        },
        render: function(e, t=null) {
            dt.sortObjects = !0,
            function(e, t) {
                if (dt.setRenderTarget(t),
                !e)
                    return yt();
                const i = e.scene
                  , n = e.currentCamera ? e.currentCamera.cam : null;
                if (!i || !n)
                    return yt();
                e.background && yt(e.background, 1),
                dt.render(i, n)
            }(t || pa.getActive(), pt),
            dt.sortObjects = !1;
            const i = pa.get("uiBack");
            i && dt.render(i.scene, i.currentCamera.cam),
            dt.setRenderTarget(null),
            dt.render(ht.postprocess.scene, ht.postprocess.cam);
            const n = pa.get("uiTop");
            n && dt.render(n.scene, n.currentCamera.cam)
        },
        init: function(e={}) {
            ft || (ft = !0,
            dt = e.renderer,
            mt.black = new ge.k(n.a.colors.black),
            ct.prerender = nt({
                renderer: dt,
                depth: !1,
                alpha: !1
            }),
            ct.scene1 = nt({
                renderer: dt,
                depth: !0,
                alpha: !1
            }),
            ct.scene2 = nt({
                renderer: dt,
                depth: !0,
                alpha: !1
            }),
            ht.postprocess = function(e, t, i) {
                const n = {};
                return n.material = new ge.M(Object.assign({}, i, {
                    vertexShader: e,
                    fragmentShader: t,
                    transparent: !0
                })),
                n.cam = rt,
                n.scene = new ge.P,
                n.screen = new ge.x(ot,n.material),
                n.screen.frustumCulled = !1,
                n.screen.matrixAutoUpdate = !1,
                n.scene.add(n.screen),
                n.uniforms = n.material.uniforms,
                n
            }(tt, it, {
                uniforms: Object.assign({
                    scene: {
                        value: null,
                        type: "t"
                    },
                    snapshot: {
                        value: null,
                        type: "t"
                    },
                    res: {
                        value: [0, 0, 0, 0]
                    },
                    time: {
                        value: 0
                    },
                    flash: {
                        value: 0
                    },
                    ratio: {
                        value: 0
                    },
                    circleFill: {
                        value: 0
                    },
                    blobLeft: et.uniforms.blobLeft,
                    blobRight: et.uniforms.blobRight,
                    blobLeftColor: et.uniforms.blobLeftColor,
                    blobRightColor: et.uniforms.blobRightColor,
                    blobVertical: et.uniforms.blobVertical,
                    blobVerticalColor: et.uniforms.blobVerticalColor,
                    overlay: et.uniforms.overlay
                }),
                defines: {}
            }),
            r.a.canvasPixelRatio.subscribe(e => ht.postprocess.uniforms.ratio.value = e),
            ht.postprocess.uniforms.ratio.value = r.a.canvasPixelRatio.current,
            vt())
        },
        appLoaded: function() {},
        resize: function() {
            const e = r.a.canvasSize.get()
              , t = r.a.drawingBufferSize.get();
            ct.scene1.setSize(t[0], t[1]),
            ct.scene2.setSize(t[0], t[1]),
            ct.prerender.setSize(10, 10),
            ht.postprocess.uniforms.res.value[0] = e[0],
            ht.postprocess.uniforms.res.value[1] = e[1],
            ht.postprocess.uniforms.res.value[2] = 1 / t[0],
            ht.postprocess.uniforms.res.value[3] = 1 / t[1],
            ht.postprocess.uniforms.res.needsUpdate = !0
        },
        snapshot: vt,
        prerender: function(e, t) {
            lt("Prerender"),
            dt.setRenderTarget(ct.prerender),
            t && e.update(16.67),
            dt.render(e.scene, gt)
        },
        flash: function(e=1.2) {
            ut.flash || (ut.flash = $.a.fromTo(ht.postprocess.uniforms.flash, e, {
                value: 1
            }, {
                value: 0,
                ease: Z.e.easeOut
            }).pause()),
            ut.flash.restart()
        },
        filters: ht,
        isReady: () => ft
    }
      , xt = i(36)
      , wt = i.n(xt);
    class _t {
        constructor(e) {
            this.isComponent = !0,
            this.components = [],
            this.dynamicComponents = [],
            this.refs = {},
            this.tweens = {},
            this.timers = [],
            this.props = e
        }
        init() {}
        beforeDestroy() {}
        add(e) {
            return this.base.add(e),
            e
        }
        remove(e) {
            return this.base.remove(e),
            null
        }
        addComponent(e, t) {
            t || (t = {});
            const i = t.mountTo || this.base;
            return e.isComponent || (e = new e(t)),
            ~this.components.indexOf(e) ? e : ~this.dynamicComponents.indexOf(e) ? e : (e.parentComponent && e.parentComponent.removeComponent(e),
            e.parentComponent = this,
            e.static || this.dynamicComponents.push(e),
            this.components.push(e),
            i && e.base && i.add(e.base),
            e.added && e.added(this),
            e)
        }
        removeComponent(e) {
            const t = this.components.indexOf(e)
              , i = this.dynamicComponents.indexOf(e);
            if (~t)
                return e.parentComponent = null,
                this.components.splice(t, 1),
                ~i && this.dynamicComponents.splice(i, 1),
                this.base && e.base && this.base.remove(e.base),
                e.removed && e.removed(this),
                null
        }
        update(e) {
            if (this.updateTimers(e),
            !this.destroyed)
                for (let t = 0, i = this.dynamicComponents.length; t < i; t++)
                    this.dynamicComponents[t] && this.dynamicComponents[t].update(e)
        }
        updateTimers(e) {
            let t = this.timers.length;
            const i = this.timers;
            for (; t--; )
                i[t].update(e),
                i._stopped && (i[t].dispose(),
                i.splice(t, 1))
        }
        timer(e, t) {
            if (!this.destroyed) {
                if (t) {
                    const i = new y.a(e,t);
                    return this.timers.push(i),
                    i
                }
                return new Promise(t => {
                    const i = new y.a(e,t);
                    this.timers.push(i)
                }
                )
            }
        }
        destroy() {
            if (!this.destroyed) {
                this.beforeDestroy();
                for (let e = 0, t = this.timers.length; e < t; e++)
                    this.timers[e].dispose();
                this.parentComponent && this.parentComponent.removeComponent(this);
                for (let e = this.components.length - 1; e >= 0; e--)
                    this.components[e].destroy();
                if (this.base)
                    for (let e = this.base.children.length - 1; e >= 0; e--)
                        this.base.remove(this.base.children[e]);
                for (const e in this.tweens)
                    this.tweens[e] && this.tweens[e].kill();
                this.tweens = null,
                this.base && this.base.parent && this.base.parent.remove(this.base),
                this.refs = null,
                this.props = null,
                this.base = null,
                this.destroyed = !0,
                this.components = null,
                this.dynamicComponents = null,
                this.anims = null,
                this.timers = null
            }
        }
    }
    class Tt extends _t {
        constructor(e={}) {
            0,
            super(),
            e.noInit || this.init(e),
            this.props || (this.props = e),
            this.base || (this.base = new ge.F),
            void 0 === this.static && (this.static = !1)
        }
        destroy() {
            0,
            super.destroy()
        }
    }
    var Mt = i(8)
      , St = i(33);
    const At = .003;
    function Pt(e, t, i, n=0) {
        const r = t.size
          , s = At / t.scale
          , a = {}
          , o = e.anchor || {
            x: 0,
            y: 0
        }
          , l = i.split("_")[0];
        if ("ground" === l || "plant" === l || "bush" === l) {
            const i = 7.5 * t.scale / e.sourceSize.h;
            o.y += i
        }
        const c = e.frame
          , h = e.sourceSize
          , u = e.spriteSourceSize;
        a.id = i;
        const p = i.split("/");
        a.sequence = p.pop(),
        a.group = p.join("/"),
        a.frameIndex = n,
        void 0 !== e.channel && (a.channel = e.channel),
        void 0 !== e.batcher && (a.batcher = e.batcher),
        a.texCoords = new Float32Array([c.x / r.w, (r.h - c.y - c.h) / r.h, c.w / r.w, c.h / r.h]),
        a.meshCoords = new Float32Array([.5 * u.w + u.x - h.w * o.x, -(.5 * u.h + u.y - h.h * o.y), u.w, u.h]);
        for (let e = 0, t = a.meshCoords.length; e < t; e++)
            a.meshCoords[e] *= s;
        return a.anchor = o,
        a
    }
    function Ct(e, t={}) {
        const i = Mt.a.files.get(e);
        i.meta.scale = i.meta.scale ? parseFloat(i.meta.scale) : 1;
        const n = e.replace(/\.data\.pack/, ".tex.pack").split("/").slice(0, -1).join("/")
          , r = i.meta.image.split("?");
        r.length > 1 && r.pop();
        const s = St.a.replacePath([n, r.join("?")].join("/"))
          , a = {
            baseTexture: null,
            sprites: {}
        };
        if (St.a.canImageBeCompressed(s)) {
            const e = Mt.a.files.get(s);
            a.baseTexture = St.a.createTexture(e, !0)
        } else {
            const e = Mt.a.files.get(s).node;
            a.baseTexture = new ge.S(e);
            const n = i.meta.format;
            a.baseTexture.format = "ALPHA" === n || "ALPHA_INTENSITY" === n ? ge.b : "RGB888" === n ? ge.L : ge.K,
            t.nearest && (a.baseTexture.minFilter = ge.A,
            a.baseTexture.magFilter = ge.A)
        }
        a.baseTexture.needsUpdate = !0;
        const o = i.frames;
        i.animations || (i.animations = {});
        for (const e in i.animations) {
            const t = i.animations[e]
              , n = a.sprites[e] = [];
            for (let r = 0, s = t.length; r < s; r++) {
                const s = o[t[r]];
                delete o[t[r]],
                n.push(Pt(s, i.meta, e, r))
            }
        }
        for (const e in o) {
            const t = o[e]
              , n = a.sprites[e] = [];
            delete o[e],
            n.push(Pt(t, i.meta, e))
        }
        return a
    }
    let Lt;
    const kt = {}
      , Et = {}
      , It = {}
      , Ft = {};
    var Ot = {
        init: function(e) {
            Lt = e.renderer
        },
        appLoaded: function() {
            kt.props = Ct("spritesheets.data.pack/props.json"),
            kt.sprites = Ct("spritesheets.data.pack/sprites.json")
        },
        getMesh: e => Ft[e],
        getGeometry: e => It[e],
        getTexture: e => Et[e],
        getAtlas: e => kt[e]
    };
    const Rt = 70
      , zt = function() {};
    class Nt {
        constructor({atlas: e, id: t, group: i, sequence: n, loop: r, autoplay: s, frame: a, onUpdate: o, onEnd: l, onEndOnce: c}) {
            this.frames = [],
            this.onUpdate = o || zt,
            this.onEndOnce = c || zt,
            this.onEnd = l || zt,
            this.id = void 0 !== t ? t : i + "/" + n,
            this.group = "",
            this.sequence = "",
            this.loop = !!r,
            this.autoplay = !!s,
            this.frame = a || 0,
            this.frameCount = 0,
            this.frameDuration = Rt,
            this.frameTimer = 0,
            this.currentFrameIndex = 0,
            this.paused = !1,
            this.ended = !1,
            e && (this.setAtlas(e),
            this.change({
                id: this.id,
                autoplay: this.autoplay,
                loop: this.loop,
                frame: this.frame
            }))
        }
        setAtlas(e) {
            this.sprites = Ot.getAtlas(e).sprites
        }
        change({id: e, group: t, sequence: i, frame: n, frameDuration: r, autoplay: s, loop: a}) {
            if (this.sprites[e]) {
                if (void 0 !== e) {
                    this.id = e;
                    const t = this.id.split("/");
                    this.sequence = t.pop(),
                    this.group = t.join("/")
                } else
                    void 0 !== i && (void 0 !== t && (this.group = t),
                    this.sequence = i,
                    this.id = this.group + "/" + this.sequence);
                this.frames = this.sprites[this.id],
                this.frameCount = this.frames.length,
                this.currentFrameIndex = Math.min(n || 0, this.frameCount - 1),
                this.frame = this.frames[this.currentFrameIndex],
                this.loop = !!a,
                this.autoplay = !!s,
                this.frameDuration = r || Rt,
                this.frameTimer = this.frameTimer,
                this.paused = !this.autoplay,
                this.frameCount < 2 ? this.end() : this.ended = !1,
                this.onUpdate(this.frame)
            }
        }
        end() {
            this.ended = !0,
            this.onEndOnce(this.frame),
            this.onEndOnce = zt,
            this.onEnd(this.frame)
        }
        play() {
            this.paused = !1
        }
        pause() {
            this.paused = !0
        }
        nextFrame() {
            let e = this.currentFrameIndex + 1;
            e >= this.frameCount && (this.loop ? e = 0 : this.end()),
            e !== this.currentFrameIndex && (this.currentFrameIndex = e,
            this.frame = this.frames[this.currentFrameIndex],
            this.onUpdate(this.frame),
            !this.loop && e + 1 >= this.frameCount && this.end())
        }
        update(e) {
            this.ended || this.paused || (this.frameTimer <= 0 && (this.frameTimer = Math.max(0, this.frameDuration + this.frameTimer),
            this.nextFrame()),
            this.frameTimer -= e)
        }
        destroy() {
            this.sprites = this.frames = this.frame = this.onUpdate = null
        }
    }
    class Dt {
        constructor(e) {
            this.isComponent = !0,
            this.parentComponent = null,
            e.batcher && (this.batcher = e.batcher,
            e.atlas = this.batcher.atlas,
            e.batcher = null),
            this.position = new ge.U,
            this.scale = new ge.T(1,1),
            this.rotation = 0,
            this.color = new ge.k,
            this.alpha = void 0 !== e.alpha ? e.alpha : 1,
            this.props = e,
            e.color && this.color.copy(e.color),
            e.position && this.position.copy(e.position),
            e.scale && this.scale.copy(e.scale),
            void 0 !== e.rotation && (this.rotation = e.rotation),
            void 0 !== e.z && (this.position.z = e.z),
            this.batchLayer = void 0 !== e.batchLayer ? e.batchLayer : this.position.z,
            this.orderOffset = 0,
            this.sprite = new Nt(Object.assign({}, e, {
                id: e.sprite
            })),
            this.batcher && this.batcher.addInstance(this.batchLayer, this),
            this.init(e),
            this.sprite.update(1)
        }
        init() {}
        update(e) {
            this.sprite.update(e)
        }
        resetOrder() {
            this.batchLayer = void 0 !== this.props.batchLayer ? props.batchLayer : this.position.z,
            this.batcher && (this._addedToBatcher && this.batcher.removeInstance(this._batcherZ, this),
            this.batcher.addInstance(this.batchLayer, this))
        }
        destroy() {
            this.batcher && this.batcher.removeInstance(this.batchLayer, this),
            this.parentComponent && this.parentComponent.removeComponent(this),
            this.sprite.destroy(),
            this.sprite = this.batcher = null,
            this.props = null
        }
    }
    const Ut = {};
    function Bt(e, t, i) {
        this.x = e,
        this.y = t,
        this.z = i
    }
    Bt.prototype.dot2 = function(e, t) {
        return this.x * e + this.y * t
    }
    ,
    Bt.prototype.dot3 = function(e, t, i) {
        return this.x * e + this.y * t + this.z * i
    }
    ;
    const jt = [new Bt(1,1,0), new Bt(-1,1,0), new Bt(1,-1,0), new Bt(-1,-1,0), new Bt(1,0,1), new Bt(-1,0,1), new Bt(1,0,-1), new Bt(-1,0,-1), new Bt(0,1,1), new Bt(0,-1,1), new Bt(0,1,-1), new Bt(0,-1,-1)]
      , Vt = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]
      , Gt = new Array(512)
      , Xt = new Array(512);
    Ut.seed = function(e) {
        e > 0 && e < 1 && (e *= 65536),
        (e = Math.floor(e)) < 256 && (e |= e << 8);
        for (let i = 0; i < 256; i++) {
            var t;
            t = 1 & i ? Vt[i] ^ 255 & e : Vt[i] ^ e >> 8 & 255,
            Gt[i] = Gt[i + 256] = t,
            Xt[i] = Xt[i + 256] = jt[t % 12]
        }
    }
    ,
    Ut.seed(0);
    const Yt = .5 * (Math.sqrt(3) - 1)
      , Wt = (3 - Math.sqrt(3)) / 6
      , qt = 1 / 6;
    function Ht(e) {
        return e * e * e * (e * (6 * e - 15) + 10)
    }
    function Qt(e, t, i) {
        return (1 - i) * e + i * t
    }
    Ut.simplex2 = function(e, t) {
        let i, n, r;
        const s = (e + t) * Yt;
        let a = Math.floor(e + s)
          , o = Math.floor(t + s);
        const l = (a + o) * Wt
          , c = e - a + l
          , h = t - o + l;
        let u, p;
        c > h ? (u = 1,
        p = 0) : (u = 0,
        p = 1);
        const d = c - u + Wt
          , f = h - p + Wt
          , m = c - 1 + 2 * Wt
          , g = h - 1 + 2 * Wt
          , v = Xt[(a &= 255) + Gt[o &= 255]]
          , y = Xt[a + u + Gt[o + p]]
          , b = Xt[a + 1 + Gt[o + 1]];
        let x = .5 - c * c - h * h
          , w = .5 - d * d - f * f
          , _ = .5 - m * m - g * g;
        return 70 * ((i = x < 0 ? 0 : (x *= x) * x * v.dot2(c, h)) + (n = w < 0 ? 0 : (w *= w) * w * y.dot2(d, f)) + (r = _ < 0 ? 0 : (_ *= _) * _ * b.dot2(m, g)))
    }
    ,
    Ut.simplex3 = function(e, t, i) {
        let n, r, s, a;
        const o = (e + t + i) * (1 / 3);
        let l = Math.floor(e + o)
          , c = Math.floor(t + o)
          , h = Math.floor(i + o);
        const u = (l + c + h) * qt
          , p = e - l + u
          , d = t - c + u
          , f = i - h + u;
        let m, g, v, y, b, x;
        p >= d ? d >= f ? (m = 1,
        g = 0,
        v = 0,
        y = 1,
        b = 1,
        x = 0) : p >= f ? (m = 1,
        g = 0,
        v = 0,
        y = 1,
        b = 0,
        x = 1) : (m = 0,
        g = 0,
        v = 1,
        y = 1,
        b = 0,
        x = 1) : d < f ? (m = 0,
        g = 0,
        v = 1,
        y = 0,
        b = 1,
        x = 1) : p < f ? (m = 0,
        g = 1,
        v = 0,
        y = 0,
        b = 1,
        x = 1) : (m = 0,
        g = 1,
        v = 0,
        y = 1,
        b = 1,
        x = 0);
        const w = p - m + qt
          , _ = d - g + qt
          , T = f - v + qt
          , M = p - y + 2 * qt
          , S = d - b + 2 * qt
          , A = f - x + 2 * qt
          , P = p - 1 + .5
          , C = d - 1 + .5
          , L = f - 1 + .5
          , k = Xt[(l &= 255) + Gt[(c &= 255) + Gt[h &= 255]]]
          , E = Xt[l + m + Gt[c + g + Gt[h + v]]]
          , I = Xt[l + y + Gt[c + b + Gt[h + x]]]
          , F = Xt[l + 1 + Gt[c + 1 + Gt[h + 1]]];
        let O = .6 - p * p - d * d - f * f
          , R = .6 - w * w - _ * _ - T * T
          , z = .6 - M * M - S * S - A * A
          , N = .6 - P * P - C * C - L * L;
        return 32 * ((n = O < 0 ? 0 : (O *= O) * O * k.dot3(p, d, f)) + (r = R < 0 ? 0 : (R *= R) * R * E.dot3(w, _, T)) + (s = z < 0 ? 0 : (z *= z) * z * I.dot3(M, S, A)) + (a = N < 0 ? 0 : (N *= N) * N * F.dot3(P, C, L)))
    }
    ,
    Ut.perlin2 = function(e, t) {
        let i = Math.floor(e)
          , n = Math.floor(t);
        e -= i,
        t -= n;
        const r = Xt[(i &= 255) + Gt[n &= 255]].dot2(e, t)
          , s = Xt[i + Gt[n + 1]].dot2(e, t - 1)
          , a = Xt[i + 1 + Gt[n]].dot2(e - 1, t)
          , o = Xt[i + 1 + Gt[n + 1]].dot2(e - 1, t - 1)
          , l = Ht(e);
        return Qt(Qt(r, a, l), Qt(s, o, l), Ht(t))
    }
    ,
    Ut.perlin3 = function(e, t, i) {
        let n = Math.floor(e)
          , r = Math.floor(t)
          , s = Math.floor(i);
        e -= n,
        t -= r,
        i -= s;
        const a = Xt[(n &= 255) + Gt[(r &= 255) + Gt[s &= 255]]].dot3(e, t, i)
          , o = Xt[n + Gt[r + Gt[s + 1]]].dot3(e, t, i - 1)
          , l = Xt[n + Gt[r + 1 + Gt[s]]].dot3(e, t - 1, i)
          , c = Xt[n + Gt[r + 1 + Gt[s + 1]]].dot3(e, t - 1, i - 1)
          , h = Xt[n + 1 + Gt[r + Gt[s]]].dot3(e - 1, t, i)
          , u = Xt[n + 1 + Gt[r + Gt[s + 1]]].dot3(e - 1, t, i - 1)
          , p = Xt[n + 1 + Gt[r + 1 + Gt[s]]].dot3(e - 1, t - 1, i)
          , d = Xt[n + 1 + Gt[r + 1 + Gt[s + 1]]].dot3(e - 1, t - 1, i - 1)
          , f = Ht(e)
          , m = Ht(t)
          , g = Ht(i);
        return Qt(Qt(Qt(a, h, f), Qt(o, u, f), g), Qt(Qt(l, p, f), Qt(c, d, f), g), m)
    }
    ;
    var Jt = Ut;
    class Zt {
        constructor(e={}) {
            this.id = e.id,
            this.prng = e.prng,
            this.radius = e.radius || 4,
            this.radius2 = 2 * this.radius,
            this.k = 50,
            this.w = this.radius / Math.sqrt(2),
            this.width = 120,
            this.height = 90,
            "default" === this.id && (this.height = 220),
            this.cols = Math.ceil(this.width / this.w),
            this.rows = Math.ceil(this.height / this.w)
        }
        setup() {
            this.grid = new Array(this.cols * this.rows),
            this.active = [],
            this.ordered = [];
            for (let e = 0; e < this.grid.length; e++)
                this.grid[e] = null;
            const e = this.width / 2
              , t = this.height / 2
              , i = Math.floor(e / this.w)
              , n = Math.floor(t / this.w)
              , r = new ge.T(e,t);
            this.grid[i + n + this.cols] = r,
            this.active.push(r),
            this.getCoords()
        }
        getCoords() {
            for (; this.active.length > 0; ) {
                const e = Math.floor(this.prng.random(this.active.length))
                  , t = this.active[e];
                let i = !1;
                ge.T.get();
                for (let e = 0; e < this.k; e++) {
                    const e = new ge.T(Math.cos(this.prng.random() * (2 * Math.PI)),Math.sin(this.prng.random() * (2 * Math.PI)))
                      , n = this.prng.random(this.radius) + this.radius;
                    e.multiplyScalar(n),
                    e.add(t);
                    const r = Math.floor(e.x / this.w)
                      , s = Math.floor(e.y / this.w);
                    if (r > -1 && s > -1 && r < this.cols && s < this.rows && null == this.grid[r + s * this.cols]) {
                        let t = !0;
                        for (let i = -1; i <= 1; i++)
                            for (let n = -1; n <= 1; n++) {
                                const a = r + i + (s + n) * this.cols
                                  , o = this.grid[a];
                                if (null != o) {
                                    e.clone().distanceTo(o) < this.radius && (t = !1)
                                }
                            }
                        if (t) {
                            i = !0,
                            e.x += 3 * this.prng.random(),
                            e.y += 3 * this.prng.random(),
                            this.grid[r + s * this.cols] = e,
                            this.active.push(e),
                            this.ordered.push(e);
                            break
                        }
                    }
                }
                i || this.active.splice(e, 1)
            }
            this.grid = this.grid.filter(e => null !== e);
            const e = 2e3 * this.prng.random()
              , t = 2e3 * this.prng.random()
              , i = 2 * this.prng.random()
              , n = .1 * this.prng.random();
            this.grid = this.grid.filter(r => Jt.simplex2((r.x + e) / (19 + i), (r.y + t) / (19 + i)) > .23 - n),
            this.grid = this.grid.map(e => ({
                position: new ge.U(e.x - .5 * this.width,e.y - .15 * this.height,20 * this.prng.random() - 60),
                scale: (new ge.T).setScalar(1).multiplyScalar(.6 + 1 * this.prng.random()),
                color: this.prng.randomInt(0, 1)
            }))
        }
    }
    var $t = i(1);
    var Kt = Object(G.a)(i(184).default);
    const ei = {};
    class ti extends _t {
        constructor(e) {
            super(e),
            this.batcher = e.batcher,
            this.palette = e.palette,
            this.stars = [],
            this.count = e.count || 100,
            this.poissonDisc = ei[e.id],
            this.buildStars()
        }
        buildStars() {
            const e = ge.U.get()
              , t = ge.T.get();
            for (let e = 0; e < this.poissonDisc.grid.length; e++) {
                const t = this.poissonDisc.grid[e];
                this.stars.push(new Dt({
                    batcher: this.batcher,
                    sprite: "star_a",
                    position: t.position,
                    scale: t.scale,
                    color: this.palette[8 + t.color]
                }))
            }
            e.release(),
            t.release()
        }
        update(e) {
            for (let t = 0; t < this.poissonDisc.grid.length; t++)
                this.stars[t].scale.x += .001 * e,
                this.stars[t].scale.y += .001 * e
        }
        beforeDestroy() {
            for (let e = 0, t = this.stars.length; e < t; e++)
                this.stars[e].destroy();
            this.stars = null,
            this.batcher = null,
            this.palette = null
        }
    }
    ti.prebuiltPoissons = function() {
        let e = 236;
        for (const t in te.a.seeds.current) {
            e += 38;
            const i = Object($t.a)(e)
              , n = new Zt({
                prng: i,
                id: t
            });
            n.setup(),
            ei[t] = n
        }
        const t = Object.assign({}, X, {
            default: Kt
        });
        for (const i in t) {
            const n = t[i].current;
            if (!n)
                continue;
            e += 38;
            const r = Object($t.a)(e)
              , s = new Zt({
                prng: r,
                id: i
            });
            s.setup(),
            ei[n.id] = s
        }
    }
    ;
    var ii = "precision highp float;\n#define GLSLIFY 1\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nattribute vec2 uv;\nattribute vec3 position;\nattribute vec3 color;\nattribute vec4 data; // xy: position | z: scale | w: orientation\nattribute float z;\n\nvarying vec2 vUv;\n// varying float vSize;\nvarying vec3 vPos ;\n\nvarying vec3 vColor;\n\n// #include <rotate>\n\nvoid main() {\n\n\tvec3 pos = vec3(data.x, data.y, z);\n\t// vSize = data.z;\n\tvColor = color;\n\n\tfloat scale = 0.5 + data.z * 0.5;\n\tvec3 transformed = position * scale;\n\ttransformed.x *= data.w;\n\t// transformed.xy = rotate(transformed.xy, data.w);\n\ttransformed += pos;\n\n\tvUv = uv;\n\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.);\n\tvPos = pos;\n}\n"
      , ni = "\n#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n#define GLSLIFY 1\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvarying vec3 vPos;\nvarying vec2 vUv;\nvarying vec3 vColor;\nuniform float uTime;\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdLine( p, a, b ) ;\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\n\nvoid main( )\n{\n\n\tvec2 uv =  vUv;\n\n\tfloat noise2 = (snoise(uv.xx * .99 + (vPos.z + uTime/3.))+0.1)/1.7;\n\tfloat cosinus = (cos(uv.x * 7. + (vPos.z + uTime*1.))*2. * noise2)*0.5;\n\tfloat waves = smoothstep(0.0, 1.,(0.5 + cosinus * 0.55));\n\n\tfloat cloud = (smoothstep(0.0, .4, pow(smoothstep(0., 1.4,uv.y)+step(uv.y, 0.1), 1.8) /((sin((uv.x*1.15-0.075) * 3.1415)))));\n\tvec3 l =  line( vec3(1.), vec2(.891, 0.095),vec2(.11, 0.095), uv, vec2(0.05,1.10), vec4(0.0,0.0,0.0,1.));\n\tif(cloud == 0.) {cloud = 1.;}\n\n\tcloud = (smin(waves, cloud, 1.));\n\tcloud = (smin(l.x, cloud,.1));\n\tcloud = 1.- (smoothstep(0.07, 0.073, cloud));\n\n\tgl_FragColor = vec4(vColor, cloud);\n}\n";
    class ri extends ge.M {
        constructor(e={}) {
            super({
                transparent: !0,
                vertexShader: ii,
                fragmentShader: ni,
                uniforms: {
                    uTime: {
                        value: 0
                    }
                }
            }),
            this.useObjectUniforms = !0,
            this.time = 0
        }
    }
    var si = function(e, t, i, n, s=!0) {
        s && t.updateWorldMatrix();
        const a = ge.U.get().set(e.x / r.a.canvasSize.current[0] * 2 - 1, -e.y / r.a.canvasSize.current[1] * 2 + 1, 0);
        a.unproject(t);
        const o = a.sub(t.position).normalize()
          , l = (i - t.position.z) / o.z;
        return ge.U.release(a),
        n || (n = new ge.U),
        n.copy(t.position).add(o.multiplyScalar(l)),
        n
    };
    class ai extends Tt {
        init(e) {
            if (this.currentScene = e.scene || null,
            this.zOffset = e.zOffset || 0,
            this.scaleX = e.scaleX || 1,
            this.base = new ge.F,
            this.offset = new ge.U(0,0,.15 + this.zOffset),
            this.pos = e.position ? e.position.clone().add(this.offset) : (new ge.U).add(this.offset),
            e.screenPos) {
                const t = this.pos.x;
                this.pos.x = si({
                    x: e.screenPos,
                    y: 0
                }, this.currentScene.currentCamera.base, this.pos.z, ge.U.get()).x,
                isNaN(this.pos.x) && (this.pos.x = t)
            }
            this.base.position.copy(this.pos),
            this.speed = .012,
            this.instant = !0,
            this.time = 0,
            this.props = e,
            this.resetScale(),
            this.bind(),
            this.bounds = {
                left: 0,
                right: 0
            },
            this.viewport = n.a.viewportSize.get(),
            this.onResize(n.a.viewportSize.get())
        }
        resetScale() {
            const e = 4 + 12 * Math.random();
            this.base.scale.set(e, e, 1)
        }
        bind() {
            n.a.viewportSize.subscribe(this.onResize, this)
        }
        unbind() {
            n.a.viewportSize.unsubscribe(this.onResize, this)
        }
        onResize(e) {
            this.viewport = n.a.viewportSize.get()
        }
        update(e) {
            this.time += e,
            super.update(e);
            this.bounds.left = si({
                x: -50,
                y: 0
            }, this.currentScene.currentCamera.base, this.base.position.z, ge.U.get(), !0),
            this.bounds.right = si({
                x: this.viewport[0] + 50,
                y: 0
            }, this.currentScene.currentCamera.base, this.base.position.z, ge.U.get(), !0),
            this.base.position.x -= this.speed,
            this.base.position.x + this.base.scale.x / 2 < this.bounds.left.x && (this.resetScale(),
            this.base.position.x = this.bounds.right.x + this.base.scale.x / 2 + 2 * Math.random()),
            this.bounds.left.release(),
            this.bounds.right.release()
        }
        beforeDestroy() {
            this.currentScene = null,
            this.unbind()
        }
    }
    const oi = 4;
    let li;
    const ci = [new ge.U(-13,22,-30), new ge.U(-22,9,-30), new ge.U(25,14,-30), new ge.U(10,18,-30)]
      , hi = [.03, .35, .85, 1.2]
      , ui = []
      , pi = () => {
        let e = ui.shift();
        if (e)
            return e;
        const t = new Float32Array(4 * oi)
          , i = new Float32Array(3 * oi)
          , n = new Float32Array(1 * oi);
        e = new ge.p;
        const r = ge.I.simple;
        return e.index = r.index,
        e.attributes.position = r.attributes.position,
        e.attributes.uv = r.attributes.uv,
        e.addAttribute("data", new ge.o(t,4,!1).setDynamic(!0)),
        e.addAttribute("z", new ge.o(n,1,!1)),
        e.addAttribute("color", new ge.o(i,3,!1).setDynamic(!0)),
        e
    }
    ;
    class di extends Tt {
        constructor(e={}) {
            super(e),
            li || (li = new ri),
            this.time = 0,
            this.geo = pi(),
            this.geo.attributes.z.needsUpdate = !0,
            this.base = new ge.x(this.geo,li),
            this.base.frustumCulled = !1,
            this.scene = e.scene,
            this.base.renderOrder = 0,
            this.base.position.z = 0,
            this.clouds = [];
            const t = n.a.viewportSize.get();
            for (let i = 0; i < oi; i++) {
                const n = this.addComponent(new ai({
                    zOffset: .1 * i,
                    screenPos: hi[i] * t[0],
                    position: ci[i],
                    scaleX: .5 * Math.random() + 1.5,
                    scene: e.scene || null
                }));
                this.clouds.push(n),
                this.geo.attributes.z.array[i] = n.base.position.z,
                this.geo.attributes.z.needsUpdate = !0,
                this.geo.attributes.data.array[4 * i + 0] = n.base.position.x,
                this.geo.attributes.data.array[4 * i + 1] = n.base.position.y,
                this.geo.attributes.data.array[4 * i + 2] = n.base.scale.y,
                this.geo.attributes.data.array[4 * i + 3] = n.scaleX,
                this.geo.attributes.data.needsUpdate = !0;
                const r = 2;
                this.geo.attributes.color.array[3 * i + 0] = e.palette[r].r,
                this.geo.attributes.color.array[3 * i + 1] = e.palette[r].g,
                this.geo.attributes.color.array[3 * i + 2] = e.palette[r].b,
                this.geo.attributes.color.needsUpdate = !0
            }
        }
        update(e) {
            super.update(e),
            this.time -= e / 1e3;
            for (let e = 0; e < oi; e++)
                this.geo.attributes.data.array[4 * e + 0] = this.clouds[e].base.position.x,
                this.geo.attributes.data.needsUpdate = !0;
            this.base.material.uniforms.uTime.value = .5 * this.time
        }
        beforeDestroy() {
            const e = this.geo.attributes.data.array;
            this.geo.attributes.data.needsUpdate = !0;
            for (let t = 0; t < oi; t++)
                e[4 * t + 0] = 0,
                e[4 * t + 1] = 0,
                e[4 * t + 2] = 0,
                e[4 * t + 3] = 0;
            ui.push(this.geo),
            this.data = this.geo = null
        }
    }
    class fi extends Dt {
        init(e) {
            this.batchers = e.batchers,
            this.landscapeComponents = [],
            mi({
                context: this,
                parent: this,
                components: e.children,
                palette: e.palette,
                landscapeOptions: e.landscapeOptions
            })
        }
        destroy() {
            for (let e = this.landscapeComponents.length - 1; e >= 0; e--)
                this.landscapeComponents[e].destroy();
            this.batchers = null,
            this.landscapeComponents = null,
            super.destroy()
        }
    }
    function mi({palette: e, context: t, components: i, parent: n, landscapeOptions: r}) {
        if (!i)
            return;
        r || (r = {}),
        r.scale || (r.scale = 1),
        r.position || (r.position = new ge.U),
        t.landscapeComponents = [];
        const s = ge.T.get()
          , a = ge.U.get()
          , o = ge.U.get();
        n ? o.set(n.scale.x, n.scale.y, 1) : o.set(1, 1, 1);
        for (let l = i.length - 1; l >= 0; l--) {
            const c = i[l]
              , h = c.id;
            if (!h)
                continue;
            const u = e[void 0 !== c.color ? c.color : Math.floor(6 * Math.random())];
            let p = h.split("_")[0];
            p = "ground" === p || "bush" === p ? "grounds" : "plants",
            a.set(c.pos[0] || 0, c.pos[1] || 5, c.pos[2] || 0),
            n ? a.multiply(o).add(n.position) : a.add(r.position),
            s.set(c.size[0] || 1, c.size[1] || 1),
            a.multiplyScalar(r.scale),
            s.multiplyScalar(r.scale);
            const d = {
                palette: e,
                batchers: t.batchers,
                batcher: t.batchers[p],
                sprite: h,
                rotation: c.ang || 0,
                position: a,
                scale: s,
                color: u,
                type: p,
                children: c.children,
                landscapeOptions: r
            };
            t.landscapeComponents.push(new fi(d))
        }
        s.release(),
        a.release(),
        o.release()
    }
    class gi extends Tt {
        constructor(e) {
            super(e),
            this.scale = e.scale || 1,
            this.position = e.position || new ge.U(0,0,0),
            this.sceneData = e.sceneData,
            this.batchers = e.batchers,
            this.prngSeed = +this.sceneData.current.prngSeed,
            this.prng = Object($t.a)(this.prngSeed),
            this.base = new ge.F,
            this.landscapeComponents = [],
            this.rebuildLandscape();
            const t = ee.a.palettes.current[this.sceneData.current.palette];
            this.addComponent(di, {
                palette: t,
                prng: this.prng,
                scene: e.scene || null
            }),
            this.addComponent(ti, {
                palette: t,
                batcher: this.batchers.stars,
                id: this.sceneData.current.id
            })
        }
        rebuildLandscape() {
            this.batchers.grounds.needsUpdate = !0,
            this.batchers.plants.needsUpdate = !0;
            for (let e = this.landscapeComponents.length - 1; e >= 0; e--)
                this.landscapeComponents[e].destroy();
            const e = this.sceneData.current.scene;
            mi({
                palette: ee.a.palettes.current[this.sceneData.current.palette],
                context: this,
                components: e,
                landscapeOptions: {
                    scale: this.scale,
                    position: this.position
                }
            })
        }
        beforeDestroy() {
            for (let e = this.landscapeComponents.length - 1; e >= 0; e--)
                this.landscapeComponents[e].destroy();
            for (const e in this.batchers)
                this.batchers[e].needsUpdate = !0;
            this.sceneData = null,
            this.batchers = null
        }
    }
    const vi = new Float32Array([-1, 0]);
    function yi() {
        const e = n.a.viewportRatio.current;
        if (vi[0] === e)
            return vi[1];
        const t = Object(b.clamp)(Object(b.norm)(e, .45, 1.6), 0, 1);
        return vi[0] = e,
        vi[1] = t,
        t
    }
    const {damp: bi} = i(5)
      , xi = Math.PI
      , wi = 2 * Math.PI;
    const _i = e => t => {
        e.current = function(e, t, i, n) {
            return e = (e + wi) % wi,
            t = (t + wi) % wi,
            Math.abs(e - t) < xi ? bi(e, t, i, n) : (e > t ? e -= wi : t -= wi,
            bi(e, t, i, n))
        }(e.current, e.target, e.currentEase, t)
    }
      , Ti = e => t => {
        e.current = Object(b.damp)(e.current, e.target, e.currentEase, t)
    }
      , Mi = e => t => {
        for (let i = 0, n = e.current.length; i < n; i++)
            e.current[i] = Object(b.damp)(e.current[i], e.target[i], e.currentEase, t)
    }
      , Si = e => t => {
        for (const i in e.current)
            e.current[i] = Object(b.damp)(e.current[i], e.target[i], e.currentEase, t)
    }
      , Ai = e => t => {
        e.current.x = Object(b.damp)(e.current.x, e.target.x, e.currentEase, t),
        e.current.y = Object(b.damp)(e.current.y, e.target.y, e.currentEase, t)
    }
      , Pi = e => t => {
        e.current.x = Object(b.damp)(e.current.x, e.target.x, e.currentEase, t),
        e.current.y = Object(b.damp)(e.current.y, e.target.y, e.currentEase, t),
        e.current.z = Object(b.damp)(e.current.z, e.target.z, e.currentEase, t)
    }
    ;
    function Ci(e) {
        let t = e.eases;
        t || (t = {
            default: parseFloat(void 0 !== e.ease ? e.ease : 1)
        }),
        t.default || (t.default = Object.values(t)[0]);
        const i = {
            current: e.current || 0,
            target: (n = e.current,
            n instanceof ge.U || n instanceof ge.T ? n.clone() : Array.isArray(n) ? value.slice(0) : "object" == typeof n ? Object.assign({}, n) : n),
            masterEase: e.masterEase || 1,
            currentEase: t.default,
            setEase: function(e, i) {
                void 0 === i && (t.default = e);
                t[i] = e
            },
            update: function(e, n="default") {
                e = Math.min(e, 150);
                const s = t[n] || t.default;
                i.currentEase = Object(b.damp)(i.currentEase, s, i.masterEase, e),
                r(e)
            }
        };
        var n;
        const r = function(e, t, i=!1) {
            return e instanceof ge.U ? Pi(t) : e instanceof ge.T ? Ai(t) : Array.isArray(e) ? Mi(t) : "object" == typeof e ? Si(t) : i ? _i(t) : Ti(t)
        }(e.current, i, e.angle);
        return i
    }
    var Li = class extends _t {
        constructor(e={}) {
            var t;
            super(),
            this.isCamera = !0,
            e.noInit || this.init(e),
            this.props || (this.props = e),
            this.base || ((t = this).cam = new ge.H(55,window.innerWidth / window.innerHeight,.1,200),
            t.base = t.cam,
            t.base.position.set(0, .2, 1).multiplyScalar(5),
            t.base.lookAt(new ge.U(0,0,0))),
            this.resizeSignal = r.a.canvasSize.subscribe(this.resize, this),
            this.resize(r.a.canvasSize.current)
        }
        update() {}
        resize(e) {
            this.cam.aspect = e[0] / e[1],
            this.cam.updateProjectionMatrix()
        }
        beforeDestroy() {
            r.a.canvasSize.unsubscribe(this.resizeSignal, this)
        }
        destroy() {
            this.cam = null,
            super.destroy()
        }
    }
    ;
    const ki = e => {
        const t = e * n.a.viewportSize.current[0]
          , i = ee.a.panelOffset.current;
        let r = 0;
        return n.a.menuOpen.current ? r = -.5 : n.a.seedListOpen.current && (r = .5),
        Math.abs(i) > Math.abs(r) ? i * t : r * t
    }
      , Ei = () => new ge.U
      , Ii = () => new ge.J;
    class Fi extends Li {
        init(e) {
            if (this.store = e.seedStore,
            this.isSeedScene = this.store,
            this.cam = new ge.H(55,window.innerWidth / window.innerHeight,.1,200),
            this.base = this.cam,
            this.quaternion = this.base.quaternion,
            this.position = this.base.position,
            this.rotation = this.base.rotation,
            this.isSeedScene) {
                const e = this.store.sceneData.current.hideCamera;
                this.hideCamera = {
                    qMix: 1,
                    pMix: 1,
                    position: Ei().fromArray(e.cameraPositionHide),
                    quaternion: Ii().setFromEuler(ge.n.get().release().fromArray(e.cameraRotationHide))
                }
            }
            this.origin = {
                position: {
                    ease: .055,
                    portrait: Ei(),
                    landscape: Ei(),
                    current: Ei(),
                    target: Ei()
                },
                quaternion: {
                    ease: .056,
                    portrait: Ii(),
                    landscape: Ii(),
                    current: Ii(),
                    target: Ii()
                }
            },
            this.wiggleFreq = .03,
            this.wiggleAmp = .1,
            this.wiggle = new ge.U,
            this.panX = Ci({
                current: 0,
                target: 0,
                ease: .0025
            }),
            this.angX = Ci({
                current: 0,
                target: 0,
                ease: .002
            }),
            this.panMenuX = Ci({
                current: 0,
                target: 0,
                ease: .0025
            }),
            this.angMenuX = Ci({
                current: 0,
                target: 0,
                ease: .002
            }),
            this.panY = 0,
            this.angY = 0,
            this.zoom = 0,
            this.initTweens(),
            this.updateOriginReferences(e.preset),
            this.updateOrigin(!0),
            this.setInitialPanelOffset(),
            n.a.viewportRatio.subscribe(this.updateOrigin, this),
            this.time = 0,
            this.setPanY(0, 0),
            this.update(0),
            this.isSeedScene && this.fromHide(!0)
        }
        initTweens() {
            this.isSeedScene && (this.tweens.hide = new J.a({
                paused: !0
            }).to(this.hideCamera, .9, {
                qMix: 0,
                ease: Xe.e.easeOut
            }, 0).to(this.hideCamera, 1.5, {
                pMix: 0,
                ease: Xe.e.easeOut
            }, 0))
        }
        fromHide(e) {
            e ? (this.hideCamera.qMix = 0,
            this.hideCamera.pMix = 0) : (this.hideCamera.qMix = 1,
            this.hideCamera.pMix = 1,
            this.tweens.hide.invalidate().restart())
        }
        setPanY(e, t=.8, i="easeInOut") {
            this.tweens.y && this.tweens.y.kill(),
            this.tweens.y = null;
            const n = this.getOffsetScale()
              , r = -e * n * (e > 0 ? 7 : 12)
              , s = e * n * .4;
            if (t <= 0)
                return this.panY = r,
                void (this.angY = s);
            this.tweens.y = $.a.to(this, 1.2, {
                panY: r,
                angY: s,
                ease: Xe.d[i]
            })
        }
        updateOriginReferences(e) {
            const t = this.preset = e || this.store && this.store.getPreset();
            if (!this.preset)
                return;
            const i = this.origin;
            i.position.portrait.fromArray(t.cameraPositionPortrait),
            i.position.landscape.fromArray(t.cameraPositionLandscape);
            const n = ge.n.get();
            i.quaternion.portrait.setFromEuler(n.fromArray(t.cameraRotationPortrait)),
            i.quaternion.landscape.setFromEuler(n.fromArray(t.cameraRotationLandscape)),
            n.release()
        }
        updateOrigin(e=!1) {
            const t = this.origin
              , i = yi();
            t.position.target.copy(t.position.portrait).lerp(t.position.landscape, i),
            t.quaternion.target.copy(t.quaternion.portrait).slerp(t.quaternion.landscape, i),
            e && (t.position.current.copy(t.position.target),
            t.quaternion.current.copy(t.quaternion.target))
        }
        setInitialPanelOffset() {
            if (!te.a.previousSeed.current)
                return;
            const e = te.a.offsetMultiplier.current;
            this.panX.current = 5 * e,
            this.angX.current = .14 * e
        }
        getOffsetScale() {
            this.preset;
            return Object(b.map)(this.preset.seedScale || 0, .3, 2.5, .23, .6)
        }
        update(e) {
            this.time += 8e-4 * e;
            const t = this.origin;
            t.quaternion.current.slerp(t.quaternion.target, t.quaternion.ease),
            t.position.current.lerp(t.position.target, t.position.ease);
            const i = this.wiggle;
            i.set(Math.cos(this.time + Math.cos(.8 * -this.time) * this.wiggleFreq) * this.wiggleAmp, Math.sin(.8 * this.time + Math.cos(this.time) * this.wiggleFreq) * this.wiggleAmp, Math.sin(.4 * this.time + Math.cos(this.time) * this.wiggleFreq) * this.wiggleAmp);
            const n = this.getOffsetScale();
            this.panX.target = ki(.01) * n,
            this.angX.target = ki(1e-4) * n,
            this.panX.update(e),
            this.angX.update(e),
            this.rotation.setFromQuaternion(t.quaternion.current),
            this.position.copy(t.position.current).add(i),
            this.rotation.x += this.angY,
            this.rotation.y += this.angX.current,
            this.position.x += this.panX.current,
            this.position.y += this.panY,
            this.position.z += this.zoom,
            this.position.lerp(this.hideCamera.position, this.hideCamera.pMix),
            this.quaternion.slerp(this.hideCamera.quaternion, this.hideCamera.qMix),
            this.base.updateMatrix()
        }
        beforeDestroy() {
            this.preset = null,
            n.a.viewportRatio.unsubscribe(this.updateOrigin, this),
            super.beforeDestroy()
        }
    }
    const Oi = () => new ge.U
      , Ri = () => new ge.J;
    class zi extends Fi {
        init(e) {
            this.choiceCamPortrait = {
                position: Oi(),
                quaternion: Ri()
            },
            this.choiceCamLandscape = {
                position: Oi(),
                quaternion: Ri()
            },
            this.choiceCam = {
                position: Oi(),
                quaternion: Ri(),
                qInfluence: 0,
                pInfluence: 0
            };
            const t = ge.n.get().fromArray(e.preset.cameraRotationChoicePortrait);
            this.choiceCamPortrait.position.fromArray(e.preset.cameraPositionChoicePortrait),
            this.choiceCamPortrait.quaternion.setFromEuler(t),
            t.fromArray(e.preset.cameraRotationChoiceLandscape),
            this.choiceCamLandscape.position.fromArray(e.preset.cameraPositionChoiceLandscape),
            this.choiceCamLandscape.quaternion.setFromEuler(t.release()),
            this.yOffset = 0,
            this.target = null,
            this.targetOffset = Ci({
                ease: .01
            }),
            this.targetPan = 0,
            this.targetMix = 1,
            super.init(e)
        }
        updateOrigin(e=!1) {
            const t = n.a.viewportRatio.current
              , i = Object(b.clamp)(Object(b.norm)(t, .45, 1.6), 0, 1);
            this.choiceCam.position.copy(this.choiceCamPortrait.position).lerp(this.choiceCamLandscape.position, i),
            this.choiceCam.quaternion.copy(this.choiceCamPortrait.quaternion).slerp(this.choiceCamLandscape.quaternion, i),
            super.updateOrigin(e)
        }
        follow(e, t) {
            if (this.target = e,
            t) {
                const t = e.base.position.y;
                this.targetOffset.target = t,
                this.targetOffset.current = t
            }
        }
        update(e) {
            this.time += 8e-4 * e;
            const t = this.origin;
            t.quaternion.current.slerp(t.quaternion.target, t.quaternion.ease),
            t.position.current.lerp(t.position.target, t.position.ease);
            const i = this.wiggle;
            i.set(Math.cos(this.time + Math.cos(.8 * -this.time) * this.wiggleFreq) * this.wiggleAmp, Math.sin(.8 * this.time + Math.cos(this.time) * this.wiggleFreq) * this.wiggleAmp, Math.sin(.4 * this.time + Math.cos(this.time) * this.wiggleFreq) * this.wiggleAmp),
            this.rotation.setFromQuaternion(t.quaternion.current),
            this.position.copy(t.position.current).add(i);
            const n = this.choiceCam;
            this.base.quaternion.slerp(n.quaternion, n.qInfluence),
            this.position.lerp(n.position, n.pInfluence),
            this.position.y += this.yOffset,
            this.target && (this.targetOffset.target = Object(b.lerp)(0, this.target.base.position.y + this.targetPan, this.targetMix)),
            this.targetOffset.update(e),
            this.position.y += this.targetOffset.current,
            this.base.updateMatrix()
        }
        beforeDestroy() {
            this.target = null,
            super.beforeDestroy()
        }
    }
    class Ni {
        constructor(e) {
            this.static = !0,
            this.props = e
        }
        update(e) {
            this.destroyed
        }
        beforeDestroy() {}
        destroy() {
            this.destroyed || (this.beforeDestroy(),
            this.parentComponent && this.parentComponent.removeComponent(this),
            this.props = null,
            this.destroyed = !0)
        }
    }
    const Di = () => 3e3 * Math.random() + 1e3
      , Ui = () => 8e3 * Math.random() + 2e3;
    class Bi extends Ni {
        constructor({id: e, skeleton: t}) {
            super(),
            this.skeleton = t;
            const i = "lavande" === e ? ["happy", "neutral"] : ["smile", "neutral"];
            this.blinkingTypes = {},
            i.forEach(e => this.blinkingTypes[e] = !0),
            this.eyeGroups = [];
            let n = [["eyes-Left", "eyes-Right"]];
            if ("cerisier" === e)
                n = [];
            else if ("lavande" === e) {
                n = [];
                let e = 0;
                for (; this.skeleton.findSlot("eyes-Left-" + ++e); )
                    n.push(["eyes-Left-" + e, "eyes-Right-" + e])
            }
            n.forEach(e => this.createEyeGroup(e))
        }
        createEyeGroup(e) {
            const t = {
                timer: Di(),
                doubleTimer: Ui(),
                blinking: !1,
                eyes: []
            };
            e.forEach(e => {
                const i = this.createEye(e);
                i && t.eyes.push(i)
            }
            ),
            this.eyeGroups.push(t)
        }
        createEye(e) {
            let t = e.split("-");
            t = [t[0], t[1]].join("-");
            const i = this.skeleton.findSlot(e);
            if (!i)
                return !1;
            const n = {
                slot: i,
                initial: i.attachment,
                previous: i.attachment,
                types: {
                    angry: this.skeleton.getAttachmentByName(e, t + "--angry"),
                    blink: this.skeleton.getAttachmentByName(e, t + "--blink"),
                    happy: this.skeleton.getAttachmentByName(e, t + "--happy"),
                    neutral: this.skeleton.getAttachmentByName(e, t + "--neutral"),
                    sad: this.skeleton.getAttachmentByName(e, t + "--sad"),
                    smile: this.skeleton.getAttachmentByName(e, t + "--smile")
                }
            };
            for (const e in n.types) {
                const t = n.types[e];
                t ? this.blinkingTypes[e] && (t.canBlink = !0) : delete n.types[e]
            }
            return n
        }
        update(e) {
            for (let t = 0, i = this.eyeGroups.length; t < i; t++) {
                const i = this.eyeGroups[t];
                if (i.timer -= e,
                i.doubleTimer -= e,
                i.timer > 0)
                    continue;
                let n = !1;
                const r = i.eyes.length;
                if (i.blinking)
                    for (let e = 0; e < r; e++) {
                        const t = i.eyes[e];
                        if (t.slot.attachment !== t.types.blink) {
                            n = !0;
                            break
                        }
                    }
                for (let e = 0; e < r; e++) {
                    const t = i.eyes[e]
                      , r = t.slot.attachment;
                    r !== t.types.blink && (t.previous = r),
                    i.blinking ? !n && t.slot.setAttachment(t.previous) : r.canBlink && t.slot.setAttachment(t.types.blink)
                }
                i.blinking = !i.blinking,
                n && (i.blinking = !1),
                i.blinking ? i.timer = 50 * Math.random() + 60 : i.doubleTimer < 0 ? (i.timer = 80 * Math.random() + 90,
                i.doubleTimer = Ui()) : i.timer = Di()
            }
        }
        resetEyes() {
            for (let e = 0, t = this.eyeGroups.length; e < t; e++) {
                const t = this.eyeGroups[e]
                  , i = t.eyes.length;
                for (let e = 0; e < i; e++) {
                    const i = t.eyes[e];
                    i.initial && i.slot.setAttachment(i.initial)
                }
            }
        }
        beforeDestroy() {
            this.resetEyes(),
            this.groupNames = null,
            this.eyeGroups = null,
            this.skeleton = null
        }
    }
    class ji extends Ni {
        constructor(e={}) {
            super(),
            this.skeleton = e.skeleton,
            this.position = e.position,
            this.scale = e.scale,
            this.bones = {},
            this.anchors = {};
            for (const t in e.anchors)
                this.bones[t] = this.skeleton.findBone(e.anchors[t]),
                this.anchors[t] = new ge.U
        }
        update() {
            const e = this.position;
            for (const t in this.bones)
                this.anchors[t].x = e.x + this.bones[t].worldX * this.scale,
                this.anchors[t].y = e.y + this.bones[t].worldY * this.scale,
                this.anchors[t].z = e.z
        }
        beforeDestroy() {
            this.skeleton = null,
            this.position = null,
            this.scale = null,
            this.bones = null,
            this.anchors = null
        }
    }
    function Vi(e, t, i=0) {
        if ("string" == typeof e && (e = t[e]),
        0 === i)
            return function() {
                e.call(t)
            }
            ;
        if (1 === i)
            return function(i) {
                e.call(t, i)
            }
            ;
        if (2 === i)
            return function(i, n) {
                e.call(t, i, n)
            }
            ;
        if (3 === i)
            return function(i, n, r) {
                e.call(t, i, n, r)
            }
            ;
        if (4 === i)
            return function(i, n, r, s) {
                e.call(t, i, n, r, s)
            }
            ;
        if (5 === i)
            return function(i, n, r, s, a) {
                e.call(t, i, n, r, s, a)
            }
            ;
        throw new Error("Too many arguments")
    }
    var Gi = i(44);
    const Xi = new ge.U;
    function Yi(e, t, i) {
        const n = r.a.canvasSize.get()
          , s = .5 * n[0]
          , a = .5 * n[1];
        return Xi.copy(e),
        Xi.project(t),
        Xi.x = Xi.x * s + s,
        Xi.y = -Xi.y * a + a,
        i || (i = new ge.T),
        i.set(Xi.x, Xi.y)
    }
    const Wi = function() {};
    class qi extends Ni {
        constructor(e) {
            super(e),
            this.tweens = {},
            this.onAnimationComplete = Vi(this.onAnimationComplete, this, 2),
            this.onCustomEvent = Vi(this.onCustomEvent, this, 2),
            this.mesh = e.forceMesh || Gi.a.createMesh(e.spineId),
            this.mesh.scale.set(-e.scale, e.scale, e.scale),
            this.skeleton = this.mesh.skeleton,
            this.skeletonData = this.skeleton.data,
            this.state = this.mesh.state,
            this.initState(),
            this.stateListeners = {
                complete: this.onAnimationComplete,
                event: this.onCustomEvent
            },
            this.state.addListener(this.stateListeners),
            this.mesh.update(0),
            this.mesh.batches.forEach(e => {
                e.renderOrder = 1,
                e.frustumCulled = !1,
                this.mesh.add(e)
            }
            ),
            this.initTweens(),
            this.bb = {
                min: new ge.U,
                max: new ge.U,
                box: new ge.g,
                size: new ge.U
            },
            this.boundCount = 2,
            this.boundingBox = new ge.U,
            this.computeBounds(),
            n.a.touch.subscribe(this.onTouch, this),
            this.seedIn = !1
        }
        update(e) {
            this.updateBounds(),
            this.mesh.update(e)
        }
        initTweens() {
            this.flash = 0,
            this.tweens.flash = $.a.fromTo(this, .4, {
                flash: 1
            }, {
                flash: 0,
                ease: Xe.d.easeInOut,
                onUpdate: () => !this.destroyed && this.setFlash(this.flash)
            }).progress(1, !1)
        }
        playAudio(e) {
            let t = e.audioPath.split(".");
            t.pop(),
            !1 | (t = t.join(".")).charAt(t.length - 1) && (t = t.slice(0, -1)),
            ve.a.play(t)
        }
        onAnimationComplete() {}
        onCustomEvent(e, t) {
            const i = t.data && t.data.name;
            t.data.audioPath ? this.playAudio(t.data) : this[i] && this[i](e, t)
        }
        initState() {
            this.state.setAnimation(0, "idle", !0).mixDuration = 0,
            this.state.data.defaultMix = .5
        }
        onTouch(e) {
            const t = this.props.scene;
            if (!t)
                return;
            if (n.a.device.current.hasTouch && !e.clickOut && !e.clickIn)
                return;
            const i = t.currentCamera.base
              , r = Yi(this.bb.min, i, ge.T.get())
              , s = Yi(this.bb.max, i, ge.T.get())
              , a = ge.f.get().set(r, s)
              , o = ge.T.get().fromArray(e.pos)
              , l = a.containsPoint(o) && Math.abs(e.relativePos[0]) < 8;
            if (l && e.clickOut) {
                const e = si(o, i, 0, ge.U.get());
                this.props.onClick && this.props.onClick(e),
                e.release()
            } else
                l && !this.seedIn ? (this.seedIn = !0,
                this.props.onMouseIn && this.props.onMouseIn()) : !l && this.seedIn && (this.seedIn = !1,
                this.props.onMouseOut && this.props.onMouseOut());
            ge.T.release(r, s, o),
            ge.f.release(a)
        }
        computeBounds() {
            this.bb.box.setFromObject(this.mesh),
            this.bb.box.getSize(this.bb.size),
            this.updateBounds()
        }
        updateBounds() {
            this.bb.min.set(.5 * -this.bb.size.x, this.bb.size.y, 0).add(this.mesh.position),
            this.bb.max.set(.5 * this.bb.size.x, 0, 0).add(this.mesh.position),
            this.mesh.parent && (this.bb.min.applyMatrix4(this.mesh.parent.matrixWorld),
            this.bb.max.applyMatrix4(this.mesh.parent.matrixWorld))
        }
        makeFlash() {
            this.tweens.flash && this.tweens.flash.restart()
        }
        setFlash(e) {
            for (let t = 0, i = this.mesh.batches.length; t < i; t++)
                this.mesh.batches[t].flash = e
        }
        play(e, t, i, n, r) {
            const s = this.state.setAnimation(e, t, i);
            void 0 !== n && (s.mixDuration = n),
            void 0 !== r && (s.timeScale = r)
        }
        beforeDestroy() {
            for (const e in this.tweens)
                this.tweens[e].kill();
            this.tweens = null,
            this.state.removeListener(this.stateListeners),
            this.mesh.parent && this.mesh.parent.remove(this.mesh),
            this.mesh.parent = null,
            this.mesh.clearBatches(),
            this.mesh.batches.forEach(e => {
                e.parent && e.parent.remove(e),
                e.material.release(),
                e.geometry.dispose()
            }
            ),
            this.mesh = null,
            this.props = null,
            this.skeleton = null,
            this.skeletonData = null,
            this.state = null,
            this.update = Wi,
            n.a.touch.unsubscribe(this.onTouch, this)
        }
    }
    class Hi extends qi {
        constructor(e) {
            super(e),
            this.level = this.props.level || this.props.store.level.current,
            this.idles = new Set(["idle", "fly", "sad"]),
            this.cycles = 0,
            this.resetIdleCycles(),
            this.cycleTimer = 1,
            this.chanceStep = 3,
            this.anims = {},
            this.sadAnims = [],
            this.idleAnims = [],
            this.hasSad = !1,
            this.buildAnims()
        }
        buildAnims() {
            if (!this.props.store || this.level < 1)
                return;
            const e = this.props.store.sceneData.current.seedPresets["lvl" + this.level];
            if (e) {
                this.anims = e.animations || {},
                this.sadAnims = [],
                this.idleAnims = [],
                this.hasSad = !1,
                this.sadMix = 0;
                for (const e in this.anims) {
                    const t = this.anims[e];
                    t.name = e,
                    "request" !== t.name ? "sad" !== t.name ? "sad" === t.from ? this.sadAnims.push(t) : "idle" === t.from && this.idleAnims.push(t) : (this.hasSad = !0,
                    this.sadMix = t.mix || .5) : this.requestAnim = t
                }
                this.resetIdleCycles()
            }
        }
        hasRequest() {
            if (!this.props.store)
                return;
            const e = this.props.store.resources.water.query.current
              , t = this.props.store.resources.sun.query.current
              , i = this.props.store.resources.love.query.current;
            return e || t || i
        }
        isSad() {
            if (!this.props.store || !this.hasSad)
                return !1;
            const e = this.props.store.resources.water.query.current
              , t = this.props.store.resources.sun.query.current
              , i = this.props.store.resources.love.query.current;
            return e && t && i
        }
        initState() {
            this.state.setAnimation(0, "idle", !0),
            this.state.data.defaultMix = .5
        }
        resetIdleCycles() {
            this.cycleTimer = 1,
            this.cycles = 0
        }
        tryToPlayAdditionalAnim() {
            if (this.props.simple)
                return;
            this.cycles++;
            const e = []
              , t = 100 * Math.random()
              , i = this.isSad()
              , n = i ? this.sadAnims : this.idleAnims;
            for (let i = 0, r = n.length; i < r; i++) {
                const r = n[i];
                if (this.cycles < r.delay)
                    continue;
                const s = r.step || this.chanceStep;
                t < r.chance + (this.cycles - r.delay) * s && e.push(r)
            }
            if (this.requestAnim && this.cycles >= this.requestAnim.delay && this.hasRequest() && !i) {
                t < this.requestAnim.chance + (this.cycles - this.requestAnim.delay) * this.chanceStep && e.push(this.requestAnim)
            }
            const r = e.length;
            if (r > 0) {
                const t = e[Math.floor(Math.random() * r)];
                this.playUniqueAnim(t.name, t.mix)
            }
        }
        playLoop(e, t) {
            const i = this.state.tracks[0].animation.name;
            let n = "sad" === e && this.sadMix ? this.sadMix : this.state.data.defaultMix;
            this.anims[i] && this.anims[i].endMix && (n = this.anims[i].endMix),
            this.cycles = 0,
            this.state.setAnimation(0, e, !0).mixDuration = void 0 !== t ? t : n
        }
        playUniqueAnim(e, t) {
            this.cycles = 0,
            this.state.setAnimation(0, e).mixDuration = void 0 !== t ? t : this.state.data.defaultMix
        }
        onAnimationComplete(e) {
            const t = e === this.state.tracks[0];
            t && this.isCurrentlyIdle() || t && !this.isCurrentlyIdle() && (this.isSad() ? this.playLoop("sad") : this.playLoop("idle"))
        }
        animProgressQuery() {
            this.level >= 4 || this.isCurrentlyIdle() && this.playUniqueAnim("action")
        }
        animCompleteQuery(e) {
            this.level >= 4 || (e || this.isCurrentlyIdle()) && this.playUniqueAnim("action")
        }
        animIn() {
            this.playUniqueAnim("in", 0),
            this.update(0)
        }
        animRequest() {
            this.isCurrentlyIdle() && this.playUniqueAnim("request")
        }
        update(e) {
            this.props.simple || (this.cycleTimer -= e,
            this.cycleTimer <= 0 && (this.cycleTimer = 1 - Math.max(0, -this.cycleTimer),
            this.isCurrentlyIdle() && this.tryToPlayAdditionalAnim())),
            super.update(e)
        }
        getCurrentAnim() {
            return this.state.tracks[0].animation.name
        }
        isRequesting() {
            return "request" === this.state.tracks[0].animation.name
        }
        isCurrentlyIdle() {
            const e = this.state.tracks[0].animation.name;
            return this.idles.has(e)
        }
    }
    class Qi extends Tt {
        init({scene: e, id: t, level: i, touchable: n}) {
            this.resourceRepeaters = {
                water: null,
                sun: null
            },
            this.store = te.a.getSeedById(t),
            this.spineId = t + "_lvl" + Math.max(i, 1),
            this.seedScale = this.store.getPreset(i).seedScale || 1,
            this.scale = ee.a.spineScale.current * this.seedScale,
            this.touchable = void 0 === n || n,
            this.spineSystem = this.addComponent(Hi, {
                store: this.store,
                level: i,
                scene: e,
                spineId: this.spineId,
                scale: this.scale,
                simple: !0,
                onMouseIn: () => this.onSeedIn(),
                onMouseOut: () => this.onSeedOut(),
                onClick: e => this.canInteract() && this.onSeedClick(e)
            }),
            this.base = this.spineSystem.mesh,
            this.spineSystem.computeBounds(),
            this.state = this.spineSystem.state,
            this.skeleton = this.spineSystem.skeleton,
            this.eyeSystem = this.addComponent(Bi, {
                id: this.store.id.current,
                skeleton: this.skeleton
            }),
            this.anchorsSystem = this.addComponent(ji, {
                skeleton: this.skeleton,
                position: this.base.position,
                scale: this.scale,
                anchors: this.createAnchors() || {}
            }),
            this.anchors = this.anchorsSystem.anchors,
            this.anchorsSystem.update(0)
        }
        createAnchors() {}
        canInteract() {
            return !this.destroyed && !!this.touchable
        }
        update(e) {
            this.eyeSystem.update(e),
            this.anchorsSystem.update(e),
            this.spineSystem.update(.001 * e),
            this.destroyed
        }
        onSeedIn() {
            this.canInteract() && (U.setCursor("pointer"),
            this.props.onMouseIn && this.props.onMouseIn())
        }
        onSeedOut() {
            this.canInteract() && (U.removeCursor(),
            this.props.onMouseOut && this.props.onMouseOut())
        }
        onSeedClick(e) {
            this.props.onClick && this.props.onClick(e)
        }
        beforeDestroy() {
            U.removeCursor(),
            this.skeleton = null,
            this.state = null,
            this.anchors = null,
            this.store = null,
            this.props = null
        }
    }
    var Ji = "precision highp float;\n#define GLSLIFY 1\n\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\nuniform float propType;\n\nattribute vec2 uv;\nattribute vec3 position;\n\nattribute vec4 texCoords;\nattribute vec4 transformsA; // meshCoords premultiplied by sprite.scale\nattribute vec4 transformsB; // sprite.position.xyz and rotation\nattribute vec4 color;\n\nvarying vec2 vUv;\n// varying vec2 vPos;\nvarying vec4 vColor;\n\nvec3 bend( vec3 p, float y, float f )\n{\n\tfloat k = y + 0.5;\n    float c = cos(f * k);\n    float s = sin(f * k);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid main() {\n\tvColor = color;\n\tvUv = uv * texCoords.zw + texCoords.xy;\n\n\tvec3 transformed = position;\n\n  \ttransformed.xy = transformed.xy * transformsA.zw + (transformsA.xy * 0.5);\n\n\tfloat idx = (transformsB.x + transformsB.y);\n\tfloat time = sin(time * 1.8 * (0.1 + cos(idx) * 0.05) + idx * 40.);\n\n  \tfloat offset = pow(position.y + 0.5, 1.1);\n\toffset *= (time * 0.5);\n\n\tfloat force = 0.07 * min(propType, 1.);\n\n\tfloat rotateOffset = time * force - offset * force * 0.75;\n\ttransformed = bend(transformed, position.y, rotateOffset * 5.2),\n\n\ttransformed.xy += transformsA.xy * 0.5;\n\ttransformed.xy = rotate(transformed.xy, transformsB.w + rotateOffset * 1.4);\n\ttransformed += transformsB.xyz;\n\n\t// vPos.xy = transformsB.xy;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.);\n\n}\n"
      , Zi = "precision highp float;\n#define GLSLIFY 1\n\nuniform float propType;\nuniform float time;\nuniform sampler2D atlas;\n\nvarying vec2 vUv;\n// varying vec2 vPos;\nvarying vec4 vColor;\n\n#include <equals>\n\nvoid main() {\n\n\tvec2 uv = vUv;\n\t// uv.y += cos(floor(time * 0.7) * 3. + vPos.x * 30. + uv.x * 40. + uv.y * 90.) * 0.001;\n\n\tfloat color = texture2D(atlas, uv).a;\n\tfloat c = 0.73;\n\tif (smoothstep(c, c + .02, color) < 0.9) discard;\n\n\t// vec3 c = mix(vec3(0.), vColor.rgb, smoothstep(0.89, 0.891, color));\n\n\tgl_FragColor = vec4(vColor.rgb, 1.);\n\n}\n\n";
    var $i = "precision highp float;\n#define GLSLIFY 1\n\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nattribute vec2 uv;\nattribute vec3 position;\n\nattribute vec4 texCoords;\nattribute vec4 transformsA; // meshCoords premultiplied by sprite.scale\nattribute vec4 transformsB; // sprite.position.xyz and rotation\nattribute vec4 color;\n\nvarying vec2 vUv;\nvarying vec4 vColor;\n\n#include <rotate>\n\nvoid main() {\n\tvColor = color;\n\n\tvec2 signs = sign(transformsA.zw);\n\n\t// Manage flip X and flip Y for scale\n\tvUv = ((uv.xy - 0.5) * signs.xy + 0.5) * texCoords.zw + texCoords.xy;\n\n\tvec3 transformed = position;\n  \ttransformed.xy = transformed.xy * abs(transformsA.zw) + transformsA.xy;\n\ttransformed.xy = rotate(transformed.xy, transformsB.w);\n\ttransformed += transformsB.xyz;\n\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.);\n\n}\n"
      , Ki = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform float time;\nuniform float opacity;\n\nvarying vec2 vUv;\nvarying vec4 vColor;\n\nvoid main() {\n\n\tvec2 uv = vUv;\n\tvec4 color = texture2D(atlas, uv).rgba;\n\tcolor.rgb = clamp(color.rgb / max(color.a, 0.00001), 0., 1.);\n\n\tgl_FragColor = vec4(color.rgb * vColor.rgb, vColor.a * color.a * 1.);\n\n}\n\n";
    const en = {
        no: ge.D,
        normal: ge.E,
        additive: ge.a,
        multiply: ge.z
    }
      , tn = {
        basic: class extends ge.M {
            constructor(e={}) {
                super({
                    transparent: !0,
                    vertexShader: $i,
                    fragmentShader: Ki,
                    uniforms: {
                        atlas: {
                            type: "t"
                        },
                        time: {
                            value: 0
                        }
                    }
                }),
                this.isCustomSpriteMaterialInstanced = !0,
                e.atlasTexture && (this.atlasTexture = e.atlasTexture)
            }
            get atlasTexture() {
                return this.uniforms.atlas.value
            }
            set atlasTexture(e) {
                e !== this.uniforms.atlas.value && (this.uniforms.atlas.value = e,
                this.uniforms.atlas.needsUpdate = !0)
            }
            dispose() {
                y.c.remove(this.update),
                super.dispose()
            }
        }
        ,
        props: class extends ge.M {
            constructor(e={}) {
                super({
                    vertexShader: Ji,
                    fragmentShader: Zi,
                    transparent: !0,
                    uniforms: {
                        atlas: {
                            type: "t"
                        },
                        time: {
                            type: "f",
                            value: 0
                        },
                        propType: {
                            type: "f",
                            value: 0
                        }
                    }
                }),
                this.update = this.update.bind(this),
                y.c.add(this.update),
                this.useObjectUniforms = !0,
                this.isPropsMaterial = !0,
                e.atlasTexture && (this.atlasTexture = e.atlasTexture)
            }
            get atlasTexture() {
                return this.uniforms.atlas.value
            }
            set atlasTexture(e) {
                e !== this.uniforms.atlas.value && (this.uniforms.atlas.value = e,
                this.uniforms.atlas.needsUpdate = !0)
            }
            update(e) {
                this.uniforms.time.value = this.uniforms.time.value + .01 * e
            }
            dispose() {
                y.c.remove(this.update),
                super.dispose()
            }
        }
    }
      , nn = {
        basic: {},
        props: {}
    }
      , rn = {};
    class sn {
        constructor(e) {
            this.z = e,
            this.instances = []
        }
    }
    class an extends Tt {
        getMaterial(e) {
            const t = e.atlas
              , i = void 0 === e.depthWrite || e.depthWrite
              , n = void 0 === e.depthTest || e.depthTest
              , r = void 0 !== e.transparent && e.transparent;
            let s = e.blending || "normal";
            en[s] || (s = "normal");
            const a = [t, s, r ? "t:1" : "t:0", i ? "dw:1" : "dw:0", n ? "dt:1" : "dt:0"].join("_");
            if (nn[this.materialType][a])
                return nn[this.materialType][a];
            const o = Object.values(nn[this.materialType])
              , l = o[0] ? o[0].clone() : new tn[this.materialType];
            return l.atlasTexture = Ot.getAtlas(t).baseTexture,
            l.depthWrite = i,
            l.depthTest = n,
            l.transparent = r,
            l.blending = en[s],
            l.needsUpdate = !0,
            nn[this.materialType][a] = l,
            l
        }
        getBlueprint({widthSegments: e, heightSegments: t}) {
            const i = e + "-" + t;
            if (rn[i])
                return rn[i];
            const n = new ge.I(1,1,e,t);
            return rn[i] = n,
            n
        }
        init(e={}) {
            0,
            this.materialType = e.material;
            this.atlas = e.atlas;
            e.subdivisions || (e.subdivisions = [1, 1]);
            const t = e.subdivisions[0] || 1
              , i = e.subdivisions[1] || 1
              , n = this.getMaterial(e)
              , r = this.getBlueprint({
                heightSegments: i,
                widthSegments: t
            });
            if (this.count = e.count || 500,
            this.needsUpdate = !0,
            this.attrs = {},
            this.geo = new ge.p,
            this.geo.index = r.index,
            this.geo.attributes.position = r.attributes.position,
            this.geo.attributes.uv = r.attributes.uv,
            this.initAttributes(),
            this.setDynamic(void 0 === e.dynamic || e.dynamic),
            this.base = new ge.x(this.geo,n),
            this.base.frustumCulled = !1,
            this.layers = [],
            this.layersHashmap = {},
            this.orderStep = .001,
            this.geo.maxInstancedCount = 0,
            this.prevDrawCount = 0,
            e.meshProperties)
                for (const t in e.meshProperties)
                    this.base[t] = e.meshProperties[t]
        }
        setMaterial(e) {
            const t = this.getMaterial(e);
            t !== this.base.material && (this.base.material = t,
            this.base.needsUpdate)
        }
        initAttributes() {
            this.stride = 16,
            this.buffer = new Float32Array(this.count * this.stride),
            this.interleavedBuffer = new ge.q(this.buffer,this.stride),
            this.geo.addAttribute("texCoords", new ge.s(this.interleavedBuffer,4,0,!1)),
            this.geo.addAttribute("transformsA", new ge.s(this.interleavedBuffer,4,4,!1)),
            this.geo.addAttribute("transformsB", new ge.s(this.interleavedBuffer,4,8,!1)),
            this.geo.addAttribute("color", new ge.s(this.interleavedBuffer,4,12,!1)),
            this.interleavedBuffer.needsUpdate = !0
        }
        setDynamic(e) {
            this.dynamic = void 0 === e || !!e,
            this.needsUpdate = !0,
            this.interleavedBuffer.setDynamic(this.dynamic),
            this.interleavedBuffer.needsUpdate = !0
        }
        addAttribute(e, t, i) {
            i = i || 1,
            this.attrs[e] = new t(this.count * i),
            this.geo.addAttribute(e, new ge.o(this.attrs[e],i,!1)),
            this.geo.attributes[e].needsUpdate = !0
        }
        insertNewLayer(e) {
            const t = new sn(e);
            if (!this.layers[0] || e < this.layers[0].z)
                return this.layers.unshift(t),
                this.layersHashmap[e] = t;
            for (let i = this.layers.length - 1; i >= 0; i--)
                if (!(e < this.layers[i].z))
                    return this.layers.splice(i + 1, 0, t),
                    this.layersHashmap[e] = t
        }
        addInstance(e, t) {
            if (t._addedToBatcher)
                return;
            void 0 === this.layersHashmap[e] && this.insertNewLayer(e),
            t._batcherZ = e,
            t._addedToBatcher = !0,
            this.layersHashmap[e].instances.push(t)
        }
        removeInstance(e, t) {
            t._addedToBatcher = !1;
            const i = this.layersHashmap[e];
            if (!i)
                return;
            const n = i.instances.indexOf(t);
            ~n && (i.instances.splice(n, 1),
            Number.isInteger(10 * e) || window.setTimeout( () => {
                const t = this.layersHashmap[e];
                t && !t.instances.length && delete this.layersHashmap[e]
            }
            , 1e3 * Math.random() + 2e3))
        }
        updateInstance(e, t, i, n) {
            const r = i.sprite.frame
              , s = this.stride;
            this.buffer[t * s + 0] = r.texCoords[0],
            this.buffer[t * s + 1] = r.texCoords[1],
            this.buffer[t * s + 2] = r.texCoords[2],
            this.buffer[t * s + 3] = r.texCoords[3],
            this.buffer[t * s + 4] = r.meshCoords[0] * i.scale.x,
            this.buffer[t * s + 5] = r.meshCoords[1] * i.scale.y,
            this.buffer[t * s + 6] = r.meshCoords[2] * i.scale.x,
            this.buffer[t * s + 7] = r.meshCoords[3] * i.scale.y,
            this.buffer[t * s + 8] = i.position.x,
            this.buffer[t * s + 9] = i.position.y,
            this.buffer[t * s + 10] = i.position.z + n,
            this.buffer[t * s + 11] = i.rotation,
            this.buffer[t * s + 12] = i.color.r,
            this.buffer[t * s + 13] = i.color.g,
            this.buffer[t * s + 14] = i.color.b,
            this.buffer[t * s + 15] = i.alpha
        }
        update(e) {
            if (!this.dynamic && !this.needsUpdate)
                return;
            let t = 0;
            for (let i = 0, n = this.layers.length; i < n; i++) {
                const n = this.layers[i].instances;
                let r = 0;
                for (let i = 0, s = n.length; i < s; i++) {
                    const s = n[i];
                    s && (t < this.count && (this.updateInstance(e, t, s, r),
                    r += this.orderStep,
                    t++))
                }
            }
            this.geo.maxInstancedCount = t,
            this.interleavedBuffer.needsUpdate = !0,
            this.prevDrawCount = t,
            this.needsUpdate = !1
        }
        clearInstances() {
            this.instances = [],
            this.prevDrawCount = 0
        }
        clearLayers() {
            this.layers = [],
            this.layersHashmap = {}
        }
        destroy() {
            this.geo.dispose(),
            this.instances = null,
            this.attrs = null,
            this.atlas = null,
            super.destroy()
        }
    }
    const on = {};
    an.get = function(e) {
        const t = (e = Object.assign({}, {
            material: "basic",
            atlas: "sprites",
            subdivisions: [1, 1],
            heightSegments: 1,
            count: 300,
            dynamic: !0
        }, e)).subdivisions[0] + "_" + e.subdivisions[1] + "_" + e.count;
        on[t] || (on[t] = []);
        const i = on[t]
          , n = i[0] ? i.shift() : new an(e);
        if (n.hash = t,
        n.materialType = e.material,
        n.base.renderOrder = e.renderOrder,
        n.setMaterial(e),
        n.setDynamic(e.dynamic),
        e.meshProperties)
            for (const t in e.meshProperties)
                n.base[t] = e.meshProperties[t];
        return n.needsUpdate = !0,
        e.offset && (n.base.position.z = e.offset),
        n
    }
    ,
    an.release = function(e) {
        e.parentComponent && e.parentComponent.removeComponent(e),
        e.base.parent && e.base.parent.remove(e.base),
        e.clearInstances(),
        e.clearLayers(),
        e.base.position.setScalar(0),
        e.base.scale.setScalar(1),
        e.base.rotation.set(0, 0, 0),
        on[e.hash].push(e)
    }
    ,
    an.prototype.release = function() {
        an.release(this)
    }
    ;
    const ln = {
        desktop: [new ge.U(-3.1,8.8,-.9), new ge.U(0,8.4,1.2), new ge.U(3.1,8.8,-.9)],
        mobile: [new ge.U(-2.2,8.8,-.9), new ge.U(0,8.5,1.2), new ge.U(2.2,8.8,-.9)]
    }
      , cn = {
        desktop: [new ge.U(-2.2,8,.85), new ge.U(0,8,.85), new ge.U(2.2,8,.85)],
        mobile: [new ge.U(-1.85,8.25,.1), new ge.U(0,8.25,.1), new ge.U(1.85,8.25,.1)]
    }
      , hn = {
        desktop: -.43,
        mobile: -.25
    }
      , un = {
        desktop: [.75, 1.05, .75],
        mobile: [.73, .95, .73]
    }
      , pn = {
        desktop: [.75, .75, .75],
        mobile: [.73, .73, .73]
    }
      , dn = {
        amandier: 0,
        immortelle: 0,
        lavande: .02
    };
    class fn extends Tt {
        constructor(e) {
            super(e),
            this.store = te.a.getSeedById(e.id),
            this.id = e.id,
            this.seed = this.addComponent(Qi, {
                id: e.id,
                scene: e.scene,
                level: 1,
                onClick: t => !this.hidden && e.onClick && e.onClick(t),
                onMouseIn: () => this.onMouseIn(),
                onMouseOut: () => this.onMouseOut()
            }),
            this.seed.base.position.y = dn[e.id],
            this.seed.spineSystem.computeBounds(),
            this.seed.state.setAnimation(1, "blue-shadow").alpha = 1,
            this.plants = an.get({
                count: 15,
                material: "props",
                atlas: "props",
                dynamic: !1,
                offset: -.002,
                meshProperties: {
                    propType: 1
                }
            }),
            this.grounds = an.get({
                count: 15,
                material: "props",
                atlas: "props",
                dynamic: !1,
                offset: -.003,
                meshProperties: {
                    propType: 0
                }
            }),
            this.add(this.plants.base),
            this.add(this.grounds.base),
            this.orderScale = 1,
            this.orderPos = {
                x: new ye.a({
                    tension: .06,
                    friction: .3
                }),
                y: new ye.a({
                    tension: .06,
                    friction: .3
                }),
                z: new ye.a({
                    tension: .07,
                    friction: .2
                })
            },
            this.scaleOffset = new ye.a({
                tension: .07,
                friction: .2
            }),
            this.xRotation = new ye.a({
                tension: .04,
                friction: .12
            }),
            this.yAdjust = 0,
            this.yMultiplier = Ci({
                current: 0,
                ease: .003
            }),
            this.orderScale = Ci({
                current: 1,
                ease: .008
            }),
            this.initPlant(),
            this.hidden = !0,
            this.time = 0;
            const t = e.seedArrays.indexOf(e.id);
            this.setOrder(t, !0, !0),
            this.initialized = !1,
            n.a.viewportRatio.subscribe(this.onViewportChange, this)
        }
        initPlant() {
            const e = ge.U.get()
              , t = ge.T.get();
            new Dt({
                batcher: this.grounds,
                sprite: "ground_c",
                color: new ge.k(2845623),
                position: e.set(0, .2, -.001),
                scale: t.set(2.7, .5)
            }),
            new Dt({
                batcher: this.grounds,
                sprite: "ground_c",
                color: new ge.k(2119068),
                position: e.set(-.35, .35, -.01),
                scale: t.set(1.75, .6)
            }),
            new Dt({
                batcher: this.grounds,
                sprite: "ground_d",
                color: new ge.k(7326191),
                position: e.set(.35, .35, -.015),
                scale: t.set(3.35, .65)
            }),
            new Dt({
                batcher: this.grounds,
                sprite: "circle",
                color: new ge.k(2845623),
                position: e.set(0, -.03, -.02),
                scale: t.set(7, 2)
            }),
            new Dt({
                batcher: this.grounds,
                sprite: "circle",
                color: new ge.k(16117732),
                position: e.set(0, -.06, -.021),
                scale: t.set(7, 2)
            }),
            new Dt({
                batcher: this.plants,
                sprite: "plant_small_j",
                color: new ge.k(2119068),
                position: e.set(-1.1, .07, -.03),
                rotation: -.2,
                scale: t.set(.3, .3)
            }),
            new Dt({
                batcher: this.plants,
                sprite: "plant_medium_l",
                color: new ge.k(2119068),
                position: e.set(-1, .08, -.03),
                scale: t.set(.6, .6)
            }),
            new Dt({
                batcher: this.plants,
                sprite: "plant_small_e",
                color: new ge.k(2119068),
                position: e.set(-.8, .2, -.03),
                rotation: -.2,
                scale: t.set(.4, .4)
            }),
            new Dt({
                batcher: this.plants,
                sprite: "plant_small_e",
                color: new ge.k(7326191),
                position: e.set(1, .09, -.04),
                rotation: .2,
                scale: t.set(.5, .5)
            }),
            new Dt({
                batcher: this.plants,
                sprite: "plant_small_e",
                color: new ge.k(7326191),
                position: e.set(1.05, .1, -.03),
                rotation: .4,
                scale: t.set(.3, .3)
            }),
            new Dt({
                batcher: this.plants,
                sprite: "plant_medium_i",
                color: new ge.k(1185623),
                position: e.set(-.8, -.31, .03),
                scale: t.set(.7, .7)
            }),
            new Dt({
                batcher: this.plants,
                sprite: "plant_medium_h",
                color: new ge.k(1185623),
                position: e.set(.8, -.32, .03),
                scale: t.set(.85, .85)
            }),
            t.release(),
            e.release()
        }
        onMouseIn() {
            this.scaleOffset.setTarget(1 === this.currentOrder && this.initialized ? 0 : .09)
        }
        onMouseOut() {
            this.scaleOffset.setTarget(0)
        }
        onViewportChange() {
            this.updateTarget(!0)
        }
        updateTarget(e) {
            const t = n.a.viewportRatio.current
              , i = Object(b.clamp)(Object(b.norm)(t, .45, 1.6), 0, 1);
            this.yAdjust = Object(b.lerp)(hn.mobile, hn.desktop, i);
            const r = this.initialized ? ln : cn
              , s = this.initialized ? un : pn
              , a = r.mobile[this.currentOrder]
              , o = r.desktop[this.currentOrder]
              , l = this.orderPos;
            l.x.setTarget(Object(b.lerp)(a.x, o.x, i)),
            l.y.setTarget(Object(b.lerp)(a.y, o.y, i)),
            l.z.setTarget(Object(b.lerp)(a.z, o.z, i)),
            e && (l.x.setValue(l.x.target),
            l.y.setValue(l.y.target),
            l.z.setValue(l.z.target));
            const c = s.mobile[this.currentOrder]
              , h = s.desktop[this.currentOrder];
            this.orderScale.target = Object(b.lerp)(c, h, i),
            e && (this.orderScale.current = this.orderScale.target)
        }
        setOrder(e, t, i) {
            this.currentOrder = e,
            this.happy = !(!t || 1 !== e),
            i || (this.initialized = !0),
            this.updateTarget(t)
        }
        update(e) {
            this.time += .002 * e;
            const t = this.orderPos;
            t.x.update(e),
            t.y.update(e),
            t.z.update(e);
            const i = this.base.position.x
              , r = this.hidden ? 300 : 0;
            this.base.position.set(t.x.value + r, t.y.value + 0, t.z.value),
            this.yMultiplier.target = n.a.seedChosen.current ? 1 : 0,
            this.yMultiplier.update(e),
            this.base.position.y += this.yAdjust * this.yMultiplier.current,
            this.xRotation.setTarget(Object(b.clamp)(-1 * (this.base.position.x - i), -.16, .16)),
            this.xRotation.update(e),
            this.base.rotation.z = this.xRotation.value,
            1 === this.currentOrder && Math.abs(t.x.value - t.x.target) < .02 && !this.happy && (this.seed.spineSystem.animCompleteQuery(),
            this.happy = !0),
            this.scaleOffset.update(e),
            this.orderScale.update(e),
            this.base.scale.setScalar(this.orderScale.current + this.scaleOffset.value),
            super.update(e),
            this.plants.update(e),
            this.grounds.update(e)
        }
        beforeDestroy() {
            n.a.viewportRatio.unsubscribe(this.onViewportChange, this),
            this.plants.release(),
            this.grounds.release(),
            this.plants = null,
            this.grounds = null,
            this.store = this.seed = null,
            super.beforeDestroy()
        }
    }
    const mn = new Map
      , gn = e => e;
    function vn(e) {
        return e ? (mn.has(e) || mn.set(e, wt()(e[0], e[1], e[2], e[3])),
        mn.get(e)) : gn
    }
    Object(me.a)("Particle", "black", "#f0e5d2", 0).log;
    const yn = 1 / Number.MAX_SAFE_INTEGER;
    class bn extends Dt {
        constructor(e) {
            super(e),
            this.batcher && this.batcher.removeInstance(this._batcherZ, this),
            this.spriteId = null,
            this.spriteFrame = 0,
            this.spriteFrameDuration = 50,
            this.spriteLoop = !1,
            this.spriteAutoplay = !1,
            this.delay = 0,
            this.duration = 0,
            this.age = 0,
            this.progress = 0,
            this.onProgress = null,
            this.onComplete = null,
            this.onEnd = null,
            this.angVelocity = 0,
            this.angVelocityDrag = 0,
            this.velocity = new ge.T,
            this.velocityDrag = new ge.T,
            this.velocityDragMult = new ge.T,
            this.useVelocityDragMult = !1,
            this.gravity = new ge.T,
            this.scaleFrom = new ge.T,
            this.scaleTo = new ge.T,
            this.colorFrom = new ge.k,
            this.colorTo = new ge.k,
            this.alphaFrom = 1,
            this.alphaTo = 1,
            this.alive = !1,
            this.killable = !1,
            this.progressEase = vn(),
            this.scaleEase = vn(),
            this.alphaEase = vn(),
            this.colorEase = vn(),
            this.needsReorder = !1
        }
        reset() {
            this.alive && this.onEnd && this.onEnd(),
            this.spriteId = null,
            this.spriteFrame = 0,
            this.spriteFrameDuration = 50,
            this.spriteLoop = !1,
            this.spriteAutoplay = !1,
            this.rotation = 0,
            this.position.setScalar(0),
            this.scale.setScalar(1),
            this.delay = 0,
            this.duration = 1e3,
            this.age = 0,
            this.progress = 0,
            this.onProgress = null,
            this.onComplete = null,
            this.onEnd = null,
            this.angVelocity = 0,
            this.angVelocityDrag = 0,
            this.velocity.setScalar(0),
            this.velocityDrag.setScalar(0),
            this.useVelocityDragMult = !1,
            this.gravity.setScalar(0),
            this.scaleFrom.setScalar(1),
            this.scaleTo.setScalar(1),
            this.colorFrom.setRGB(0, 0, 0),
            this.colorTo.setRGB(0, 0, 0),
            this.alphaFrom = 1,
            this.alphaTo = 1,
            this.progressEase = vn(),
            this.scaleEase = vn(),
            this.alphaEase = vn(),
            this.colorEase = vn()
        }
        emit(e, t, i, n) {
            this.reset(),
            e !== this.batcher ? (this.batcher && this._addedToBatcher && this.batcher.removeInstance(this._batcherZ, this),
            this.batcher = e,
            this.needsReorder = !1) : this.needsReorder = !0,
            this.killable = !1,
            this.alive = !0,
            this.index = n,
            t && t(this, i),
            this.sprite.setAtlas(this.batcher.atlas),
            this.sprite.change({
                id: this.spriteId,
                frame: this.spriteFrame,
                frameDuration: this.spriteFrameDuration,
                loop: this.spriteLoop,
                autoplay: this.spriteAutoplay
            }),
            this.sprite.update(1),
            this.update(0),
            this.resetOrder()
        }
        kill() {
            this.killable && this.onComplete && this.onComplete(),
            this.batcher && (this.batcher.removeInstance(this._batcherZ, this),
            this.batcher = null),
            this.reset(),
            this.progress = 1,
            this.alive = !1,
            this.killable = !1
        }
        update(e) {
            if (!this.alive || this.killable)
                return;
            if (this.progress >= 1)
                return this.killable = !0;
            if (this.delay > 0) {
                if (this.delay -= e,
                this.delay > 0)
                    return this.alpha = 0,
                    void this.scale.setScalar(yn);
                e = Math.max(0, e + this.delay)
            }
            super.update(e);
            const t = Math.max(Math.min(e / 16.666666667, 1.5), .5);
            if (this.age += e,
            this.progress = this.progressEase(Object(b.clamp)(this.age / this.duration, 0, 1)),
            this.useVelocityDragMult)
                this.velocity.multiply(this.velocityDrag),
                this.velocity.lengthSq < 1e-4 && this.velocity.setScalar(0);
            else {
                if (this.velocity.x) {
                    const e = Math.sign(this.velocity.x);
                    this.velocity.x -= e * this.velocityDrag.x * t,
                    Math.sign(this.velocity.x) !== e && (this.velocity.x = 0)
                }
                if (this.velocity.y) {
                    const e = Math.sign(this.velocity.y);
                    this.velocity.y -= e * this.velocityDrag.y * t,
                    Math.sign(this.velocity.y) !== e && (this.velocity.y = 0)
                }
            }
            if (this.angVelocity) {
                const e = Math.sign(this.angVelocity);
                this.angVelocity -= e * this.angVelocityDrag * t,
                Math.sign(this.angVelocity) !== e && (this.angVelocity = 0)
            }
            this.position.x += (this.velocity.x + this.gravity.x) * t,
            this.position.y += (this.velocity.y + this.gravity.y) * t,
            this.rotation += this.angVelocity * t,
            this.scale.copy(this.scaleFrom).lerp(this.scaleTo, this.scaleEase(this.progress)),
            this.color.copy(this.colorFrom).lerp(this.colorTo, this.colorEase(this.progress)),
            this.alpha = Object(b.lerp)(this.alphaFrom, this.alphaTo, this.alphaEase(this.progress)),
            this.onProgress && this.onProgress(this, this.progress)
        }
    }
    const xn = 200
      , wn = Object(me.a)("EMITTER", "black", "#b6a484", 1).log;
    class _n extends _t {
        constructor(e) {
            super(e),
            this.count = e.count || xn,
            this.dead = new Array(this.count).fill(0).map( () => new bn({})),
            this.alive = [],
            this.batchers = [],
            0
        }
        emit(e, t, i) {
            wn("Emit " + t + " particles using batcher " + e);
            const n = this.batchers[e] || this.batchers[0];
            t = t || 1;
            const r = this.alloc(t);
            for (let e = r.length - 1; e >= 0; e--)
                r[e].alive || 0,
                this.alive.push(r[e]),
                r[e].emit(n, i, t, e)
        }
        update(e) {
            const t = [];
            for (let i = this.alive.length - 1; i >= 0; i--) {
                const n = this.alive[i];
                n.update(e),
                n.killable && (t.push(n),
                this.alive.splice(i, 1),
                this.dead.push(n),
                0)
            }
            for (let e = t.length - 1; e >= 0; e--)
                t[e].kill()
        }
        alloc(e) {
            const t = this.dead
              , i = this.alive;
            let n = []
              , r = e;
            return t.length > 0 && (n = t.splice(0, r)),
            (r -= n.length) > 0 && (n = n.concat(i.splice(0, r))),
            n
        }
        killAll() {
            for (let e = this.alive.length - 1; e >= 0; e--)
                this.alive[e].kill(),
                this.dead.push(this.alive[e]),
                this.alive.splice(e, 1),
                0
        }
    }
    const Tn = {};
    _n.get = function(e={}) {
        e.count = e.count || xn;
        const t = Tn[e.count] && Tn[e.count][0] ? Tn[e.count].shift() : new _n(e);
        return t.batchers = e.batchers,
        t
    }
    ,
    _n.release = function(e) {
        e.parentComponent && e.parentComponent.removeComponent(e),
        e.base && e.base.parent && e.base.parent.remove(e.base),
        e.batchers = [],
        e.killAll(),
        Tn[e.count] || (Tn[e.count] = []),
        Tn[e.count].push(e)
    }
    ,
    _n.prototype.release = function() {
        _n.release(this)
    }
    ;
    var Mn = i(39);
    let Sn, An = !1;
    const Pn = 16;
    let Cn = 0;
    function Ln(e) {
        Sn.setPixelRatio(e),
        kn()
    }
    function kn() {
        const e = n.a.viewportSize.current
          , t = n.a.device.current
          , i = n.a.scrollable.current;
        let s = e[0]
          , a = e[1];
        if (i && t.type.mobile) {
            const t = e[0] / e[1] > 1.4;
            s = t ? screen.height : screen.width,
            a = t ? screen.width : screen.height
        }
        Sn.setSize(s, a),
        function() {
            const e = ge.T.get();
            Sn.getDrawingBufferSize(e),
            ge.T.release(e),
            r.a.drawingBufferSize.update(t => (t[0] = e.x,
            t[1] = e.y,
            t), !0)
        }(),
        r.a.canvasSize.update(e => (e[0] = s,
        e[1] = a,
        e), !0),
        bt.isReady() && bt.resize()
    }
    var En = {
        init: function(e={}) {
            An || (An = !0,
            (Sn = new ge.X({
                antialias: !1,
                alpha: !1,
                depth: !0,
                stencil: !1,
                preserveDrawingBuffer: !1,
                powerPreference: "high-performance"
            })).setClearColor(r.a.bgColor.current),
            Sn.autoClear = !1,
            Sn.info.autoReset = !1,
            Sn.shadowMap.enabled = r.a.enableShadows.current,
            Sn.shadowMap.type = ge.e,
            (e.parent || document.body).appendChild(Sn.domElement),
            n.a.viewportSize.subscribe(kn),
            r.a.canvasPixelRatio.subscribe(Ln),
            n.a.scrollable.subscribe(kn),
            Ln(r.a.canvasPixelRatio.get()),
            kn(n.a.viewportSize.get()),
            bt.init({
                renderer: Sn
            }),
            bt.resize())
        },
        appLoaded: function() {
            bt.appLoaded()
        },
        tick: function(e) {
            void 0 === e && (e = 16.6667);
            let t = Object(b.clamp)(e, 1, 130);
            (Cn += t) < Pn || (t = Cn - Cn % Pn,
            Cn %= Pn,
            Sn.info.reset(),
            function(e) {
                Object(Mn.b)(e),
                bt.update(e)
            }(t),
            function(e) {
                bt.render(e)
            }(t))
        },
        getRenderer: () => Sn,
        getDomElement: () => Sn.domElement
    };
    var In = class extends _t {
        constructor(e={}) {
            super(),
            this.isScene = !0,
            this.scene = this.base = new ge.P,
            this.background = new ge.k(0,0,0),
            e.noInit || this.init(e),
            this.props || (this.props = e),
            this.currentCamera || this.fallbackCamera()
        }
        fallbackCamera() {
            this.defaultCamera || (this.defaultCamera = this.addComponent(new Li)),
            this.useCamera(this.defaultCamera)
        }
        useCamera(e) {
            this.currentCamera && (this.previousCamera = this.currentCamera),
            this.currentCamera = e,
            this.currentCamera || this.fallbackCamera()
        }
        usePreviousCamera() {
            const e = this.currentCamera;
            this.currentCamera = this.previousCamera,
            this.previousCamera = e,
            this.currentCamera || this.fallbackCamera()
        }
        activated() {}
        deactivated() {}
        enter() {}
        exit() {}
        destroy() {
            En.getRenderer().renderLists.disposeScene(this.scene),
            this.previousCamera = this.currentCamera = this.defaultCamera = null,
            super.destroy()
        }
    }
    ;
    const Fn = 2 * Math.PI
      , On = new ge.k(1,1,1);
    function Rn({position: e, scale: t, sprite: i, color: n}) {
        const r = $t.b.randomFloat(0, Fn);
        return (s, a) => {
            const o = Fn / a
              , l = s.index * o + $t.b.randomFloat(-.2, .2) + r
              , c = (.06 + $t.b.randomFloat(-.05, .01)) * t;
            s.rotation = $t.b.randomFloat(0, Fn),
            s.angVelocity = .1 + $t.b.randomFloat(0, .01),
            s.spriteId = i,
            s.velocity.x = c * Math.cos(l),
            s.velocity.y = c * Math.sin(l),
            s.velocityDrag.setScalar(.9),
            s.useVelocityDragMult = !0,
            s.position.copy(e),
            s.gravity.set(0, .011 * t, 0),
            s.duration = $t.b.randomFloat(500, 900),
            s.scaleFrom.setScalar((.5 + $t.b.randomFloat(-.1, .1)) * t),
            s.scaleTo.setScalar(0),
            s.colorFrom.copy(n || On),
            s.colorTo.copy(n || On).offsetHSL(0, $t.b.randomFloat(-.2, .2), $t.b.randomFloat(-.3, .3))
        }
    }
    window.requestAnimationFrame;
    const zn = Object($t.a)(Date.now())
      , Nn = (Math.PI,
    Math.PI);
    Math.PI,
    Math.PI;
    const Dn = 2 * Math.PI
      , Un = new ge.k(1,1,1);
    const Bn = new ge.k(16777215);
    const jn = new ge.k(16777215);
    window.requestAnimationFrame;
    const Vn = Object($t.a)(Date.now());
    Math.PI,
    Math.PI,
    Math.PI,
    Math.PI;
    window.requestAnimationFrame;
    const Gn = Object($t.a)(Date.now());
    Math.PI,
    Math.PI,
    Math.PI,
    Math.PI;
    window.requestAnimationFrame;
    const Xn = Object($t.a)(Date.now())
      , Yn = new ge.k(16777215)
      , Wn = 2 * Math.PI
      , qn = Math.PI
      , Hn = Math.PI / 2;
    Math.PI;
    const Qn = 2 * Math.PI
      , Jn = new ge.k(1,1,1);
    const Zn = Math.PI
      , $n = 2 * Math.PI
      , Kn = new ge.k(1,1,1);
    const er = Math.PI
      , tr = (Math.PI,
    new ge.k(1,1,1));
    const ir = 2 * Math.PI
      , nr = new ge.k(1,1,1);
    const rr = 2 * Math.PI
      , sr = new ge.k(1,1,1);
    const ar = new ge.k(16777215);
    const or = new ge.k(16777215)
      , lr = ["glow_a", "glow_b", "glow_c"];
    const cr = 2 * Math.PI
      , hr = new ge.k(1,1,1);
    const ur = 2 * Math.PI
      , pr = new ge.k(1,1,1);
    const dr = new ge.k(16777215);
    const fr = 2 * Math.PI
      , mr = (new ge.k(1,1,1),
    new ge.k(.838,.653,.318));
    var gr = {
        resourceBurst: function({position: e, type: t, emit: i, onComplete: n}) {
            return (r, s) => {
                const a = Nn / s
                  , o = r.index * a + zn.randomFloat(-.01, .01)
                  , l = .05 + zn.randomFloat(0, .04);
                r.delay = r.index ? zn.randomFloat(0, 160) : 0,
                r.position.copy(e),
                r.rotation = zn.randomFloat(-.3, .3),
                r.angVelocity = zn.randomFloat(-.01, .01),
                r.spriteId = "icon_" + t,
                r.velocity.x = l * Math.cos(o),
                r.velocity.y = l * Math.sin(o),
                r.velocityDrag.setScalar(.92),
                r.useVelocityDragMult = !0,
                r.gravity.set(0, zn.randomFloat(.012, .017), 0),
                r.duration = zn.randomFloat(700, 1200),
                r.alphaFrom = 0,
                r.alphaTo = 1,
                r.alphaEase = vn([0, .83, .045, 1]),
                r.scaleFrom.setScalar(1.7 + zn.randomFloat(-.1, .1)),
                r.scaleTo.setScalar(.4 + zn.randomFloat(-.1, .1));
                const c = ee.a.resourcesColors.current[t].normal;
                r.colorFrom.copy(c).offsetHSL(0, zn.randomFloat(-.2, .2), zn.randomFloat(-.2, .2)),
                r.colorTo.copy(c).offsetHSL(0, 0, 0),
                n && (r.onEnd = n),
                r.onComplete = () => {
                    const e = r.position.clone()
                      , t = c.clone();
                    i("topSprites", 4, Rn({
                        position: e,
                        type: "love",
                        sprite: "shape_circle",
                        scale: .3,
                        color: t
                    }))
                }
            }
        },
        bubbleBurst: function({position: e, scale: t, durationMax: i, delayMax: n}) {
            const r = $t.b.randomFloat(0, Dn);
            return (s, a) => {
                const o = Dn / a
                  , l = s.index * o + $t.b.randomFloat(-.2, .2) + r
                  , c = (.06 + $t.b.randomFloat(-.05, .01)) * t;
                s.rotation = $t.b.randomFloat(0, Dn),
                s.angVelocity = .1 + $t.b.randomFloat(0, .01),
                s.spriteId = $t.b.random() > .4 ? "smoke_b" : "smoke_a",
                s.velocity.x = c * Math.cos(l),
                s.velocity.y = c * Math.sin(l),
                s.velocityDrag.setScalar(.9),
                s.useVelocityDragMult = !0,
                s.position.copy(e),
                s.gravity.set(0, .011 * t, 0),
                i || (i = 900),
                s.duration = $t.b.randomFloat(.5 * i, i),
                n || (n = 0),
                s.delay = $t.b.randomFloat(0, n),
                s.scaleFrom.setScalar((.5 + $t.b.randomFloat(-.1, .1)) * t),
                s.scaleTo.setScalar(0),
                s.colorFrom.copy(Un),
                s.colorTo.copy(Un).offsetHSL(0, $t.b.randomFloat(-.2, .2), $t.b.randomFloat(-.3, .3))
            }
        },
        glow: function({position: e, color: t}) {
            return (i, n) => {
                i.spriteId = "glow_a",
                i.duration = 1e3,
                i.scaleEase = vn([0, .86, .2, 1]),
                i.colorEase = vn([0, .86, .2, 1]),
                i.position.copy(e),
                i.scaleFrom.set(2.1, 2.1),
                i.scaleTo.copy(i.scaleFrom).multiplyScalar(1.8),
                i.colorFrom.copy(t || Bn),
                i.colorTo.copy(t || Bn).offsetHSL(0, 0, -1)
            }
        },
        lightGlow: function({position: e, color: t, scale: i}) {
            return (n, r) => {
                n.spriteId = "glow_a",
                n.duration = 1e3,
                n.scaleEase = vn([0, .86, .2, 1]),
                n.colorEase = vn([0, .86, .2, 1]),
                n.position.copy(e),
                i || (i = 1),
                n.scaleFrom.set(10 * i, 10 * i),
                n.scaleTo.copy(n.scaleFrom),
                n.colorFrom.copy(t || jn),
                n.colorTo.set(0)
            }
        },
        burst: Rn,
        rain: function({position: e, emit: t, scale: i, bounds: n, onComplete: r}) {
            const s = Object(b.map)(i, .25, 2.5, .7, 1.5);
            return (i, a) => {
                i.spriteId = "game_drop";
                i.index,
                Vn.randomFloat(-.01, .01),
                Vn.randomFloat(0, .04),
                i.delay = i.index ? Vn.randomFloat(0, 1e3) : 0,
                i.position.copy(e),
                i.position.x = Vn.randomFloat(n.min.x, n.max.x),
                i.position.z += Vn.randomFloat(-1, 1),
                i.gravity.set(0, -.17 * s, 0),
                i.duration = Vn.randomFloat(5e3, 5e3),
                i.alphaFrom = 1,
                i.alphaTo = 1,
                i.alphaEase = vn([0, .83, .045, 1]),
                i.scaleFrom.setScalar((.9 + Vn.randomFloat(-.2, .1)) * s),
                i.scaleTo.setScalar((.9 + Vn.randomFloat(-.2, .1)) * s);
                const o = ee.a.resourcesColors.current.water.normal;
                i.colorFrom.copy(o).offsetHSL(0, Vn.randomFloat(-.2, .2), Vn.randomFloat(-.2, .2)),
                i.colorTo.copy(o).offsetHSL(0, 0, 0),
                i.onProgress = () => {
                    const e = i.position;
                    if (e.x > .5 * n.min.x && e.x < .5 * n.max.x) {
                        const t = e.x + Vn.random(-.05, .05)
                          , r = Math.max(-.2, .9 * n.min.y * Vn.random())
                          , s = t < 0 ? Object(b.map)(t, .5 * n.min.x, 0, -.2, r) : Object(b.map)(t, .5 * n.max.x, 0, -.2, r);
                        if (e.y < s)
                            return void (i.killable = !0)
                    }
                    e.y < -.2 && (i.killable = !0)
                }
                ,
                i.onEnd = r,
                i.onComplete = () => {
                    const e = i.position.clone()
                      , n = o.clone();
                    t("sprites", 2, Rn({
                        position: e,
                        type: "love",
                        sprite: "shape_circle",
                        scale: .6 * s,
                        color: n
                    }))
                }
            }
        },
        sun: function({minX: e, maxX: t, y: i, position: n, emit: r, scale: s, bounds: a, onComplete: o}) {
            const l = Object(b.map)(s, .25, 2.5, .7, 1.5);
            return (n, r) => {
                n.spriteId = "light_ray";
                n.index,
                Gn.randomFloat(-.01, .01),
                Gn.randomFloat(0, .04),
                n.duration = Gn.randomFloat(1e3, 3e3),
                n.delay = n.index ? Gn.randomFloat(0, 150) : 0,
                n.position.x = Gn.randomFloat(e, t),
                n.position.y = i,
                n.position.z = Gn.randomFloat(-1, 1),
                n.rotation = Gn.randomFloat(.3, .3),
                n.alphaFrom = 0,
                n.alphaTo = 1,
                n.velocity.x = Gn.randomFloat(-.002, -.005),
                n.scaleFrom.set((4 + Gn.randomFloat(-2, .1)) * l, (2.9 + Gn.randomFloat(0, 1.5)) * l),
                n.scaleTo.copy(n.scaleFrom);
                const s = ge.k.get();
                s.set(16770631),
                n.colorFrom.copy(s).offsetHSL(0, Gn.randomFloat(-.2, .2), Gn.randomFloat(-.2, .2)),
                n.colorTo.copy(s).offsetHSL(0, 0, 0),
                s.release(),
                n.onEnd = o,
                n.onProgress = () => {
                    const e = n.progress;
                    n.alpha = .15 * (Math.cos(e * Math.PI * 2 + Math.PI) + 1)
                }
            }
        },
        levelSmoke: function({position: e, emit: t, scale: i=1, bounds: n}) {
            const r = Object(b.map)(i, .25, 2.5, .7, 1.5)
              , s = Xn.randomFloat(0, Hn);
            return (t, i) => {
                t.spriteId = "fx_smoke",
                t.spriteFrame = 2,
                t.spriteAutoplay = !0,
                t.spriteFrameDuration = 60,
                t.position.copy(e),
                t.duration = Xn.randomInt(1e3, 1500),
                t.delay = t.index ? Xn.randomFloat(0, 30) : 0,
                t.colorFrom.copy(Yn),
                t.colorTo.copy(t.colorFrom);
                const n = Wn / i
                  , a = t.index * n + Xn.randomFloat(-.05, .05) + s;
                t.rotation = qn / 1.3 - a;
                const o = (.2 + Xn.randomFloat(-.2, .2)) * r;
                t.velocity.x = o * Math.cos(a),
                t.velocity.y = o * Math.sin(a),
                t.velocityDrag.setScalar(.89),
                t.useVelocityDragMult = !0,
                t.scaleFrom.setScalar((3 + Xn.randomFloat(-1, 1)) * r),
                t.scaleTo.setScalar((3 + Xn.randomFloat(-1, 1)) * r)
            }
        },
        collectable: function({type: e, position: t, scale: i, angle: n, from: r, to: s, bezier: a, bezier2: o, durationMax: l, delayMax: c}) {
            return $t.b.randomFloat(0, Qn),
            (h, u) => {
                h.index,
                $t.b.randomFloat(-.2, .2),
                $t.b.randomFloat(-.05, .01),
                h.rotation = n,
                h.spriteId = "resource_" + e,
                h.position.copy(t),
                h.gravity.set(0, 0, 0),
                l || (l = 900),
                c || (c = 0),
                h.delay = $t.b.randomFloat(0, c),
                h.scaleFrom.setScalar((.5 + $t.b.randomFloat(-.1, .1)) * i),
                h.scaleTo.setScalar((.2 + $t.b.randomFloat(-.1, .1)) * i),
                h.colorFrom.copy(Jn),
                h.colorTo.copy(h.colorFrom),
                h.onProgress = () => {
                    h.position.x = Math.pow(1 - h.progress, 3) * r.x + 3 * h.progress * Math.pow(1 - h.progress, 2) * a.x + Math.pow(h.progress, 2) * (1 - h.progress) * a.y * 3 + Math.pow(h.progress, 3) * s.x,
                    h.position.y = Math.pow(1 - h.progress, 3) * r.y + 3 * h.progress * Math.pow(1 - h.progress, 2) * o.x + Math.pow(h.progress, 2) * (1 - h.progress) * o.y * 3 + Math.pow(h.progress, 3) * s.y
                }
                ,
                h.onComplete = () => {
                    ve.a.play("get_" + e),
                    ee.a.resourceButtonReceive[e].dispatch()
                }
            }
        },
        smokeTrail: function({position: e}) {
            return t => {
                Math.random() > .4 ? function(e, t) {
                    const i = $t.b.randomFloat(Zn / 2 - .6, Zn / 2 + .6)
                      , n = 0 + $t.b.randomFloat(0, .01);
                    e.rotation = $t.b.randomFloat(0, $n),
                    e.angVelocity = .1 + $t.b.randomFloat(0, .01),
                    e.spriteId = "smoke_b",
                    e.position.copy(t),
                    e.position.x += $t.b.randomFloat(-.2, .2),
                    e.position.y += $t.b.randomFloat(-.2, .2),
                    e.velocity.x = n * Math.cos(i),
                    e.velocity.y = n * Math.sin(i),
                    e.duration = $t.b.randomFloat(400, 600),
                    e.scaleFrom.setScalar(.4 + $t.b.randomFloat(-.1, .4)),
                    e.scaleTo.setScalar(e.scaleFrom.x + $t.b.randomFloat(.1, .4)),
                    e.alphaFrom = $t.b.randomFloat(.3, .7),
                    e.alphaTo = 0,
                    e.colorFrom.copy(Kn),
                    e.colorTo.copy(Kn).offsetHSL(0, $t.b.randomFloat(-.2, .2), $t.b.randomFloat(-.3, .3))
                }(t, e) : function(e, t) {
                    const i = $t.b.randomFloat(Zn / 2 - .8, Zn / 2 + .8)
                      , n = .05 + $t.b.randomFloat(0, .01);
                    e.rotation = $t.b.randomFloat(0, $n),
                    e.angVelocity = .1 + $t.b.randomFloat(0, .01),
                    e.spriteId = "seed_a",
                    e.position.copy(t),
                    e.position.x += $t.b.randomFloat(-.3, .3),
                    e.position.y += $t.b.randomFloat(-.2, .2),
                    e.velocity.x = n * Math.cos(i),
                    e.velocity.y = n * Math.sin(i),
                    e.alphaFrom = 1,
                    e.alphaTo = 0,
                    e.gravity.set(0, -.12, 0),
                    e.duration = $t.b.randomFloat(1200, 1800),
                    e.scaleFrom.setScalar(.4 + $t.b.randomFloat(0, .3)),
                    e.scaleTo.setScalar(e.scaleFrom.x),
                    e.colorFrom.copy(Kn),
                    e.colorTo.copy(Kn)
                }(t, e)
            }
        },
        speedLines: function({position: e}) {
            return t => {
                t.rotation = er / 2,
                t.spriteId = "shape_line_b",
                t.position.copy(e),
                t.position.x += $t.b.randomFloat(-.2, .2),
                t.position.y += $t.b.randomFloat(-.2, .2),
                t.gravity.set(0, -.011, 0),
                t.duration = $t.b.randomFloat(400, 750),
                t.scaleFrom.set(0, .06),
                t.scaleTo.set(30, .06),
                t.alphaEase = vn([.405, .015, .405, 1]),
                t.alphaFrom = 1,
                t.alphaTo = 0,
                t.alphaEase = vn([.715, .01, .915, .31]),
                t.colorFrom.copy(tr),
                t.colorTo.copy(tr).offsetHSL(0, $t.b.randomFloat(-.2, .2), $t.b.randomFloat(-.3, .3))
            }
        },
        seedAppearSmoke: function({position: e, scale: t, durationMax: i, delayMax: n}) {
            const r = $t.b.randomFloat(0, ir);
            return n = n || 60,
            i = i || 1100,
            t = t || 2,
            (s, a) => {
                const o = s
                  , l = ir / a
                  , c = s.index * l + $t.b.randomFloat(-.2, .2) + r
                  , h = (.055 + $t.b.randomFloat(-.01, .025)) * t;
                o.rotation = $t.b.randomFloat(0, ir),
                o.angVelocity = .07 + $t.b.randomFloat(0, .01),
                o.spriteId = $t.b.random() > .4 ? "smoke_b" : "smoke_a",
                o.velocity.x = h * Math.cos(c),
                o.velocity.y = h * Math.sin(c),
                o.velocityDrag.setScalar(.92),
                o.useVelocityDragMult = !0,
                o.position.copy(e),
                o.position.x += .1 * $t.b.randomFloat(-1, 1) * t,
                o.position.y += .1 * $t.b.randomFloat(-1, 1) * t,
                o.gravity.set(0, .011 * t, 0),
                o.duration = $t.b.randomFloat(.5 * i, i),
                o.delay = $t.b.randomFloat(0, n),
                o.scaleFrom.setScalar((.5 + $t.b.randomFloat(-.1, .2)) * t),
                o.scaleTo.setScalar(0),
                o.colorFrom.copy(nr),
                o.colorTo.copy(nr).offsetHSL(0, $t.b.randomFloat(-.2, .2), $t.b.randomFloat(-.3, .3))
            }
        },
        seedAppearLeaf: function({position: e, scale: t, durationMax: i, delayMax: n}) {
            const r = $t.b.randomFloat(0, rr);
            return n = n || 60,
            i = i || 1600,
            t = t || 2,
            (s, a) => {
                const o = s
                  , l = rr / a
                  , c = s.index * l + $t.b.randomFloat(-.2, .2) + r
                  , h = (.07 + $t.b.randomFloat(-.01, .04)) * t;
                o.rotation = $t.b.randomFloat(0, rr),
                o.angVelocity = .01 + $t.b.randomFloat(0, .01),
                o.spriteId = "seed_a",
                o.velocity.x = h * Math.cos(c),
                o.velocity.y = h * Math.sin(c),
                o.velocityDrag.setScalar(.85),
                o.useVelocityDragMult = !0,
                o.position.copy(e);
                const u = $t.b.random();
                o.position.x += o.velocity.x * t * 2 * u,
                o.position.y += o.velocity.y * t * 2 * u,
                o.gravity.set(0, .004 * t, 0),
                o.duration = $t.b.randomFloat(.5 * i, i),
                o.delay = $t.b.randomFloat(0, n),
                o.alphaFrom = 1,
                o.alphaTo = 0,
                o.alphaEase = vn([.955, .005, .625, 1]),
                o.scaleFrom.setScalar((.5 + $t.b.randomFloat(0, .2)) * t),
                o.scaleTo.copy(o.scaleFrom).multiplyScalar(.7),
                o.colorFrom.copy(sr),
                o.colorTo.copy(sr).offsetHSL(0, $t.b.randomFloat(-.2, .2), $t.b.randomFloat(-.3, .3))
            }
        },
        guidePulse: function({position: e, scale: t, isSceneFlag: i}) {
            return n => {
                n.spriteId = "glow_c",
                n.duration = 300,
                n.scaleEase = vn([0, .5, .46, .995]),
                n.position.copy(e),
                n.scaleFrom.set(t, t),
                n.scaleTo.copy(n.scaleFrom).multiplyScalar(1.8),
                n.alphaFrom = 1,
                n.alphaTo = 0,
                n.colorFrom.copy(ar),
                n.colorTo.copy(ar),
                i && (n.onProgress = function(e, t) {
                    const i = 1 - t;
                    e.alpha = i * (1 - 7 * Math.abs(ee.a.blobOffset.current))
                }
                )
            }
        },
        evolveGlow: function({position: e, color: t, scale: i, type: n}) {
            return (r, s) => {
                r.spriteId = lr[n],
                r.duration = n > 1 ? 2800 : 1800,
                r.scaleEase = vn([0, .86, .2, 1]),
                r.colorEase = vn([0, .86, .2, 1]),
                r.position.copy(e),
                r.position.y += .3 * i,
                r.angVelocity = .05,
                i || (i = 1),
                r.scaleFrom.set(i, i).multiplyScalar(n > 1 ? 2.2 : 1.6),
                r.scaleTo.copy(r.scaleFrom).multiplyScalar(n > 1 ? 5.5 : 3),
                r.colorFrom.copy(t || or),
                r.colorTo.set(0)
            }
        },
        evolveSmoke: function({position: e, scale: t, durationMax: i, delayMax: n}) {
            const r = $t.b.randomFloat(0, cr);
            return n = n || 30,
            i = i || 1600,
            t = t || 2,
            (s, a) => {
                const o = s
                  , l = cr / a
                  , c = s.index * l + $t.b.randomFloat(-.2, .2) + r
                  , h = (.11 + $t.b.randomFloat(-.01, .025)) * t * .7;
                o.rotation = $t.b.randomFloat(0, cr),
                o.angVelocity = .07 + $t.b.randomFloat(0, .01),
                $t.b.random() > .5 && (o.angVelocity *= -1),
                o.spriteId = $t.b.random() > .4 ? "smoke_b" : "smoke_a",
                o.velocity.x = h * Math.cos(c),
                o.velocity.y = h * Math.sin(c),
                o.velocityDrag.setScalar(.88),
                o.useVelocityDragMult = !0,
                o.position.copy(e),
                o.position.x += .1 * $t.b.randomFloat(-1, 1) * t,
                o.position.y += .2 * $t.b.randomFloat(-1, 1) * t,
                o.gravity.set(0, .006 * t, 0),
                o.duration = $t.b.randomFloat(.5 * i, i),
                o.delay = $t.b.randomFloat(0, n),
                o.scaleFrom.setScalar((.5 + $t.b.randomFloat(-.2, .1)) * t),
                o.scaleTo.setScalar(0),
                o.colorFrom.copy(hr).offsetHSL(0, $t.b.randomFloat(-.1, 0), $t.b.randomFloat(0, 0)),
                o.colorTo.copy(hr).offsetHSL(0, $t.b.randomFloat(-.1, 0), $t.b.randomFloat(-.2, 0))
            }
        },
        evolveLeaf: function({position: e, scale: t, durationMax: i, delayMax: n}) {
            const r = $t.b.randomFloat(0, 0) - .05 * ur;
            return n = n || 120,
            i = i || 2e3,
            t = t || 2,
            (s, a) => {
                const o = s
                  , l = ur / 1.5 / a
                  , c = s.index * l + $t.b.randomFloat(-.2, .2) + r
                  , h = (.09 + $t.b.randomFloat(-.05, .05)) * t * .7;
                o.rotation = $t.b.randomFloat(0, ur),
                o.angVelocity = .02 + $t.b.randomFloat(0, .01),
                $t.b.random() > .5 && (o.angVelocity *= -1),
                o.spriteId = "seed_a",
                o.velocity.x = h * Math.cos(c),
                o.velocity.y = h * Math.sin(c),
                o.velocityDrag.setScalar(.9),
                o.useVelocityDragMult = !0,
                o.position.copy(e),
                o.gravity.set(0, -.001 * t, 0),
                o.duration = $t.b.randomFloat(.5 * i, i),
                o.delay = $t.b.randomFloat(0, n),
                o.alphaFrom = 1,
                o.alphaTo = 0,
                o.alphaEase = vn([.955, .005, .625, 1]),
                o.scaleFrom.setScalar((.5 + $t.b.randomFloat(-.2, .1)) * t),
                o.scaleTo.copy(o.scaleFrom).multiplyScalar(.7),
                o.colorFrom.copy(pr).offsetHSL(0, $t.b.randomFloat(-.2, 0), $t.b.randomFloat(-.2, 0)),
                o.colorTo.copy(pr).offsetHSL(0, $t.b.randomFloat(-.3, 0), $t.b.randomFloat(-.45, 0))
            }
        },
        progressGlow: function({position: e, scale: t}) {
            return i => {
                i.spriteId = "glow_c",
                i.duration = 2800,
                i.scaleEase = vn([0, .86, .2, 1]),
                i.alphaEase = vn([0, .86, .2, 1]),
                i.position.copy(e),
                i.position.y += .3 * t,
                i.angVelocity = .05,
                t || (t = 1),
                i.scaleFrom.set(t, t).multiplyScalar(2.26),
                i.scaleTo.copy(i.scaleFrom).multiplyScalar(5.5),
                i.colorFrom.copy(dr),
                i.colorTo.set(0),
                i.alphaFrom = 1,
                i.alphaTo = 0
            }
        },
        progressSmoke: function({position: e, scale: t, type: i}) {
            const n = $t.b.randomFloat(0, fr)
              , r = [1e3, 1600][i];
            return t = t || 2,
            (s, a) => {
                const o = s
                  , l = fr / a
                  , c = s.index * l + $t.b.randomFloat(-.2, .2) + n
                  , h = [(.05 + $t.b.randomFloat(-.01, .08)) * t * 1.1, (.05 + $t.b.randomFloat(-.01, .08)) * t * .7][i];
                o.rotation = Math.PI - c,
                o.spriteId = ["smoke_a", "smoke_a"][i],
                o.velocity.x = h * Math.cos(c),
                o.velocity.y = h * Math.sin(c),
                o.velocityDrag.setScalar(.88),
                o.useVelocityDragMult = !0,
                o.position.copy(e),
                o.gravity.set(0, [.006 * t, .006 * t][i], 0),
                o.duration = $t.b.randomFloat(.5 * r, r),
                o.delay = $t.b.randomFloat(0, 30),
                o.scaleFrom.setScalar((.5 + $t.b.randomFloat(-.2, .1)) * t),
                o.scaleTo.setScalar(0);
                const u = [mr, mr][i];
                o.colorFrom.copy(u).offsetHSL(0, $t.b.randomFloat(-.1, 0), $t.b.randomFloat(0, 0)),
                o.colorTo.copy(u).offsetHSL(0, $t.b.randomFloat(-.1, 0), $t.b.randomFloat(-.2, 0))
            }
        }
    }
      , vr = i(197);
    const yr = wt()(.75, .005, .18, 1)
      , br = wt()(.085, .335, .505, .885)
      , xr = Object(vr.a)(["lavande", "immortelle", "amandier"]);
    class wr extends Tt {
        playAudio(e) {
            let t = e.audioPath.split(".");
            t.pop(),
            !1 | (t = t.join(".")).charAt(t.length - 1) && (t = t.slice(0, -1)),
            ve.a.play(t)
        }
        onAnimationComplete() {}
        onCustomEvent(e, t) {
            const i = t.data && t.data.name;
            t.data.audioPath ? this.playAudio(t.data) : this[i] && this[i](e, t)
        }
        onMouseIn() {}
        onMouseOut() {}
        onClick() {}
        canTouch() {
            if (we())
                return !this.props.scene.isGameOver()
        }
        init(e) {
            this.tweens = {},
            this.flash = 0,
            this.touchable = e.touchable,
            this.useCircleBounds = !!e.useCircleBounds,
            this.raftouchable = n.a.device.current.type.desktop;
            const t = e.scale || 1;
            this.base = new ge.F,
            this.spine = Gi.a.createMesh(e.spineId),
            this.spine.scale.set(-t, t, t),
            this.base.add(this.spine),
            this.skeleton = this.spine.skeleton,
            this.skeletonData = this.skeleton.data,
            this.state = this.spine.state,
            this.initState(),
            this.onAnimationComplete = this.onAnimationComplete.bind(this),
            this.onCustomEvent = this.onCustomEvent.bind(this),
            this.stateListeners = {
                complete: this.onAnimationComplete,
                event: this.onCustomEvent
            },
            this.state.addListener(this.stateListeners),
            this.spine.update(0),
            this.spine.batches.forEach(t => {
                void 0 !== e.frustumCulled && (t.frustumCulled = e.frustumCulled),
                this.spine.add(t)
            }
            ),
            this.initTweens(),
            this.initBones(),
            this.anchors = {};
            for (const e in this.bones)
                this.anchors[e] = {
                    bone: this.skeleton.findBone(this.bones[e]),
                    position: new ge.U
                };
            this.updateAnchors(),
            this.touchable && n.a.touch.subscribe(this.onTouch, this)
        }
        initTweens() {
            this.flash = 0,
            this.tweens.flash = $.a.fromTo(this, .4, {
                flash: 1
            }, {
                flash: 0,
                ease: Xe.d.easeInOut,
                onUpdate: () => !this.destroyed && this.setFlash(this.flash)
            }).progress(1, !1)
        }
        makeFlash() {
            this.tweens.flash && this.tweens.flash.restart()
        }
        setFlash(e) {
            for (let t = 0, i = this.spine.batches.length; t < i; t++)
                this.spine.batches[t].flash = e
        }
        update(e) {
            this.spine.update(.001 * e),
            this.raftouchable && this.onTouch(n.a.touch.current)
        }
        initState() {
            this.state.data.defaultMix = .5
        }
        initBones() {
            this.bones = this.touchable ? {
                boundMin: "clickable-1",
                boundMax: "clickable-2"
            } : {}
        }
        updateAnchors() {
            for (const e in this.anchors) {
                const t = this.anchors[e];
                t.position.x = -t.bone.worldX,
                t.position.y = t.bone.worldY,
                t.position.applyMatrix4(this.spine.matrixWorld)
            }
        }
        playAnimation(e, t, i) {
            const n = this.state.setAnimation(0, e, !!t);
            return void 0 !== i && (n.mixDuration = i),
            n
        }
        isHoverBox(e) {
            const t = this.props.scene;
            if (!t)
                return !1;
            const i = t.currentCamera.base
              , n = ge.T.get()
              , r = ge.T.get();
            Yi(this.anchors.boundMin.position, i, n),
            Yi(this.anchors.boundMax.position, i, r);
            const s = ge.f.get();
            s.setFromPoints([n, r]);
            const a = s.containsPoint(e);
            return ge.T.release(n, r),
            ge.f.release(s),
            a
        }
        isHoverCircle(e) {
            const t = this.props.scene;
            if (!t)
                return !1;
            const i = t.currentCamera.base
              , n = ge.T.get()
              , r = ge.T.get();
            Yi(this.anchors.boundMin.position, i, n),
            Yi(this.anchors.boundMax.position, i, r);
            const s = r.distanceTo(n)
              , a = e.distanceTo(n);
            return ge.T.release(n, r),
            a <= s * this.props.hitRadiusMultiplier
        }
        onTouch(e) {
            const t = ge.T.get().fromArray(e.pos)
              , i = this.useCircleBounds ? this.isHoverCircle(t) : this.isHoverBox(t);
            t.release(),
            i && e.clickIn ? this.canTouch() && this.onClick() : i && !this.seedIn ? (this.seedIn = !0,
            this.canTouch() && this.onMouseIn()) : !i && this.seedIn && (this.seedIn = !1,
            this.canTouch() && this.onMouseOut())
        }
        beforeDestroy() {
            for (const e in this.tweens)
                this.tweens[e].kill();
            this.tweens = null,
            n.a.touch.unsubscribe(this.onTouch, this),
            this.spine.parent && this.spine.parent.remove(this.spine),
            this.spine.parent = null,
            this.spine.clearBatches(),
            this.spine.batches.forEach(e => {
                e.parent && e.parent.remove(e),
                e.material.release(),
                e.geometry.dispose()
            }
            ),
            this.spine = null,
            this.store = null,
            this.skeleton = null,
            this.skeletonData = null,
            this.state = null
        }
    }
    class _r extends In {
        init() {
            this.items = [];
            const e = (e, t) => this.items.push([Qi, {
                scene: this,
                id: e,
                level: t,
                touchable: !1
            }]);
            this.items.push([wr, {
                spineId: "bag",
                touchable: !1,
                frustumCulled: !1
            }]),
            this.currentItem = null;
            for (const t in te.a.seeds.current)
                for (let i = 1; i < 5; i++)
                    e(t, i)
        }
        update() {
            this.currentItem && this.removeComponent(this.currentItem);
            const e = this.items.shift();
            e ? this.addComponent(e[0], e[1]) : this.prerendered = !0
        }
    }
    class Tr extends qi {
        constructor(e) {
            super(e)
        }
        initState() {
            this.props.store.unlocked.subscribe(this.onUnlockChange, this),
            this.onUnlockChange(),
            this.state.setAnimation(0, this.props.store.unlocked.current ? "idle-on" : "idle-off", !0),
            this.state.data.defaultMix = .5
        }
        onUnlockChange() {
            const e = this.props.store.unlocked.current
              , t = this.props.store.id.current + (e ? "--on" : "--off");
            this.skeleton.setSkinByName(t),
            this.makeFlash(),
            this.isCurrentlyIdle() && this.state.setAnimation(0, this.props.store.unlocked.current ? "idle-on" : "idle-off", !0)
        }
        bagDidOpen(e, t) {
            this.props.onOpen(t)
        }
        onAnimationComplete(e) {
            "opening" === e.animation.name && this.opening ? this.props.onComplete() : this.opening || this.isCurrentlyIdle() || this.state.setAnimation(0, this.props.store.unlocked.current ? "idle-on" : "idle-off", !0)
        }
        animOpen() {
            this.props.store.level.current >= 4 || (this.opening = !0,
            this.state.setAnimation(0, "opening"))
        }
        isCurrentlyIdle() {
            const e = this.state.tracks[0] && this.state.tracks[0].animation.name;
            return !e || ("idle-on" === e || "idle-off" === e)
        }
        beforeDestroy() {
            this.props.store.unlocked.unsubscribe(this.onUnlockChange, this),
            super.beforeDestroy()
        }
    }
    class Mr extends Tt {
        init({seedStore: e, seedScene: t, seedId: i, forceMesh: n, onOpen: r, onComplete: s}) {
            this.id = i,
            this.store = e,
            this.level = this.store.level.current,
            this.bagScale = 4.4,
            this.scale = ee.a.spineScale.current * this.bagScale,
            this.uiScene = pa.get("uiTop"),
            this.spineSystem = this.addComponent(Tr, {
                forceMesh: n,
                scene: t,
                store: this.store,
                spineId: "bag",
                scale: this.scale,
                onMouseIn: () => this.onMouseIn(),
                onMouseOut: () => this.onMouseOut(),
                onClick: e => this.canInteract() && this.onBagClick(e),
                onOpen: r,
                onComplete: s
            }),
            this.base = this.spineSystem.mesh,
            this.base.position.fromArray(this.store.getPreset().seedPosition),
            this.base.position.z += .2,
            this.base.position.y -= .17,
            this.state = this.spineSystem.state,
            this.skeleton = this.spineSystem.skeleton,
            this.opening = !1
        }
        onMouseIn() {
            if (!this.canInteract())
                return;
            U.setCursor("pointer"),
            this.state.setAnimation(1, "hover").timeScale = 1.8
        }
        onMouseOut() {
            this.canInteract() || U.removeCursor()
        }
        canInteract() {
            if (this.destroyed)
                return !1;
            if (!we())
                return;
            const e = this.store.visibleLevel.current
              , t = this.store.unlocked.current;
            return !(e > 1 || this.opening || !t)
        }
        open() {
            if (!this.opening)
                return new Promise(e => {
                    this.opening = !0,
                    this.spineSystem.animOpen()
                }
                )
        }
        update(e) {
            this.spineSystem.update(.001 * e),
            this.destroyed || ee.a.guideAnchors.update(e => {
                const t = this.store.scene.current.currentCamera.base
                  , i = this.spineSystem.bb
                  , n = ge.U.get().set(.75 * (i.max.x + this.base.position.x), .5 * i.min.y + this.base.position.y, this.base.position.z)
                  , r = ge.T.get();
                return Yi(n, t, r),
                e.bag.position.x = r.x,
                e.bag.position.y = -r.y,
                r.release(),
                n.release(),
                e
            }
            , !0)
        }
        onBagClick(e) {
            if (!this.canInteract())
                return;
            const t = this.store.scene.current;
            this.spineSystem.makeFlash(),
            t.emitter.emit("topSprites", 6, gr.bubbleBurst({
                position: e,
                scale: 1.4
            })),
            this.store.level.current < 1 && j.a.plant(this.store.id.current)
        }
        beforeDestroy() {
            U.removeCursor(),
            this.skeleton = null,
            this.state = null,
            this.anchors = null,
            this.store = null,
            this.uiScene = null,
            this.spineSystem = null
        }
    }
    var Sr = {
        checkSeed: function(e) {
            if (!this.seed)
                return e();
            if (this.seed.rainScore + this.seed.sunScore + this.seed.loveScore <= 0)
                return e();
            this.checkSeedTimer = Object(Mn.a)(100, () => this.checkSeed(e))
        },
        waitSeedFinish: function() {
            return new Promise(e => {
                this.checkSeed(e)
            }
            )
        },
        startEvolve: function(e, t) {
            this.evolving = !0,
            this.store.emit;
            const i = this.seed
              , n = i && i.spineSystem
              , r = this.gardenCamera
              , s = this.store.getPreset().seedScale;
            n && n.tweens.flash && n.tweens.flash.pause(),
            this.tweens.evolve && this.tweens.evolve.kill();
            const a = this.tweens.evolve = new J.a;
            this.store.seedPresets.current["lvl" + t],
            this.muteResources(),
            this.waitSeedFinish().then( () => {
                const e = n.isCurrentlyIdle();
                a.addLabel("begin").add( () => e && n.animCompleteQuery(!0)).to(r, 1, {
                    zoom: Object(b.map)(s, .25, 2.5, -.4, -1.4),
                    ease: Xe.c.easeInOut
                }, e ? "begin+=0.2" : "begin+=0").addLabel("cam").to(n, .6, {
                    flash: 1,
                    ease: Xe.c.easeIn,
                    onUpdate: () => !this.destroyed && n.setFlash(n.flash)
                }, e ? "cam-=0.4" : "cam-=0.3").call( () => this.store.visibleLevel.set(t))
            }
            )
        },
        finishEvolve: function() {
            this.evolving = !1,
            this.store.emit;
            const e = this.seed
              , t = e && e.spineSystem
              , i = this.gardenCamera;
            t && t.tweens.flash && t.tweens.flash.pause(),
            this.tweens.evolve && this.tweens.evolve.kill(),
            this.particlesEvolve(),
            (this.tweens.evolve = new J.a({
                useFrames: !0
            })).to(i, 1, {
                zoom: 0,
                ease: Xe.c.easeOut
            })
        },
        cancelEvolve: function() {
            ee.a.muteGuide.set(!1),
            this.unmuteResources(),
            this.checkSeedTimer && this.checkSeedTimer.destroy(),
            this.checkSeedTimer = null,
            this.evolving = !1,
            this.tweens.evolve && this.tweens.evolve.kill(),
            this.tweens.flash && this.tweens.flash.kill()
        },
        particlesEvolve: function() {
            if (this.destroyed)
                return;
            ve.a.play("level_up"),
            this.unmuteResources(),
            this.store.emit;
            const e = this.seed
              , t = e && e.spineSystem
              , i = (this.gardenCamera,
            t.bb)
              , n = e.level;
            let r = 1;
            r = n < 3 ? Object(b.map)(Math.max(i.size.y, i.size.x), 2, 19, .86, 2.55) : Object(b.map)(Math.max(i.size.y, i.size.x), 2, 19, 1, 3.25);
            let s = 1;
            s = n < 3 ? Object(b.map)(Math.max(i.size.y, i.size.x), 2, 19, .86, 2.55) : Object(b.map)(Math.max(i.size.y, i.size.x), 2, 19, .9, 3);
            let a = 1;
            a = n < 3 ? Object(b.map)(Math.max(i.size.y, i.size.x), 2, 19, .86, 2.5) : Object(b.map)(Math.max(i.size.y, i.size.x), 2, 19, .9, 2.7);
            const o = ge.U.get()
              , l = this.store.getPreset(n);
            o.copy(i.min).add(i.max).divideScalar(2),
            o.y *= .75,
            o.x += l.seedPosition[0],
            o.y += l.seedPosition[1],
            o.z += l.seedPosition[2],
            ve.a.play("gift_click");
            const c = [9, 9, 9, 11, 15][n]
              , h = [8, 8, 8, 9, 12][n];
            this.store.emit("topSprites", c, gr.evolveSmoke({
                scale: 2.9 * s,
                position: o
            })),
            this.store.emit("topSprites", h, gr.evolveLeaf({
                scale: 3 * a,
                position: o
            })),
            this.store.emit("addSprites", 1, gr.evolveGlow({
                scale: r,
                position: o,
                type: 0
            })),
            this.store.emit("addSprites", 1, gr.evolveGlow({
                scale: r,
                position: o,
                type: 2
            })),
            !t.destroyed && t.tweens.flash && t.tweens.flash.pause(),
            bt.flash(),
            t.animIn(),
            t.setFlash(1);
            const u = {
                flash: 1
            };
            this.tweens.flash = new J.a({
                paused: !0
            }).to(u, 1, {
                flash: 0,
                ease: Xe.d.easeOut,
                onUpdate: () => !this.destroyed && t.setFlash(u.flash)
            }).add( () => this.unmuteResources()).play(),
            o.release()
        }
    };
    let Ar = 0;
    const Pr = 1e-4;
    var Cr = i(158)
      , Lr = "precision highp float;\n#define GLSLIFY 1\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec3 cameraPosition;\nuniform float bubbleScale;\n\nattribute vec2 uv;\nattribute vec3 position;\nattribute vec4 data; // xy: position | z: scale | w: orientation\nattribute float z;\n\nvarying vec2 vUv;\nvarying float vSize;\n\n#include <rotate>\n\nvoid main() {\n\n\tvec3 pos = vec3(data.x, data.y, z);\n\tvSize = data.z;\n\n\tfloat scale = max(0.5 + vSize * 0.5, vSize);\n\n\tvec3 transformed = position * scale * bubbleScale;\n\ttransformed.xy = rotate(transformed.xy, data.w);\n\ttransformed += pos;\n\n\tvUv = (uv - 0.5) * scale + 0.5;\n\n\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(transformed, 1.);\n\n}\n"
      , kr = "precision highp float;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvarying float vSize;\n\n#include <smin>\n\nvoid main() {\n\n\tvec2 uv = vUv;\n\tfloat mr = 0.5;\n\tfloat r = vSize * mr;\n\tfloat d = r / mr;\n\n\tvec2 center = vec2(0.5, 0.5);\n\tvec2 corner = vec2(0., 0.);\n\t// vec2 offset = vec2(cos(uWiggle * 20. + uv.x * 40.), sin(uWiggle * 20. - uv.y * 20.)) * 0.006;\n\n\tvec2 p2 = mix(corner, center, mix(0.65, 0.08, d));\n\tvec2 p3 = mix(corner, center, mix(0.80, 0.20, d));\n\tvec2 p4 = mix(corner, center, mix(0.95, 0.45, d));\n\n\tfloat f = length(center - vUv) - r;\n\tf = smin(f, length(p4 - uv) - mix(0.0001, 0.002, d), mix(0.30, 0.21, d));\n\tf = smin(f, length(p3 - uv) - mix(0.0002, 0.0008, d), mix(0.22, 0.2, d));\n\tf = smin(f, length(p2 - uv) - mix(0.0001, 0.0004, d), mix(0.2, 0.16, d));\n\n\tfloat color = 1.0 - smoothstep(0.0, 0.01, f);\n\n\tif (color < 1.) discard;\n\tgl_FragColor = vec4(1.);\n\n}\n\n";
    class Er extends ge.M {
        constructor(e={}) {
            super({
                vertexShader: Lr,
                fragmentShader: kr,
                uniforms: {
                    wiggle: {
                        value: 0
                    },
                    bubbleScale: {
                        type: "f",
                        value: 0
                    }
                },
                transparent: !0,
                depthTest: !1,
                depthWrite: !0
            }),
            this.useObjectUniforms = !0,
            this.isBubbleMaterial = !0
        }
    }
    class Ir extends Tt {
        init(e) {
            this.store = e.store,
            this.batcher = this.store.scene.current.batchers.bubbleSprites,
            this.zOffset = e.zOffset || 0,
            this.bubbleScale = e.bubbleScale,
            this.spriteBaseScale = new ge.T(1.1 * e.bubbleScale,1.1 * e.bubbleScale),
            this.spriteOffset = e.baseZOffset + .01,
            this.spriteOpts = {
                batcher: this.batcher,
                scale: this.spriteBaseScale.clone(),
                color: ee.a.resourcesColors.current.love.normal
            },
            this.base = new ge.F,
            this.base.position.z = this.zOffset,
            this.timeOffset = 30 * Math.random(),
            this.offset = new ge.U(0,0,.15),
            this.pos = Ci({
                current: new ge.U,
                ease: .001
            }),
            this.rotation = Ci({
                current: 0,
                ease: .006,
                angle: !0
            }),
            this.sizeSpring = new ye.a({
                initial: 0,
                tension: .02,
                friction: .1
            }),
            this.rotSpring = new ye.a({
                tension: .03,
                friction: .1
            }),
            this.size = 1e-4,
            this.needsInstant = !0,
            this.used = !1,
            this.dying = !1,
            this.dead = !1
        }
        onAlloc(e) {
            this.sprite && this.sprite.destroy(),
            this.sprite = null;
            const t = "icon_" + e;
            this.sprite = new Dt(Object.assign({}, this.spriteOpts, {
                sprite: t,
                color: ee.a.resourcesColors.current[e].normal
            })),
            this.timeOffset = 30 * Math.random(),
            this.needsInstant = !0,
            this.used = !0,
            this.dying = !1,
            this.dead = !1,
            this.type = e;
            const i = -Math.sign(this.props.bubbleAnchor.x) || 1;
            if (this.rotSpring.setTarget(0),
            this.store.bubbleInitialized.current) {
                const t = "message" === e ? "love" : e;
                ve.a.play("bubble_need_" + t),
                this.rotSpring.setValue(Math.PI * i * .8),
                this.sizeSpring.setValue(.001)
            } else
                this.rotSpring.setValue(Math.PI * i * .075);
            this.update(0)
        }
        onFree() {
            this.dying && this.store.scene.current && this.store.scene.current.emitter && (ve.a.play("bubble_pop"),
            this.store.scene.current.emitter.emit("topSprites", 10, gr.bubbleBurst({
                position: this.base.position,
                scale: this.bubbleScale
            }))),
            this.sprite && this.sprite.destroy(),
            this.sprite = null,
            this.needsInstant = !0,
            this.used = !1,
            this.type = null,
            this.dying = !1
        }
        onQuery(e) {
            if (!e)
                return this.kill();
            let t = 1 * (1 - e.received / e.asked);
            if (t <= 0)
                return this.kill();
            t = Object(b.map)(t, 0, 1, .25, 1),
            this.sizeSpring.setTarget(t),
            this.store.bubbleInitialized.current || this.sizeSpring.setValue(.8 * this.sizeSpring.target)
        }
        kill() {
            this.sizeSpring.setTarget(0),
            this.dying = !0
        }
        update(e) {
            if (!this.used)
                return;
            const t = ee.a.sceneTime.current;
            this.rotSpring.update(e),
            this.sizeSpring.update(e),
            this.offset.y = .075 * Math.cos(t + this.timeOffset);
            const i = this.props.bubbleAnchor;
            this.pos.target.copy(i).add(this.offset),
            this.needsInstant && this.pos.current.copy(this.pos.target),
            this.size = this.sizeSpring.value * this.ratioMult,
            this.pos.update(e),
            this.base.position.copy(this.pos.current);
            const n = this.base.position
              , r = this.props.mouthAnchor;
            this.rotation.target = Object(b.ang)(r.x, r.y, n.x, n.y),
            this.needsInstant && (this.rotation.current = this.rotation.target,
            this.needsInstant = !1),
            this.rotation.update(e);
            const s = this.rotation.current + this.rotSpring.value;
            this.base.rotation.z = .76 - s;
            const a = (.34 * this.size + .3) * this.bubbleScale;
            this.base.position.x += a * Math.cos(s),
            this.base.position.y += a * Math.sin(s),
            this.sprite.rotation = .2 * Math.cos(4 * t + this.timeOffset);
            const o = 1 + .03 * Math.cos(12 * t);
            this.sprite.scale.copy(this.spriteBaseScale).multiplyScalar(this.size * o * this.spriteMult),
            this.sprite.position.copy(this.base.position),
            this.sprite.position.z = this.spriteOffset,
            this.dying && this.size < .03 && (this.dead = !0)
        }
        beforeDestroy() {
            this.onFree(),
            this.store = null
        }
    }
    const Fr = 4;
    let Or;
    const Rr = []
      , zr = () => {
        let e = Rr.shift();
        if (e)
            return e;
        const t = new Float32Array(4 * Fr)
          , i = new Float32Array(1 * Fr);
        e = new ge.p;
        const n = ge.I.simple;
        return e.index = n.index,
        e.attributes.position = n.attributes.position,
        e.attributes.uv = n.attributes.uv,
        e.addAttribute("data", new ge.o(t,4,!1).setDynamic(!0)),
        e.addAttribute("z", new ge.o(i,1,!1)),
        e
    }
    ;
    class Nr extends Tt {
        constructor(e={}) {
            super(e),
            Or || (Or = new Er),
            this.store = e.store,
            this.geo = zr(),
            this.geo.attributes.z.needsUpdate = !0,
            this.base = new ge.x(this.geo,Or),
            this.base.frustumCulled = !1,
            this.base.position.z = .1,
            this.base.renderOrder = 10,
            this.base.bubbleScale = 1;
            const t = e.store.getPreset().cameraPositionLandscape[2];
            if (t) {
                const e = Object(b.map)(t, 4, 30, .7, 3.6);
                this.base.bubbleScale = e
            }
            this.allBubbles = [],
            this.freeBubbles = [],
            this.usedBubbles = [],
            this.hashmapBubbles = {};
            for (let e = 0; this.props.seedAnchors["bubble" + e]; e++) {
                const t = this.addComponent(new Ir({
                    store: this.props.store,
                    batchers: this.props.batchers,
                    bubbleScale: this.base.bubbleScale,
                    bubbleAnchor: this.props.seedAnchors["bubble" + e],
                    mouthAnchor: this.props.seedAnchors.mouth,
                    zOffset: .001 * e,
                    baseZOffset: this.base.position.z
                }));
                this.allBubbles.push(t),
                this.freeBubbles.push(t),
                this.geo.attributes.z.array[e] = t.base.position.z
            }
            const i = e => () => this.onQueryUpdate(e);
            this.queryUnlisteners = [];
            for (const e in this.store.resources) {
                const t = this.store.resources[e].visibleQuery
                  , n = i(e);
                t.subscribe(n),
                this.queryUnlisteners.push( () => t.unsubscribe(n)),
                this.onQueryUpdate(e, !0)
            }
            n.a.viewportRatio.subscribe(this.onResize, this),
            this.onResize()
        }
        onResize() {
            const e = yi();
            for (let t = 0, i = this.allBubbles.length; t < i; t++)
                this.allBubbles[t].ratioMult = Object(b.lerp)(.5, .9, e),
                this.allBubbles[t].spriteMult = Object(b.lerp)(1.25, 1.05, e)
        }
        allocBubble(e) {
            if (this.freeBubbles.length < 1)
                return;
            const t = this.freeBubbles[3] ? 3 : 0
              , i = this.freeBubbles.splice(t, 1)[0];
            return i.onAlloc(e),
            this.usedBubbles.push(i),
            this.hashmapBubbles[e] = i,
            i
        }
        freeBubble(e, t) {
            this.usedBubbles.splice(e, 1),
            this.freeBubbles.push(t),
            this.hashmapBubbles[t.type] = null,
            t.onFree()
        }
        onQueryUpdate(e) {
            const t = this.store.resources[e].visibleQuery.current;
            (t || this.hashmapBubbles[e]) && (this.hashmapBubbles[e] || this.allocBubble(e)).onQuery(t)
        }
        update(e) {
            super.update(e);
            let t = 0;
            const i = this.geo.attributes.data.array;
            this.geo.attributes.data.needsUpdate = !0;
            for (let e = this.usedBubbles.length - 1; e >= 0; e--) {
                const n = this.usedBubbles[e];
                i[4 * e + 0] = n.base.position.x,
                i[4 * e + 1] = n.base.position.y,
                i[4 * e + 2] = n.size,
                i[4 * e + 3] = n.base.rotation.z,
                t++,
                n.dead && this.freeBubble(e, n)
            }
            this.geo.maxInstancedCount = t
        }
        beforeDestroy() {
            n.a.viewportRatio.unsubscribe(this.onResize, this),
            this.queryUnlisteners.forEach(e => e()),
            this.queryUnlisteners = [],
            this.allBubbles = null,
            this.usedBubbles.forEach(e => e.destroy()),
            this.freeBubbles.forEach(e => e.destroy());
            const e = this.geo.attributes.data.array;
            this.geo.attributes.data.needsUpdate = !0;
            for (let t = 0; t < Fr; t++)
                e[4 * t + 0] = 0,
                e[4 * t + 1] = 0,
                e[4 * t + 2] = 0,
                e[4 * t + 3] = 0;
            Rr.push(this.geo),
            this.data = this.geo = null
        }
    }
    var Dr = i(30)
      , Ur = i(6);
    const Br = 50
      , jr = 10;
    var Vr = {
        light: function() {
            if (this.sunScore > jr)
                return;
            const e = ge.T.get()
              , t = ge.U.get()
              , i = this.store.scene.current;
            e.set(.5 * n.a.viewportSize.current[0], -100),
            si(e, i.currentCamera.base, 0, t);
            const r = t.x;
            e.set(n.a.viewportSize.current[0], -100),
            si(e, i.currentCamera.base, 0, t);
            const s = t.x
              , a = t.y;
            this.sunScore += 3,
            this.store.emit("addSprites", 3, gr.sun({
                minX: r,
                maxX: s,
                y: a,
                emit: this.store.emit,
                scale: this.seedScale,
                bounds: this.spineSystem.bb,
                onComplete: this.decreaseSunScore
            })),
            e.release(),
            t.release()
        },
        rain: function() {
            if (this.sunScore > Br)
                return;
            const e = ge.T.get()
              , t = ge.U.get()
              , i = this.store.scene.current;
            e.set(.5 * n.a.viewportSize.current[0], -100),
            si(e, i.currentCamera.base, 0, t),
            this.rainScore += 10,
            this.store.emit("sprites", 10, gr.rain({
                position: t,
                emit: this.store.emit,
                scale: this.seedScale,
                bounds: this.spineSystem.bb,
                onComplete: this.decreaseRainScore
            })),
            e.release(),
            t.release()
        },
        love: function(e) {
            this.loveScore += 3,
            this.store.emit("topSprites", 3, gr.resourceBurst({
                position: e,
                type: "love",
                emit: this.store.emit,
                onComplete: this.decreaseLoveScore
            })),
            this.store.emit("addSprites", 1, gr.glow({
                position: e,
                color: ee.a.resourcesColors.current.love.normal
            }))
        },
        decreaseRainScore: function() {
            this.rainScore = Math.max(0, this.rainScore - 1)
        },
        decreaseSunScore: function() {
            this.sunScore = Math.max(0, this.sunScore - 1)
        },
        decreaseLoveScore: function() {
            this.loveScore = Math.max(0, this.loveScore - 1)
        },
        initResourceAnims: function() {
            this.rainScore = 0,
            this.sunScore = 0,
            this.loveScore = 0,
            this.decreaseRainScore = this.decreaseRainScore.bind(this),
            this.decreaseSunScore = this.decreaseSunScore.bind(this),
            this.decreaseLoveScore = this.decreaseLoveScore.bind(this)
        }
    };
    const Gr = 1400
      , Xr = 700
      , Yr = 100;
    class Wr extends Tt {
        init({scene: e, id: t, spineId: i}) {
            this.initResourceAnims(),
            this.resourceRepeaters = {
                water: null,
                sun: null
            },
            this.spineId = i,
            this.id = t,
            this.store = te.a.getSeedById(t),
            this.level = Math.max(this.store.level.current, 1),
            this.seedScale = this.store.getPreset().seedScale || 1,
            this.scale = ee.a.spineScale.current * this.seedScale,
            this.uiScene = pa.get("uiTop"),
            this.store.visibleLevel.subscribe(this.onVisibleLevel, this),
            this.spineSystem = this.addComponent(Hi, {
                store: this.store,
                scene: e,
                spineId: i,
                scale: this.scale,
                onMouseIn: () => this.canInteract() && U.setCursor("pointer"),
                onMouseOut: () => this.canInteract() && U.removeCursor(),
                onClick: e => this.canInteract() && this.onSeedClick(e)
            }),
            this.base = this.spineSystem.mesh,
            this.base.position.fromArray(this.store.getPreset().seedPosition),
            this.spineSystem.computeBounds(),
            this.state = this.spineSystem.state,
            this.skeleton = this.spineSystem.skeleton,
            this.eyeSystem = this.addComponent(Bi, {
                id: this.id,
                skeleton: this.skeleton
            }),
            this.anchorsSystem = this.addComponent(ji, {
                skeleton: this.skeleton,
                position: this.base.position,
                scale: this.scale,
                anchors: {
                    mouth: "mouth",
                    bubble0: "bubbles01-anchor",
                    bubble1: "bubbles02-anchor",
                    bubble2: "bubbles03-anchor",
                    bubble3: "bubbles04-anchor"
                }
            }),
            this.anchors = this.anchorsSystem.anchors,
            this.anchorsSystem.update(0),
            this.pendingResource = {
                sun: 0,
                water: 0
            },
            this.bubbles = this.addComponent(Nr, {
                store: this.store,
                seedAnchors: this.anchors,
                mountTo: e.base
            }),
            this.resourcesTimer = {
                water: 0,
                sun: 0
            },
            this.previousQueryProgress = {
                water: null,
                sun: null,
                love: null
            },
            this.giveWater = Vi(this.giveWater, this),
            this.giveSun = Vi(this.giveSun, this),
            this.initQueries(),
            this.onVisibleLevel(this.store.visibleLevel.current)
        }
        initQueries() {
            this.defferedQueries = {
                water: !1,
                message: !1,
                sun: !1,
                love: !1
            };
            const e = e => () => this.onVisibleQueryUpdate(e)
              , t = e => () => this.updateVisibleQuery(e);
            this.queryUnlisteners = [];
            for (const i in this.store.resources) {
                this.store.resources[i].visibleQuery.set(null);
                const n = this.store.resources[i].query
                  , r = t(i);
                n.subscribe(r),
                this.queryUnlisteners.push( () => n.unsubscribe(r));
                const s = this.store.resources[i].visibleQuery
                  , a = e(i);
                s.subscribe(a),
                this.queryUnlisteners.push( () => s.unsubscribe(a)),
                this.updateVisibleQuery(i)
            }
            this.checkDefferQueries = this.checkDefferQueries.bind(this),
            this.queryTimer = new y.a(1500,this.checkDefferQueries,!0)
        }
        canInteract() {
            if (this.destroyed)
                return !1;
            if (!we())
                return;
            const e = this.store.visibleLevel.current;
            return !(!e || e > 3)
        }
        update(e) {
            this.eyeSystem.update(e),
            this.anchorsSystem.update(e),
            this.spineSystem.update(.001 * e),
            this.bubbles.update(e),
            this.destroyed || (this.queryTimer.update(e),
            ee.a.guideAnchors.update(e => {
                const t = this.store.scene.current.currentCamera.base
                  , i = this.spineSystem.bb
                  , n = ge.U.get().set(.35 * (i.max.x + this.base.position.x), .5 * i.min.y + this.base.position.y, this.base.position.z)
                  , r = ge.T.get();
                return Yi(n, t, r),
                e.seed.position.x = r.x,
                e.seed.position.y = -r.y,
                r.release(),
                n.release(),
                e
            }
            , !0))
        }
        onVisibleLevel(e) {
            0 === e ? this.base.scale.set(-1e-5, 1e-5, 1e-5) : this.base.scale.set(-this.scale, this.scale, this.scale)
        }
        onSeedClick(e) {
            this.store.resources.message.query.current ? this.onSeedClickMessage(e) : this.onSeedClickLove(e)
        }
        onSeedClickMessage() {
            this.openMessage()
        }
        onSeedClickLove(e) {
            this.spineSystem.isCurrentlyIdle() && (this.spineSystem.makeFlash(),
            this.spineSystem.animProgressQuery()),
            this.store.resources.love.query.current && (this.love(e),
            this.giveLove())
        }
        defferResource(e) {
            if (this.destroyed)
                return !1;
            if ("sun" === e || "water" === e) {
                if (!j.a.prepareResource(this.id, e)) {
                    return ve.a.play("give_empty"),
                    Date.now() - this.resourcesTimer[e] > 2500 && this.spineSystem.animRequest(),
                    !1
                }
                return this.pendingResource[e]++,
                "water" === e && this.rain(),
                "sun" === e && this.light(),
                "water" === e ? this.giveWater() : this.giveSun(),
                this.resourcesTimer[e] = Date.now(),
                !0
            }
            return !0
        }
        giveResource(e) {
            return this.defferResource(e)
        }
        giveLove() {
            j.a.giveResource(this.id, "love"),
            ve.a.play("give_love"),
            this.canInteract() || U.removeCursor()
        }
        openMessage() {
            j.a.giveResource(this.id, "message");
            const e = this.store.level.current - 1
              , t = this.store.settings.current.message_rewards["lvl" + (e + 1)]
              , i = t.count >= 0 && (t.water || t.sun);
            1 !== e && 2 !== e || (fe.a.createBase({
                title: Object(Ur.a)(`seeds.${this.id}.message_${e}_title`),
                text: Object(Ur.a)(`seeds.${this.id}.message_${e}_description`),
                button: {
                    label: i ? Object(Ur.a)("interface.game.cta_collect") : Object(Ur.a)("interface.messages.cta")
                },
                game_over: i ? {
                    resources_won: t.count || 0,
                    water: !!t.water,
                    sun: !!t.sun
                } : void 0,
                onClose: i ? () => {
                    t.water && te.a.resources.water.collectable.update(e => e + t.count),
                    t.sun && te.a.resources.sun.collectable.update(e => e + t.count)
                }
                : void 0
            }),
            Cr.a.event({
                type: "mmEvent",
                category: "plant",
                action: "message",
                label: Object(Dr.a)(this.id)
            })),
            this.canInteract() || U.removeCursor()
        }
        giveWater() {
            this.pendingResource.water && (this.pendingResource.water--,
            ve.a.play("give_water"),
            j.a.giveResource(this.id, "water"))
        }
        giveSun() {
            this.pendingResource.sun && (this.pendingResource.sun--,
            ve.a.play("give_sun"),
            j.a.giveResource(this.id, "sun"))
        }
        onVisibleQueryUpdate(e) {
            const t = this.store.resources[e].visibleQuery.current
              , i = this.previousQueryProgress
              , n = t ? t.received / t.asked : 1;
            null === i[e] && (i[e] = n),
            n > i[e] && "message" !== e ? 1 === n ? this.spineSystem.animCompleteQuery() : this.spineSystem.animProgressQuery() : null !== t && ("message" === e ? this.spineSystem.animProgressQuery() : this.spineSystem.animRequest()),
            i[e] = n
        }
        updateVisibleQuery(e) {
            const t = this.store.resources[e]
              , i = t.query.current
              , n = t.visibleQuery.current;
            this.store.bubbleInitialized.current ? i && !n ? this.defferedQueries[e] = !0 : !i && n ? t.visibleQuery.set(null) : t.visibleQuery.set(i, !0) : t.visibleQuery.set(i, !0)
        }
        checkDefferQueries() {
            let e = !1;
            if (this.store.muteResources.current)
                this.queryTimer.restart(Yr, !1);
            else {
                for (const t in this.defferedQueries) {
                    const i = this.store.resources[t]
                      , n = i.query.current
                      , r = i.visibleQuery.current;
                    this.defferedQueries[t] = !1,
                    n && !r ? e || (e = !0,
                    i.visibleQuery.set(n, !0)) : this.defferedQueries[t] = !1
                }
                this.queryTimer.restart(e ? Xr : Gr, !1)
            }
        }
        beforeDestroy() {
            this.queryTimer.dispose(),
            this.store.visibleLevel.unsubscribe(this.onVisibleLevel, this),
            this.queryUnlisteners.forEach(e => e()),
            this.queryUnlisteners = [];
            for (let e = 0; e < this.pendingResource.water; e++)
                this.giveWater();
            for (let e = 0; e < this.pendingResource.sun; e++)
                this.giveSun();
            U.removeCursor(),
            this.skeleton = null,
            this.state = null,
            this.anchors = null,
            this.store = null
        }
    }
    Object.assign(Wr.prototype, Vr);
    var qr = {
        default: Wr
    };
    class Hr extends In {
        init({seedId: e}) {
            this.seedId = e,
            this.store = te.a.getSeedById(this.seedId),
            this.store.bubbleInitialized.current = !1,
            this.muteResources(),
            this.store.visibleLevel.update( () => this.store.level.current),
            this.store.visibleLevel.subscribe(this.onVisibleLevelChange, this),
            this.store.level.subscribe(this.onLevelChange, this),
            ee.a.muteGuide.set(!1),
            this.store.scene.set(this),
            this.offset = Ci({
                current: 0,
                ease: .005
            }),
            this.rotation = Ci({
                current: 0,
                ease: .005
            }),
            this.camPos = Ci({
                current: new ge.U,
                ease: .005
            }),
            this.camAng = {
                value: new ge.J,
                target: new ge.J
            },
            this.background = this.store.palette.current[0],
            this.gardenCamera = this.addComponent(Fi, {
                seedId: this.seedId,
                seedStore: this.store
            }),
            this.useCamera(this.gardenCamera),
            this.batchers = {
                grounds: an.get({
                    count: 50,
                    material: "props",
                    atlas: "props",
                    dynamic: !1,
                    meshProperties: {
                        propType: 0
                    }
                }),
                plants: an.get({
                    count: 100,
                    material: "props",
                    atlas: "props",
                    dynamic: !1,
                    subdivisions: [1, 8],
                    offset: Pr * Ar++,
                    meshProperties: {
                        propType: 1
                    }
                }),
                stars: an.get({
                    count: 1e3,
                    material: "props",
                    atlas: "props",
                    dynamic: !1,
                    offset: Pr * Ar++,
                    meshProperties: {
                        propType: 2
                    }
                }),
                sprites: an.get({
                    count: 300,
                    material: "basic",
                    atlas: "sprites",
                    offset: Pr * Ar++,
                    transparent: !0,
                    renderOrder: 5
                }),
                topSprites: an.get({
                    count: 200,
                    material: "basic",
                    atlas: "sprites",
                    offset: Pr * Ar++,
                    renderOrder: 6,
                    transparent: !0,
                    depthWrite: !0,
                    depthTest: !1
                }),
                addSprites: an.get({
                    count: 100,
                    material: "basic",
                    atlas: "sprites",
                    offset: Pr * Ar++,
                    renderOrder: 11,
                    blending: "additive",
                    transparent: !0,
                    depthWrite: !0,
                    depthTest: !1
                }),
                bubbleSprites: an.get({
                    count: 100,
                    material: "basic",
                    atlas: "sprites",
                    offset: Pr * Ar++,
                    renderOrder: 12,
                    transparent: !0,
                    depthWrite: !0,
                    depthTest: !1
                })
            };
            for (const e in this.batchers)
                this.base.add(this.batchers[e].base);
            this.landscape = this.addComponent(gi, {
                seedId: this.seedId,
                sceneData: this.store.sceneData,
                batchers: this.batchers,
                parent: this.base,
                scene: this
            }),
            this.emitter = _n.get({
                batchers: this.batchers
            }),
            this.addSpineSeed(),
            this.update(0),
            bt.prerender(this),
            this.cancelEvolve(),
            this.store.bubbleInitialized.current = !1
        }
        appearSeed() {
            if (!this.seed)
                return;
            this.seed.appearing = !0;
            const e = this.seed.base.scale.clone();
            this.seed.base.scale.set(-1e-4, 1e-4, 1e-4),
            this.timer(500, () => {
                if (this.destroyed)
                    return;
                this.seed.appearing = !1,
                this.seed.base.scale.copy(e),
                this.seed.spineSystem.play(0, "in", !1, 0, 1.1),
                this.seed.update(0),
                this.seed.base.updateMatrix(),
                this.seed.update(0),
                this.seed.spineSystem.makeFlash();
                const t = ge.U.get().set(0, .5, 0).add(this.seed.anchors.mouth)
                  , i = ge.U.get().set(.8, .5, 0).add(this.seed.anchors.mouth);
                ve.a.play("gift_click"),
                this.store.emit("topSprites", 8, gr.seedAppearSmoke({
                    position: t
                })),
                this.store.emit("topSprites", 5, gr.seedAppearLeaf({
                    position: t
                })),
                this.store.emit("addSprites", 1, gr.lightGlow({
                    scale: 1,
                    position: i
                })),
                t.release(),
                i.release()
            }
            )
        }
        muteResources() {
            this.store.muteResources.set(!0)
        }
        unmuteResources() {
            this.store.muteResources.set(!1)
        }
        onLevelChange(e) {
            const t = this.store.visibleLevel.current;
            e > 1 && this.bag && (this.bag.destroy(),
            this.bag = null),
            1 !== e || 0 !== t ? t === e - 1 ? this.startEvolve(t, e) : (this.cancelEvolve(),
            this.store.visibleLevel.set(e)) : this.plantAnim()
        }
        plantAnim() {
            this.bag.open()
        }
        onVisibleLevelChange() {
            this.addSpineSeed(),
            this.gardenCamera.updateOriginReferences(),
            this.gardenCamera.updateOrigin(),
            ee.a.muteGuide.set(!1),
            this.evolving ? (this.finishEvolve(),
            this.checkRegisterPopin(),
            this.checkGiftPopin()) : this.cancelEvolve()
        }
        openVoucherDetails(e) {
            function t(i) {
                n.a.leftPanelView.set({
                    type: "voucherDetails",
                    seedId: e
                }),
                n.a.menuOpen.set(!0),
                te.a.vouchers.unsubscribe(t, this)
            }
            n.a.menuOpen.current && !document.body.classList.contains("left-panel-open") || (te.a.vouchers.current[e] ? t() : te.a.vouchers.subscribe(t, this))
        }
        checkGiftPopin() {
            this.store.visibleLevel.current < 4 || (this.pendingPopin = !0,
            this.muteResources(),
            ee.a.muteGuide.set(!0),
            this.timer(1500, () => {
                if (!this.destroyed)
                    if (te.a.id.current) {
                        if (te.a.gameComplete.current)
                            return;
                        this.openVoucherDetails(this.seedId),
                        this.timer(1500, () => {
                            this.destroyed || (this.pendingPopin = !1,
                            ee.a.muteGuide.set(!1))
                        }
                        )
                    } else
                        fe.a.createAskRegister({
                            onClose: () => {
                                this.destroyed || this.timer(1500, () => {
                                    this.destroyed || (this.pendingPopin = !1,
                                    ee.a.muteGuide.set(!1))
                                }
                                )
                            }
                        })
            }
            ))
        }
        checkRegisterPopin() {
            if (te.a.id.current)
                return;
            const e = te.a.seedsArray.current;
            if (2 !== this.store.level.current)
                return;
            let t = 0;
            for (let i = 0, n = e.length; i < n; i++)
                e[i].level.current >= 2 && t++;
            1 === t && (ee.a.muteGuide.set(!0),
            this.pendingPopin = !0,
            this.muteResources(),
            this.timer(1500, () => {
                this.destroyed || fe.a.createAskRegister({
                    type: "tutoriel",
                    onClose: () => this.timer(1500, () => {
                        this.destroyed || (this.pendingPopin = !1,
                        ee.a.muteGuide.set(!1))
                    }
                    )
                })
            }
            ))
        }
        addSpineSeed() {
            const e = this.store.level.current
              , t = !this.store.unlocked.current
              , i = e < 1 || t
              , n = this.seedId + "_lvl" + Math.max(e, 1)
              , r = Gi.a.fileExists(n)
              , s = function(e, t) {
                return qr[e] ? qr[e][t] ? qr[e][t] : qr[e].default ? qr[e].default : qr.default : qr.default
            }(this.seedId, e);
            i && !this.bag && (this.bag = this.addComponent(Mr, {
                seedId: this.seedId,
                seedStore: this.store,
                seedScene: this,
                onOpen: () => {
                    this.destroyed || 1 === this.store.level.current && (this.store.visibleLevel.set(this.store.level.current),
                    this.seed.spineSystem.animIn())
                }
                ,
                onComplete: () => {
                    this.bag.destroy(),
                    this.bag = null
                }
            })),
            this.seed && this.seed.level !== e && this.seed.destroy(),
            !r || this.seed && this.seed.level === e || (this.seed = this.addComponent(s, {
                scene: this,
                id: this.store.id.current,
                spineId: n
            }))
        }
        update(e) {
            super.update(e),
            this.seed && this.seed.spineSystem && !this.evolving && (this.pendingPopin || !this.seed.spineSystem.isCurrentlyIdle() && !this.seed.spineSystem.isRequesting() && this.seed.appearing ? this.muteResources() : this.unmuteResources()),
            this.emitter.update(e);
            for (const t in this.batchers)
                this.batchers[t].update(e);
            this.store.bubbleInitialized.current = !0
        }
        beforeDestroy() {
            this.unmuteResources(),
            this.cancelEvolve(),
            this.store.visibleLevel.unsubscribe(this.onVisibleLevelChange, this),
            this.store.level.unsubscribe(this.onLevelChange, this),
            this.store.visibleLevel.update( () => this.store.level.current),
            this.emitter.release();
            for (const e in this.batchers)
                this.batchers[e].release();
            this.batchers = null,
            this.batchersList = null,
            this.store.scene.set(null),
            this.debugCamera = null,
            this.seedGroup = null
        }
    }
    Object.assign(Hr.prototype, Sr);
    var Qr = Hr;
    const Jr = () => new ge.U
      , Zr = () => new ge.J;
    class $r extends Fi {
        init(e) {
            if (this.hideCam = {
                position: Jr(),
                quaternion: Zr(),
                qInfluence: Ci({
                    ease: .0015,
                    current: 0,
                    target: 0
                }),
                pInfluence: Ci({
                    ease: .0019,
                    current: 0,
                    target: 0
                })
            },
            e.preset.cameraPositionHide) {
                const t = ge.n.get().fromArray(e.preset.cameraRotationHide).release();
                this.hideCam.position.fromArray(e.preset.cameraPositionHide),
                this.hideCam.quaternion.setFromEuler(t),
                this.hideCam.qInfluence.current = 1,
                this.hideCam.pInfluence.current = 1
            }
            super.init(e)
        }
        update(e) {
            this.time += 8e-4 * e;
            const t = this.origin;
            t.quaternion.current.slerp(t.quaternion.target, t.quaternion.ease),
            t.position.current.lerp(t.position.target, t.position.ease);
            const i = this.wiggle;
            i.set(Math.cos(this.time + Math.cos(.8 * -this.time) * this.wiggleFreq) * this.wiggleAmp, Math.sin(.8 * this.time + Math.cos(this.time) * this.wiggleFreq) * this.wiggleAmp, Math.sin(.4 * this.time + Math.cos(this.time) * this.wiggleFreq) * this.wiggleAmp),
            this.rotation.setFromQuaternion(t.quaternion.current),
            this.position.copy(t.position.current).add(i),
            this.hideCam.qInfluence.update(e),
            this.hideCam.pInfluence.update(e),
            this.base.quaternion.slerp(this.hideCam.quaternion, this.hideCam.qInfluence.current),
            this.position.lerp(this.hideCam.position, this.hideCam.pInfluence.current),
            this.base.updateMatrix()
        }
    }
    class Kr extends In {
        onMissed() {}
        onCollected() {}
        onResize() {}
        onLost() {}
        onTouch() {}
        onGameOver() {}
        onPlayerLost() {
            this.elpasedTime = void 0,
            this.level = this.levels[0]
        }
        onPlayerReady() {
            this.elpasedTime = 0,
            te.a.playerReady.dispatch()
        }
        constructor(...e) {
            super(...e),
            V.a.playGame(),
            n.a.touch.subscribe(this.onTouch, this),
            n.a.viewportSize.subscribe(this.onResize, this),
            this._wpos = new ge.U,
            this.onResize(n.a.viewportSize.current),
            this.addComponent(gi, {
                batchers: this.batchers,
                sceneData: X[this.landscapeId],
                scene: this
            }),
            this.background = ee.a.palettes.current[X[this.landscapeId].current.palette][0],
            this.reset(),
            this.start()
        }
        init() {
            this.onMissed = this.onMissed.bind(this),
            this.onCollected = this.onCollected.bind(this),
            this.raycaster = new ge.N,
            this.gardenCamera = this.addComponent($r, {
                preset: X[this.landscapeId].current.camera
            }),
            this.useCamera(this.gardenCamera),
            this.batchers = {
                grounds: an.get({
                    count: 50,
                    material: "props",
                    atlas: "props",
                    dynamic: !1,
                    offset: -.003,
                    meshProperties: {
                        propType: 0
                    }
                }),
                plants: an.get({
                    count: 100,
                    material: "props",
                    atlas: "props",
                    dynamic: !1,
                    subdivisions: [1, 8],
                    offset: -.002,
                    meshProperties: {
                        propType: 1
                    }
                }),
                stars: an.get({
                    count: 1e3,
                    material: "props",
                    atlas: "props",
                    dynamic: !1,
                    offset: -.001,
                    meshProperties: {
                        propType: 2
                    }
                }),
                topSprites: an.get({
                    count: 200,
                    material: "basic",
                    atlas: "sprites",
                    offset: 0,
                    renderOrder: 2,
                    transparent: !0
                }),
                addSprites: an.get({
                    count: 200,
                    material: "basic",
                    atlas: "sprites",
                    offset: .001,
                    renderOrder: 7,
                    blending: "additive",
                    transparent: !0
                }),
                drops: an.get({
                    count: 100,
                    material: "basic",
                    atlas: "sprites",
                    offset: .004,
                    renderOrder: 6,
                    transparent: !0
                })
            };
            for (const e in this.batchers)
                this.add(this.batchers[e].base);
            this.emitter = _n.get({
                batchers: this.batchers
            }),
            this.landscape = this.add(new ge.F),
            this.landscape.add(this.batchers.grounds.base),
            this.landscape.add(this.batchers.plants.base),
            this.landscape.add(this.batchers.stars.base)
        }
        reset() {
            this.setScore(0),
            this.level = this.levels[0]
        }
        start() {
            this.started || (this.started = !0)
        }
        stop() {
            this.started && (this.started = !1)
        }
        isGameOver() {
            return this.gameover
        }
        gameOver() {
            be.a.noGameOver.current || this.isGameOver() || (this.gameover = !0,
            V.a.saveCurrentScore(this.gameId),
            V.a.resetGameTime(),
            fe.a.createGameOver(this.gameId),
            ve.a.play("game_end"),
            this.onGameOver(),
            this.onPlayerLost())
        }
        getScore() {
            return this.score
        }
        setScore(e) {
            te.a.scores[this.gameId].set(e),
            this.score = e
        }
        screenToWorld(e, t) {
            return si(e, this.currentCamera.base, t, this._wpos),
            this._wpos
        }
        destroy() {
            for (const e in this.batchers)
                this.batchers[e].release();
            this.batchers = null,
            document.body.classList.remove("game-lost"),
            n.a.viewportSize.unsubscribe(this.onResize, this),
            n.a.touch.unsubscribe(this.onTouch, this),
            super.destroy()
        }
        update(e) {
            if (super.update(e),
            void 0 !== this.elpasedTime) {
                this.elpasedTime += .001 * e;
                const t = e => this.elpasedTime >= e.startTime
                  , i = this.levels.filter(t)
                  , n = this.levels[i.length - 1];
                n !== this.level && (this.level = n)
            }
        }
    }
    function es(e, t=.03) {
        const i = Mt.a.files.get(e, !0).node;
        let n = parseInt(i.getAttribute("width"))
          , r = parseInt(i.getAttribute("height"));
        if (!n || !r) {
            const e = i.getAttribute("viewBox").trim().split(" ");
            n = parseInt(e[2]),
            r = parseInt(e[3])
        }
        const s = new ge.T(n,r)
          , a = function(e, t, i) {
            const n = [];
            for (let r = 0, s = e.length; r < s; r++) {
                const s = e[r]
                  , a = parseInt(s.getAttribute("cx"))
                  , o = parseInt(s.getAttribute("cy"))
                  , l = parseInt(s.getAttribute("r"));
                if ("circle" !== s.tagName)
                    continue;
                const c = new ge.U(a,o,0);
                c.x -= .5 * t.x,
                c.y = t.y - c.y,
                c.y -= .5 * t.y,
                c.multiplyScalar(i),
                c.scale = l / 15,
                n.push(c)
            }
            return n
        }(i.children, s, t);
        return a.sort( (e, t) => t.y - e.y),
        a
    }
    var ts = [{
        startTime: 0,
        visibilityDuration: 500,
        visibilityDurationRandomness: 500,
        spawnDelay: 1500,
        spawnDelayRandomness: 500
    }, {
        startTime: 10,
        visibilityDuration: 450,
        visibilityDurationRandomness: 400,
        spawnDelay: 1e3,
        spawnDelayRandomness: 500
    }, {
        startTime: 15,
        visibilityDuration: 400,
        visibilityDurationRandomness: 300,
        spawnDelay: 750,
        spawnDelayRandomness: 400
    }, {
        startTime: 22,
        visibilityDuration: 375,
        visibilityDurationRandomness: 275,
        spawnDelay: 700,
        spawnDelayRandomness: 375
    }, {
        startTime: 30,
        visibilityDuration: 350,
        visibilityDurationRandomness: 250,
        spawnDelay: 615,
        spawnDelayRandomness: 350
    }, {
        startTime: 40,
        visibilityDuration: 300,
        visibilityDurationRandomness: 200,
        spawnDelay: 515,
        spawnDelayRandomness: 300
    }, {
        startTime: 50,
        visibilityDuration: 270,
        visibilityDurationRandomness: 170,
        spawnDelay: 475,
        spawnDelayRandomness: 250
    }, {
        startTime: 60,
        visibilityDuration: 230,
        visibilityDurationRandomness: 125,
        spawnDelay: 425,
        spawnDelayRandomness: 200
    }, {
        startTime: 70,
        visibilityDuration: 200,
        visibilityDurationRandomness: 100,
        spawnDelay: 375,
        spawnDelayRandomness: 150
    }, {
        startTime: 80,
        visibilityDuration: 180,
        visibilityDurationRandomness: 90,
        spawnDelay: 325,
        spawnDelayRandomness: 125
    }, {
        startTime: 95,
        visibilityDuration: 170,
        visibilityDurationRandomness: 60,
        spawnDelay: 290,
        spawnDelayRandomness: 100
    }, {
        startTime: 110,
        visibilityDuration: 150,
        visibilityDurationRandomness: 40,
        spawnDelay: 220,
        spawnDelayRandomness: 75
    }, {
        startTime: 130,
        visibilityDuration: 130,
        visibilityDurationRandomness: 20,
        spawnDelay: 175,
        spawnDelayRandomness: 50
    }];
    class is extends wr {
        init(e) {
            this.deactivate = this.deactivate.bind(this),
            this.onHideComplete = this.onHideComplete.bind(this),
            this.minY = .6,
            this.maxY = 1,
            this.hideY = -3.5,
            super.init(Object.assign({
                spineId: "chenille",
                touchable: !0,
                scale: .07
            }, e)),
            e.index % 2 && (this.spine.scale.x *= -1),
            void 0 === is.index && (is.index = 0),
            this.index = is.index++,
            this.initTweens(),
            this.setFlash(0),
            this.timeout = new y.a(1,this.deactivate,!1)
        }
        initTweens() {
            super.initTweens(),
            this.tweens.show = $.a.to(this.moveAnim, 1, {
                alpha: () => $t.b.randomFloat(this.minY, this.maxY),
                ease: Z.d.easeOut.config(1, .5),
                paused: !0
            }),
            this.tweens.hide = $.a.to(this.moveAnim, .5, {
                alpha: 0,
                ease: Z.a.easeIn,
                onComplete: this.onHideComplete,
                paused: !0
            })
        }
        initState() {
            this.state.data.defaultMix = .2,
            this.state.setAnimation(0, "idle", !0),
            this.moveAnim = this.state.setAnimation(1, "move", !0)
        }
        reset() {
            this.timeout.stop(),
            this.setFlash(0),
            this.active = !1,
            this.catchable = !1,
            this.catched = !1,
            this.moveAnim.alpha = 0,
            this.state.setAnimation(0, "idle", !0)
        }
        activate(e) {
            if (this.active)
                return;
            this.active = !0,
            this.catchable = !0,
            this.catched = !1,
            this.state.setAnimation(0, "idle", !0);
            const t = this.tweens;
            t.hide.pause(),
            t.show.isActive() || (ve.a.play("cater_appear"),
            t.show.invalidate().restart()),
            void 0 !== e && this.timeout.restart(e, !1)
        }
        deactivate() {
            if (!this.active)
                return;
            this.active = !1;
            const e = this.tweens;
            e.show.pause(),
            e.hide.isActive() || e.hide.invalidate().restart(),
            this.timeout.stop()
        }
        update(e) {
            super.update(e),
            this.updateAnchors(),
            this.timeout.update(e)
        }
        onHideComplete() {
            this.catchable = !1,
            !this.catched && this.props.onMissed && this.props.onMissed(this)
        }
        onClick() {
            !this.catched && this.catchable && (this.state.setAnimation(0, "hit", !0),
            this.makeFlash(),
            this.deactivate(),
            this.catched = !0,
            this.props.onCollected && this.props.onCollected(this))
        }
        onMouseIn() {
            U.setCursor("pointer")
        }
        onMouseOut() {
            U.removeCursor()
        }
        beforeDestroy() {
            super.beforeDestroy(),
            this.timeout.dispose()
        }
    }
    var ns = i(48);
    class rs extends ns.a {
        constructor() {
            super(),
            Object(ie.a)(this),
            this.pressedKeys = {}
        }
        isDown(e) {
            return this.pressedKeys[e]
        }
        _onKeyDown(e) {
            this.pressedKeys[e.code] = !0,
            this.dispatchEvent({
                type: "keyDown",
                originalEvent: e,
                key: e.key,
                code: e.code
            })
        }
        _onKeyUp(e) {
            delete this.pressedKeys[e.code],
            this.dispatchEvent({
                type: "keyUp",
                originalEvent: e,
                key: e.key,
                code: e.code
            })
        }
        addEventListeners() {
            this.hasListeners || (this.hasListeners = !0,
            addEventListener("keyup", this._onKeyUp),
            addEventListener("keydown", this._onKeyDown))
        }
        removeEventListeners() {
            this.hasListeners && (this.hasListeners = !1,
            removeEventListener("keyup", this._onKeyUp),
            removeEventListener("keydown", this._onKeyDown))
        }
    }
    var ss = [{
        startTime: 0,
        speed: .02
    }, {
        startTime: 5,
        speed: .03
    }, {
        startTime: 15,
        speed: .04
    }, {
        startTime: 30,
        speed: .06
    }, {
        startTime: 40,
        speed: .08
    }, {
        startTime: 50,
        speed: .1
    }]
      , as = "precision highp float;\n#define GLSLIFY 1\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec4 texCoords;\n\nattribute vec2 uv;\nattribute vec3 position;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvUv = uv * texCoords.zw + texCoords.xy;\n\tvec3 transformed = position;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.);\n\n}\n"
      , os = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform float opacity;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec2 uv = vUv;\n\tvec4 color = texture2D(atlas, uv).rgba;\n\tcolor.rgb = clamp(color.rgb / max(color.a, 0.00001), 0., 1.);\n\n\tif (color.a < 0.9) discard;\n\tgl_FragColor = vec4(color.rgb, color.a * opacity);\n\n}\n\n";
    class ls extends ge.M {
        constructor(e={}) {
            super({
                vertexShader: as,
                fragmentShader: os,
                transparent: !!e.transparent,
                depthWrite: !!e.depthWrite,
                depthTest: !!e.depthTest,
                uniforms: {
                    opacity: {
                        value: 1
                    },
                    atlas: {
                        type: "t"
                    },
                    texCoords: {
                        value: new Float32Array([0, 0, 0, 0])
                    }
                }
            }),
            this.useObjectUniforms = !0,
            this.isCustomSpriteMaterial = !0,
            e.atlasTexture && (this.atlasTexture = e.atlasTexture)
        }
        get atlasTexture() {
            return this.uniforms.atlas.value
        }
        set atlasTexture(e) {
            e !== this.uniforms.atlas.value && (this.uniforms.atlas.value = e,
            this.uniforms.atlas.needsUpdate = !0)
        }
    }
    const cs = {}
      , hs = {};
    class us extends Tt {
        init(e) {
            void 0 === e.depthWrite && (e.depthWrite = !0),
            void 0 === e.depthTest && (e.depthTest = !0);
            const t = e.atlas
              , i = cs[t] || function({transparent: e, depthWrite: t, depthTest: i, atlas: n}) {
                const r = (e ? "a1" : "a0") + "-" + (t ? "dw1" : "dw0") + "-" + (i ? "dt1" : "dt0") + "-" + n
                  , s = Object.values(cs)
                  , a = s[0] ? s[0].clone() : new ls({
                    transparent: e,
                    depthWrite: t,
                    depthTest: i
                });
                return a.atlasTexture = Ot.getAtlas(n).baseTexture,
                cs[r] = a,
                a
            }(e)
              , n = hs[0] || function({id: e}) {
                const t = new ge.I;
                return hs[e] = t,
                t
            }({
                id: "0"
            });
            this.spriteMesh = new ge.x(n,i),
            this.base = new ge.F,
            this.base.add(this.spriteMesh),
            this.position = this.base.position,
            this.scale = this.base.scale,
            this.rotation = this.base.rotation,
            this.onSpriteUpdate = this.onSpriteUpdate.bind(this),
            this.sprite = new Nt(Object.assign({}, e, {
                id: e.sprite,
                onUpdate: this.onSpriteUpdate
            }))
        }
        onSpriteUpdate(e) {
            this.spriteMesh.texCoords = e.texCoords,
            this.spriteMesh.position.x = e.meshCoords[0],
            this.spriteMesh.position.y = e.meshCoords[1],
            this.spriteMesh.scale.x = e.meshCoords[2],
            this.spriteMesh.scale.y = e.meshCoords[3]
        }
        update(e) {
            this.sprite.update(e),
            super.update(e)
        }
        destroy() {
            this.sprite.destroy(),
            this.sprite = null,
            super.destroy()
        }
    }
    class ps extends Tt {
        init() {
            this.base = new ge.F,
            this.handle = new ge.F,
            this.position = this.base.position,
            this.rotation = this.base.rotation;
            const e = {
                atlas: "sprites",
                depthTest: !0,
                depthWrite: !0,
                transparent: !0
            };
            this.handleBack = this.addComponent(us, Object.assign({
                sprite: "bucket_handle_back"
            }, e)),
            this.back = this.addComponent(us, Object.assign({
                sprite: "bucket_body_back"
            }, e)),
            this.water = this.addComponent(us, Object.assign({
                sprite: "buck_water"
            }, e)),
            this.front = this.addComponent(us, Object.assign({
                sprite: "bucket_body_front"
            }, e)),
            this.handleFront = this.addComponent(us, Object.assign({
                sprite: "bucket_handle_front"
            }, e)),
            this.handleBack.base.children[0].renderOrder = 0,
            this.back.base.children[0].renderOrder = 1,
            this.water.base.children[0].renderOrder = 3,
            this.front.base.children[0].renderOrder = 4,
            this.handleFront.base.children[0].renderOrder = 5,
            this.handleBack.position.z = -.002,
            this.back.position.z = -.001,
            this.water.position.z = .001,
            this.front.position.z = .002,
            this.handleFront.position.z = .003,
            this.handle.add(this.handleFront.base, this.handleBack.base),
            this.base.add(this.handle),
            this.handleBack.base.position.x = -.175,
            this.handleFront.base.position.x = .031,
            this.handleBack.base.position.y = .225,
            this.handleFront.base.position.y = .03,
            this.baseWaterPos = .25,
            this.water.position.y = this.baseWaterPos,
            this.handle.position.y = .31,
            this.base.scale.setScalar(1.5);
            const t = ge.g.get()
              , i = t.setFromObject(this.base).getSize(ge.U.get().release());
            this.size = new ge.T(.85 * i.x,.6 * i.y),
            this.yOffset = -.05,
            this.min = new ge.T(-.5 * this.size.x,-.5 * this.size.y + this.yOffset),
            this.max = new ge.T(.5 * this.size.x,.5 * this.size.y + this.yOffset),
            this.bb = new ge.f(this.min.clone(),this.max.clone()),
            t.release(),
            this.y = 0,
            this.x = Ci({
                current: 0,
                ease: .04
            }),
            this.paused = !1,
            this.rot = new ye.a({
                initial: 1,
                tension: .21,
                friction: .4
            }),
            this.waterSpring = new ye.a({
                initial: 1,
                tension: .08,
                friction: .08
            }),
            this.waterColectSpring = new ye.a({
                initial: 0,
                tension: .15,
                friction: .08
            }),
            this.currentTarget = 1.1,
            this.prevPosX = 0,
            this.speed = 0,
            this.easedSpeed = 0,
            this.bucketSpeed = 0,
            this.handleSpeed = 0,
            this.easedHandleSpeed = 0,
            this.gravity = .16,
            this.force = 0,
            this.time = 0,
            this.handlePhysics = {
                fy: 0,
                mass: .2,
                vy: 0,
                ay: 0,
                dy: 0,
                e: -.5,
                rho: 1.2,
                C_d: .47
            },
            this.handle.rotation.z = -Math.PI
        }
        setX(e) {
            this.x.target = e
        }
        setY(e) {
            this.y = e
        }
        onLost() {
            this.paused = !0,
            this.tweens.hide && this.tweens.hide.kill(),
            this.tweens.hide = $.a.to(this.position, .5, {
                y: -5,
                ease: Z.a.easeIn.config(1.5)
            })
        }
        onCollected() {
            this.waterColectSpring.setValue(.1)
        }
        update(e) {
            this.x.update(e),
            this.rot.update(e),
            this.prevPosX = this.position.x,
            this.paused || (this.position.x = this.x.current,
            this.position.y = this.y),
            this.speed = 1 * (this.position.x - this.prevPosX),
            this.easedSpeed += .1 * (this.speed - this.easedSpeed),
            this.rot.setTarget(this.speed),
            this.handleSpeed = -2 * (this.force + (this.position.x - this.prevPosX)),
            this.easedHandleSpeed += .3 * (this.handleSpeed - this.easedHandleSpeed),
            this.rotation.z = this.rot.value,
            this.waterColectSpring.update(e),
            this.water.scale.y = 1 + 2 * this.waterColectSpring.value,
            this.waterSpring.setTarget(.3 * -this.speed),
            this.waterSpring.update(e),
            this.water.rotation.z = .3 * this.waterSpring.value,
            this.water.position.y = this.baseWaterPos + .1 * this.waterSpring.value - .7 * this.waterColectSpring.value,
            this.bb.min.set(this.min.x + this.position.x, this.min.y + this.position.y),
            this.bb.max.set(this.max.x + this.position.x, this.max.y + this.position.y),
            this.handle.rotation.z += .3 * this.easedHandleSpeed,
            this.handlePhysics.fy = 0,
            this.handlePhysics.fy += 9.21 * this.handlePhysics.mass,
            this.handlePhysics.fy += Math.pow(this.handlePhysics.vy, 2);
            const t = this.handlePhysics.fy / this.handlePhysics.mass;
            this.handlePhysics.vy += .001 * t,
            this.handle.rotation.z += this.handlePhysics.vy,
            this.handle.rotation.z >= 0 && this.handlePhysics.vy > 0 && (this.handlePhysics.vy *= this.handlePhysics.e,
            this.handle.rotation.z = 0),
            this.handle.rotation.z = Math.min(.2, this.handle.rotation.z)
        }
    }
    class ds {
        constructor() {
            Object(ie.a)(this),
            this.ratio = .03,
            this.gravity = .0015,
            this.types = ["Easy", "Medium", "Hard"];
            const e = Mt.a.files.get("GameB.raw.svg", !0).node;
            let t = parseInt(e.getAttribute("width"))
              , i = parseInt(e.getAttribute("height"));
            if (!t || !i) {
                const n = e.getAttribute("viewBox").trim().split(" ");
                t = parseInt(n[2]),
                i = parseInt(n[3])
            }
            this.size = new ge.T(t,i),
            this.levels = {};
            for (let t = 0, i = e.children.length; t < i; t++) {
                const i = e.children[t];
                if (!i.id)
                    continue;
                const n = i.id.match(/(Easy|Medium|Hard)/g).pop();
                !this.levels[n] && (this.levels[n] = []),
                this.levels[n].push(i.children)
            }
            this.reset()
        }
        onLost() {
            this.paused = !0
        }
        reset() {
            this.index = 0,
            this.firstDropCollected = !1,
            this.levelCount = 4,
            this.paused = !1,
            this.positions = [],
            this.velocities = [];
            for (let e = 0, t = 50; e < t; e++)
                this._get(),
                this.velocities[e] = 0
        }
        start() {
            this.started || (this.started = !0)
        }
        stop() {
            this.started && (this.started = !1)
        }
        getNextIndex() {
            const e = this.index;
            return this.index++,
            this.index %= this.positions.length,
            e
        }
        getPosition(e) {
            return this.positions[e]
        }
        getVelocity(e) {
            return this.velocities[e]
        }
        _get() {
            let e = [];
            for (let t = 0, i = this.types.length; t < i; t++) {
                const i = this.types[t]
                  , n = this.levels[i];
                if (n) {
                    n.sort( () => Math.random() > .5);
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = this._getCoordinates(n[t]);
                        e = e.concat(i)
                    }
                }
            }
            this.totalHeight = this.levelCount * this.size.y * this.ratio,
            this.positions = this.positions.concat(e)
        }
        _getCoordinates(e) {
            const t = [];
            e = Array.from(e);
            const i = Math.random() > .5
              , n = Math.random() > .5;
            for (let r = 0, s = e.length; r < s; r++) {
                const s = e[r]
                  , a = parseInt(s.getAttribute("cx"))
                  , o = parseInt(s.getAttribute("cy"));
                if ("circle" !== s.tagName)
                    continue;
                const l = new ge.U(a,o,0);
                i && (l.x = this.size.x - a),
                n && (l.y = this.size.y - o),
                l.x -= .5 * this.size.x,
                l.y += this.size.y * this.levelCount,
                l.multiplyScalar(this.ratio),
                t[r] = l
            }
            return this.levelCount++,
            t
        }
        update() {
            if (this.started)
                for (let e = 0, t = this.positions.length; e < t; e++) {
                    const t = this.positions[e];
                    t.y > 15 ? this.velocities[e] = -this.level.speed : this.velocities[e] -= this.gravity,
                    t.y += this.velocities[e],
                    t.y = Object(b.mod)(t.y, this.totalHeight)
                }
        }
    }
    class fs extends Dt {
        constructor(e) {
            e.position = new ge.U(0,0,1e-5 * e.index),
            super(e),
            this.bucket = e.bucket,
            this.patterns = e.patterns,
            this.index = this.patterns.getNextIndex(),
            this.offsetY = e.offsetY,
            this.paused = !1,
            this.size = new ge.T(.1 * this.scale.x,.05 * this.scale.y),
            this.bb = new ge.f,
            this.bb.setFromCenterAndSize(this.position, this.size)
        }
        onLost() {
            this.paused = !0
        }
        reset() {
            this.paused = !1,
            this.index = this.patterns.getNextIndex()
        }
        activate() {
            this.active || this.paused || (this.active = !0,
            this.scaleFactor = $t.b.randomFloat(.45, .75))
        }
        deactivate() {
            this.active && !this.paused && (this.active = !1,
            this.scaleFactor = .001)
        }
        update(e) {
            const t = this.bucket.bb.intersectsBox(this.bb);
            this.active && t && (this.props.onCollected && this.props.onCollected(this),
            this.index = this.patterns.getNextIndex(),
            this.activate());
            const i = this.patterns.getVelocity(this.index);
            this.scale.setScalar(this.scaleFactor),
            this.scale.y -= 2.5 * i,
            this.scale.x += .25 * i;
            const n = this.position.x;
            this.position.copy(this.patterns.getPosition(this.index)),
            this.patterns.firstDropCollected ? this.patterns.firstDropCollected && 1.5 === n && this.position.y < 15 && (this.position.x = 1.5) : this.position.x = 1.5,
            this.position.y += -10,
            this.bb.setFromCenterAndSize(this.position, this.size),
            this.position.y < -3 && (this.props.onMissed && this.props.onMissed(this),
            this.index = this.patterns.getNextIndex(),
            this.activate()),
            this.sprite.update(e)
        }
        destroy() {
            this.bucket = null,
            this.patterns = null,
            super.destroy()
        }
    }
    const ms = .12;
    var gs = [{
        startTime: 0,
        speedFactor: 2.5,
        spawnDelay: 1e3,
        spawnDelayRandomness: 500
    }, {
        startTime: 5,
        speedFactor: 2.75,
        spawnDelay: 750,
        spawnDelayRandomness: 500
    }, {
        startTime: 10,
        speedFactor: 3.15,
        spawnDelay: 550,
        spawnDelayRandomness: 250
    }, {
        startTime: 20,
        speedFactor: 3.5,
        spawnDelay: 450,
        spawnDelayRandomness: 150
    }, {
        startTime: 30,
        speedFactor: 4,
        spawnDelay: 250,
        spawnDelayRandomness: 100
    }, {
        startTime: 40,
        speedFactor: 4.25,
        spawnDelay: 150,
        spawnDelayRandomness: 50
    }, {
        startTime: 50,
        speedFactor: 4.25,
        spawnDelay: 150,
        spawnDelayRandomness: 50
    }, {
        startTime: 60,
        speedFactor: 4.5,
        spawnDelay: 100,
        spawnDelayRandomness: 25
    }];
    class vs extends wr {
        init(e) {
            this.bounds = {},
            this.active = !1,
            this.hidding = !1,
            this.visible = !1,
            this.catched = !1,
            this.catchable = !1,
            e.scale = .02,
            this.minY = .6,
            this.maxY = 1,
            this.hideY = -3.5,
            this.z = .05 * e.index,
            this.spriteZ = this.z - .002,
            super.init(Object.assign({
                useCircleBounds: !0,
                spineId: "spider",
                touchable: !0,
                scale: .07
            }, e)),
            this.props = e,
            e.index % 2 && (this.spine.scale.x *= -1),
            this.offset = new ge.U(-.3,-.3,0),
            this.silk = this.addComponent(Dt, {
                batcher: e.scene.batchers.addSprites,
                sprite: "progress_bar",
                alpha: .3,
                z: this.spriteZ
            }),
            this.glowB = this.addComponent(Dt, {
                batcher: e.scene.batchers.addSprites,
                sprite: "progress_bubble",
                alpha: .05,
                z: this.spriteZ
            }),
            this.glowA = this.addComponent(Dt, {
                batcher: e.scene.batchers.addSprites,
                sprite: "progress_bubble",
                alpha: .08,
                z: this.spriteZ
            }),
            this.initTweens(),
            this.setFlash(0),
            this.speed = .01,
            this.speedFactor = $t.b.randomFloat(.8, 1),
            this.added = !1,
            this.reset()
        }
        initState() {
            this.state.data.defaultMix = .2,
            this.playAnimation("idle", !0, .1),
            this.offAnim = this.state.setAnimation(1, "off", !0),
            this.offAnim.alpha = 0,
            this.offAnim.mixDuration = 0
        }
        reset() {
            this.bounds.top = 4.6,
            this.bounds.bottom = -3,
            this.active = !1,
            this.hidding = !1,
            this.visible = !1,
            this.catched = !1,
            this.catchable = !1,
            this.offAnim.alpha = 0,
            this.removeTween();
            const e = this.playAnimation("idle", !0, .1)
              , t = e.animation;
            e.trackTime = t.duration * Math.random(),
            e.timeScale = $t.b.randomFloat(1, 2.5);
            const i = this.isFirstSpider ? 0 : $t.b.randomFloat(-1.5, 1.5);
            this.base.position.set(i, this.bounds.top, this.z),
            this.time = 0,
            this.speed = 0,
            this.speedFactor = 0,
            this.scaleFactor = 1e-4,
            this.silk.scale.set(0, 0),
            this.silkOffset = new ge.U(0,.6,0).multiplyScalar(this.scaleFactor),
            this.glowNeedsInstantUpdate = 2
        }
        activate(e) {
            this.isFirstSpider = e,
            this.reset(),
            this.active = !0,
            this.catchable = !0,
            this.speed = .01,
            this.speedFactor = $t.b.randomFloat(.8, 1),
            this.scaleFactor = $t.b.randomFloat(.7, .9),
            this.silk.scale.set(.15, 10),
            this.silkOffset = new ge.U(0,.6,0).multiplyScalar(this.scaleFactor),
            this.glowRandom = Math.random(),
            this.glowASpeed = $t.b.randomFloat(.004, .008),
            this.glowBSpeed = $t.b.randomFloat(.004, .008),
            this.isFirstSpider && (this.removeTween(),
            this.currentTween = $.a.to(this.base.position, 4.5, {
                y: 0,
                ease: Expo.easeOut
            }))
        }
        removeTween() {
            this.currentTween && (this.currentTween.pause(),
            this.currentTween = null)
        }
        hide() {
            this.playAnimation("action", !0, .1).timeScale = $t.b.randomFloat(1, 2.5),
            this.speedFactor *= 0,
            this.hidding = !0,
            this.removeTween(),
            this.currentTween = $.a.to(this.base.position, this.isFirstSpider ? .6 : .55, {
                y: this.bounds.top + .25 + Math.abs(this.base.position.y),
                ease: Z.a.easeIn.config(this.isFirstSpider ? 2 : 2.2)
            })
        }
        onClick() {
            !this.catched && this.catchable && (this.hide(),
            this.catched = !0,
            this.catchable = !1,
            this.props.onCollected && this.props.onCollected(this))
        }
        onMouseIn() {
            !this.catched && this.catchable && U.setCursor("pointer")
        }
        onMouseOut() {
            U.removeCursor()
        }
        updateCatched(e) {
            this.offAnim.alpha = Math.min(1, this.offAnim.alpha + .2)
        }
        update(e) {
            if (this.glowNeedsInstantUpdate || this.active) {
                if (super.update(e),
                this.time += e,
                this.catched && this.updateCatched(e),
                !this.isFirstSpider) {
                    if (!this.hidding) {
                        const e = this.speed * this.speedFactor * this.props.scene.level.speedFactor * (n.a.device.current.hasTouch ? 2 : 1);
                        this.base.position.y -= e
                    }
                    this.base.scale.setScalar(this.scaleFactor),
                    this.base.position.y < this.bounds.bottom && (this.props.onMissed && this.props.onMissed(this),
                    this.hide()),
                    this.hidding && this.base.position.y > this.bounds.top && this.reset()
                }
                this.updateAnchors(),
                this.updateAttachments()
            }
        }
        updateAttachments() {
            const e = this.anchors.boundMin.position;
            this.glowA.position.lerp(e, .8),
            this.glowB.position.lerp(e, .7);
            const t = this.time + this.glowRandom
              , i = .5 * (1 + Math.sin(t * this.glowASpeed))
              , n = .5 * (1 + Math.sin(t * this.glowBSpeed));
            this.glowA.scale.setScalar((.8 + .25 * i) * this.scaleFactor),
            this.glowB.scale.setScalar((1.3 + .25 * n) * this.scaleFactor),
            this.glowA.rotation += .07,
            this.glowB.rotation -= .06,
            this.glowNeedsInstantUpdate > 0 && (this.glowA.position.copy(e),
            this.glowB.position.copy(e),
            this.glowNeedsInstantUpdate--),
            this.silk.position.copy(this.base.position).add(this.silkOffset),
            this.glowA.position.z = this.spriteZ,
            this.glowB.position.z = this.spriteZ,
            this.silk.position.z = this.spriteZ
        }
        beforeDestroy() {
            super.beforeDestroy()
        }
    }
    class ys extends Li {
        constructor(e) {
            super(e),
            this.cam = new ge.G(0,0,0,0,-1e4,1e4),
            this.base = this.cam,
            r.a.recomputeDOMObjects.subscribe(this.resize, this)
        }
        resize() {
            const e = n.a.viewportSize.current;
            this.cam.left = 0,
            this.cam.right = e[0],
            this.cam.top = 0,
            this.cam.bottom = -e[1],
            this.cam.updateProjectionMatrix()
        }
        beforeDestroy() {
            r.a.recomputeDOMObjects.unsubscribe(this.resize, this),
            super.beforeDestroy()
        }
    }
    var bs = "precision highp float;\n#define GLSLIFY 1\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\n\nattribute vec2 uv;\nattribute vec3 position;\n\nattribute vec4 transforms; // xy: position | z: scale | w: orientation\nattribute vec3 color;\nattribute float fill;\nattribute vec2 timer;\n\nvarying float vDoodle;\nvarying vec3 vColor;\nvarying vec2 vUv;\nvarying vec3 vPos;\nvarying vec2 vTimer;\n\n#include <rotate>\n\nvoid main() {\n\n\tvUv = uv;\n\tvColor = color;\n\n\tvec2 transformed = position.xy * transforms.zw + transforms.xy;\n\n\tvPos = vec3(transforms.xy * 4., 1. - fill);\n\tvDoodle = time;\n\tvTimer = timer;\n\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, position.z, 1.);\n\n}\n"
      , xs = "precision highp float;\n#define GLSLIFY 1\n\n#define RADIUS 0.41\n#define SHADOW_RADIUS 0.45\n#define OFFSET_MULT 0.02\n\n#define ARC_THICKNESS 0.02\n#define ARC_RADIUS 0.46\n\n#ifndef PI2\n#define PI2 6.283185307\n#endif\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n#include <aastep>\n#include <atan2>\n\nuniform float time;\n\nconst vec3 white = vec3(1.);\nconst vec3 black = vec3(0.);\nconst vec2 center = vec2(0.5);\n\nvarying vec3 vPos;\nvarying vec3 vColor;\nvarying vec2 vTimer;\nvarying float vDoodle;\nvarying vec2 vUv;\n\nfloat arc (\n\tvec2 pos,\n\tvec2 bounds\n) {\n\n\tfloat progress = max(bounds.y - bounds.x, 0.);\n\tfloat dist = distance(pos, center);\n\tfloat ang = atan2(center.x - pos.x, center.y - pos.y) - PI / 4. + bounds.x * PI2 + vTimer.x * PI;\n\tang = mod((ang + PI / 4.), PI2) / (PI2);\n\n\t// float dotted = max(sign(mod(ang * PI2 * 60., PI2) - PI), 0.);\n\tfloat radius = ARC_RADIUS - vTimer.x * 0.03;\n\tfloat thickness = ARC_THICKNESS * clamp(smoothstep(0., 0.08, vTimer.y), 0., 1.);\n\tfloat shape = sign(progress) * (\n\t\taastep(radius, 0.007, dist) *\n\t\t(1. - aastep(radius + thickness, 0.007, dist))\n\t) * aastep(1. - progress, 0.004, ang); // * dotted;\n\n  return shape;\n\n}\n\nvoid main() {\n\n\tvec2 uv = vUv;\n\tuv.y = 1. - uv.y;\n\n\tvec2 offset = vec2(\n\t\tsnoise(vec2(uv.y * 1.2 + vDoodle, vPos.x)),\n\t\tsnoise(vec2(vPos.x, uv.x * 1.2 + vDoodle))\n\t) * (OFFSET_MULT);\n\n\tfloat circle = 1. - aastep(RADIUS, 0.007, distance(uv + offset, center));\n\tfloat stroke = aastep(RADIUS - 0.02, 0.007, distance(uv + offset, center));\n\n\tfloat shadow = (1. - aastep(\n\t\tRADIUS,\n\t\t0.008,\n\t\tdistance(uv + vec2(0., -0.03) + offset, center)\n\t)) * 0.8;\n\n\tfloat water1 = aastep(vPos.z, 0.007, uv.y + cos(vPos.x * 10. + time * 5. + uv.x * 2.9) * 0.03);\n\tfloat water2 = aastep(vPos.z + 0.05, 0.007, uv.y + cos(vPos.x * 5. + 40. + time * (2.1) + uv.x * 3.4) * 0.05);\n\n\tvec3 color = white;\n\tvec3 waterColor2 = mix(vColor, (vColor * vColor - 0.0001) * 0.9, 0.5);\n\tcolor = mix(color, waterColor2, water1);\n\tcolor = mix(color, vColor, water2);\n\n\tvec3 composite = mix(color, black, shadow);\n\tcomposite = mix(composite, color, circle);\n\n\tfloat timerArc = arc(uv + offset, vTimer);\n\tcomposite = mix(composite, white, timerArc);\n\n\tfloat alpha = max(timerArc, max(circle, shadow));\n\n\tgl_FragColor = vec4(composite, alpha);\n\n}\n\n";
    class ws extends ge.M {
        constructor(e={}) {
            super({
                vertexShader: bs,
                fragmentShader: xs,
                transparent: !0,
                depthTest: !1,
                depthWrite: !1,
                uniforms: {
                    time: {
                        value: 0
                    }
                }
            }),
            this.time = 0,
            y.c.add(e => {
                this.time += .001 * e,
                this.uniforms.time.value = this.time
            }
            )
        }
    }
    function _s(e, t) {
        t && (e = e.bind(t));
        let i = !1;
        function n() {
            i = !1,
            e()
        }
        return function() {
            i || (i = !0,
            Promise.resolve().then(n).catch(e => setTimeout( () => {
                throw e
            }
            , 0)))
        }
    }
    class Ts extends Tt {
        constructor(e={}) {
            super(e),
            this.domElement = null,
            this.bounds = null,
            this.anchor = new ge.T(.5,.5),
            this.useScale = !1,
            this.preserveRatio = !1,
            this.defferRequested = !1,
            this.recompute = Vi("recompute", this, 0),
            this.domPos = new ge.T
        }
        addListeners() {
            n.a.viewportSize.subscribe(this.defferRecompute, this),
            r.a.recomputeDOMObjects.subscribe(this.defferRecompute, this)
        }
        removeListeners() {
            n.a.viewportSize.unsubscribe(this.defferRecompute, this),
            r.a.recomputeDOMObjects.unsubscribe(this.defferRecompute, this)
        }
        attach(e, t={}) {
            this.domElement || this.addListeners(),
            this.domElement = e,
            this.preserveRatio = !!t.preserveRatio,
            this.useScale = void 0 === t.useScale || !!t.useScale,
            this.anchor.x = void 0 !== t.anchorX ? t.anchorX : .5,
            this.anchor.y = void 0 !== t.anchorY ? t.anchorY : .5,
            this.scaleMult = void 0 !== t.scaleMult ? t.scaleMult : 1,
            this.recompute()
        }
        detach() {
            this.domElement && this.removeListeners(),
            this.domElement = null
        }
        defferRecompute() {
            this.defferRequested || y.c.add(this.recompute)
        }
        afterRecompute() {}
        recompute() {
            this.domElement && !this.destroyed && (this.defferRequested = !1,
            this.bounds = this.domElement.getBoundingClientRect(),
            this.base.position.x = this.bounds.left + this.bounds.width * this.anchor.x,
            this.base.position.y = -this.bounds.top - this.bounds.height * this.anchor.y,
            this.domPos.copy(this.base.position),
            this.useScale && this.base.scale.set(this.bounds.width * this.scaleMult, (this.preserveRatio ? this.bounds.width : this.bounds.height) * this.scaleMult, 1),
            this.afterRecompute(this.bounds),
            y.c.remove(this.recompute))
        }
        destroy() {
            y.c.remove(this.recompute),
            this.detach(),
            super.destroy()
        }
    }
    const Ms = wt()(.525, .005, .48, .995)
      , Ss = wt()(.36, .005, .695, .995)
      , As = 300;
    class Ps extends Ts {
        constructor(e={}) {
            super(e),
            this.updateButtonState = _s(this.updateButtonState, this),
            this.type = e.type,
            this.index = ["sun", "game", "water", "gift"].indexOf(this.type),
            this.rules = ee.a.rules.current.refills[this.type],
            this.isGift = "gift" === this.type,
            this.nonCountingResource = "game" === this.type || "gift" === this.type,
            this.isGift || (this.resource = te.a.resources[this.type],
            this.maxResource = this.rules.limit);
            const t = ee.a.resourcesColors.current[this.type];
            this.color = t.light,
            this.circTimer = new ge.T,
            this.circTimerLerp = 0,
            this.circTimerY = 0,
            this.realTimerY = 0,
            this.position = this.base.position,
            this.scale = new ge.T,
            this.fill = 0,
            this.fillTarget = 0,
            e.color && this.color.copy(e.color),
            this.scaleX = new ye.a({
                initial: 1
            }),
            this.scaleY = new ye.a({
                initial: 1
            }),
            this.baseScale = new ge.T,
            this.enter = Vi(this.enter, this, 1),
            this.leave = Vi(this.leave, this, 1),
            this.up = Vi(this.up, this, 1),
            this.down = Vi(this.down, this, 1),
            this.currentTarget = 1,
            this.spriteScale = .85;
            const i = ge.T.get();
            i.setScalar(this.spriteScale),
            this.activeColor = "gift" === this.type ? t.light : t.normal,
            this.emptyColor = new ge.k(14540253),
            this.sprite = new Dt({
                batcher: e.batcher,
                sprite: "icon_" + this.type,
                color: t.normal,
                scale: i
            }),
            i.release(),
            this.isGift || this.resource.amount.subscribe(this.onResourceUpdate, this),
            this.isGift || ee.a.resourceButtonReceive[this.type].subscribe(this.onResourceReceive, this),
            te.a.flags.subscribe(this.onPlayerFlagsUpdate, this),
            te.a.resources.water.amount.subscribe(this.onPlayerFlagsUpdate, this),
            this.onPlayerFlagsUpdate(),
            "water" !== this.type && "sun" !== this.type || (te.a.currentSeed.subscribe(this.onSeedChange, this),
            this.onSeedChange()),
            this.updateButtonState(!0),
            this.basePosition = new ge.T,
            this.periode0 = 0,
            this.periode1 = 0,
            this.periode2 = 0,
            this.visibilityOffset = {
                y: 0
            }
        }
        resetTimer() {
            this.circTimerY = 0,
            this.circTimer.x = 0,
            this.circTimerLerp = 1
        }
        enter(e) {
            e.preventDefault(),
            this.empty || (this.currentTarget = 1.1,
            this.scaleX.setTarget(this.currentTarget),
            this.scaleY.setTarget(this.currentTarget),
            this.scaleX.setTension(.2),
            this.scaleX.setFriction(.12),
            this.scaleY.setTension(.3),
            this.scaleY.setFriction(.18),
            ve.a.play("mouse_hover"))
        }
        leave(e) {
            e && e.preventDefault(),
            this.empty || this.resetButtonScale()
        }
        resetButtonScale() {
            this.currentTarget = 1,
            this.scaleX.setTarget(this.currentTarget),
            this.scaleY.setTarget(this.currentTarget),
            this.scaleX.setTension(.13),
            this.scaleX.setFriction(.12),
            this.scaleY.setTension(.23),
            this.scaleY.setFriction(.09)
        }
        down(e) {
            if (e && e.preventDefault(),
            this.empty)
                return this.cantGive || ve.a.play("give_empty"),
                void (this.pressed = !1);
            this.cantGive,
            this.scaleX.setValue(this.currentTarget - .2),
            this.scaleY.setValue(this.currentTarget - .2),
            this.scaleX.setTarget(this.currentTarget - .1),
            this.scaleY.setTarget(this.currentTarget - .1),
            this.props.onClick ? this.props.onClick() : (this.give(),
            this.pressed = !0,
            this.timerAuto = As)
        }
        give() {
            this.empty && (this.up(),
            this.resetButtonScale(),
            this.pressed = !1);
            const e = te.a.currentSeed.current;
            if (!e || !e.scene.current || !e.scene.current.seed)
                return;
            const t = e.scene.current.seed.giveResource(this.type);
            this.nonCountingResource || t || (this.up(),
            this.resetButtonScale(),
            this.pressed = !1)
        }
        up(e) {
            e && e.preventDefault(),
            this.pressed = !1,
            this.scaleX.setTarget(this.currentTarget),
            this.scaleY.setTarget(this.currentTarget)
        }
        onResourceReceive(e) {
            this.scaleX.setTarget(.8),
            this.scaleY.setTarget(.8),
            this.scaleX.setValue(.8 + .05),
            this.scaleY.setValue(.8),
            this.scaleX.setTarget(this.currentTarget),
            this.scaleY.setTarget(this.currentTarget)
        }
        onPlayerFlagsUpdate() {
            if ("game" === this.type) {
                const e = te.a.flags.current
                  , t = te.a.resources.water.amount.current <= 0
                  , i = !e.openGame && te.a.gameButtonCalled.current;
                this.locked = !(e.openGame || e.gaveSun && e.gaveLove && (i || e.gaveWater || t))
            }
            this.updateButtonState()
        }
        onResourceUpdate() {
            this.updateButtonState()
        }
        onSeedChange() {
            this.currentSeed && this.currentSeed.resources[this.type].query.unsubscribe(this.onResourceUpdate, this),
            this.currentSeed = te.a.getCurrent(),
            this.currentSeed && this.currentSeed.resources[this.type].query.subscribe(this.onResourceUpdate, this),
            this.updateButtonState()
        }
        updateButtonState(e) {
            if (this.isGift)
                return void (this.empty = !1);
            if ("water" === this.type || "sun" === this.type) {
                const e = this.currentSeed && this.currentSeed.resources[this.type].query.current;
                this.cantGive = !e || e.received >= e.asked
            } else
                this.cantGive = !1;
            const t = this.resource.amount.current
              , i = t / this.maxResource;
            this.empty = t < 1 || this.locked,
            this.domElement && (this.domElement.classList.toggle("locked", this.empty),
            (this.empty || this.cantGive) && this.resetButtonScale()),
            "game" === this.type ? this.fill = this.fillTarget = 0 : (this.fillTarget = i,
            e && (this.fill = this.fillTarget))
        }
        timerUpdate(e) {
            const t = ee.a.dateFloat.current
              , i = this.resource.amount.current
              , n = this.resource.lastRefill.current
              , r = this.rules.delay
              , s = i < this.rules.limit ? Object(b.clamp)((t - n) / r, 0, 1) : 0;
            (s >= 1 || s < this.realTimerY) && 0 === this.circTimerLerp && this.resetButtonTimer(this.realTimerY),
            this.realTimerY = s,
            this.circTimer.y = Object(b.lerp)(this.realTimerY, this.circTimerY, this.circTimerLerp),
            this.pressed && (this.timerAuto -= e,
            this.timerAuto <= 0 && (this.timerAuto = Math.max(As - Math.abs(this.timerAuto), 10),
            this.give()))
        }
        resetButtonTimer(e) {
            this._lastFrom = e,
            this.circTimer.x = 0,
            this.circTimerY = e,
            this.circTimerLerp = 1,
            this.tweens.resetTimer && this.tweens.resetTimer.clear().kill(),
            this.tweens.resetTimer = new J.a({
                paused: !0
            }).to(this, .7, {
                timerY: 1,
                ease: Xe.d.easeInOut
            }, "+=0.1").to(this.circTimer, .7, {
                x: 1,
                ease: Xe.d.easeInOut
            }, 0).call(this.resetTimer, null, this).to(this, 2, {
                circTimerLerp: 0,
                ease: Xe.d.easeOut
            }, .7),
            this.tweens.resetTimer.seek(0).restart()
        }
        update(e) {
            if (this.periode0 = (this.periode0 + .008 * e) % (2 * Math.PI),
            this.periode1 = (this.periode1 + .0083 * e) % (2 * Math.PI),
            this.periode2 = (this.periode2 + .0093 * e) % (2 * Math.PI),
            this.nonCountingResource || this.timerUpdate(e),
            this.sprite.color.lerp(this.empty ? this.emptyColor : this.activeColor, .1),
            this.scaleX.update(e),
            this.scaleY.update(e),
            this.baseScale.x = this.base.scale.x * this.scaleX.value,
            this.baseScale.y = this.base.scale.y * this.scaleY.value,
            this.scale.x = this.baseScale.x,
            this.scale.y = this.baseScale.y,
            this.base.position.y = this.domPos.y - this.visibilityOffset.y,
            this.sprite.position.copy(this.position),
            this.sprite.scale.copy(this.scale),
            "gift" === this.type) {
                const e = .085 * (Ms(.5 * (Math.cos(this.periode1) + 1)) - .5)
                  , t = .09 * (Ss(.5 * (Math.sin(this.periode2) + 1)) - .5);
                this.sprite.rotation = .07 * Math.cos(this.periode0),
                this.sprite.scale.x *= 1 + e,
                this.sprite.scale.y *= 1 + t
            }
            const t = ee.a.resourceButtonPositions[this.type];
            t && (t.x = this.base.position.x,
            t.y = this.base.position.y),
            this.fill = Object(b.lerp)(this.fill, this.fillTarget, .05),
            super.update(e)
        }
        beforeDestroy() {
            this.resource.amount.unsubscribe(this.onResourceUpdate, this),
            ee.a.resourceButtonReceive[this.type].unsubscribe(this.onResourceReceive, this),
            this.resource = null,
            this.rules = null,
            this.color = this.position = this.scale = null,
            this.scaleX.dispose(),
            this.scaleY.dispose(),
            this.sprite.destroy(),
            "water" !== this.type && "sun" !== this.type || (te.a.currentSeed.unsubscribe(this.onSeedChange, this),
            this.currentSeed && this.currentSeed.resources[this.type].query.unsubscribe(this.onResourceUpdate, this)),
            super.beforeDestroy()
        }
        recompute() {
            super.recompute();
            const e = ee.a.guideAnchors.current;
            if (!e[this.type])
                return;
            const t = this.nonCountingResource ? -1 : 1;
            e[this.type].position.x = this.position.x + .25 * this.baseScale.x * t,
            e[this.type].position.y = this.position.y + .25 * this.baseScale.y,
            ee.a.guideAnchors.set(e, !0)
        }
    }
    let Cs;
    const Ls = []
      , ks = () => {
        let e = Ls.shift();
        if (e)
            return e;
        e = new ge.p;
        const t = ge.I.simple;
        e.index = t.index,
        e.attributes.position = t.attributes.position,
        e.attributes.uv = t.attributes.uv;
        const i = new Float32Array(40)
          , n = new ge.q(i,10).setDynamic(!0);
        return e.addAttribute("transforms", new ge.s(n,4,0,!1)),
        e.addAttribute("fill", new ge.s(n,1,4,!1)),
        e.addAttribute("color", new ge.s(n,3,5,!1)),
        e.addAttribute("timer", new ge.s(n,2,8,!1)),
        n.needsUpdate = !0,
        e
    }
    ;
    class Es extends Tt {
        constructor(e={}) {
            super(e),
            Cs || (Cs = new ws),
            this.geo = ks(),
            this.base = new ge.x(this.geo,Cs),
            this.base.frustumCulled = !1,
            this.water = this.addComponent(new Ps({
                type: "water",
                batcher: e.batcher
            })),
            this.game = this.addComponent(new Ps({
                type: "game",
                batcher: e.batcher
            })),
            this.sun = this.addComponent(new Ps({
                type: "sun",
                batcher: e.batcher
            })),
            this.gift = this.addComponent(new Ps({
                type: "gift",
                batcher: e.batcher
            })),
            this.buttons = [this.water, this.game, this.sun, this.gift],
            this.initButtonAttrs()
        }
        initButtonAttrs() {
            const e = this.geo.attributes.fill.data
              , t = e.array
              , i = e.stride;
            e.needsUpdate = !0;
            for (let e = 0, n = this.buttons.length; e < n; e++) {
                const n = this.buttons[e];
                t[e * i + 0] = n.position.x,
                t[e * i + 1] = n.position.y,
                t[e * i + 2] = n.scale.x,
                t[e * i + 3] = n.scale.y,
                t[e * i + 4] = n.fill,
                t[e * i + 5] = n.color.r,
                t[e * i + 6] = n.color.g,
                t[e * i + 7] = n.color.b,
                t[e * i + 8] = n.circTimer.x,
                t[e * i + 9] = n.circTimer.y
            }
        }
        update(e) {
            super.update(e);
            const t = this.geo.attributes.fill.data
              , i = t.array
              , n = t.stride;
            t.needsUpdate = !0;
            for (let e = 0, t = this.buttons.length; e < t; e++) {
                const t = this.buttons[e];
                i[e * n + 0] = t.position.x,
                i[e * n + 1] = t.position.y,
                i[e * n + 2] = t.scale.x,
                i[e * n + 3] = t.scale.y,
                i[e * n + 4] = t.fill,
                i[e * n + 8] = t.circTimer.x,
                i[e * n + 9] = t.circTimer.y
            }
        }
        beforeDestroy() {
            Ls.push(this.geo),
            this.data = this.geo = null
        }
    }
    const Is = Object(me.a)("ℹ️ TUTORIAL", "black", "#ddeeff", 1).log
      , Fs = {
        gaveLove: 1,
        openBag: 1,
        openMessage: 1
    };
    let Os = null;
    const Rs = {
        gaveSun: "sun",
        gaveWater: "water",
        gaveLove: "seed",
        openBag: "bag",
        openGarden: "garden",
        openGift: "gift",
        openGame: "game",
        openMessage: "seed"
    }
      , zs = {
        gaveSun: "sun",
        gaveWater: "water",
        gaveLove: "love",
        openGarden: "garden",
        openGame: "game"
    };
    class Ns extends Tt {
        constructor(e) {
            super(e),
            this.updateAnchor = _s(this.updateAnchor, this)
        }
        init(e) {
            this.currentQuery = 0,
            this.isHideComplete = !0,
            this.isShowComplete = !0,
            this.lastFlagHide = null,
            this.lastHide = 0,
            this.lastGlow = 0,
            this.flagTime = 0,
            this.flags = {
                inSeedView: !1,
                seedChanging: !1,
                noAnchor: !1,
                hidden: !0
            },
            this.base = new ge.F,
            this.size = 110,
            this.shadow = this.addComponent(Dt, {
                batcher: e.batcher,
                sprite: "hand_shadow",
                color: new ge.k(0),
                position: new ge.U(0,0,3)
            }),
            this.hand = this.addComponent(Dt, {
                batcher: e.batcher,
                sprite: "hand",
                position: new ge.U(0,0,3)
            }),
            this.offset = {
                shadow: new ge.T(-.25,.06),
                shadow2: new ge.T(-.15,.21),
                hand: new ge.T(-.25,.25)
            },
            this.anchor = ee.a.guideAnchors.current.seed,
            this.periode = 0,
            this.initTweens(),
            this.tweens.hide.progress(1),
            this.seedUnlisteners = [],
            this.addListeners(),
            this.updateAnchor()
        }
        initTweens() {
            this.switchAnchor = this.switchAnchor.bind(this),
            this.getShowDelay = this.getShowDelay.bind(this),
            this.hideComplete = this.hideComplete.bind(this),
            this.showComplete = this.showComplete.bind(this),
            this.showText = this.showText.bind(this),
            this.hideText = this.hideText.bind(this),
            this.tweens = {},
            this.currentTween = null,
            this.data = {
                handX: 0,
                handY: 0,
                handScaleX: 0,
                handScaleY: 0,
                handRotation: 0,
                handAlpha: 0,
                shadowX: 0,
                shadowY: 0,
                shadowScaleX: 1,
                shadowScaleY: 1,
                shadowRotation: 0,
                shadowAlpha: 0
            },
            this.tweens.new = new J.a({
                paused: !0
            }).add(this.switchAnchor).add(this.showText).addLabel("init", "+=0.25").to(this.data, .1, {
                handAlpha: 1
            }, "init+=0").to(this.data, .15, {
                shadowAlpha: 1
            }, "init+=0.25").to(this.data, 1.5, {
                handScaleX: 1,
                ease: Z.d.easeOut.config(1, .25)
            }, "init+=0").to(this.data, 1.4, {
                handScaleY: 1,
                ease: Z.d.easeOut.config(1, .3),
                delay: .05
            }, "init+=0").add(this.showComplete),
            this.tweens.show = new J.a({
                paused: !0
            }).add(this.switchAnchor).add(this.showText).addLabel("init", "+=0.25").to(this.data, .1, {
                handAlpha: 1
            }, "init+=0").to(this.data, .15, {
                shadowAlpha: 1
            }, "init+=0.25").to(this.data, 1.5, {
                handScaleX: 1,
                ease: Z.d.easeOut.config(1, .25)
            }, "init+=0").to(this.data, 1.4, {
                handScaleY: 1,
                ease: Z.d.easeOut.config(1, .3),
                delay: .05
            }, "init+=0").add(this.showComplete),
            this.tweens.hide = new J.a({
                paused: !0
            }).add(this.hideText).to(this.data, .3, {
                handScaleX: 0,
                handScaleY: 0,
                ease: Z.a.easeIn.config(4)
            }).to(this.data, .1, {
                shadowAlpha: 0
            }, .15).set(this.data, {
                handAlpha: 0
            }).add(this.hideComplete),
            this.tweens.complete = new J.a({
                paused: !0
            }).add(this.hideText).to(this.data, .3, {
                handScaleX: 0,
                handScaleY: 0,
                ease: Z.a.easeIn.config(4)
            }).to(this.data, .1, {
                shadowAlpha: 0
            }, .15).set(this.data, {
                handAlpha: 0
            }).add(this.hideComplete)
        }
        showText() {
            const e = zs[this.currentFlag];
            e && (Is("Text", e),
            oc.showGuideText(e))
        }
        hideText() {
            oc.hideGuideText()
        }
        showComplete() {
            this.isShowComplete = !0
        }
        hideComplete() {
            this.hidding = !1,
            this.isHideComplete = !0,
            this.onHide && this.onHide()
        }
        switchAnchor() {
            this.isShowComplete = !1,
            this.isHideComplete = !1,
            this.flagTime = 0;
            const e = this.currentFlag
              , t = ee.a.guideAnchors.current[Rs[e]];
            this.anchor = t,
            this.fadableFlag = Fs[e]
        }
        getShowDelay() {
            const e = this.currentFlag === this.lastFlagHide && "openBag" !== this.lastFlagHide && "openGift" !== this.lastFlagHide && "openMessage" !== this.lastFlagHide && "gaveLove" !== this.lastFlagHide ? 200 : 1100
              , t = Date.now() - this.lastHide;
            return Object(b.clamp)(e - t, 10, e)
        }
        addListeners() {
            te.a.resources.water.amount.subscribe(this.updateAnchor, this),
            n.a.resourceButtonsVisible.subscribe(this.updateAnchor, this),
            n.a.seedUiVisible.subscribe(this.onSeedUiVisible, this),
            te.a.currentSeed.subscribe(this.onSeed, this),
            te.a.flags.subscribe(this.updateAnchor, this),
            n.a.menuOpen.subscribe(this.updateAnchor, this),
            ee.a.muteGuide.subscribe(this.updateAnchor, this),
            ee.a.gardenNotification.subscribe(this.updateAnchor, this),
            this.onSeedUiVisible(n.a.seedUiVisible.current),
            this.onSeed(te.a.currentSeed.current)
        }
        onSeedUiVisible(e) {
            this.flags.inSeedView = e,
            this.flags.seedChanging = !1
        }
        onSeed(e) {
            this.seedUnlisteners.forEach(e => e()),
            this.seedUnlisteners = [],
            this.currentSeed = e,
            e && (this.seedListen(e.level),
            this.seedListen(e.visibleLevel),
            this.seedListen(e.resources.sun.visibleQuery),
            this.seedListen(e.resources.water.visibleQuery),
            this.seedListen(e.resources.love.visibleQuery),
            this.seedListen(e.resources.message.visibleQuery),
            this.seedListen(e.unlocked),
            this.updateAnchor())
        }
        seedListen(e) {
            const t = e.subscribe(this.updateAnchor, this);
            this.seedUnlisteners.push( () => e.unsubscribe(t))
        }
        updateAnchor() {
            const e = this.currentSeed;
            if (!e)
                return;
            const t = te.a.flags.current;
            t[this.currentFlag] && this.completeFlag();
            const i = e.level.current >= 4 && e.visibleLevel.current >= 4
              , r = !t.openGame && te.a.gameButtonCalled.current
              , s = te.a.resources.water.amount.current <= 0
              , a = (r || s || t.gaveWater) && t.gaveSun && t.gaveLove && n.a.resourceButtonsVisible.get()
              , o = !t.openGame && null !== e.resources.water.visibleQuery.current
              , l = null !== e.resources.sun.visibleQuery.current
              , c = null !== e.resources.love.visibleQuery.current
              , h = null !== e.resources.message.visibleQuery.current
              , u = e.unlocked.current && e.level.current < 1
              , p = t.gaveSun && t.gaveLove && t.gaveWater && t.openGame && ee.a.gardenNotification.current && !n.a.menuOpen.current;
            let d = null;
            u && !t.openBag ? d = "openBag" : a && !t.openGame ? d = "openGame" : l && !t.gaveSun ? d = "gaveSun" : c && !t.gaveLove ? d = "gaveLove" : o && !t.gaveWater ? d = "gaveWater" : h && !t.openMessage ? d = "openMessage" : p && t.openMessage && !t.openGarden ? d = "openGarden" : i && t.openMessage && t.openGarden && !t.openGift && (d = "openGift"),
            Is(d),
            "openGame" === d && te.a.gameButtonCalled.set(!0),
            ee.a.muteGuide.current && (d = !1),
            this.flags.noAnchor = !d,
            d && this.useFlag(d)
        }
        useFlag(e) {
            this.previousFlag = this.currentFlag,
            this.currentFlag = e,
            this.previousFlag !== this.currentFlag ? this.show() : this.discreteShow(),
            this.previousFlag = this.currentFlag
        }
        show() {
            if (this.previousFlag === this.currentFlag && !this.flags.hidden)
                return;
            Os && Os.destroy(),
            Os && (Os = null),
            Is("New flag " + this.currentFlag),
            this.currentQuery++;
            const e = this.currentQuery;
            this.flags.hidden = !1,
            this.ensureHide( () => {
                e === this.currentQuery && (Os = Object(Mn.a)(this.getShowDelay(), () => {
                    e === this.currentQuery && (this.currentTween && this.currentTween.pause(),
                    this.currentTween = this.tweens.new,
                    this.currentTween.invalidate().restart(!0))
                }
                ))
            }
            )
        }
        discreteShow() {
            if (this.previousFlag === this.currentFlag && !this.flags.hidden)
                return;
            Os && Os.destroy(),
            Os && (Os = null),
            Is("Show flag " + this.currentFlag),
            this.currentQuery++;
            const e = this.currentQuery;
            this.flags.hidden = !1,
            this.ensureHide( () => {
                e === this.currentQuery && (Os = Object(Mn.a)(this.getShowDelay(), () => {
                    e === this.currentQuery && (this.currentTween && this.currentTween.pause(),
                    this.currentTween = this.tweens.show,
                    this.currentTween.invalidate().restart(!0))
                }
                ))
            }
            )
        }
        ensureHide(e) {
            if (this.isHideComplete)
                return e();
            this.onHide = e,
            this.isShowComplete = !1,
            this.hidding = !0,
            this.currentTween && this.currentTween.pause(),
            this.currentTween = this.tweens.hide,
            this.currentTween.invalidate().restart(!0)
        }
        hide() {
            this.flags.hidden || (Os && Os.destroy(),
            Os && (Os = null),
            Is("Hide flag " + this.currentFlag),
            this.currentQuery++,
            this.flags.hidden = !0,
            this.lastFlagHide = this.currentFlag,
            this.lastHide = Date.now(),
            this.isHideComplete = !1,
            this.hidding = !0,
            this.onHide = null,
            this.isShowComplete = !1,
            this.currentTween && this.currentTween.pause(),
            this.currentTween = this.tweens.hide,
            this.currentTween.invalidate().restart(!0))
        }
        completeFlag() {
            this.flags.hidden || (Os && Os.destroy(),
            Os && (Os = null),
            Is("Complete flag " + this.currentFlag),
            this.currentQuery++,
            this.lastHide = Date.now(),
            this.lastFlagHide = this.currentFlag,
            this.flags.hidden = !0,
            this.currentFlag = null,
            this.hidding = !1,
            this.isHideComplete = !1,
            this.onHide = null,
            this.isShowComplete = !1,
            this.currentTween && this.currentTween.pause(),
            this.currentTween = this.tweens.complete,
            this.currentTween.invalidate().restart(!0))
        }
        needsHide() {
            const e = this.flags;
            return ee.a.muteGuide.current,
            !e.inSeedView || e.seedChanging || e.noAnchor
        }
        update(e) {
            this.needsHide() ? this.hide() : this.show(),
            this.flagTime += e,
            this.periode = (this.periode + .008 * e) % (2 * Math.PI);
            const t = this.fadableFlag ? 1 - 8 * Math.abs(ee.a.blobOffset.current) : 1;
            this.base.position.copy(this.anchor.position),
            this.base.scale.x = this.size * this.anchor.scale.x,
            this.base.scale.y = this.size * this.anchor.scale.y;
            const i = this.base.position
              , n = this.base.scale
              , r = this.offset
              , s = this.anchor.scale.y > 0 ? this.offset.shadow : this.offset.shadow2
              , a = .03 * Math.cos(this.periode) * .8
              , o = .035 * -Math.cos(this.periode) * .8;
            this.hand.position.x = i.x + (r.hand.x + a) * n.x,
            this.hand.position.y = i.y + (r.hand.y + o) * n.y,
            this.hand.rotation = .06 * Math.cos(this.periode) * this.anchor.scale.x,
            this.hand.alpha = 1,
            this.hand.scale.set(n.x + 1.1 * o * n.x * this.anchor.scale.y, n.y + 1.6 * a * n.y * this.anchor.scale.y),
            this.shadow.position.x = i.x + (s.x - .1 * a) * n.x,
            this.shadow.position.y = i.y + (s.y - .1 * o) * n.y,
            this.shadow.scale.set(n.x + 1.1 * a * n.x * this.anchor.scale.y, n.y + 1.1 * o * n.y * this.anchor.scale.y),
            this.shadow.rotation = -.09 * Math.cos(this.periode) * this.anchor.scale.x,
            this.shadow.alpha = .95 + .4 * Math.cos(this.periode),
            this.hand.alpha *= this.data.handAlpha,
            this.hand.scale.x *= this.data.handScaleX,
            this.hand.scale.y *= this.data.handScaleY,
            this.shadow.alpha *= this.data.shadowAlpha,
            this.shadow.scale.x *= this.data.shadowScaleX,
            this.shadow.scale.y *= this.data.shadowScaleY,
            this.hand.alpha *= t,
            this.shadow.alpha *= t
        }
        beforeDestroy() {}
    }
    var Ds = i(13);
    const Us = 40
      , Bs = 2500
      , js = 1e3
      , Vs = wt()(.6, 0, 1, .565)
      , Gs = wt()(0, .425, .475, 1)
      , Xs = wt()(0, .47, .38, .975);
    $t.b.randomFloat(0, 10),
    $t.b.randomFloat(0, 10);
    class Ys extends Dt {
        constructor(e) {
            e.sprite = "resource_" + e.type,
            e.z = 100,
            super(e),
            this.time = 0,
            this.size = Us,
            this.scale.setScalar(this.size),
            this.ang = Ci({
                current: 0,
                target: 0,
                ease: .001,
                angle: !0
            }),
            this.velocity = 0,
            this.maxAcceleration = 5,
            this.maxVelocity = 5,
            this.v = new ge.T,
            this.initPos()
        }
        initPos() {
            const e = this.position
              , t = ee.a.resourceButtonPositions[this.props.type]
              , i = n.a.viewportSize.current
              , r = t.x > .5 * i[0] ? 1 : -1
              , s = this.size
              , a = $t.b.randomFloat(-10, 20) * -r
              , o = Object(b.degToRad)($t.b.randomFloat(-30, 50) * -r);
            e.x = t.x + s * r + a,
            e.y = -i[1] - .5 * this.size;
            const l = 2 * e.x - t.x;
            this.ang.current = Object(b.ang)(e.x, e.y, l, t.y) + o,
            this.ang.target = this.ang.current,
            this.acceleration = 1,
            this.velocity = 0,
            this.maxVelocity = 5,
            this.duration = $t.b.randomFloat(1e3, 1600)
        }
        update(e) {
            this.time += e;
            const t = Object(b.clamp)(this.time / this.duration, 0, 1);
            this.ang.update(e);
            const i = this.v
              , n = this.position;
            i.x = Math.cos(this.ang.current) * this.velocity,
            i.y = Math.sin(this.ang.current) * this.velocity,
            n.x += this.v.x,
            n.y += this.v.y;
            const r = ee.a.resourceButtonPositions[this.props.type]
              , s = Object(b.dist)(n.x, n.y, r.x, r.y)
              , a = 9 * Xs(Math.min(1, .005 * s));
            this.ang.target = Object(b.ang)(n.x, n.y, r.x, r.y),
            this.ang.setEase(Object(b.lerp)(3e-4, .019, Gs(t))),
            this.velocity = a;
            const o = Xs(Object(b.clamp)(Object(b.norm)(s, 10, 40), 0, 1));
            this.decrease = this.time > Bs ? 1 - Vs(Object(b.clamp)((this.time - Bs) / js, 0, 1)) : 1;
            const l = o * this.size * this.decrease;
            this.scale.setScalar(l),
            l <= .01 && this.destroy()
        }
        destroy() {
            this.props.onComplete && this.props.onComplete(this.props.type),
            super.destroy()
        }
    }
    const Ws = 3e3
      , qs = 700
      , Hs = 150;
    let Qs = 0;
    const Js = e => ({
        type: e,
        pending: 0,
        timer: 0
    });
    class Zs extends Tt {
        constructor(e={}) {
            super(e),
            n.a.seedUiVisible.subscribe(this.onSeedUIVisibility, this),
            this.visible = !1,
            this.visibleTimer = qs,
            this.onBiscuitComplete = this.onBiscuitComplete.bind(this),
            this.water = Js("water"),
            this.sun = Js("sun"),
            this.updateWater = this.updatePool.bind(this, this.water),
            this.updateSun = this.updatePool.bind(this, this.sun),
            this.pool = [this.water, this.sun],
            te.a.resources.water.collectable.subscribe(this.updateWater),
            te.a.resources.sun.collectable.subscribe(this.updateSun),
            this.onSeedUIVisibility()
        }
        onSeedUIVisibility() {
            const e = n.a.seedUiVisible.current;
            this.visible && !e ? this.visible = !1 : !this.visible && e && (this.water.timer = 0,
            this.sun.timer = 0,
            this.visibleTimer = qs,
            this.visible = !0)
        }
        beforeDestroy() {
            te.a.resources.water.collectable.unsubscribe(this.updateWater),
            te.a.resources.sun.collectable.unsubscribe(this.updateSun),
            n.a.seedUiVisible.unsubscribe(this.onSeedUIVisibility, this)
        }
        updatePool(e) {
            te.a.resources[e.type].collectable.current
        }
        onBiscuitComplete(e) {
            const t = this[e]
              , i = te.a.resources[t.type].collectable;
            t.pending <= 0 || i.current < t.pending ? t.pending = 0 : (t.pending--,
            i.set(Math.max(0, i.current - 1)),
            V.a.addResource(e, 1),
            n.a.resourceButtonsVisible.current && (ve.a.play("get_" + e),
            ee.a.resourceButtonReceive[e].dispatch()),
            t.pending <= 0 && (Qs = Ws))
        }
        allocNewBiscuit(e) {
            e.pending++,
            this.addComponent(Ys, {
                type: e.type,
                batcher: this.props.batcher,
                onComplete: this.onBiscuitComplete
            })
        }
        updateVisible(e) {
            for (let t = 0, i = this.pool.length; t < i; t++) {
                const i = this.pool[t]
                  , n = te.a.resources[i.type].collectable;
                i.pending >= n.current || (i.timer <= 0 ? (i.timer = Math.max(10, Hs + i.timer),
                this.allocNewBiscuit(i)) : i.timer -= e)
            }
        }
        update(e) {
            super.update(e),
            this.visible && (this.visibleTimer <= 0 ? this.updateVisible(e) : this.visibleTimer -= e),
            Qs > 0 && (Qs -= e) <= 0 && (Qs = 0,
            Ds.a.requestSave())
        }
    }
    const $s = wt()(.57, .005, .25, 1)
      , Ks = 1e3
      , ea = 300
      , ta = {
        Blue: new ge.k(.044,.058,.259),
        White: new ge.k(1,1,1),
        Gold: new ge.k(.838,.653,.318),
        Gold2: new ge.k(1,.804,.358),
        Grey: new ge.k(.655,.655,.655)
    }
      , ia = (e, t, i) => new Dt({
        batcher: i,
        sprite: "progress_bubble",
        position: t.set(0, 0, 2 * e * .1 + .3),
        rotation: .6 * e,
        color: ta.White
    })
      , na = (e, t, i) => new Dt({
        batcher: i,
        sprite: "progress_" + ["one", "two", "three"][e % 3],
        position: t.set(0, 0, .1 * (2 * e + 1) + .3),
        color: ta.Blue
    });
    class ra extends Ts {
        constructor(e={}) {
            super(e),
            this.barHeight = 300,
            this.spriteScale = 100 / 3,
            this.circleRadius = 28,
            this.circleBleed = [-15, 9],
            this.thickness = 3;
            const t = ge.U.get()
              , i = ge.T.get();
            this.goldPeriod = 0,
            this.goldColor = ta.Gold.clone(),
            this.gaugeBackground = new Dt({
                batcher: e.batcher,
                sprite: "progress_bar",
                position: t.set(50, -50, .1),
                scale: i.set(10, 10)
            }),
            this.gauge = new Dt({
                batcher: e.batcher,
                sprite: "progress_bar",
                position: t.set(50, -50, .2),
                scale: i.set(10, 10),
                color: this.goldColor
            }),
            this.steps = [{
                bubble: ia(0, t, e.batcher),
                number: na(0, t, e.batcher),
                scale: new ye.a({
                    initial: 1
                }),
                y: .25,
                colorMix: 0
            }, {
                bubble: ia(1, t, e.batcher),
                number: na(1, t, e.batcher),
                scale: new ye.a({
                    initial: 1
                }),
                y: .5,
                colorMix: 0
            }, {
                bubble: ia(2, t, e.batcher),
                number: na(2, t, e.batcher),
                scale: new ye.a({
                    initial: 1
                }),
                y: .75,
                colorMix: 0
            }, {
                giftBg: new Dt({
                    batcher: e.batcher,
                    sprite: "progress_bubblegift",
                    position: t.set(0, 0, 1),
                    color: ta.White
                }),
                gift: new Dt({
                    batcher: e.batcher,
                    sprite: "progress_gift",
                    position: t.set(0, 0, 1.2),
                    color: ta.Grey
                }),
                scale: new ye.a({
                    initial: 1
                }),
                y: 1,
                colorMix: 0
            }];
            const n = this.steps
              , r = [.005, .012, .012];
            this.computedBounds = [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
            this.levelBounds = [0, n[0].y + r[0], n[1].y + r[1], n[2].y + r[2], 1],
            this.progress = Ci({
                current: 0,
                target: 0,
                ease: .005
            }),
            this.thickness *= .5,
            this.circleScale = 1,
            this.unsubscribers = [],
            this.currentSeed = null,
            this.seedLevel = 0,
            this.seedProgress = 0,
            this.animStopped = !0,
            this.animTimer = 0,
            this.animEmitTimer = 1e3,
            this.progressSpeed = 0,
            this.prevLevel = 0,
            te.a.currentSeed.subscribe(this.onSeedChange, this),
            this.onSeedChange(te.a.currentSeed.current)
        }
        afterRecompute(e) {
            const t = e.height / this.barHeight
              , i = .005 * this.spriteScale
              , n = e.left
              , r = -e.top
              , s = e.height;
            this.scale = t,
            this.maxScale = 2 * e.height,
            this.circleScale = 1.29 * this.circleRadius * this.scale,
            this.gaugeBackground.scale.x = this.thickness * this.scale * this.spriteScale,
            this.gaugeBackground.scale.y = this.maxScale * i,
            this.gaugeBackground.position.x = n,
            this.gaugeBackground.position.y = r - e.height,
            this.gauge.scale.x = (this.thickness + .001) * this.scale * this.spriteScale,
            this.gauge.scale.y = this.maxScale * this.scale * i,
            this.gauge.position.x = n,
            this.gauge.position.y = r - e.height,
            this.steps.forEach(e => {
                const t = e.y * this.maxScale;
                e.bubble ? (e.bubble.position.x = n,
                e.bubble.position.y = r - s + .5 * t,
                e.number.position.x = e.bubble.position.x,
                e.number.position.y = e.bubble.position.y) : e.gift && (e.giftBg.position.x = n,
                e.giftBg.position.y = r - s + .5 * t - 10 * this.scale,
                e.gift.position.x = e.giftBg.position.x,
                e.gift.position.y = e.giftBg.position.y)
            }
            );
            const a = (1.29 * this.circleRadius - this.circleBleed[0]) / this.maxScale * .5 * this.scale
              , o = (1.29 * this.circleRadius - this.circleBleed[1]) / this.maxScale * .5 * this.scale;
            for (let e = 0, t = this.computedBounds.length; e < t; e++) {
                const t = e < 1 || e >= 3 ? 1 * o : 2 * o
                  , n = e < 4 ? this.levelBounds[e + 1] - this.levelBounds[e] - t : 0;
                this.computedBounds[e][0] = e < 1 ? 0 : e < 4 ? (this.levelBounds[e] + a) * this.maxScale : 1 * this.maxScale,
                this.computedBounds[e][1] = e < 4 ? this.computedBounds[e][0] + n * this.maxScale : 1 * this.maxScale,
                this.computedBounds[e][0] *= i,
                this.computedBounds[e][1] *= i
            }
            this.updateProgress(!0)
        }
        updateProgress(e) {
            e && (this.needsInstant = !0);
            let t = this.seedLevel
              , i = this.seedProgress;
            e && (this.prevLevel = t),
            this.prevLevel !== t && (e = !0),
            this.debugProgress > 0 && (t = Math.floor(this.debugProgress),
            i = this.debugProgress % 1);
            const n = this.computedBounds[t]
              , r = n[0] + (n[1] - n[0]) * i;
            e || r === this.progress.target || this.emitParticles(!0),
            this.progress.target = r,
            this.prevLevel = t,
            e && (this.progress.current = r)
        }
        updateStep(e, t, i) {
            const n = t.bubble
              , r = t.number;
            ta.White;
            let s = ta.Blue
              , a = 0;
            i ? (n.rotation += .002 * e,
            t.scale.setTarget(1.5),
            this.needsInstant && t.scale.setValue(1.5),
            a = 1,
            s = ta.White) : (t.scale.setTarget(1),
            this.needsInstant && t.scale.setValue(1)),
            t.scale.update(e),
            r.color.lerp(s, this.needsInstant ? 1 : .4),
            t.colorMix = Object(b.lerp)(t.colorMix, a, this.needsInstant ? 1 : .2),
            n.color.copy(ta.White).lerp(this.goldColor, t.colorMix),
            n.scale.setScalar(this.circleScale * t.scale.value),
            r.scale.copy(n.scale)
        }
        updateGift(e, t, i) {
            const r = t.giftBg
              , s = t.gift;
            let a = ta.Grey;
            i ? (t.scale.setTarget(n.a.giftButtonHover.current ? 1.25 : 1.15),
            this.needsInstant && t.scale.setValue(1),
            a = ta.Gold) : (t.scale.setTarget(1),
            this.needsInstant && t.scale.setValue(1)),
            t.scale.update(e),
            r.scale.setScalar(this.circleScale * t.scale.value * 2),
            n.a.giftButtonClickable.set(t.scale.value > 1.1),
            s.scale.copy(r.scale),
            s.color.lerp(a, this.needsInstant ? 1 : .2)
        }
        emitParticles(e) {
            if (this.seedLevel < 1 || 1 === this.seedLevel && this.seedProgress <= 0)
                return;
            this.animEmitTimer = Math.max(10, 150);
            const t = ge.U.get().copy(this.gauge.position);
            t.x -= .5 * this.gauge.scale.x * .03,
            t.y += 3.06 * this.gauge.scale.y,
            t.z = 20;
            const i = e ? 0 : 1
              , n = [25 * this.scale, 25 * this.scale][i];
            e && this.props.emitter.emit("sprites", 2, gr.progressGlow({
                position: t,
                scale: 15 * this.scale
            })),
            this.props.emitter.emit("sprites", e ? 12 : 4, gr.progressSmoke({
                position: t,
                scale: n,
                type: i
            })),
            t.release(),
            e && (this.animEmitTimer = ea)
        }
        update(e) {
            this.updateProgress(),
            this.progress.update(e),
            this.gauge.scale.y = this.progress.current;
            const t = this.gauge.scale.y;
            let i = 0;
            if (this.needsInstant)
                this.animEmitTimer = 0,
                this.progressSpeed = 0,
                this.animStopped = !0;
            else {
                this.progressSpeed = Math.abs(this.progress.target - this.progress.current);
                const t = this.progressSpeed < .2;
                t ? this.animTimer -= e : this.animTimer = Ks,
                t && !this.animStopped ? this.animStopped = t : !t && this.animStopped && (this.animStopped = t),
                this.animTimer < 0 && (this.animTimer = 0),
                i = this.animTimer / Ks
            }
            this.animEmitTimer -= e,
            this.animEmitTimer <= 0 && !this.animStopped && (this.animEmitTimer = Math.max(10, ea + this.animEmitTimer),
            this.emitParticles());
            for (let i = 0, n = this.steps.length; i < n; i++) {
                const n = this.steps[i]
                  , r = this.computedBounds[i][1];
                let s = i >= 3 ? t - r > -5 : t - r > -.01;
                this.currentSeed && this.currentSeed.visibleLevel.current <= i && (s = !1),
                i < 3 ? this.updateStep(e, n, s) : 3 === i && this.updateGift(e, n, s)
            }
            this.goldPeriod = (this.goldPeriod + .02 * e) % (2 * Math.PI);
            const n = .5 * (Math.cos(this.goldPeriod) + 1);
            this.goldColor.copy(ta.Gold).lerp(ta.Gold2, n * $s(i)),
            this.gauge.color.copy(this.goldColor),
            this.needsInstant = !1
        }
        updateSeedProgress() {
            const e = this.currentSeed;
            if (!e)
                return;
            const t = e.level.current
              , i = e.visibleLevel.current;
            if (t < 1)
                return this.seedLevel = 0,
                void (this.seedProgress = 0);
            if (t > 3)
                return this.seedLevel = 4,
                void (this.seedProgress = 0);
            const n = ee.a.rules.current.seeds[e.id.current]["lvl" + Object(b.clamp)(t, 1, 3)];
            let r = 0
              , s = 0
              , a = 0;
            const o = {};
            for (const t in e.resources) {
                if (!n[t] || 0 === n[t].ask[0])
                    continue;
                const e = o[t] = n[t].ask[0];
                e > a && (a = e)
            }
            for (const t in e.resources) {
                if (!o[t])
                    continue;
                const i = o[t] = a / o[t];
                r += e.resources[t].goal.current * i
            }
            for (const t in e.resources) {
                if (!o[t])
                    continue;
                const i = o[t]
                  , n = e.resources[t]
                  , a = n.goal.current * i
                  , l = n.amount.current * i
                  , c = a > 0 ? Object(b.clamp)(l / a, 0, 1) : 0;
                s += r > 0 ? c * (a / r) : 0
            }
            this.seedLevel = t,
            this.seedProgress = s,
            i < t && (this.seedLevel = i,
            this.seedProgress = 1)
        }
        seedSubscribe(e) {
            e.forEach(e => {
                const t = e.subscribe(this.updateSeedProgress, this);
                this.unsubscribers.push( () => e.unsubscribe(t))
            }
            )
        }
        onSeedChange(e) {
            this.currentSeed = e,
            this.unsubscribers.forEach(e => e()),
            this.unsubscribers = [],
            this.currentSeed && (this.seedSubscribe([e.unlocked, e.level, e.visibleLevel, e.resources.sun.amount, e.resources.water.amount, e.resources.love.amount, e.resources.sun.goal, e.resources.water.goal, e.resources.love.goal]),
            this.updateSeedProgress(),
            this.updateProgress(!0))
        }
        beforeDestroy() {}
    }
    const sa = Object(me.a)("🎥 SCENES", "black", "#d7d3db", 1).log
      , aa = {
        default: null,
        game: null,
        seed: null,
        prerender: null,
        uiBack: null,
        uiTop: null
    }
      , oa = {
        default: class extends In {
            constructor(e) {
                super(e)
            }
            init() {
                n.a.homeUiVisible.set(!1),
                n.a.choiceUiVisible.set(!1),
                this.background = ee.a.palettes.current[Kt.current.palette][0],
                this.cam = this.addComponent(zi, {
                    preset: Kt.current.camera
                }),
                this.useCamera(this.cam),
                this.batchers = {
                    grounds: an.get({
                        count: 50,
                        material: "props",
                        atlas: "props",
                        dynamic: !1,
                        offset: -.003,
                        meshProperties: {
                            propType: 0
                        }
                    }),
                    plants: an.get({
                        count: 100,
                        material: "props",
                        atlas: "props",
                        dynamic: !1,
                        subdivisions: [1, 8],
                        offset: -.002,
                        meshProperties: {
                            propType: 1
                        }
                    }),
                    stars: an.get({
                        count: 1e3,
                        material: "props",
                        atlas: "props",
                        dynamic: !1,
                        offset: -.001,
                        meshProperties: {
                            propType: 2
                        }
                    }),
                    sprites: an.get({
                        count: 200,
                        material: "basic",
                        atlas: "sprites",
                        offset: 0,
                        renderOrder: 2,
                        transparent: !0
                    }),
                    addSprites: an.get({
                        count: 100,
                        material: "basic",
                        atlas: "sprites",
                        offset: .001,
                        renderOrder: 7,
                        blending: "additive",
                        transparent: !0
                    })
                };
                for (const e in this.batchers)
                    this.add(this.batchers[e].base);
                this.emitter = _n.get({
                    batchers: this.batchers
                }),
                this.landscape = this.add(new ge.F),
                this.landscape.add(this.batchers.grounds.base),
                this.landscape.add(this.batchers.plants.base),
                this.landscape.add(this.batchers.stars.base),
                this.addComponent(gi, {
                    batchers: this.batchers,
                    sceneData: Kt,
                    scene: this
                });
                const e = this
                  , t = t => this.addComponent(fn, {
                    id: t,
                    scene: e,
                    onClick: () => n.a.currentStarterChoice.set(t),
                    seedArrays: xr
                });
                this.amandier1 = this.addComponent(Qi, {
                    scene: this,
                    id: "amandier",
                    level: 1,
                    touchable: !1
                }),
                this.amandier1.base.scale.setScalar(.01),
                this.amandier1.base.position.y = 40,
                this.flyAnim = this.amandier1.spineSystem.state.setAnimation(1, "fly", !0),
                this.flyAnim.timeScale = 2.2,
                this.cam.follow(this.amandier1, !0),
                this.cam.targetMix = 1,
                this.amandier2 = this.addComponent(Qi, {
                    scene: this,
                    id: "amandier",
                    level: 2,
                    touchable: !1
                }),
                this.amandier2.base.position.set(300, 0, 0),
                this.amandier2.base.scale.set(-.025, .025, .025),
                this.platforms = {
                    amandier: t("amandier"),
                    immortelle: t("immortelle"),
                    lavande: t("lavande")
                },
                this.cam.choiceCam.qInfluence = 0,
                this.cam.choiceCam.pInfluence = 0,
                this.initTweens(),
                this.intro = !0,
                this.planted = !1,
                this.introTime = 0,
                this.introTimers = {
                    smoke: 200,
                    speedlines: 100
                },
                n.a.routeStatus.subscribe(this.onRouteChange, this),
                n.a.currentStarterChoice.subscribe(this.onStarterChange, this),
                n.a.swipeLeft.subscribe(this.choosePreviousSeed, this),
                n.a.swipeRight.subscribe(this.chooseNextSeed, this),
                ve.a.play("intro_fall"),
                "choice" === n.a.currentView.current.id && (this.planted = !0,
                this.amandier1.base.position.y = 0,
                this.tweens.choice.progress(1),
                this.showPlatforms())
            }
            choosePreviousSeed() {
                const e = n.a.currentStarterChoice.current
                  , t = e ? xr.indexOf(e) : 1
                  , i = t < xr.length - 1 ? t + 1 : 0
                  , r = xr[i];
                n.a.currentStarterChoice.set(r)
            }
            chooseNextSeed() {
                const e = n.a.currentStarterChoice.current
                  , t = e ? xr.indexOf(e) : 1
                  , i = t > 0 ? t - 1 : xr.length - 1
                  , r = xr[i];
                n.a.currentStarterChoice.set(r)
            }
            initTweens() {
                this.tweens.choice = new J.a({
                    paused: !0
                }).to(this.cam.choiceCam, 2, {
                    qInfluence: 1,
                    ease: Z.e.easeInOut
                }, 0).to(this.cam.choiceCam, 1.7, {
                    pInfluence: 1,
                    ease: Xe.e.easeInOut
                }, .4).addCallback( () => {
                    n.a.choiceUiVisible.set(!0)
                }
                )
            }
            selectSeed(e, t) {
                t || ve.a.play("starter_navigate"),
                e === xr[1] ? (this.platforms[xr[0]].setOrder(0, t),
                this.platforms[xr[1]].setOrder(1, t),
                this.platforms[xr[2]].setOrder(2, t)) : e === xr[0] ? (this.platforms[xr[2]].setOrder(0, t),
                this.platforms[xr[0]].setOrder(1, t),
                this.platforms[xr[1]].setOrder(2, t)) : e === xr[2] && (this.platforms[xr[1]].setOrder(0, t),
                this.platforms[xr[2]].setOrder(1, t),
                this.platforms[xr[0]].setOrder(2, t))
            }
            onStarterChange() {
                this.selectSeed(n.a.currentStarterChoice.current)
            }
            onRouteChange(e) {
                if (2 != e.status)
                    return;
                const t = e.from && e.from.id
                  , i = e.to.id;
                "choice" === i ? (this.tweens.choice.pause(),
                this.tweens.choice.play(),
                "default" === t && (ve.a.play("intro_validate"),
                ve.a.play("transition_whoosh"))) : "default" === i && (this.tweens.choice.reverse(),
                t && "default" !== t && ve.a.play("transition_whoosh"))
            }
            onImpact() {
                this.impacted || (this.impacted = !0,
                n.a.homeUiVisible.set(!0),
                ve.a.play("intro_impact"),
                ve.a.play("music_loop"))
            }
            showAmandier2() {
                this.amandier2Visible || (this.amandier2Visible = !0,
                this.amandier2.base.position.set(0, -.21, 0),
                this.entry = this.amandier2.spineSystem.state.setAnimation(0, "in-2"),
                this.entry.mixDuration = 0,
                this.entry.timeScale = .7)
            }
            updateFall(e) {
                const t = this.introTimers
                  , i = 1 - br(Object(b.clamp)(this.introTime / 2e3, 0, 1));
                this.cam.targetPan = -10 * i - 1,
                this.amandier1.base.position.y -= .012 * e;
                const n = this.amandier1.base.position.y
                  , r = yr(Object(b.clamp)(.03 * n + .42, 0, 1));
                if (n < -1.3 && this.onImpact(),
                n < -5 && this.showAmandier2(),
                t.smoke -= e,
                t.smoke < 0) {
                    t.smoke = 50 + 100 * Math.random();
                    const e = ge.U.get().copy(this.amandier1.base.position).release();
                    e.y += .5,
                    e.z -= .2,
                    this.emitter.emit("sprites", 1, gr.smokeTrail({
                        position: e
                    }))
                }
                if (t.speedlines -= e,
                t.speedlines < 0 && n > 2.5) {
                    t.speedlines = 10 + 10 * Math.random() + Object(b.clamp)(Object(b.map)(n, 3, 9, 200, 0), 0, 200);
                    const e = ge.U.get().copy(this.amandier1.base.position).release();
                    e.x += $t.b.randomFloat(-10, 10),
                    e.y += .5 + $t.b.randomFloat(-10, 10),
                    e.z += -.2,
                    this.emitter.emit("sprites", 1, gr.speedLines({
                        position: e
                    }))
                }
                this.cam.targetMix = r,
                this.cam.targetMix <= 0 && (this.showPlatforms(),
                this.planted = !0,
                this.cam.follow(null))
            }
            showPlatforms() {
                for (const e in this.platforms)
                    this.platforms[e].hidden = !1
            }
            updatePlanted(e) {}
            updateIntro(e) {
                this.introTime += e,
                this.planted ? this.updatePlanted(e) : this.updateFall(e)
            }
            update(e) {
                this.intro && this.updateIntro(e),
                super.update(e),
                this.emitter.update(e);
                for (const t in this.batchers)
                    this.batchers[t].update(e)
            }
            destroy() {
                for (const e in this.batchers)
                    this.batchers[e].release();
                this.batchers = null,
                n.a.routeStatus.unsubscribe(this.onRouteChange, this),
                n.a.currentStarterChoice.unsubscribe(this.onStarterChange, this),
                super.destroy()
            }
        }
        ,
        game: {
            caterpillars: class extends Kr {
                init() {
                    this.gameId = "caterpillars",
                    this.landscapeId = "caterpillars",
                    super.init(),
                    this.landscape.position.set(0, 0, 0),
                    this.landscape.rotation.set(0, 0, 0),
                    this.landscape.scale.set(1, 1, 1),
                    this.activateCollectable = this.activateCollectable.bind(this),
                    this.spawnTimer = new y.a(1e3,this.activateCollectable,!1),
                    this.levels = ts;
                    const e = es("GameA_1.raw.svg", .03)
                      , t = new ge.U(0,-.5,-5)
                      , i = new ge.U(1.7,1.7,1);
                    this.collectables = e.map( (e, n) => {
                        const r = this.addComponent(is, {
                            index: n,
                            scene: this,
                            onMissed: this.onMissed,
                            onCollected: this.onCollected
                        });
                        return r.base.scale.setScalar(e.scale),
                        r.base.position.copy(e),
                        r.base.position.add(t).multiply(i),
                        r.base.scale.multiply(i),
                        r
                    }
                    )
                }
                onGameOver() {
                    U.removeCursor()
                }
                onMissed() {
                    this.isGameOver() || this.gameOver()
                }
                onCollected() {
                    ve.a.play("cater_click"),
                    this.spawnTimer._stopped && (this.spawnTimer.restart(1e3, !1),
                    this.onPlayerReady()),
                    this.isGameOver() || this.setScore(this.getScore() + 1)
                }
                reset(e) {
                    super.reset(),
                    e || (this.collectables.forEach(e => e.reset()),
                    this.spawnTimer.stop())
                }
                start() {
                    this.started || (this.started = !0,
                    this.getDeactivatedCollectable().activate())
                }
                stop() {
                    this.started && (this.started = !1)
                }
                getDeactivatedCollectable() {
                    let e = null;
                    for (let t = 0, i = this.collectables.length; t < i; t++) {
                        const i = this.collectables[t];
                        if ((!i.active || i.catchable) && this.previousCollectableIndex !== i.index) {
                            e = this.collectables[t];
                            break
                        }
                    }
                    return e && (this.collectables = Object(vr.a)(this.collectables)),
                    this.previousCollectableIndex = e.index,
                    e
                }
                activateCollectable(e) {
                    if (!this.started)
                        return;
                    const t = this.getDeactivatedCollectable();
                    if (!t)
                        return e(100);
                    const i = n.a.device.current.hasTouch ? .9 : 1
                      , r = (this.level.visibilityDuration + this.level.visibilityDurationRandomness * Math.random()) * i
                      , s = (this.level.spawnDelay + this.level.spawnDelayRandomness * Math.random()) * i;
                    t.activate(r),
                    e(s, !1)
                }
                update(e) {
                    super.update(e),
                    this.emitter.update(e),
                    this.spawnTimer.update(e);
                    for (const t in this.batchers)
                        this.batchers[t].update(e)
                }
            }
            ,
            bucket: class extends Kr {
                init() {
                    this.gameId = "bucket",
                    this.landscapeId = "bucket",
                    super.init(),
                    this.landscape.position.set(0, 0, -2),
                    this.landscape.rotation.set(0, 0, 0),
                    this.landscape.scale.set(1, 1, 1),
                    this.levels = ss,
                    this.currentCamera.base.rotation.set(0, 0, 0),
                    this.currentCamera.base.position.set(0, .15, 5),
                    this.patterns = new ds,
                    this.drops = [],
                    this.userTouched = !1,
                    this.firstDropCollected = !1,
                    this.keyboardDirection = !1,
                    this.keyboardSpeed = 1,
                    this.bucket = this.addComponent(ps, {
                        scene: this
                    });
                    for (let e = 0, t = 50; e < t; e++) {
                        const t = this.addComponent(fs, {
                            index: e,
                            batcher: this.batchers.topSprites,
                            sprite: "game_drop",
                            color: new ge.k(6529753),
                            patterns: this.patterns,
                            bucket: this.bucket,
                            offsetY: -10,
                            offsetZ: -.001 * e,
                            onMissed: this.onMissed,
                            onCollected: this.onCollected
                        });
                        t.position.y = 10,
                        this.drops.push(t),
                        t.activate()
                    }
                    ve.a.play("bucket_rain_loop"),
                    this.keyboard = new rs,
                    this.keyboard.addEventListeners(),
                    this.keyboard.addEventListener("keyDown", this.onKeyPress.bind(this)),
                    this.keyboard.addEventListener("keyUp", this.onKeyUp.bind(this))
                }
                emit(e) {
                    const t = ge.U.get().copy(e).release();
                    this.emitter.emit("drops", 10, function({position: e, sprite: t}) {
                        return i => {
                            const n = $t.b.randomFloat(-.3, .3) + .5 * Math.PI
                              , r = .05 + $t.b.randomFloat(0, .12);
                            i.position.copy(e),
                            i.spriteId = t,
                            i.velocity.x = r * Math.cos(n),
                            i.velocity.y = r * Math.sin(n) + $t.b.randomFloat(.05, .1),
                            i.velocityDrag.setScalar(.9),
                            i.useVelocityDragMult = !0,
                            i.rotation = n,
                            i.gravity.set(0, -.06, 0),
                            i.duration = $t.b.randomFloat(600, 1300),
                            i.scaleFrom.setScalar(.04 + $t.b.randomFloat(-.025, .05)),
                            i.scaleTo.setScalar(0),
                            i.colorFrom.setHex(6529753).offsetHSL(0, $t.b.randomFloat(-.2, .2), $t.b.randomFloat(-.2, .2)),
                            i.colorTo.setHex(6529753).offsetHSL(0, 0, 0),
                            i.alphaFrom = 1,
                            i.alphaTo = 0
                        }
                    }({
                        position: t,
                        sprite: "shape_circle"
                    }))
                }
                onMissed() {
                    this.isGameOver() || this.firstDropCollected && (U.removeCursor(),
                    this.gameOver())
                }
                onGameOver() {
                    this.patterns.onLost(),
                    this.bucket.onLost();
                    for (let e = 0, t = this.drops.length; e < t; e++)
                        this.drops[e].onLost()
                }
                onCollected(e) {
                    this.emit(e.position),
                    this.bucket.onCollected(),
                    this.isGameOver() || this.setScore(this.getScore() + 1),
                    this.userTouched && !this.firstDropCollected && (this.firstDropCollected = !0,
                    this.patterns.firstDropCollected = !0,
                    this.onPlayerReady()),
                    ve.a.play("bucket_waterdrop")
                }
                reset() {
                    super.reset(),
                    this.patterns.reset();
                    for (let e = 0, t = this.drops.length; e < t; e++)
                        this.drops[e].reset()
                }
                start() {
                    this.started || (this.started = !0,
                    this.patterns.start())
                }
                stop() {
                    this.started && (this.started = !1,
                    this.patterns.stop(),
                    this.reset())
                }
                onResize(e) {
                    const t = ge.T.get()
                      , i = Math.min(420, .15 * e[1]);
                    t.y = e[1] - i;
                    const n = this.screenToWorld(t, 0);
                    this.bucket.setY(n.y),
                    this.bounds = {},
                    t.set(...e),
                    this.bounds.max = this.screenToWorld(t, 0).x,
                    t.set(0, 0),
                    this.bounds.min = this.screenToWorld(t, 0).x,
                    t.release()
                }
                onKeyPress(e) {
                    if (n.a.touch.current.pressed)
                        return;
                    const {code: t} = e;
                    "ArrowLeft" !== t && "ArrowRight" !== t || t === this.keyboardDirection || (this.userTouched = !0,
                    this.keyboardDirection = t,
                    $.a.fromTo(this, .2, {
                        keyboardSpeed: 0
                    }, {
                        keyboardSpeed: 1,
                        ease: Xe.c.easeOut
                    }))
                }
                onKeyUp(e) {
                    const {code: t} = e;
                    "ArrowLeft" !== t && "ArrowRight" !== t || t !== this.keyboardDirection || (this.keyboardDirection = !1)
                }
                onTouch(e) {
                    if (!e.pressed)
                        return;
                    this.keyboardDirection = !1;
                    const t = ge.T.get().set(e.pos[0], e.pos[1])
                      , i = this.screenToWorld(t, 0);
                    this.bucket.setX(i.x),
                    t.release(),
                    this.userTouched = !0
                }
                updateKeyboardDirection() {
                    const e = ("ArrowLeft" === this.keyboardDirection ? -1 : 1) * ms * this.keyboardSpeed
                      , t = Object(b.clamp)(this.bucket.x.target + e, this.bounds.min, this.bounds.max);
                    this.bucket.setX(t)
                }
                update(e) {
                    this.keyboardDirection && this.updateKeyboardDirection(),
                    this.patterns.level = this.level,
                    this.patterns.update(),
                    super.update(e),
                    this.emitter.update(e),
                    U.setCursor(n.a.touch.current.pressed ? "none" : "grab");
                    for (const t in this.batchers)
                        this.batchers[t].update(e)
                }
                beforeDestroy() {
                    ve.a.stop("bucket_rain_loop"),
                    super.beforeDestroy()
                }
            }
            ,
            spiders: class extends Kr {
                init() {
                    this.gameId = "spiders",
                    this.landscapeId = "spiders",
                    super.init(),
                    this.activateCollectable = this.activateCollectable.bind(this),
                    this.spawnTimer = new y.a(1e3,this.activateCollectable,!1),
                    this.levels = gs,
                    this.collectables = [];
                    for (let e = 0, t = 10; e < t; e++) {
                        const t = this.addComponent(vs, {
                            index: e,
                            scene: this,
                            onMissed: this.onMissed,
                            onCollected: this.onCollected,
                            hitRadiusMultiplier: 1.5
                        });
                        this.collectables.push(t)
                    }
                    this.reset()
                }
                onMissed() {
                    this.isGameOver() || (U.removeCursor(),
                    this.gameOver())
                }
                onCollected() {
                    ve.a.play("spider_click"),
                    this.spawnTimer._stopped && (this.spawnTimer.restart(1e3, !1),
                    this.onPlayerReady()),
                    this.isGameOver() || this.setScore(this.getScore() + 1)
                }
                reset() {
                    super.reset()
                }
                start() {
                    this.started || (this.started = !0,
                    this.getDeactivatedCollectable().activate(!0))
                }
                stop() {
                    this.started && (this.started = !1)
                }
                getDeactivatedCollectable() {
                    let e = null;
                    for (let t = 0, i = this.collectables.length; t < i; t++)
                        if (!this.collectables[t].active) {
                            e = this.collectables[t];
                            break
                        }
                    return e && (this.collectables = Object(vr.a)(this.collectables)),
                    e
                }
                activateCollectable(e) {
                    if (!this.started)
                        return;
                    const t = this.getDeactivatedCollectable();
                    if (!t)
                        return e(100);
                    t.activate(),
                    e((this.level.spawnDelay + this.level.spawnDelayRandomness * Math.random()) * (n.a.device.current.hasTouch ? .5 : 1))
                }
                update(e) {
                    super.update(e),
                    this.emitter.update(e),
                    this.spawnTimer.update(e);
                    for (const t in this.batchers)
                        this.batchers[t].update(e)
                }
                beforeDestroy() {
                    this.spawnTimer.dispose(),
                    super.beforeDestroy()
                }
            }
        },
        seed: Qr,
        prerender: _r,
        uiBack: class extends In {
            init() {
                this.base = new ge.F,
                this.scene.add(this.base),
                this.camUI = this.addComponent(new ys),
                this.useCamera(this.camUI),
                this.scene.add(this.camUI.base),
                this.batchers = {
                    sprites: an.get({
                        atlas: "sprites",
                        material: "basic",
                        dynamic: !0,
                        transparent: !0
                    })
                },
                this.emitter = _n.get({
                    batchers: this.batchers
                }),
                this.progressbar = this.addComponent(ra, {
                    batcher: this.batchers.sprites,
                    emitter: this.emitter
                });
                for (const e in this.batchers)
                    n.a.seedUiVisible.current && this.base.add(this.batchers[e].base);
                this.bind()
            }
            bind() {
                n.a.seedUiVisible.subscribe(this.seedUIChange, this)
            }
            unbind() {
                n.a.seedUiVisible.unsubscribe(this.seedUIChange, this)
            }
            seedUIChange() {
                for (const e in this.batchers)
                    n.a.seedUiVisible.current ? this.base.add(this.batchers[e].base) : this.base.remove(this.batchers[e].base)
            }
            update(e) {
                super.update(e);
                for (const t in this.batchers)
                    this.batchers[t].update(e);
                this.emitter.update(e)
            }
            beforeDestroy() {
                this.unbind()
            }
        }
        ,
        uiTop: class extends In {
            init() {
                this.base = new ge.F,
                this.scene.add(this.base),
                this.camUI = this.addComponent(new ys),
                this.useCamera(this.camUI),
                this.scene.add(this.camUI.base),
                this.batchers = {
                    sprite: an.get({
                        atlas: "sprites",
                        material: "basic",
                        dynamic: !0,
                        transparent: !0
                    })
                },
                this.emitter = _n.get({
                    batchers: this.batchers
                }),
                this.buttons = this.addComponent(Es, {
                    batcher: this.batchers.sprite
                }),
                this.guide = this.addComponent(Ns, {
                    batcher: this.batchers.sprite,
                    emitter: this.emitter
                }),
                this.biscuits = this.addComponent(Zs, {
                    batcher: this.batchers.sprite,
                    emitter: this.emitter
                }),
                this.time = {
                    water: 0,
                    sun: 0
                },
                this.collecting = {
                    water: !1,
                    sun: !1
                },
                this.buttons.base.visible = !0;
                for (const e in this.batchers)
                    this.base.add(this.batchers[e].base)
            }
            update(e) {
                super.update(e);
                for (const t in this.batchers)
                    this.batchers[t].update(e);
                this.emitter.update(e)
            }
            beforeDestroy() {
                this.unbind(),
                this.emitter.release()
            }
        }
    };
    let la = null
      , ca = null;
    function ha(e, t={}) {
        if (!ca)
            return sa("Deffer " + e),
            void (la = [e, t]);
        if (e && oa[e] || (e = "default"),
        aa.default && ua() === aa.default && "default" === e)
            return;
        !function(e=[]) {
            e.forEach(e => {
                aa[e] && aa[e].deactivated()
            }
            )
        }(["prerender", "game", "seed", "default"]),
        function(e=[]) {
            e.forEach(e => {
                aa[e] && (aa[e].destroy(),
                aa[e] = null)
            }
            )
        }(["prerender", "game", "seed", "default"]);
        const i = "game" === e ? oa.game[t.gameId] || oa.game.default : oa[e];
        aa[e] || (aa[e] = new i(t)),
        aa[e].activated(t),
        ee.a.sceneTime.set(0),
        sa("Activate " + e + ("seed" === e ? " " + t.seedId : ""))
    }
    function ua() {
        return aa.game ? aa.game : aa.seed ? aa.seed : aa.default
    }
    var pa = {
        init: function() {},
        appReady: function() {
            aa.uiTop = new oa.uiTop,
            aa.uiBack = new oa.uiBack,
            ca = !0,
            la && (ha(la[0], la[1]),
            la = null)
        },
        snapshot: function() {
            bt.snapshot()
        },
        set: ha,
        get: function(e) {
            return aa[e]
        },
        getActive: ua
    };
    function da() {
        const e = te.a.flags.current;
        if (e.openGift || (e.openGift = !0,
        te.a.flags.set(e, !0),
        Ds.a.requestSave()),
        n.a.demoMode.current)
            fe.a.createDemoModeAlert();
        else if (te.a.id.current) {
            if (n.a.menuOpen.current && !document.body.classList.contains("left-panel-open"))
                return;
            n.a.leftPanelView.set({
                type: "voucherDetails",
                seedId: te.a.currentSeed.current.id.current
            }),
            n.a.menuOpen.set(!0)
        } else
            fe.a.createAskRegister();
        Cr.a.event({
            type: "mmEvent",
            category: "voucher",
            action: "click_gift",
            label: Object(Dr.a)(te.a.currentSeed.current.id.current)
        })
    }
    var fa = i(131)
      , ma = i.n(fa)
      , ga = i(132)
      , va = i.n(ga);
    class ya extends K.a {
        constructor(e) {
            super(Object.assign({}, {
                name: "ResourceButtons",
                log: 0,
                template: ma.a,
                styles: va.a
            }, e)),
            this.openGameList = this.openGameList.bind(this)
        }
        afterMount() {
            const e = pa.get("uiTop");
            this.timer = this.addComponent(de),
            this.timer.mount(this.nodes.game),
            this.nodes.buttons.forEach(t => {
                const i = t.dataset.type
                  , r = e.buttons[i];
                r && (r.attach(t),
                n.a.device.current.type.desktop && (t.addEventListener("mouseenter", r.enter),
                t.addEventListener("mouseleave", r.leave)),
                this.touchStart = ["touchstart", "mousedown"],
                this.touchEnd = ["touchend", "touchcancel", "mouseup"],
                this.touchStart.forEach(e => t.addEventListener(e, r.down)),
                this.touchEnd.forEach(e => t.addEventListener(e, r.up)),
                "game" === i ? r.props.onClick = this.openGameList : "gift" === i && (r.props.onClick = da),
                r.updateButtonState())
            }
            ),
            ee.a.disableResourceOverflow.current ? this.overflows = [] : this.overflows = this.nodes.resources.map(e => {
                return this.addComponent(le, {
                    type: e.getAttribute("data-type")
                }).mount(e)
            }
            ),
            this.groups = [{
                y: 0,
                gl: e.buttons.buttons[0],
                overflow: this.overflows[1]
            }, {
                y: 0,
                gl: e.buttons.buttons[1],
                timer: this.timer
            }, {
                y: 0,
                gl: e.buttons.buttons[2],
                overflow: this.overflows[0]
            }],
            this.giftGroups = [{
                y: 0,
                gl: e.buttons.buttons[3]
            }],
            this.initTweens(),
            this.bind(),
            this.updateVisibility(),
            this.updateGiftVisibility()
        }
        initTweens() {
            this.tweens = {},
            this.updateGift = this.update.bind(this, this.giftGroups),
            this.updateResources = this.update.bind(this, this.groups),
            this.tweens.hide = new J.a({
                paused: !0,
                onUpdate: this.updateResources
            }).staggerTo(this.groups, .3, {
                y: 150,
                ease: Z.a.easeIn
            }, .03),
            this.tweens.show = new J.a({
                paused: !0,
                onUpdate: this.updateResources
            }).staggerTo(this.groups, .6, {
                y: 0,
                ease: Z.d.easeOut.config(1, .75)
            }, .03),
            this.tweens.hideGift = new J.a({
                paused: !0,
                onUpdate: this.updateGift
            }).staggerTo(this.giftGroups, .3, {
                y: 150,
                ease: Z.a.easeIn
            }, .03),
            this.tweens.showGift = new J.a({
                paused: !0,
                onUpdate: this.updateGift
            }).staggerTo(this.giftGroups, .6, {
                y: 0,
                ease: Z.d.easeOut.config(1, .75)
            }, .03),
            this.tweens.hide.progress(1),
            this.tweens.hideGift.progress(1)
        }
        hideGift() {
            this.tweens.showGift.pause(),
            this.tweens.hideGift.invalidate().restart(!0)
        }
        showGift() {
            this.tweens.hideGift.pause(),
            this.tweens.showGift.invalidate().restart(!0)
        }
        hide() {
            this.tweens.show.pause(),
            this.tweens.hide.invalidate().restart(!0)
        }
        show() {
            this.tweens.hide.pause(),
            this.tweens.show.invalidate().restart(!0)
        }
        update(e) {
            for (let t = 0, i = e.length; t < i; t++) {
                const i = e[t];
                if (i.gl.visibilityOffset.y = i.y,
                i.overflow && i.overflow.nodes.main) {
                    i.overflow.nodes.main.style.transform = `translate3d(0, ${i.y}px, 0)`
                }
                if (i.timer && i.timer.nodes.main) {
                    i.timer.nodes.main.style.transform = `translate3d(0, ${i.y}px, 0)`
                }
            }
        }
        bind() {
            n.a.resourceButtonsVisible.subscribe(this.updateVisibility, this),
            n.a.giftButtonVisible.subscribe(this.updateGiftVisibility, this)
        }
        unbind() {
            n.a.resourceButtonsVisible.unsubscribe(this.updateVisibility, this),
            n.a.giftButtonVisible.unsubscribe(this.updateGiftVisibility, this)
        }
        updateVisibility() {
            n.a.resourceButtonsVisible.current ? this.show() : this.hide()
        }
        updateGiftVisibility() {
            n.a.giftButtonVisible.current ? this.showGift() : this.hideGift()
        }
        openGameList(e) {
            e && e.preventDefault(),
            te.a.resources.game.amount.current < 1 || (fe.a.createGameList(),
            Cr.a.event({
                type: "mmEvent",
                category: "mini-game",
                action: "game"
            }))
        }
        beforeDestroy() {
            const e = pa.get("uiTop");
            this.nodes.buttons.forEach(t => {
                const i = t.dataset.type
                  , r = e.buttons[i];
                r && (r.detach(t),
                n.a.device.current.type.desktop && (t.removeEventListener("mouseenter", r.enter),
                t.removeEventListener("mouseleave", r.leave)),
                this.touchStart.forEach(e => t.removeEventListener(e, r.down)),
                this.touchEnd.forEach(e => t.removeEventListener(e, r.up)))
            }
            )
        }
    }
    var ba = i(53)
      , xa = i(9)
      , wa = i(38)
      , _a = i(129)
      , Ta = i.n(_a)
      , Ma = i(130)
      , Sa = i.n(Ma);
    let Aa = 0;
    class Pa extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Seeds Button",
                log: 0,
                template: Ta.a,
                styles: Sa.a
            }, e)),
            this.tweens = {},
            this.preventShaking = [ba.a],
            this.onHover = this.onHover.bind(this),
            this.keyboard = new rs
        }
        afterMount() {
            super.afterMount(),
            this._getSeedId(),
            this._initTweens(),
            this._initBodymovin(),
            this._toggleButton(),
            this.bind()
        }
        beforeDestroy() {
            this.unbind(),
            super.beforeDestroy()
        }
        onHover() {
            ve.a.play("mouse_hover")
        }
        goToSeed() {
            if (!we())
                return;
            const e = Date.now();
            e - Aa < 750 || (Aa = e,
            this.tweens.icons.restart(),
            this.tweens.buttons.restart(),
            xe.a.navigate(xe.a.url("seed", {
                id: this.seedId
            })))
        }
        bind() {
            te.a.requestedSeed.subscribe(this._onSeedChange, this),
            n.a.seedUiVisible.subscribe(this._toggleButton, this),
            n.a.device.current.type.desktop && (this.keyboard.addEventListeners(),
            this.keyboard.addEventListener("keyDown", this._onKeyPress.bind(this)),
            this.nodes.main.addEventListener("mouseenter", this.onHover))
        }
        unbind() {
            te.a.requestedSeed.unsubscribe(this._toggleButton, this),
            n.a.seedUiVisible.unsubscribe(this._toggleButton, this),
            this.keyboard.removeEventListeners(),
            this.nodes.main.removeEventListener("mouseenter", this.onHover)
        }
        _toggleButton(e) {
            const t = e || n.a.seedUiVisible.current;
            this.tweens.showButton[t ? "play" : "reverse"]()
        }
        _initTweens() {
            this.tweens.showButton = new J.a({
                paused: !0
            }),
            this.tweens.showButton.fromTo(this.nodes.main, .5, {
                x: "Prev" === this.props.name ? "-100%" : "100%"
            }, {
                x: "0%",
                ease: Z.a.easeInOut.config(1.5)
            }),
            this.tweens.buttons = new J.a({
                paused: !0
            }),
            this.tweens.buttons.to(this.nodes.seedsButtonBg, .2, {
                y: "3px",
                ease: Z.a.easeInOut.config(1.5),
                repeat: 1,
                yoyo: !0
            }),
            this.tweens.icons = new J.a({
                paused: !0
            }),
            this.tweens.icons.to(this.nodes.seedsButtonIcon, .2, {
                x: "Prev" === this.props.name ? "50%" : "-50%",
                ease: Z.a.easeInOut.config(1.5),
                repeat: 1,
                yoyo: !0
            }),
            this.tweens.seed = new J.a({
                paused: !0
            })
        }
        _getSeedId(e) {
            const t = "Prev" === this.props.name ? "getPreviousSeed" : "getNextSeed";
            this.seedId = te.a[t](e || te.a.currentSeed.current).id.current
        }
        _initBodymovin() {
            this.animation && this.animation.destroy(),
            this.animation = this.addComponent(wa.a, {
                name: `${this.seedId}-locked`,
                loop: !0,
                data: {
                    modifiers: this.seedId
                }
            }).mount(this.nodes.seedsButtonAnim)
        }
        _updateBodymovin(e) {
            this.tweens.seed.isActive() || this.tweens.seed.to(this.animation.nodes.main, .25, {
                x: "prev" === this.direction ? "100%" : "-100%",
                ease: Z.a.easeInOut.config(1.5)
            }).add( () => this._getSeedId(e)).add( () => this._initBodymovin()).add( () => {
                $.a.fromTo(this.animation.nodes.main, .25, {
                    x: "prev" === this.direction ? "-100%" : "100%"
                }, {
                    x: "0%",
                    ease: Z.a.easeInOut.config(1.5)
                })
            }
            ).play()
        }
        _onSeedChange(e) {
            const t = te.a.getCurrent();
            this.direction = te.a.getNextSeed(t) === e ? "next" : "prev",
            this._updateBodymovin(e)
        }
        _onKeyPress(e) {
            "seed" === n.a.currentView.current.id && ("ArrowLeft" === e.code && "Prev" === this.props.name || "ArrowRight" === e.code && "Next" === this.props.name) && this.goToSeed()
        }
    }
    var Ca = i(140)
      , La = i.n(Ca)
      , ka = i(141)
      , Ea = i.n(ka);
    class Ia extends K.a {
        constructor(e) {
            super(Object.assign({}, {
                name: "ProgressBar",
                log: 0,
                template: La.a,
                styles: Ea.a
            }, e))
        }
        afterMount() {
            pa.get("uiBack").progressbar.attach(this.nodes.main),
            this.onGiftClick = this.onGiftClick.bind(this),
            n.a.giftButtonClickable.subscribe(this.onGiftButtonClickableChange, this),
            this.onGiftButtonClickableChange(n.a.giftButtonClickable.current),
            this.nodes.giftButton.addEventListener("click", this.onGiftClick),
            n.a.device.current.type.desktop && (this.nodes.giftButton.addEventListener("mouseenter", this.onGiftEnter),
            this.nodes.giftButton.addEventListener("mouseleave", this.onGiftLeave))
        }
        onGiftEnter() {
            n.a.giftButtonClickable.current && we() && n.a.giftButtonHover.set(!0)
        }
        onGiftLeave() {
            n.a.giftButtonHover.set(!1)
        }
        onGiftButtonClickableChange(e) {
            e && we() || this.onGiftLeave(),
            this.nodes.giftButton && this.nodes.giftButton.classList.toggle("clickable", e)
        }
        onGiftClick(e) {
            e.preventDefault(),
            n.a.giftButtonClickable.current && we() && da()
        }
        beforeDestroy() {
            n.a.device.current.type.desktop && (this.nodes.giftButton.removeEventListener("mouseenter", this.onGiftEnter),
            this.nodes.giftButton.removeEventListener("mouseleave", this.onGiftLeave),
            this.onGiftLeave()),
            n.a.giftButtonClickable.unsubscribe(this.onGiftButtonClickableChange, this),
            this.nodes.giftButton.removeEventListener("click", this.onGiftClick),
            pa.get("uiBack").progressbar.detach()
        }
    }
    var Fa = i(16)
      , Oa = i(147)
      , Ra = i.n(Oa)
      , za = i(148)
      , Na = i.n(za);
    class Da extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Message",
                log: 0,
                template: Ra.a,
                styles: Na.a
            }, e)),
            this.onHideComplete = this.onHideComplete.bind(this),
            this.tweens = {},
            this.currentParagraph = null,
            this.currentLink = null,
            this.currentData = null,
            this.queuedData = null,
            this.hideUID = null,
            this.hidding = !1,
            this.hidden = !0
        }
        afterMount() {
            super.afterMount(),
            this.initTweens(),
            this.tweens.hide.play({
                instant: !0
            })
        }
        rerender() {
            if (!this.queuedData || this.currentData === this.queuedData)
                return;
            const e = this.currentData = this.queuedData;
            this.queuedData = null;
            const t = this.nodes.main
              , i = this.nodes.content;
            this.currentParagraph && i.removeChild(this.currentParagraph),
            this.currentLink && this.currentLink.removeEventListener("click", this.onCtaClick),
            this.currentParagraph = this.currentLink = null;
            const n = this.currentParagraph = document.createElement("p")
              , r = document.createTextNode(e.text + (e.cta ? " " : ""));
            if (i.appendChild(n),
            n.appendChild(r),
            e.cta && e.link) {
                const t = this.currentLink = document.createElement("a");
                t.href = e.link,
                t.textContent = e.cta,
                t.target = "_blank",
                this.currentLink.addEventListener("click", this.onCtaClick),
                n.appendChild(t)
            }
            t.classList.toggle("newmessage--wide", "verveine" === e.id),
            ["blue", "red", "tchern", "safari"].forEach(i => t.classList.toggle(i + "-palette", e.palette === i))
        }
        queue(e) {
            e && (this.queuedData = e)
        }
        show(e) {
            this.data && this.queue(e),
            this.hidden ? (this.hidding = !1,
            this.hidden = !1,
            this.rerender(),
            this.currentData && this.tweens.show.play()) : this.hide()
        }
        hide(e) {
            if (!0 === e || e && e === this.queuedData)
                this.currentData = null,
                this.queuedData = null;
            else if (e && e !== this.queuedData)
                return;
            if (this.hidden)
                return this.onHideComplete();
            this.hideUID = Date.now(),
            this.hidding = !0,
            this.hidden = !1,
            this.tweens.hide.play().then( () => this.onHideComplete(this.hideUID))
        }
        onHideComplete(e) {
            this.hideUID === e && (this.hidding = !1,
            this.hidden = !0,
            this.queuedData && this.show())
        }
        initTweens() {
            this.tweens.hide = Object(Fa.a)({
                target: this.nodes.main,
                willChange: !0,
                transform: "translate3d(0, 110%, 0)",
                ease: [.635, .015, .08, 1],
                duration: 350
            }),
            this.tweens.show = Object(Fa.a)({
                target: this.nodes.main,
                willChange: !0,
                transform: "translate3d(0, 0, 0)",
                ease: [.635, .015, .08, 1],
                duration: 500,
                delay: 750
            })
        }
        onCtaClick() {
            Cr.a.event({
                type: "mmEvent",
                category: "plant",
                action: "click_social_seed_8"
            })
        }
    }
    class Ua extends K.a {
        constructor(e) {
            super(Object.assign({
                name: "Preloader",
                log: 0
            }, e)),
            Object(ie.a)(this),
            this.finish = null,
            this.finished = new Promise(e => this.finish = e)
        }
        afterMount() {
            super.afterMount(),
            this._bind()
        }
        exit() {
            if (be.a.removePreloaderDelay.current)
                return this.destroy();
            const e = Object(Fa.a)({
                willChange: !0,
                target: this.nodes.main,
                opacity: 0,
                ease: "out-swift",
                duration: 800
            });
            return new Promise(t => {
                Object(Fa.a)({
                    willChange: !0,
                    target: this.nodes.spinner,
                    opacity: 0,
                    transform: "translateY(25%)",
                    ease: "out-swift",
                    duration: 300
                }).play(),
                Object(Fa.a)({
                    willChange: !0,
                    target: this.nodes.logo,
                    transform: `translateY(${this.nodes.spinner.offsetHeight}px)`,
                    ease: "out-swift",
                    duration: 500
                }).play().then(e.play).then( () => {
                    this.destroy(),
                    t(),
                    Cr.a.event({
                        type: "mmEvent",
                        category: "loader",
                        action: "end_loading"
                    })
                }
                )
            }
            )
        }
        _bind() {
            Mt.a.fileLoader.addEventListener("progress", this._onProgress)
        }
        _unbind() {
            Mt.a.fileLoader.removeEventListener("progress", this._onProgress)
        }
        _onProgress(e) {
            if (be.a.removePreloaderDelay.current)
                return void this.finish();
            Object.keys(Mt.a.fileLoader.waitingList).length || 1 !== e.progress || (Mt.a.fileLoader.removeEventListener("progress", this._onProgress),
            this.finish())
        }
        beforeDestroy() {
            super.beforeDestroy(),
            this._unbind()
        }
    }
    var Ba = i(142)
      , ja = i.n(Ba);
    class Va extends K.a {
        constructor(e) {
            super(Object.assign({
                name: "Rotate",
                log: 0,
                template: ja.a
            }, e)),
            Object(ie.a)(this)
        }
    }
    var Ga = i(35)
      , Xa = i(145)
      , Ya = i.n(Xa)
      , Wa = i(146)
      , qa = i.n(Wa);
    class Ha extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Guide",
                log: 0,
                template: Ya.a,
                styles: qa.a
            }, e)),
            this.currentGuide = Object(G.a)(null),
            this.props.show = this.show.bind(this),
            this.props.hide = this.hide.bind(this)
        }
        afterMount() {
            super.afterMount(),
            this.title = this.addComponent(Ga.a, {
                store: this.currentGuide,
                data: {
                    modifiers: "white",
                    underline: !1,
                    store: !0
                }
            }).mount(this.nodes.wrapper),
            this.hide()
        }
        beforeDestroy() {
            super.beforeDestroy()
        }
        show(e) {
            if (!e)
                return;
            const t = te.a.getCurrent();
            t && (t.level.current < 1 || t.level.current > 2 || (this.currentGuide.set(Object(Ur.a)(`interface.tutorial.tutorial_${e}`)),
            Object(Fa.a)({
                target: this.title.nodes.main,
                opacity: [0, 1],
                transform: ["translateY(20px)", "translateY(0px)"],
                duration: 350,
                ease: "out-swift"
            }).play()))
        }
        hide() {
            Object(Fa.a)({
                target: this.title.nodes.main,
                opacity: 0,
                transform: "translateY(0px)",
                duration: 350,
                ease: "out-swift"
            }).play()
        }
    }
    var Qa = i(143)
      , Ja = i.n(Qa)
      , Za = i(144)
      , $a = i.n(Za);
    class Ka extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Footer",
                log: 0,
                template: Ja.a,
                styles: $a.a
            }, e))
        }
        onClick() {
            Cr.a.event({
                type: "mmEvent",
                category: "menu",
                action: "website_occitane"
            })
        }
    }
    var eo = i(187)
      , to = i(68)
      , io = i.n(to)
      , no = i(97)
      , ro = i.n(no);
    class so extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: `${e.data.name} Button`,
                log: 0,
                template: io.a,
                styles: ro.a
            }, e)),
            this.storeName = this.data.store,
            this.preventShaking = [ba.a],
            this.tweens = {}
        }
        afterMount() {
            super.afterMount(),
            this._initTweens(),
            this._bind()
        }
        _bind() {
            n.a[this.storeName].subscribe(this._toggleAnim, this),
            n.a.device.current.type.desktop && this.nodes.main.addEventListener("mouseenter", () => {
                ve.a.play("mouse_hover")
            }
            ),
            "Garden" === this.data.name && r.a.recomputeDOMObjects.subscribe(this._recomputeGardenAnchor, this)
        }
        _recomputeGardenAnchor() {
            const e = this.nodes.main.getBoundingClientRect()
              , t = this.nodes.main.offsetWidth
              , i = this.nodes.main.offsetHeight
              , n = e.left + .5 * e.width
              , r = e.top + .5 * e.height
              , s = ee.a.guideAnchors.current;
            s.garden.position.x = n - .25 * t,
            s.garden.position.y = -(r + .61 * i)
        }
        _initTweens() {
            this.tweens.icons = new J.a({
                paused: !0
            }),
            this.tweens.icons.to(this.nodes.headerOpenIcon, .25, {
                scale: 0,
                ease: Z.a.easeInOut.config(1.5)
            }).to(this.nodes.headerCloseIcon, .25, {
                scale: .8,
                ease: Z.a.easeInOut.config(1.5)
            }),
            this.tweens.border = $.a.to(this.nodes.headerButtonBorder, .25, {
                scale: .8,
                ease: Z.a.easeInOut.config(1.5),
                repeat: 1,
                yoyo: !0
            }).pause(),
            this.tweens.hide = $.a.to(this.nodes.main, .5, {
                scale: 0,
                ease: Z.a.easeInOut.config(1.5)
            }).pause()
        }
        _toggleAnim(e) {
            const t = e;
            this.tweens.icons[t ? "play" : "reverse"](),
            this.tweens.border.restart(),
            this.tweens.border.play()
        }
        toggleStore() {
            const e = "Menu" === this.data.name && n.a.menuOpen.current && !document.body.classList.contains("left-panel-open")
              , t = "Garden" === this.data.name && n.a.seedListOpen.current && !document.body.classList.contains("right-panel-open");
            if (!(e || t || this.tweens.icons.isActive()) && ("Menu" !== this.data.name || n.a.menuOpen.current || n.a.leftPanelView.set({
                type: "menu"
            }),
            n.a[this.storeName].update(e => !e),
            "Menu" === this.data.name && n.a.menuOpen.current && Cr.a.event({
                type: "mmPageview",
                value: "/menu"
            }),
            "Garden" === this.data.name && n.a.seedListOpen.current && !te.a.flags.current.openGarden)) {
                const e = te.a.flags.current;
                e.openGarden = !0,
                te.a.flags.set(e, !0),
                Ds.a.requestSave()
            }
        }
    }
    var ao = i(98)
      , oo = i.n(ao)
      , lo = i(99)
      , co = i.n(lo);
    class ho extends so {
        constructor(e) {
            super(Object.assign({
                name: `${e.data.name} Button`,
                log: 0,
                template: oo.a,
                styles: co.a
            }, e)),
            this.seeds = Object.values(te.a.seeds.current),
            this.store.unlockedSeeds = Object(G.a)(!0)
        }
        updateNotif(e, t) {
            e.classList.toggle("is-hidden", !t)
        }
        afterMount() {
            super.afterMount();
            this.onSeedsUnlockedOrLevelUpdate = Object(eo.a)(this._onSeedsUnlockedOrLevelUpdate, 3e3),
            this.onSeedsUnlockedOrLevelUpdate2 = Object(eo.a)(this._onSeedsUnlockedOrLevelUpdate, 350),
            this.seeds.forEach(e => {
                e.level.subscribe(this.onSeedsUnlockedOrLevelUpdate, this),
                e.unlocked.subscribe(this.onSeedsUnlockedOrLevelUpdate, this)
            }
            ),
            te.a.currentSeed.subscribe(this.onSeedsUnlockedOrLevelUpdate2, this),
            this._onSeedsUnlockedOrLevelUpdate(te.a.currentSeed.current)
        }
        _onSeedsUnlockedOrLevelUpdate(e) {
            this.onSeedsUnlockedOrLevelUpdate.cancel(),
            this.onSeedsUnlockedOrLevelUpdate2.cancel();
            let t = !1
              , i = 0;
            this.seeds.forEach(n => {
                if (0 === n.level.current && n.unlocked.current)
                    return t = !0,
                    i++,
                    e.id && e.id.current === n.id.current && (t = !1),
                    !1
            }
            ),
            ee.a.gardenNotification.set(t),
            this.nodes.notif.textContent = i,
            this.store.unlockedSeeds.current != t && this.store.unlockedSeeds.set(t)
        }
    }
    var uo = i(95)
      , po = i.n(uo)
      , fo = i(96)
      , mo = i.n(fo);
    class go extends K.a {
        constructor(e) {
            super(Object.assign({
                name: "Header",
                log: 0,
                template: po.a,
                styles: mo.a
            }, e)),
            this.buttons = []
        }
        afterMount() {
            super.afterMount(),
            this._initSubComponents(),
            this._seedUIChange(),
            this.muteButton.tweens.hide.progress(1),
            n.a.seedUiVisible.current || this.gardenButton.tweens.hide.progress(1),
            n.a.menuOpen.subscribe(this._onMenuOpen, this),
            n.a.seedListOpen.subscribe(this._onGardenOpen, this),
            n.a.seedUiVisible.subscribe(this._seedUIChange, this),
            n.a.homeUiVisible.subscribe( () => {
                this.menuButton.tweens.hide.reverse()
            }
            , this)
        }
        _initSubComponents() {
            this.menuButton = this.addComponent(so, {
                data: {
                    name: "Menu",
                    store: "menuOpen",
                    icon: "icon_burger"
                }
            }).mount(this.nodes.headerInner),
            this.muteButton = this.addComponent(so, {
                data: {
                    name: "Mute",
                    store: "muteSound",
                    icon: "icon_sound"
                }
            }).mount(this.nodes.headerInner),
            this.gardenButton = this.addComponent(ho, {
                data: {
                    name: "Garden",
                    store: "seedListOpen",
                    icon: "icon_garden"
                }
            }).mount(this.nodes.headerInner)
        }
        _onMenuOpen(e) {
            e ? (ve.a.play("panel_left_open"),
            this.muteButton.tweens.hide.reverse(),
            this.gardenButton.tweens.hide.play()) : (ve.a.play("panel_left_close"),
            this.muteButton.tweens.hide.play(),
            n.a.seedUiVisible.current && this.gardenButton.tweens.hide.reverse())
        }
        _onGardenOpen(e) {
            e ? (Cr.a.event({
                type: "mmPageview",
                value: "/garden"
            }),
            ve.a.play("panel_right_open"),
            this.menuButton.tweens.hide.play()) : (ve.a.play("panel_right_close"),
            this.menuButton.tweens.hide.reverse())
        }
        _seedUIChange(e) {
            const t = !(e || n.a.seedUiVisible.current);
            this.menuButton.tweens.hide[t ? "play" : "reverse"](),
            this.gardenButton.tweens.hide[t ? "play" : "reverse"]()
        }
    }
    var vo = i(31)
      , yo = i(109)
      , bo = i.n(yo)
      , xo = i(110)
      , wo = i.n(xo);
    const _o = {};
    class To extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Voucher Details",
                log: 0,
                template: bo.a,
                styles: wo.a
            }, e)),
            this.data = {},
            this.data.voucher = te.a.vouchers.current[e.seedId],
            this.data.seedDescription = Object(Ur.a)(`seeds.${e.seedId}.benefits`)
        }
        beforeMount() {
            const e = this.nodes.voucherImage
              , t = _o[this.props.seedId];
            t && e.parentNode ? e.parentNode.replaceChild(t, e) : (_o[this.props.seedId] = e,
            e.onload = function() {
                e.classList.add("loaded")
            }
            ,
            e.src = e.dataset.src),
            super.beforeMount()
        }
        afterMount() {
            super.afterMount(),
            this.cta = this.addComponent(vo.a, {
                data: {
                    text: this.data.voucher.voucher,
                    modifiers: "gold, voucher",
                    icon: "icon_copypaste",
                    ref: "copyToClipboard",
                    copyToClipboard: !0
                }
            }).mount(this.nodes.voucherInfos),
            this.cta.nodes.main.dataset.seedId = this.props.seedId,
            this.addComponent(wa.a, {
                name: this.props.seedId,
                loop: !0
            }).mount(this.nodes.seedAnim).addComponent(vo.a, {
                onClick: () => {
                    Cr.a.event({
                        type: "mmEvent",
                        category: "voucher",
                        action: "discover_range",
                        label: Object(Dr.a)(this.props.seedId)
                    })
                }
                ,
                data: {
                    modifiers: "blue, center",
                    text: Object(Ur.a)(`seeds.${this.props.seedId}.cta`),
                    url: Object(Ur.a)(`seeds.${this.props.seedId}.url`)
                }
            }).mount(this.nodes.voucherDesc)
        }
        beforeDestroy() {
            super.beforeDestroy()
        }
    }
    const Mo = new Set(["INPUT", "TEXTAREA", "SELECT"])
      , So = new Set(["text", "email", "tel", "file", "password", "date"])
      , Ao = () => "ios" === n.a.device.current.os
      , Po = new Map;
    function Co() {
        window.scrollTo(0, 0)
    }
    function Lo(e) {
        e && e.addEventListener("blur", Co)
    }
    function ko(e) {
        e && e.removeEventListener("blur", Co)
    }
    var Eo = {
        bind: function(e) {
            if (!Ao())
                return;
            const t = function(e) {
                const t = e.querySelectorAll("input, textarea, select")
                  , i = t ? Array.from(t) : [];
                return Mo.has(e.tagName) && i.push(e),
                i
            }(e);
            if (t.length < 1)
                return;
            Po.has(e) || Po.set(e, []);
            const i = Po.get(e);
            for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                ("INPUT" !== n.tagName || So.has(n.type || "text")) && (Lo(n),
                i.push(n))
            }
        },
        unbind: function(e) {
            if (!Ao() || !Po.has(e))
                return;
            Po.get(e).forEach(ko),
            Po.delete(e)
        }
    }
      , Io = i(117)
      , Fo = i.n(Io)
      , Oo = i(118)
      , Ro = i.n(Oo);
    class zo extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Select",
                log: 0,
                template: Fo.a,
                styles: Ro.a
            }, e)),
            this.isFilled = !1,
            this.props.markets && (this.data.options = this._getMarketsList())
        }
        beforeMount() {
            super.beforeMount(),
            this.data.defaultValue && this.data.defaultValue !== this.data.placeholder && this._setFilledState()
        }
        afterMount() {
            super.afterMount(),
            Eo.bind(this.nodes.main)
        }
        beforeDestroy() {
            super.beforeDestroy(),
            Eo.unbind(this.nodes.main)
        }
        onChange(e) {
            if (this._setFilledState(),
            this.props.markets && this.props.reload) {
                const t = e.target.value.split("/");
                t.shift(),
                xe.a.redirect({
                    market: t[0],
                    lang: t[1]
                })
            }
        }
        _setFilledState() {
            this.isFilled || (this.nodes.main.classList.add("is-filled"),
            this.isFilled = !0)
        }
        _getMarketsList() {
            const e = [];
            for (const [t,i] of Object.entries(Object(Ur.a)("markets"))) {
                if (!1 !== n.a.language.current.content.api.openedMarkets[t])
                    for (let r = 0; r < i.langs.length; r++) {
                        const s = i[`country${r + 1}`].match(/master/i);
                        "dev" !== n.a.env.current && s || e.push({
                            title: i[`country${r + 1}`],
                            value: `/${t}/${i.langs[r]}`
                        })
                    }
            }
            return e
        }
    }
    var No = i(123)
      , Do = i.n(No)
      , Uo = i(124)
      , Bo = i.n(Uo);
    class jo extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Menu Footer",
                log: 0,
                template: Do.a,
                styles: Bo.a
            }, e)),
            te.a.id.current && (this.data.userIsLogged = !0)
        }
        afterMount() {
            super.afterMount(),
            te.a.id.current || this.addComponent(zo, {
                markets: !0,
                reload: !0,
                data: {
                    defaultValue: `/${n.a.language.current.market}/${n.a.language.current.code}`,
                    placeholder: Object(Ur.a)("interface.form.country")
                }
            }).mount(this.nodes.menuSelect)
        }
        onClick(e) {
            let t = "";
            switch (e.target.dataset.index) {
            case "0":
                t = "christmas_garden";
                break;
            case "1":
                t = "access_bestsellers";
                break;
            case "2":
                t = "access_privacy";
                break;
            case "3":
                t = "access_terms"
            }
            Cr.a.event({
                type: "mmEvent",
                category: "menu",
                action: t
            })
        }
    }
    var Vo = i(105)
      , Go = i.n(Vo)
      , Xo = i(106)
      , Yo = i.n(Xo);
    class Wo extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Challenge",
                log: 0,
                template: Go.a,
                styles: Yo.a
            }, e)),
            this.data.text = Object(Ur.a)("api.finalChallenge.description")
        }
        afterMount() {
            super.afterMount(),
            this.addComponent(Ga.a, {
                data: {
                    text: Object(Ur.a)("api.finalChallenge.title"),
                    modifiers: "white",
                    underline: !1
                }
            }).mount(e => {
                this.nodes.main.insertBefore(e, this.nodes.challengeText)
            }
            ),
            te.a.gameComplete.subscribe(this._onGameComplete, this),
            this._onGameComplete()
        }
        destroy() {
            te.a.gameComplete.unsubscribe(this._onGameComplete, this),
            super.destroy()
        }
        _onGameComplete() {
            te.a.gameComplete.current && this._addButton()
        }
        _addButton() {
            !this.button && te.a.vouchers.current.final && (this.button = this.addComponent(vo.a, {
                data: {
                    text: Object(Ur.a)("api.finalChallenge.buttonLabel"),
                    url: te.a.vouchers.current.final.link,
                    modifiers: "gold",
                    onClick: () => {
                        Cr.a.event({
                            type: "mmEvent",
                            category: "voucher",
                            action: "challenge_final"
                        })
                    }
                }
            }),
            this.button.mount(this.nodes.main))
        }
    }
    var qo = function(e, t="is-error") {
        let i = !0;
        const n = new FormData(e);
        return e.querySelectorAll("[required]").forEach(n => {
            const r = n.validity.valid;
            n.parentNode.classList.toggle(t, !r),
            i = i && r,
            e.classList.toggle(t, !i)
        }
        ),
        i && n
    }
      , Ho = i(113)
      , Qo = i.n(Ho)
      , Jo = i(114)
      , Zo = i.n(Jo);
    class $o extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Input",
                log: 0,
                template: Qo.a,
                styles: Zo.a
            }, e))
        }
        afterMount() {
            super.afterMount(),
            Eo.bind(this.nodes.main)
        }
        beforeDestroy() {
            super.beforeDestroy(),
            Eo.unbind(this.nodes.main)
        }
    }
    var Ko = i(115)
      , el = i.n(Ko)
      , tl = i(116)
      , il = i.n(tl);
    class nl extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Register",
                log: 0,
                template: el.a,
                styles: il.a
            }, e)),
            this.formConfig = Object(Ur.a)("markets")[n.a.language.current.market],
            Cr.a.event({
                type: "mmPageview",
                value: "/inscription"
            })
        }
        afterMount() {
            super.afterMount(),
            this.formConfig.gender && this.addComponent(zo, {
                data: {
                    name: "gender",
                    placeholder: Object(Ur.a)("interface.form.gender"),
                    defaultValue: Object(Ur.a)("interface.form.gender"),
                    options: [{
                        title: Object(Ur.a)("interface.form.women"),
                        value: "female"
                    }, {
                        title: Object(Ur.a)("interface.form.men"),
                        value: "male"
                    }, {
                        title: Object(Ur.a)("interface.form.none"),
                        value: "none"
                    }],
                    required: !0
                }
            }).mount(this.nodes.formFields),
            this.formConfig.firstname && (this.firstname = this.addComponent($o, {
                data: {
                    name: "firstname",
                    placeholder: Object(Ur.a)("interface.form.firstname"),
                    pattern: "[a-zA-Z0-9]+",
                    required: !0
                }
            }).mount(this.nodes.formFields)),
            this.formConfig.lastname && (this.lastname = this.addComponent($o, {
                data: {
                    name: "lastname",
                    placeholder: Object(Ur.a)("interface.form.lastname"),
                    required: !0
                }
            }).mount(this.nodes.formFields)),
            this.formConfig.email && (this.email = this.addComponent($o, {
                data: {
                    type: "email",
                    name: "email",
                    placeholder: Object(Ur.a)("interface.form.email"),
                    required: !0
                }
            }).mount(this.nodes.formFields)),
            this.addComponent(zo, {
                markets: !0,
                data: {
                    name: "country",
                    placeholder: Object(Ur.a)("interface.form.country"),
                    defaultValue: `/${n.a.language.current.market}/${n.a.language.current.code}`,
                    required: !0
                }
            }).mount(this.nodes.formFields),
            this.formConfig.optin && this.addComponent($o, {
                data: {
                    type: "checkbox",
                    name: "optin",
                    label: this._addLinks(Object(Ur.a)("interface.form.optin_1"))
                }
            }).mount(this.nodes.formFields),
            this.addComponent($o, {
                data: {
                    type: "checkbox",
                    name: "optin_legals",
                    label: this._addLinks(Object(Ur.a)("interface.form.optin_2")),
                    required: !0
                }
            }).mount(this.nodes.formFields),
            this.formConfig.line_connect && (this.lineId = this.addComponent($o, {
                data: {
                    type: "hidden",
                    name: "lineId"
                }
            }).mount(this.nodes.formFields)),
            this.submitButton = this.addComponent(vo.a, {
                data: {
                    type: "submit",
                    modifiers: "submit",
                    text: Object(Ur.a)("interface.form.cta_confirm")
                }
            }).mount(this.nodes.formFields),
            this._prefillForm()
        }
        _addLinks(e) {
            const t = (e, t) => `<a onclick="event.stopPropagation()" href="${t}" target="_blank">${e}</a>`;
            return e = (e = e.replace("[TERMS]", t(Object(Ur.a)("interface.menu.legals"), Object(Ur.a)("api.legal")))).replace("[PRIVACY]", t(Object(Ur.a)("interface.menu.privacy_policy"), Object(Ur.a)("interface.menu.privacy_policy_url")))
        }
        _prefillForm() {
            const e = te.a.socialPrefill.current;
            e && (e.firstname && (this.firstname.nodes.firstname.value = e.firstname),
            e.lastname && (this.lastname.nodes.lastname.value = e.lastname),
            e.email && (this.email.nodes.email.value = e.email),
            e.lineId && (this.lineId.nodes.lineId.value = e.lineId),
            te.a.socialPrefill.set(null))
        }
        onFormSubmit(e) {
            e.preventDefault();
            const t = qo(e.target);
            if (!1 === t)
                return void n.a.registerFromError.set(!0);
            const i = t.get("country").split("/");
            i.shift(),
            t.append("market", i[0]),
            t.append("lang", i[1]),
            document.body.classList.add("is-submitting"),
            this.submitButton.nodes.main.setAttribute("disabled", !0),
            this.nodes.formError.style.display = null,
            Ds.a.register(t).then(e => {
                document.body.classList.remove("is-submitting"),
                this.submitButton.nodes.main.removeAttribute("disabled"),
                n.a.menuOpen.set(!1),
                fe.a.createRegisterConfirm({
                    onClose: () => {
                        const {market: t, code: i} = n.a.language.current;
                        if (e.lang !== i || e.market !== t)
                            return Ds.a.redirectUser(e);
                        "/" === xe.a.history.current && xe.a.navigateById("choice")
                    }
                })
            }
            ).catch(e => {
                document.body.classList.remove("is-submitting"),
                this.submitButton.nodes.main.removeAttribute("disabled"),
                4 === e.code && (this.nodes.formFields.querySelector(".input--email").classList.add("is-error"),
                n.a.registerFromError.set(!0),
                this.nodes.formError.style.display = "block",
                this.nodes.formError.textContent = Object(Ur.a)("interface.form.error_email"))
            }
            )
        }
    }
    var rl = i(72)
      , sl = i.n(rl)
      , al = i(121)
      , ol = i.n(al)
      , ll = i(122)
      , cl = i.n(ll);
    class hl extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Share",
                log: 0,
                template: ol.a,
                styles: cl.a
            }, e))
        }
        openShare(e) {
            e.preventDefault();
            const t = e.target
              , i = t.getAttribute("ref").match(/facebook/i)
              , r = t.getAttribute("ref").match(/twitter/i);
            i && (sl.a.facebook(window.location.href),
            Cr.a.event({
                type: "mmEvent",
                category: "social network",
                action: "share_facebook"
            })),
            r && (sl.a.twitter(n.a.language.current.content.interface.share.twitter_description, [], window.location.href),
            Cr.a.event({
                type: "mmEvent",
                category: "social network",
                action: "share_twitter"
            }))
        }
    }
    var ul = i(119)
      , pl = i.n(ul)
      , dl = i(120)
      , fl = i.n(dl);
    class ml extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Menu Nav",
                log: 0,
                template: pl.a,
                styles: fl.a
            }, e)),
            te.a.id.current && (this.data.userIsLogged = !0)
        }
        afterMount() {
            super.afterMount(),
            this.addComponent(hl).mount(this.nodes.main)
        }
        openLogin(e) {
            e.preventDefault(),
            n.a.leftPanelView.set({
                type: "login"
            }),
            Cr.a.event({
                type: "mmPageview",
                value: "/sign-in"
            }),
            Cr.a.event({
                type: "mmEvent",
                category: "menu",
                action: "sign_in"
            })
        }
        openVouchers(e) {
            e.preventDefault(),
            n.a.leftPanelView.set({
                type: "vouchers"
            })
        }
        logout(e) {
            e.preventDefault(),
            Ds.a.logout(),
            Cr.a.event({
                type: "mmEvent",
                category: "menu",
                action: "log_out"
            })
        }
    }
    var gl = i(107)
      , vl = i.n(gl)
      , yl = i(108)
      , bl = i.n(yl);
    class xl extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: `Voucher - ${e.title}`,
                log: 0,
                template: vl.a,
                styles: bl.a
            }, e)),
            this.data = {};
            const t = te.a.vouchers.current[this.props.seedId];
            this.props.unlocked && (this.voucherId = t.voucher,
            this.data.voucherCode = this.voucherId),
            this.desktopLayout = v.a.mq({
                from: "md"
            })
        }
        afterMount() {
            super.afterMount(),
            this._mountComponents()
        }
        goToVoucher() {
            xe.a.navigate(xe.a.url("seed", {
                id: this.props.seedId
            })),
            this.props.unlocked && (te.a.id.current ? n.a.leftPanelView.set({
                type: "voucherDetails",
                seedId: this.props.seedId
            }) : fe.a.createAskRegister())
        }
        playOnRollover() {
            this.desktopLayout && Object.keys(this.bodymovin).forEach(e => {
                this.bodymovin[e].lottie && this.bodymovin[e].play()
            }
            )
        }
        _mountComponents() {
            this.bodymovin = {},
            this.props.unlocked ? (this.cta = this.addComponent(vo.a, {
                data: {
                    modifiers: "gold, voucher, circular",
                    icon: "icon_copypaste",
                    text: this.voucherId,
                    copyToClipboard: !0
                }
            }).mount(this.nodes.main),
            this.cta.nodes.main.dataset.seedId = this.props.seedId) : (this.bodymovin.lock = this.addComponent(wa.a, {
                name: "lock",
                speed: 2,
                data: {
                    modifiers: "lock"
                }
            }).mount(this.nodes.voucherAnim),
            this.bodymovin.bag = this.addComponent(wa.a, {
                name: "bag",
                loop: this.props.unlocked,
                renderer: "svg",
                speed: 2,
                data: {
                    modifiers: "bag, locked"
                }
            }).mount(this.nodes.voucherAnim),
            this.nodes.main.classList.add("is-locked")),
            this.bodymovin.seed = this.addComponent(wa.a, {
                name: `${this.props.seedId}${this.props.unlocked ? "" : "-locked"}`,
                loop: this.props.unlocked && !n.a.device.current.type.mobile,
                renderer: !this.props.unlocked && "svg",
                speed: this.props.unlocked ? 1 : 2,
                data: {
                    modifiers: `${this.props.title}, seed, ${this.props.unlocked ? "" : "locked"}`
                }
            }).mount(this.nodes.voucherAnim),
            this.addComponent(Ga.a, {
                data: {
                    text: Object(Ur.a)(`seeds.${this.props.seedId}.seed_name`),
                    underline: !1
                }
            }).mount(e => this.nodes.voucherContent.prepend(e))
        }
    }
    var wl = i(102)
      , _l = i.n(wl)
      , Tl = i(63)
      , Ml = i(103)
      , Sl = i.n(Ml)
      , Al = i(104)
      , Pl = i.n(Al);
    class Cl extends K.a {
        constructor(e) {
            super(Object.assign({
                name: "Scroll",
                log: 0,
                template: Sl.a,
                styles: Pl.a
            }, e)),
            this.bounds = {},
            this.bounds.screenWidth = n.a.viewportSize.current[0]
        }
        afterMount() {
            super.afterMount(),
            this._customScroll()
        }
        beforeDestroy() {
            super.beforeDestroy(),
            this.scroll && this.scroll.destroy(),
            n.a.viewportSize.unsubscribe(this._onResize, this),
            n.a.registerFromError.unsubscribe(this._onResize, this)
        }
        _customScroll() {
            const e = v.a.mq({
                from: "md"
            });
            !n.a.device.current.type.tablet && e || (this.scroll = new _l.a({
                source: this.nodes.scrollInner,
                multiplier: 1.15,
                update: (e, t) => Tl.d.set(this.nodes.scrollInner, {
                    y: t,
                    z: .001
                })
            }),
            setTimeout( () => this._getBounds(!1), 100),
            n.a.viewportSize.subscribe(this._onResize, this),
            n.a.registerFromError.subscribe(this._scrollToError, this))
        }
        _scrollToError(e) {
            if (!e || !this.scroll)
                return;
            const t = this.nodes && this.nodes.scrollInner.querySelectorAll("div.is-error")[0]
              , i = t && -1 * t.offsetTop;
            if (!i)
                return;
            const r = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--panelBgHeight"));
            this.scroll.pause(),
            Tl.d.to(this.nodes.scrollInner, .5, {
                y: i + r,
                onComplete: () => {
                    n.a.registerFromError.set(!1),
                    this.scroll.setValues(0, i),
                    this.scroll.resume()
                }
            })
        }
        _getBounds(e) {
            if (e || !this.nodes)
                return;
            this.scroll.pause(),
            this.previousScroll = this.nodes.scrollInner._gsTransform,
            this.nodes.scrollInner.style.transform = null,
            this.bounds.inner = this.nodes.scrollInner.getBoundingClientRect();
            const t = this.bounds.inner.height - this.nodes.main.offsetHeight + this.bounds.inner.top;
            t > 1 && (this.scroll.setBoundY([-1 * t, 0]),
            this.previousScroll && Tl.d.set(this.nodes.scrollInner, {
                y: this.previousScroll.y
            }),
            this.previousScroll && this.scroll.setValues(0, this.previousScroll.y),
            this.scroll.resume())
        }
        _onResize() {
            const e = n.a.viewportSize.current[0] === this.bounds.screenWidth;
            this._getBounds(e),
            this.bounds.screenWidth = n.a.viewportSize.current[0]
        }
    }
    var Ll = i(127)
      , kl = i.n(Ll)
      , El = i(128)
      , Il = i.n(El);
    class Fl extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: `Garden Seed - ${e.name}`,
                log: 0,
                template: kl.a,
                styles: Il.a
            }, e)),
            this.desktopLayout = v.a.mq({
                from: "md"
            }),
            this.tweens = {},
            this.preventShaking = [ba.a],
            this.data.locked = this.props.locked,
            this.data.planted = this.props.planted
        }
        afterMount() {
            super.afterMount(),
            this._initBodymovin(),
            this.addComponent(Ga.a, {
                data: {
                    text: Object(Ur.a)(`seeds.${this.props.name}.seed_name`),
                    modifiers: "white",
                    underline: !1
                }
            }).mount(this.nodes.gardenSeedInner),
            this.nodes.main.classList.toggle("is-locked", this.props.locked),
            this.nodes.main.classList.toggle("is-planted", this.props.planted),
            n.a.seedListOpen.subscribe(this.rightPanelVisibilityUpdate, this),
            this.rightPanelVisibilityUpdate(n.a.seedListOpen.current)
        }
        rightPanelVisibilityUpdate(e) {
            this.components && this.components.forEach(t => {
                t.lottie && t.settings.loop && (e && !t.noPlay ? t.lottie.play() : t.lottie.pause())
            }
            )
        }
        playOnRollover() {
            this.desktopLayout && this.components.forEach(e => {
                e.lottie && e.play()
            }
            )
        }
        goToSeed() {
            xe.a.navigate(xe.a.url("seed", {
                id: this.props.name
            })),
            n.a.seedListOpen.set(!1),
            Cr.a.event({
                type: "mmEvent",
                category: "garden",
                action: "click_seed",
                label: Object(Dr.a)(this.props.name)
            })
        }
        activeState() {
            this.tweens.seed.restart(),
            this.tweens.seed.play()
        }
        _initBodymovin() {
            this.seed = this.addComponent(wa.a, {
                name: `${this.props.name}${this.props.planted ? "" : "-locked"}`,
                loop: this.props.planted,
                renderer: this.props.locked && "svg",
                speed: this.props.planted ? 1 : 2,
                data: {
                    modifiers: `${this.props.name}, seed, ${this.props.locked ? "locked" : ""}`
                }
            }).mount(this.nodes.gardenSeedInner),
            this.props.planted || (this.bag = this.addComponent(wa.a, {
                name: "bag",
                speed: 2,
                renderer: this.props.locked && "svg",
                data: {
                    modifiers: `bag, ${this.props.locked ? "locked" : ""}`
                }
            }).mount(this.nodes.gardenSeedInner)),
            this.tweens.seed = $.a.to(this.nodes.main, .15, {
                scale: .8,
                ease: Xe.d.easeOut,
                repeat: 1,
                yoyo: !0
            }).pause()
        }
    }
    var Ol = i(125)
      , Rl = i.n(Ol)
      , zl = i(126)
      , Nl = i.n(zl);
    const Dl = {
        unlocked: {},
        planted: {}
    };
    class Ul extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Garden",
                log: 0,
                template: Rl.a,
                styles: Nl.a
            }, e)),
            this.seeds = {}
        }
        afterMount() {
            super.afterMount(),
            this._initSeeds(),
            n.a.seedListOpen.subscribe(this._initSeeds, this)
        }
        _initSeeds(e) {
            const t = e;
            te.a.seedsArray.current.forEach( (e, i) => {
                const n = e.level.current > 0
                  , r = e.unlocked.current
                  , s = r || n ? i : null;
                t && this._destroySeed(e),
                this._mountSeed(e, s),
                r && (Dl.unlocked[e.id.current] = !0),
                n && (Dl.planted[e.id.current] = !0)
            }
            )
        }
        _destroySeed(e) {
            const t = e.unlocked.current && !Dl.unlocked[e.id.current]
              , i = e.level.current > 0 && !Dl.planted[e.id.current];
            (t || i) && (this.seeds[e.id.current].destroy(),
            this.seeds[e.id.current] = null)
        }
        _mountSeed(e, t) {
            const i = e.id.current;
            this.seeds[i] || (this.seeds[i] = this.addComponent(Fl, {
                name: i,
                locked: !e.unlocked.current,
                planted: e.level.current > 0
            }).mount(e => {
                this.nodes.main.children[t] ? this.nodes.main.insertBefore(e, this.nodes.main.children[t]) : this.nodes.main.appendChild(e)
            }
            ))
        }
    }
    let Bl = !1
      , jl = !1;
    const Vl = () => {
        FB.init({
            appId: n.a.facebookId.current,
            autoLogAppEvents: !0,
            xfbml: !0,
            version: "v3.3"
        }),
        Bl = !0
    }
    ;
    var Gl = {
        init: Vl,
        connect: () => !window.FB && window.Optanon ? (Optanon.ToggleInfoDisplay(),
        Promise.reject()) : (Bl || Vl(),
        FB.getAccessToken() ? (jl = !0,
        Promise.resolve({
            accessToken: FB.getAccessToken()
        })) : new Promise( (e, t) => {
            FB.login(function(i) {
                "connected" === i.status ? (jl = !0,
                e(i.authResponse)) : t()
            }, {
                scope: "public_profile,email"
            })
        }
        )),
        profile: () => jl ? new Promise( (e, t) => {
            FB.api("/me?fields=id,email,last_name,first_name", function(t) {
                e(t)
            })
        }
        ) : Promise.reject()
    };
    const Xl = 1e6 * Math.random() >> 0
      , Yl = (e, t, i) => {
        const n = window.innerWidth - 400
          , r = window.innerHeight / 2 - 365;
        return window.open(e + "?" + Wl(t), i, "menubar=no,location=no,resizable=no,scrollbars=no,status=no,width=800,height=730,top=" + r + ",left=" + n)
    }
      , Wl = e => {
        const t = new Array;
        for (const i in e)
            t.push(i + "=" + encodeURIComponent(e[i]));
        return t.join("&")
    }
    ;
    var ql = {
        connect: () => {
            const e = window.location.origin + "/connect"
              , t = Yl("https://access.line.me/oauth2/v2.1/authorize", {
                scope: "openid profile email",
                response_type: "code",
                client_id: n.a.lineId.current,
                state: Xl,
                redirect_uri: e
            }, "line_connect");
            return new Promise( (e, i) => {
                let n = !1;
                const r = t => (n = !0,
                clearInterval(s),
                t.origin == window.location.origin && t.data.line ? t.data.state !== Xl ? i() : (window.removeEventListener("message", r),
                void e(t.data)) : i())
                  , s = window.setInterval( () => {
                    if (!n)
                        return t.closed ? (clearInterval(s),
                        i()) : void 0;
                    clearInterval(s)
                }
                , 1e3);
                window.addEventListener("message", r)
            }
            )
        }
        ,
        share: e => {
            Yl("https://social-plugins.line.me/lineit/share", {
                url: e
            }, "line_share")
        }
    }
      , Hl = i(111)
      , Ql = i.n(Hl)
      , Jl = i(112)
      , Zl = i.n(Jl);
    class $l extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Login",
                log: 0,
                template: Ql.a,
                styles: Zl.a
            }, e)),
            this.formConfig = Object(Ur.a)("markets")[n.a.language.current.market],
            this.data.fb_connect = this.formConfig.fb_connect,
            this.data.line_connect = this.formConfig.line_connect,
            this.data.webview = n.a.webview.current
        }
        afterMount() {
            super.afterMount(),
            this.formConfig.fb_connect && !n.a.webview.current && this.addComponent(vo.a, {
                onClick: this.connectFacebook.bind(this),
                data: {
                    text: Object(Ur.a)("interface.connection.cta_facebook"),
                    icon: "logo_social_fb_bubble",
                    modifiers: "social, facebook"
                }
            }).mount(this.nodes.socialButtons),
            this.formConfig.line_connect && !n.a.webview.current && this.addComponent(vo.a, {
                onClick: this.connectLine.bind(this),
                data: {
                    text: Object(Ur.a)("interface.connection.cta_line"),
                    icon: "logo_social_line_bubble",
                    modifiers: "social, line"
                }
            }).mount(this.nodes.socialButtons),
            this.email = this.addComponent($o, {
                data: {
                    type: "email",
                    name: "email",
                    placeholder: Object(Ur.a)("interface.connection.placeholder"),
                    required: !0
                }
            }).mount(this.nodes.formFields),
            this.submitButton = this.addComponent(vo.a, {
                data: {
                    text: Object(Ur.a)("interface.connection.cta_email"),
                    modifiers: "submit",
                    type: "submit"
                }
            }).mount(this.nodes.formFields)
        }
        connectLine() {
            Ds.a.addSocialFlag(),
            ql.connect().then(e => Ds.a.socialConnect("line", e.user.idToken).then(e => {
                Ds.a.redirectUser(e),
                Cr.a.event({
                    type: "mmEvent",
                    category: "form",
                    action: "connexion",
                    label: "line"
                })
            }
            ).catch( () => {
                const {user: t} = e
                  , i = {
                    lineId: t.id
                };
                if (t.email && (i.email = t.email),
                t.name) {
                    const e = t.name.trim().split(" ");
                    i.lastname = e.pop(),
                    i.firstname = e.join(" ")
                }
                Ds.a.removeSocialFlag(),
                te.a.socialPrefill.set(i),
                n.a.leftPanelView.set({
                    type: "register"
                })
            }
            )).catch( () => {
                Ds.a.removeSocialFlag(),
                this.onSocialError()
            }
            )
        }
        connectFacebook() {
            Ds.a.addSocialFlag(),
            Gl.connect().then(e => Ds.a.socialConnect("facebook", e.accessToken).then(e => {
                Ds.a.redirectUser(e),
                Cr.a.event({
                    type: "mmEvent",
                    category: "form",
                    action: "connexion",
                    label: "facebook"
                })
            }
            ).catch( () => {
                Gl.profile().then(e => {
                    Ds.a.removeSocialFlag(),
                    te.a.socialPrefill.set({
                        email: e.email,
                        firstname: e.first_name,
                        lastname: e.last_name
                    }),
                    n.a.leftPanelView.set({
                        type: "register"
                    })
                }
                ).catch( () => {
                    Ds.a.removeSocialFlag(),
                    this.onSocialError()
                }
                )
            }
            )).catch( () => {
                Ds.a.removeSocialFlag(),
                this.onSocialError()
            }
            )
        }
        onSocialError() {
            this.nodes.main.classList.add("is-social-error")
        }
        onAskLoginEmail(e) {
            e.preventDefault();
            const t = qo(e.target);
            !1 !== t && (document.body.classList.add("is-submitting"),
            this.submitButton.nodes.main.setAttribute("disabled", !0),
            Ds.a.sendEmail(t).then( () => {
                document.body.classList.remove("is-submitting"),
                this.submitButton.nodes.main.removeAttribute("disabled"),
                n.a.menuOpen.set(!1),
                fe.a.createRegisterConfirm(),
                Cr.a.event({
                    type: "mmEvent",
                    category: "form",
                    action: "send_my_garden_link"
                })
            }
            ).catch(e => {
                document.body.classList.remove("is-submitting"),
                this.submitButton.nodes.main.removeAttribute("disabled"),
                3 === e.code && (te.a.socialPrefill.set({
                    email: this.email.nodes.email.value
                }),
                n.a.leftPanelView.set({
                    type: "register"
                }))
            }
            ))
        }
    }
    var Kl = i(100)
      , ec = i.n(Kl)
      , tc = i(101)
      , ic = i.n(tc);
    class nc extends xa.a {
        constructor(e) {
            super(Object.assign({
                name: "Panel",
                log: 0,
                template: ec.a,
                styles: ic.a
            }, e)),
            this.tweens = {},
            this.storeName = "left" === this.data.modifiers ? "menuOpen" : "seedListOpen",
            this.desktopLayout = v.a.mq({
                from: "md"
            })
        }
        afterMount() {
            super.afterMount(),
            this._setTopPadding(),
            n.a[this.storeName].subscribe(this._toggle, this),
            n.a[`${this.data.modifiers}PanelView`].subscribe(this._mountComponents, this),
            n.a.viewportSize.subscribe(this._onResize, this),
            this.nodes.main.parentNode.insertBefore(this.nodes.panelBg, this.nodes.main.nextSibling),
            this.nodes.main.parentNode.insertBefore(this.nodes.panelClose, this.nodes.main.nextSibling),
            "right" === this.data.modifiers && n.a.rightPanelView.set({
                type: "garden"
            })
        }
        _mountTitle(e) {
            this.scroll.addComponent(Ga.a, {
                data: {
                    text: Object(Ur.a)(e),
                    modifiers: "white"
                }
            }).mount(this.scroll.nodes.scrollInner)
        }
        _mountComponents(e) {
            this.panelView && this.nodes.main.classList.remove(`panel--${this.panelView}`),
            this.panelView = e.type,
            this.nodes.main.classList.add(`panel--${this.panelView}`),
            this.scroll && this.scroll.destroy(),
            this.scroll = this.addComponent(Cl).mount(this.nodes.panelContent),
            this._mountMenu(),
            this._mountVouchersList(),
            this._mountVoucherDetails(e.seedId),
            this._mountLogin(),
            this._mountRegister(),
            this._mountGarden(),
            this._setTopPadding(),
            Object(Fa.a)({
                willChange: !0,
                target: this.nodes.panelContent,
                opacity: [0, 1],
                ease: "out-swift",
                duration: 500
            }).play()
        }
        _mountVouchersList() {
            "vouchers" === this.panelView && (this._mountTitle("interface.menu.all_vouchers"),
            n.a.language.current.content.api.finalChallenge && this.scroll.addComponent(Wo).mount(this.scroll.nodes.scrollInner),
            te.a.seedsArray.current.forEach(e => {
                this.scroll.addComponent(xl, {
                    seedId: e.id.current,
                    unlocked: e.level.current > 3
                }).mount(this.scroll.nodes.scrollInner)
            }
            ),
            Cr.a.event({
                type: "mmPageview",
                value: "/all-my-vouchers"
            }))
        }
        _mountVoucherDetails(e) {
            "voucherDetails" === this.panelView && (this._mountTitle("interface.gift.title"),
            this.voucherDetails = this.scroll.addComponent(To, {
                seedId: e
            }).mount(this.scroll.nodes.scrollInner),
            this._setVoucherBgTop(),
            Object(Fa.a)({
                willChange: !0,
                target: this.nodes.voucherBg,
                opacity: [0, 1],
                ease: "out-swift",
                duration: 500
            }).play(),
            Cr.a.event({
                type: "mmPageview",
                value: `/${Object(Dr.a)(e)}/voucher`
            }))
        }
        _mountLogin() {
            "login" === this.panelView && (this._mountTitle("interface.connection.title"),
            this.scroll.addComponent($l).mount(this.scroll.nodes.scrollInner))
        }
        _mountRegister() {
            "register" === this.panelView && (this._mountTitle("interface.form.title"),
            this.addComponent(nl).mount(this.scroll.nodes.scrollInner))
        }
        _mountMenu() {
            "menu" === this.panelView && this.scroll.addComponent(ml).mount(this.scroll.nodes.scrollInner).addComponent(jo).mount(this.scroll.nodes.scrollInner)
        }
        _mountGarden() {
            "garden" === this.panelView && (this._mountTitle("interface.garden.title"),
            this.scroll.addComponent(Ul).mount(this.scroll.nodes.scrollInner))
        }
        _setTopPadding() {
            const e = this.nodes.panelBgImg.offsetHeight;
            document.documentElement.style.setProperty("--panelBgHeight", `${e}px`)
        }
        _setVoucherBgTop() {
            if (!this.voucherDetails)
                return;
            const e = this.voucherDetails.nodes.seedAnim
              , t = .65 * e.clientHeight;
            this.nodes.voucherBg.style.top = e.getBoundingClientRect().y + t + "px"
        }
        _toggle(e) {
            const t = e
              , i = n.a.device.current
              , r = i.type.desktop && "chrome" === i.browser;
            t ? (Object(Fa.a)({
                willChange: !0,
                target: this.nodes.main,
                transform: "translate3d(0, 0, 0)",
                visibility: r ? null : ["hidden", "visible"],
                ease: [.635, .015, .08, 1],
                duration: 500,
                delay: 50
            }).play().then( () => {
                "garden" !== this.panelView && "voucherDetails" !== this.panelView && document.body.classList.add(`${this.data.modifiers}-panel-open`)
            }
            ),
            "voucherDetails" === this.panelView ? Object(Fa.a)({
                willChange: !0,
                target: this.nodes.main.querySelector(".voucher-details"),
                transform: ["translate3d(-100%, 0, 0)", "translate3d(0, 0, 0)"],
                visibility: r ? null : ["hidden", "visible"],
                ease: [.635, .015, .08, 1],
                duration: 500,
                delay: this.desktopLayout ? 50 : 0
            }).play().then( () => {
                document.body.classList.add(`${this.data.modifiers}-panel-open`)
            }
            ) : "garden" === this.panelView && Object(Fa.a)({
                willChange: !0,
                target: this.nodes.main.querySelector(".garden"),
                transform: ["translate3d(100%, 0, 0)", "translate3d(0, 0, 0)"],
                visibility: r ? null : ["hidden", "visible"],
                ease: [.635, .015, .08, 1],
                duration: 500,
                delay: this.desktopLayout ? 50 : 0
            }).play().then( () => {
                document.body.classList.add(`${this.data.modifiers}-panel-open`)
            }
            ),
            Object(Fa.a)({
                willChange: !0,
                target: this.nodes.panelBg,
                visibility: "visible",
                transform: "translate3d(0, 0, 0)",
                ease: [.635, .015, .08, 1],
                duration: 500
            }).play(),
            Object(Fa.a)({
                willChange: !0,
                target: this.nodes.panelClose,
                opacity: 1,
                ease: "out-swift",
                duration: 500
            }).play().then( () => this.nodes.panelClose.style.pointerEvents = "all")) : (document.body.classList.remove(`${this.data.modifiers}-panel-open`),
            Object(Fa.a)({
                willChange: !0,
                target: this.nodes.main,
                transform: `translate3d(${"right" === this.data.modifiers ? 100 : -100}%, 0, 0)`,
                ease: [.635, .015, .08, 1],
                duration: 500
            }).play().then( () => {
                r || (this.nodes.main.style.visibility = "hidden",
                this.nodes.panelClose.visibility = "hidden"),
                "right" !== this.data.modifiers && (this.title && this.title.destroy(),
                this.title = null,
                this.scroll && this.scroll.destroy(),
                this.scroll = null,
                this.nodes.voucherBg.style.opacity = null,
                this.voucherDetails = null)
            }
            ),
            Object(Fa.a)({
                willChange: !0,
                target: this.nodes.panelBg,
                transform: `translate3d(${"right" === this.data.modifiers ? 100 : -100}%, 0, 0)`,
                ease: [.635, .015, .08, 1],
                duration: 500
            }).play(),
            Object(Fa.a)({
                willChange: !0,
                target: this.nodes.panelClose,
                opacity: 0,
                ease: "out-swift",
                duration: 500
            }).play().then( () => this.nodes.panelClose.style.pointerEvents = "none"))
        }
        closePanel() {
            n.a[this.storeName].set(!1)
        }
        _onResize() {
            this._setTopPadding(),
            this._setVoucherBgTop()
        }
    }
    const rc = {}
      , sc = {};
    function ac() {
        v.a.mq({
            from: "md"
        }) ? sc.seedsPrev.mounted || (sc.seedsPrev.mount(rc.seedsUi),
        sc.seedsNext.mount(rc.seedsUi)) : sc.seedsPrev.mounted && (sc.seedsPrev.unmount(),
        sc.seedsNext.unmount())
    }
    var oc = {
        mountComponents: function({main: e, views: t}) {
            return Object.assign(rc, {
                main: e,
                views: t,
                canvas: document.querySelector('[ref="canvas"]'),
                seedsUi: document.querySelector('[ref="seedsUi"]')
            }),
            sc.header = new go,
            sc.leftPanel = new nc({
                data: {
                    modifiers: "left"
                }
            }),
            sc.rightPanel = new nc({
                data: {
                    modifiers: "right"
                }
            }),
            sc.seedsPrev = new Pa({
                name: "Prev",
                data: {
                    modifiers: "prev",
                    ref: "seedsButtonPrev"
                }
            }),
            sc.seedsNext = new Pa({
                name: "Next",
                data: {
                    modifiers: "next",
                    ref: "seedsButtonNext"
                }
            }),
            sc.ressourcesButtons = new ya,
            sc.progressBar = new Ia,
            sc.rotate = new Va,
            sc.footer = new Ka,
            sc.guideText = new Ha({}),
            sc.ressourcesButtons.mount(rc.seedsUi),
            sc.progressBar.mount(rc.seedsUi),
            sc.guideText.mount(rc.seedsUi),
            sc.header.mount(e => rc.main.insertBefore(e, rc.views)),
            sc.leftPanel.mount(e => rc.main.insertBefore(e, rc.canvas)),
            sc.rightPanel.mount(e => rc.main.insertBefore(e, rc.canvas)),
            sc.rotate.mount(e => rc.main.insertBefore(e, rc.canvas)),
            sc.footer.mount(e => rc.main.insertBefore(e, rc.canvas)),
            ac(),
            n.a.viewportSize.subscribe(ac),
            new Promise(e => {
                window.setTimeout( () => {
                    r.a.recomputeDOMObjects.dispatch(),
                    e()
                }
                , 10)
            }
            )
        },
        hydratePreloader: function() {
            rc.preloader = document.querySelector('[ref="preloader"]'),
            sc.preloader = new Ua,
            sc.preloader.hydrate(rc.preloader),
            sc.message = new Da({
                name: "Message "
            }),
            sc.message.mount(document.body)
        },
        exitPreloader: function() {
            return new Promise(e => {
                Promise.resolve().then( () => sc.preloader.exit()).then( () => sc.preloader = null).then(e)
            }
            )
        },
        ensurePreloaderComplete: function() {
            return !sc.preloader || be.a.removePreloaderDelay.current ? Promise.resolve() : sc.preloader.finished
        },
        disconnectMessage: function() {
            te.a.sessionId.subscribe(e => {
                e || te.a.id.current || fe.a.createDisconnect()
            }
            )
        },
        socialErrorMessage: function() {
            if (!Ds.a.hasSocialFlag())
                return Promise.resolve();
            Ds.a.removeSocialFlag();
            const e = fe.a.createBase({
                prevent_overlay_close: !0,
                title: Object(Ur.a)("interface.connection.disconnect_title"),
                text: Object(Ur.a)("interface.form.error_webview"),
                button: {
                    label: Object(Ur.a)("interface.form.copy_link"),
                    copyToClipboard: !0,
                    copyText: window.location.href
                },
                button2: {
                    label: Object(Ur.a)("interface.form.continue"),
                    onClick: () => e.close()
                }
            })
        },
        showGuideText: e => sc.guideText && sc.guideText.show(e),
        hideGuideText: () => sc.guideText && sc.guideText.hide(),
        showMessage: e => sc.message.show(e),
        hideMessage: e => sc.message.hide(e)
    };
    var lc = i(149)
      , cc = i.n(lc);
    var hc = i(41)
      , uc = i.n(hc);
    class pc {
        constructor() {}
        render(e, t, i=!1) {
            const n = e(t);
            return i ? n : this._getNodes(n)
        }
        getNodesFromDom(e, t, i="*[ ref ]") {
            const n = e.querySelectorAll(i);
            for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                i.getAttribute("ref").split(", ").forEach(e => {
                    const n = t[e];
                    Array.isArray(n) ? t[e].push(i) : t[e] = n ? [n, i] : i
                }
                )
            }
        }
        _cleanDom(e) {
            for (let t = 0, i = e.childNodes.length; t < i; t++) {
                const i = e.childNodes[t];
                if (!i)
                    continue;
                const n = 1 === i.nodeType
                  , r = 8 === i.nodeType
                  , s = 3 === i.nodeType && !/\S/.test(i.nodeValue);
                r || s ? (e.removeChild(i),
                t--) : n && this._cleanDom(i)
            }
            return e
        }
        _getNodes(e) {
            const t = {}
              , i = document.createElement("div");
            if (i.innerHTML = e,
            i.children.length,
            t.main = this._cleanDom(i.children[0]),
            t.main)
                return this.getNodesFromDom(t.main, t),
                t
        }
    }
    class dc extends ns.a {
        constructor() {
            super(),
            Object(ie.a)(this),
            this.log = !1,
            this.waitingList = {},
            Mt.a.data.manifest && (this.manifest = Mt.a.data.manifest)
        }
        load(e) {
            const t = []
              , i = {
                loadedData: {},
                totalData: {}
            };
            for (const n of e)
                t.push(this._waitlist(n, i));
            return Promise.all(t)
        }
        _waitlist(e, t) {
            const i = e.path.match(/\/(.*)/)[1];
            if (Mt.a.files.get(i))
                return;
            let n = this.waitingList[e.path];
            return n || (!e.path.match(/packs/g) || (e.directoryID = i,
            this.manifest[e.directoryID]) ? (n = this._requestFile(e, t),
            this.waitingList[e.path] = n,
            n) : void this._log(`Pack '${e.directoryID}' is not in the manifest`))
        }
        _requestFile(e, t) {
            return new Promise( (i, n) => {
                const r = new XMLHttpRequest;
                r.responseType = this._getFileResponseType(e);
                const s = e.external ? e.path : `${Mt.a.data.paths.assets}/${e.path}`;
                r.open("GET", s),
                r.onprogress = i => {
                    this._getBatchProgress(i, e, t)
                }
                ,
                r.onload = s => {
                    const a = r.status >= 200 && r.status < 300
                      , o = r.response;
                    a ? this._onFileLoaded(e, o).then(i) : n(),
                    delete this.waitingList[e.path],
                    this._getBatchProgress(s, e, t)
                }
                ,
                r.onerror = () => {
                    n(),
                    delete this.waitingList[e.path]
                }
                ,
                r.send()
            }
            )
        }
        _getComputedSize(e) {
            if (!e)
                return;
            let t = 0;
            for (const [i,n] of Object.entries(e)) {
                const e = n;
                if (e.length)
                    t += e.length;
                else
                    for (const [i,n] of Object.entries(e))
                        t += n.length
            }
            return t
        }
        _getBatchProgress(e, t, i) {
            let n = 0
              , r = 0
              , s = e.total;
            if (!s) {
                const e = t.directoryID;
                this.manifest[e].length = this._getComputedSize(this.manifest[e]),
                s = this.manifest[e] && this.manifest[e].length || 1
            }
            i.loadedData[t.path] = e.loaded,
            i.totalData[t.path] = s;
            for (const e in i.loadedData)
                n += i.loadedData[e],
                r += i.totalData[e];
            const a = n / r;
            this.dispatchEvent({
                type: "progress",
                file: t,
                progress: a
            })
        }
        _getFileResponseType(e) {
            let t = "arraybuffer";
            switch (e.type) {
            case "string":
                t = "text";
                break;
            case "json":
                t = "json"
            }
            return t
        }
        _onFileLoaded(e, t) {
            return new Promise(i => {
                e.directoryID ? Mt.a.unpacker.unpack(e.directoryID, t).then(i) : (Mt.a.files.add(e.id, t),
                i())
            }
            )
        }
        _log(e) {
            this.log && Mt.a.logger.log(`FileLoader: ${e}`, {
                backgroundColor: "#9900ff",
                color: "#fff"
            })
        }
    }
    var fc = class {
        constructor() {
            Object(ie.a)(this),
            this.manifest = Mt.a.data.manifest,
            this.DOMParser = document.createElement("div"),
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)
        }
        unpack(e, t) {
            const i = this.manifest[e];
            if (i) {
                const e = [];
                return Mt.a.files.getFilesData(i, e),
                this._getFiles(t, e)
            }
        }
        getParseFunction(e) {
            switch (e) {
            case "application/json":
                return this.getAsJSON;
            case "text/plain":
                return this.getAsString;
            case "audio/mpeg":
            case "audio/mp4":
            case "audio/wav":
            case "audio/x-aac":
                return this.getAsAudioBuffer;
            case "image/png":
            case "image/jpeg":
                return this.getAsImage;
            case "image/svg+xml":
                return this.getAsSVG
            }
        }
        getAsURI(e, t) {
            const i = new Blob([e],{
                type: t
            });
            return URL.createObjectURL(i)
        }
        getAsJSON(e) {
            return new Promise(t => {
                this.getAsString(e).then(e => {
                    t(JSON.parse(e))
                }
                )
            }
            )
        }
        getAsString(e) {
            return new Promise(t => {
                let i = "";
                const n = new Uint8Array(e);
                for (const e of Array.from(n))
                    i += String.fromCharCode(e);
                t(i)
            }
            )
        }
        getAsAudioBuffer(e, t) {
            return new Promise(t => {
                this.audioContext.decodeAudioData(e, e => {
                    t(e)
                }
                , e => void 0)
            }
            )
        }
        getAsImage(e, t) {
            return new Promise(i => {
                const n = new Image
                  , r = this.getAsURI(e, t.mime);
                n.onload = () => i({
                    node: n,
                    source: r
                }, t),
                n.src = r
            }
            )
        }
        getAsSVG(e) {
            return new Promise(t => {
                this.getAsString(e).then(e => {
                    this.DOMParser.innerHTML = e;
                    const i = this.DOMParser.querySelector("svg");
                    t({
                        node: i,
                        string: e
                    })
                }
                )
            }
            )
        }
        _slice(e, t) {
            return e.slice(t.position, t.position + t.length)
        }
        _getFiles(e, t) {
            const i = [];
            for (let n = 0, r = t.length; n < r; n++) {
                const r = t[n];
                i.push(this._getFile(e, r))
            }
            return Promise.all(i)
        }
        _getFile(e, t) {
            const i = this._slice(e, t)
              , n = this.getParseFunction(t.mime);
            return new Promise(e => {
                n ? n(i, t).then(i => {
                    this._cacheFile(i, t),
                    e()
                }
                ).catch(console.error) : (this._cacheFile(i, t),
                e())
            }
            )
        }
        _cacheFile(e, t) {
            const i = t.path.split("assets/").pop();
            Mt.a.files.add(i, e, t.directoryID)
        }
    }
      , mc = i(66)
      , gc = i(75)
      , vc = (e="us", t) => {
        if (!t.match(/^[a-z0-9-]*$/))
            return "";
        return `https://${Object(Ur.a)(`markets.${e}.region`)}-${t}.cloudfunctions.net`
    }
    ;
    class yc {
        constructor(e) {
            Object(ie.a)(this);
            const t = window._app;
            let i = e.locale;
            t.demoMode ? i = e.demoDomainLocale : t.useMarketDomain && (i = e.marketDomainLocale);
            const r = uc.a.compile(i)(t.locale);
            n.a.demoMode.set(!!t.demoMode),
            n.a.env.set(t.env),
            n.a.webview.set(t.webview),
            n.a.timestamp.set(t.timestamp),
            n.a.assetsUrl.set(t.paths.assets),
            n.a.manifest.set(window.manifest),
            n.a.routes.set(e.views),
            n.a.lineId.set(t.key.line),
            n.a.facebookId.set(t.key.facebook),
            n.a.useMarketDomain.set(t.useMarketDomain),
            n.a.language.set({
                locale: r,
                code: t.locale.language,
                market: t.locale.market,
                content: t.content
            }),
            n.a.breakpoints.set(t.sass.breakpoints),
            n.a.colors.set(t.sass.colors),
            n.a.apiEndpoint.set(vc(t.locale.market, t.projectId)),
            Object.assign(Mt.a.data, window._app, {
                locale: r,
                market: t.locale.market,
                language: t.locale.language,
                routes: e.views,
                breakpoints: n.a.breakpoints.current
            }),
            Object.assign(Mt.a, {
                templateEngine: new pc,
                unpacker: new fc,
                fileLoader: new dc,
                files: new mc.a,
                router: xe.a.init()
            }),
            this.isReady = !1,
            this.nodes = {},
            this.getNodes()
        }
        start() {
            Mt.a.router.addEventListener("routeMatched", this.onRouteMatched),
            Mt.a.router.start()
        }
        beforeLoad() {}
        afterLoad() {}
        beforeRender() {}
        afterRender() {}
        beforeMount() {}
        afterMount() {}
        beforeDestroy() {}
        getNodes() {
            this.nodes.main = document.body,
            this.nodes.views = this.nodes.main.querySelector(".views")
        }
        ready() {
            Mt.a.router.addEventListeners(),
            this.isReady = !0
        }
        duringRouteLoad() {}
        afterRouteLoad() {}
        loadViewFromRoute(e, t) {
            return new Promise( (i, r) => {
                const s = {
                    id: e.id,
                    params: t
                }
                  , a = n.a.previousView
                  , o = n.a.currentView;
                e.module(l => {
                    const c = new l.default({
                        id: e.id,
                        routeParams: t
                    });
                    Promise.resolve().then( () => !this.isReady && this.beforeLoad()).then( () => {
                        this.isReady || (c.files = c.files.concat(this.files))
                    }
                    ).then( () => {
                        n.a.routeStatus.set({
                            status: 1,
                            from: o.current || null,
                            to: s
                        })
                    }
                    ).then( () => {
                        const i = [c.load()]
                          , r = gc.a.current
                          , s = n.a.currentView.get()
                          , a = {
                            id: e.id,
                            params: t
                        };
                        return r && i.push(r.beforeExit(a, s)),
                        Promise.all(i)
                    }
                    ).then( () => !this.isReady && this.afterLoad()).then( () => {
                        if (!this.isReady) {
                            document.querySelector(".views").innerHTML = "";
                            const e = document.querySelector(".old-browser");
                            e.parentNode.removeChild(e),
                            this.beforeRender()
                        }
                        c.render(),
                        !this.isReady && this.afterRender(),
                        !this.isReady && this.beforeMount(),
                        c.mount(this.nodes.views),
                        !this.isReady && this.afterMount(),
                        a.set(o.current, !0),
                        o.set(s, !0),
                        n.a.routeStatus.set({
                            status: 2,
                            from: a.current,
                            to: o.current
                        })
                    }
                    ).then( () => this.afterRouteLoad()).then( () => !this.isReady && this.ready()).then(i).catch(r)
                }
                )
            }
            )
        }
        onRouteMatched(e) {
            const t = e.route;
            this.loadViewFromRoute(t, e.params),
            Mt.a.router.replaceState(e.path, t)
        }
    }
    class bc {
        static assign(e, t) {
            e.pool = new bc(e),
            e.pool.reset = t,
            e.get = function() {
                const t = e.pool.get();
                return t && e.pool.reset && e.pool.reset(t),
                t
            }
            ,
            e.release = function() {
                e.pool.release(...arguments)
            }
            ,
            e.prototype.release = function() {
                return e.pool.release(this),
                this
            }
        }
        constructor(e) {
            this.prototype = e,
            this.items = [],
            this.availables = []
        }
        clear() {
            this.items = [],
            this.availables = []
        }
        release() {
            for (let e = 0; e < arguments.length; e++) {
                const t = arguments[e];
                if (!t.isFromPool)
                    throw new Error("The item is not from the pool");
                this.availables.push(t)
            }
        }
        get() {
            if (!(this.items.length > this.maxLength)) {
                if (this.availables.length)
                    return this.availables.pop();
                {
                    const e = new this.prototype;
                    return e.isFromPool = !0,
                    this.items.push(e),
                    e
                }
            }
        }
    }
    var xc = i(186)
      , wc = '#define GLSLIFY 1\n// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n//----------------------------------------------------------------------------------\n// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n// SDK Version: v3.00\n// Email:       gameworks@nvidia.com\n// Site:        http://developer.nvidia.com/\n//\n// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n//  * Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n//  * Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\n//    contributors may be used to endorse or promote products derived\n//    from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS\'\' AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n//----------------------------------------------------------------------------------\n\n#define FXAA_PC 1\n#define FXAA_GLSL_100 1\n#define FXAA_QUALITY_PRESET 15 // MEDIUM\n#define FXAA_GREEN_AS_LUMA 1\n\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_PC_CONSOLE\n    //\n    // The console algorithm for PC is included\n    // for developers targeting really low spec machines.\n    // Likely better to just run FXAA_PC, and use a really low preset.\n    //\n    #define FXAA_PC_CONSOLE 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_120\n    #define FXAA_GLSL_120 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GLSL_130\n    #define FXAA_GLSL_130 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_3\n    #define FXAA_HLSL_3 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_4\n    #define FXAA_HLSL_4 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_HLSL_5\n    #define FXAA_HLSL_5 0\n#endif\n/*==========================================================================*/\n#ifndef FXAA_GREEN_AS_LUMA\n    //\n    // For those using non-linear color,\n    // and either not able to get luma in alpha, or not wanting to,\n    // this enables FXAA to run using green as a proxy for luma.\n    // So with this enabled, no need to pack luma in alpha.\n    //\n    // This will turn off AA on anything which lacks some amount of green.\n    // Pure red and blue or combination of only R and B, will get no AA.\n    //\n    // Might want to lower the settings for both,\n    //    fxaaConsoleEdgeThresholdMin\n    //    fxaaQualityEdgeThresholdMin\n    // In order to insure AA does not get turned off on colors\n    // which contain a minor amount of green.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_GREEN_AS_LUMA 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_EARLY_EXIT\n    //\n    // Controls algorithm\'s early exit path.\n    // On PS3 turning this ON adds 2 cycles to the shader.\n    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n    // Turning this off on console will result in a more blurry image.\n    // So this defaults to on.\n    //\n    // 1 = On.\n    // 0 = Off.\n    //\n    #define FXAA_EARLY_EXIT 1\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_DISCARD\n    //\n    // Only valid for PC OpenGL currently.\n    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n    //\n    // 1 = Use discard on pixels which don\'t need AA.\n    //     For APIs which enable concurrent TEX+ROP from same surface.\n    // 0 = Return unchanged color on pixels which don\'t need AA.\n    //\n    #define FXAA_DISCARD 0\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_FAST_PIXEL_OFFSET\n    //\n    // Used for GLSL 120 only.\n    //\n    // 1 = GL API supports fast pixel offsets\n    // 0 = do not use fast pixel offsets\n    //\n    #ifdef GL_EXT_gpu_shader4\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_FAST_PIXEL_OFFSET 1\n    #endif\n    #ifndef FXAA_FAST_PIXEL_OFFSET\n        #define FXAA_FAST_PIXEL_OFFSET 0\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#ifndef FXAA_GATHER4_ALPHA\n    //\n    // 1 = API supports gather4 on alpha channel.\n    // 0 = API does not support gather4 on alpha channel.\n    //\n    #if (FXAA_HLSL_5 == 1)\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_ARB_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifdef GL_NV_gpu_shader5\n        #define FXAA_GATHER4_ALPHA 1\n    #endif\n    #ifndef FXAA_GATHER4_ALPHA\n        #define FXAA_GATHER4_ALPHA 0\n    #endif\n#endif\n\n/*============================================================================\n                        FXAA QUALITY - TUNING KNOBS\n------------------------------------------------------------------------------\nNOTE the other tuning knobs are now in the shader function inputs!\n============================================================================*/\n#ifndef FXAA_QUALITY_PRESET\n    //\n    // Choose the quality preset.\n    // This needs to be compiled into the shader as it effects code.\n    // Best option to include multiple presets is to\n    // in each shader define the preset, then include this file.\n    //\n    // OPTIONS\n    // -----------------------------------------------------------------------\n    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n    // 39       - no dither, very expensive\n    //\n    // NOTES\n    // -----------------------------------------------------------------------\n    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n    // 13 = about same speed as FXAA 3.9 and better than 12\n    // 23 = closest to FXAA 3.9 visually and performance wise\n    //  _ = the lowest digit is directly related to performance\n    // _  = the highest digit is directly related to style\n    //\n    #define FXAA_QUALITY_PRESET 12\n#endif\n\n/*============================================================================\n\n                           FXAA QUALITY - PRESETS\n\n============================================================================*/\n\n/*============================================================================\n                     FXAA QUALITY - MEDIUM DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - LOW DITHER PRESETS\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n/*============================================================================\n                     FXAA QUALITY - EXTREME QUALITY\n============================================================================*/\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n/*============================================================================\n\n                                API PORTING\n\n============================================================================*/\n#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n    #define FxaaBool bool\n    #define FxaaDiscard discard\n    #define FxaaFloat float\n    #define FxaaFloat2 vec2\n    #define FxaaFloat3 vec3\n    #define FxaaFloat4 vec4\n    #define FxaaHalf float\n    #define FxaaHalf2 vec2\n    #define FxaaHalf3 vec3\n    #define FxaaHalf4 vec4\n    #define FxaaInt2 ivec2\n    #define FxaaSat(x) clamp(x, 0.0, 1.0)\n    #define FxaaTex sampler2D\n#else\n    #define FxaaBool bool\n    #define FxaaDiscard clip(-1)\n    #define FxaaFloat float\n    #define FxaaFloat2 float2\n    #define FxaaFloat3 float3\n    #define FxaaFloat4 float4\n    #define FxaaHalf half\n    #define FxaaHalf2 half2\n    #define FxaaHalf3 half3\n    #define FxaaHalf4 half4\n    #define FxaaSat(x) saturate(x)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_100 == 1)\n  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_120 == 1)\n    // Requires,\n    //  #version 120\n    // And at least,\n    //  #extension GL_EXT_gpu_shader4 : enable\n    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n    #if (FXAA_FAST_PIXEL_OFFSET == 1)\n        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n    #else\n        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n    #endif\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_GLSL_130 == 1)\n    // Requires "#version 130" or better\n    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n    #if (FXAA_GATHER4_ALPHA == 1)\n        // use #extension GL_ARB_gpu_shader5 : enable\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n    #endif\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_3 == 1)\n    #define FxaaInt2 float2\n    #define FxaaTex sampler2D\n    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_4 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n#endif\n/*--------------------------------------------------------------------------*/\n#if (FXAA_HLSL_5 == 1)\n    #define FxaaInt2 int2\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n#endif\n\n/*============================================================================\n                   GREEN AS LUMA OPTION SUPPORT FUNCTION\n============================================================================*/\n#if (FXAA_GREEN_AS_LUMA == 0)\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n#else\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n#endif\n\n/*============================================================================\n\n                             FXAA3 QUALITY - PC\n\n============================================================================*/\n#if (FXAA_PC == 1)\n/*--------------------------------------------------------------------------*/\nFxaaFloat4 FxaaPixelShader(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Used only for FXAA Console, and not used on the 360 version.\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy_} = upper left of pixel\n    // {_zw} = lower right of pixel\n    FxaaFloat4 fxaaConsolePosPos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {__a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 2nd sampler.\n    // This sampler needs to have an exponent bias of -1.\n    FxaaTex fxaaConsole360TexExpBiasNegOne,\n    //\n    // Only used on the optimized 360 version of FXAA Console.\n    // For everything but 360, just use the same input here as for "tex".\n    // For 360, same texture, just alias with a 3nd sampler.\n    // This sampler needs to have an exponent bias of -2.\n    FxaaTex fxaaConsole360TexExpBiasNegTwo,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Console.\n    // This must be from a constant/uniform.\n    // This effects sub-pixel AA quality and inversely sharpness.\n    //   Where N ranges between,\n    //     N = 0.50 (default)\n    //     N = 0.33 (sharper)\n    // {x__} = -N/screenWidthInPixels\n    // {_y_} = -N/screenHeightInPixels\n    // {_z_} =  N/screenWidthInPixels\n    // {__w} =  N/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt,\n    //\n    // Only used on FXAA Console.\n    // Not used on 360, but used on PS3 and PC.\n    // This must be from a constant/uniform.\n    // {x__} = -2.0/screenWidthInPixels\n    // {_y_} = -2.0/screenHeightInPixels\n    // {_z_} =  2.0/screenWidthInPixels\n    // {__w} =  2.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n    //\n    // Only used on FXAA Console.\n    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n    // This must be from a constant/uniform.\n    // {x__} =  8.0/screenWidthInPixels\n    // {_y_} =  8.0/screenHeightInPixels\n    // {_z_} = -4.0/screenWidthInPixels\n    // {__w} = -4.0/screenHeightInPixels\n    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only three safe values here: 2 and 4 and 8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // For all other platforms can be a non-power of two.\n    //   8.0 is sharper (default!!!)\n    //   4.0 is softer\n    //   2.0 is really soft (good only for vector graphics inputs)\n    FxaaFloat fxaaConsoleEdgeSharpness,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // This does not effect PS3, as this needs to be compiled in.\n    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n    //   Due to the PS3 being ALU bound,\n    //   there are only two safe values here: 1/4 and 1/8.\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\n    // The console setting has a different mapping than the quality setting.\n    // Other platforms can use other values.\n    //   0.125 leaves less aliasing, but is softer (default!!!)\n    //   0.25 leaves more aliasing, and is sharper\n    FxaaFloat fxaaConsoleEdgeThreshold,\n    //\n    // Only used on FXAA Console.\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    // The console setting has a different mapping than the quality setting.\n    // This only applies when FXAA_EARLY_EXIT is 1.\n    // This does not apply to PS3,\n    // PS3 was simplified to avoid more shader instructions.\n    //   0.06 - faster but more aliasing in darks\n    //   0.05 - default\n    //   0.04 - slower and less aliasing in darks\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaConsoleEdgeThresholdMin,\n    //\n    // Extra constants for 360 FXAA Console only.\n    // Use zeros or anything else for other platforms.\n    // These must be in physical constant registers and NOT immediates.\n    // Immediates will result in compiler un-optimizing.\n    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n    FxaaFloat4 fxaaConsole360ConstDir\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    #if (FXAA_GATHER4_ALPHA == 1)\n        #if (FXAA_DISCARD == 0)\n            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n            #if (FXAA_GREEN_AS_LUMA == 0)\n                #define lumaM rgbyM.w\n            #else\n                #define lumaM rgbyM.y\n            #endif\n        #endif\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n        #else\n            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n        #endif\n        #if (FXAA_DISCARD == 1)\n            #define lumaM luma4A.w\n        #endif\n        #define lumaE luma4A.z\n        #define lumaS luma4A.x\n        #define lumaSE luma4A.y\n        #define lumaNW luma4B.w\n        #define lumaN luma4B.z\n        #define lumaW luma4B.x\n    #else\n        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n        #if (FXAA_GREEN_AS_LUMA == 0)\n            #define lumaM rgbyM.w\n        #else\n            #define lumaM rgbyM.y\n        #endif\n        #if (FXAA_GLSL_100 == 1)\n          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n        #endif\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        #if (FXAA_DISCARD == 1)\n            FxaaDiscard;\n        #else\n            return rgbyM;\n        #endif\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_GATHER4_ALPHA == 0)\n        #if (FXAA_GLSL_100 == 1)\n          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n        #else\n          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n        #endif\n    #else\n        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n    #endif\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    #if (FXAA_DISCARD == 1)\n        return FxaaTexTop(tex, posM);\n    #else\n        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n    #endif\n}\n/*==========================================================================*/\n#endif\n\nvec4 fxaa (sampler2D diffuse, vec2 uv, vec2 resolution) {\n\treturn FxaaPixelShader(\n    uv,\n    vec4(0.0),\n    diffuse,\n    diffuse,\n    diffuse,\n    resolution,\n    vec4(0.0),\n    vec4(0.0),\n    vec4(0.0),\n    0.75,\n    0.166,\n    0.0833,\n    0.0,\n    0.0,\n    0.0,\n    vec4(0.0)\n  );\n}\n'
      , _c = "#define GLSLIFY 1\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n"
      , Tc = "#define GLSLIFY 1\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n"
      , Mc = "#define GLSLIFY 1\n#ifndef PI\n#define PI 3.141592653589793\n#endif\n\nfloat atan2(float y, float x) {\n\tbool s = (abs(x) > abs(y));\n\treturn s ? (PI / 2.0) - atan(x,y) : atan(y,x);\n}\n"
      , Sc = "#define GLSLIFY 1\nfloat aastep(float threshold, float e, float value) {\n\treturn smoothstep(threshold - e, threshold + e, value);\n}\n"
      , Ac = "#define GLSLIFY 1\nfloat equals(float x, float y) {\n  return 1.0 - abs(sign(x - y));\n}\n";
    let Pc = !1;
    let Cc, Lc = !1;
    const kc = function() {}
      , Ec = {
        name: kc
    };
    function Ic() {
        Cc = !!Lc && new Lc,
        be.a.openGui.current || Cc.close();
        const e = Cc.domElement.parentNode;
        e.classList.add("__datgui"),
        e.style.zIndex = 5e3,
        e.style.top = "5px",
        e.style.right = "-10px",
        e.style.pointerEvents = "visible",
        document.body.appendChild(e)
    }
    const Fc = e => (...t) => {
        if (!Lc)
            return Ec;
        Cc || Ic(),
        e || (e = Cc);
        const i = [...t]
          , n = i.shift()
          , r = {};
        r[n] = Store[n].get();
        const s = e.add(r, n, ...i);
        return s.onChange(e => Store[n].set(e)),
        s
    }
      , Oc = e => (...t) => {
        if (!Lc)
            return Ec;
        Cc || Ic(),
        e || (e = Cc);
        const i = [...t]
          , n = i.shift()
          , r = i.shift()
          , s = e.add(n.uniforms[r], "value", ...i);
        return s.name(r),
        s.onChange(e => {
            n.uniforms[r].value = e,
            n.uniforms[r].needsUpdate = !0
        }
        ),
        s
    }
    ;
    var Rc = {
        add: function(...e) {
            return Lc ? (Cc || Ic(),
            Cc.add(...e)) : Ec
        },
        remove: function(...e) {
            return Lc ? (Cc || Ic(),
            Cc.remove(...e)) : Ec
        },
        addColor: function(...e) {
            return Lc ? (Cc || Ic(),
            Cc.addColor(...e)) : Ec
        },
        addUniform: Oc(),
        addStore: Fc(),
        folder: function(e) {
            if (!Lc)
                return {
                    add: kc,
                    open: kc,
                    close: kc,
                    remove: kc,
                    destroy: kc
                };
            Cc || Ic();
            const t = Cc.addFolder(e);
            return t.addUniform = Oc(t),
            t.addStore = Fc(t),
            t.destroy = () => {
                t.close(),
                delete Cc.__folders[t.name],
                t.__controllers.forEach(e => t.remove(e)),
                t.domElement.parentNode.parentNode.removeChild(t.domElement.parentNode),
                t[e] = void 0,
                Cc.onResize()
            }
            ,
            t
        },
        getInstance: () => Cc
    };
    var zc = {
        init: function({parent: e}) {
            bc.assign(ge.J, e => e.set(0, 0, 0, 0)),
            bc.assign(ge.k, e => e.setRGB(0, 0, 0)),
            bc.assign(ge.T, e => e.setScalar(0)),
            bc.assign(ge.U, e => e.setScalar(0)),
            bc.assign(ge.V, e => e.setScalar(0)),
            bc.assign(ge.n, e => e.set(0, 0, 0, "XYZ")),
            bc.assign(ge.w),
            bc.assign(ge.g),
            bc.assign(ge.f),
            ge.I.simple || (ge.I.simple = new ge.I),
            Pc || (Object.assign(ge.Q, {
                fxaa: wc,
                rotate: _c,
                smin: Tc,
                atan2: Mc,
                equals: Ac,
                aastep: Sc
            }),
            Pc = !0),
            xc.a.init(),
            et.init(),
            En.init({
                parent: e
            }),
            Ot.init({
                renderer: En.getRenderer()
            }),
            pa.init(),
            y.c.add(En.tick)
        },
        prerender: function() {
            return new Promise(e => {
                ti.prebuiltPoissons();
                const t = new _r;
                Promise.resolve().then( () => new Promise(e => (function e(t, i) {
                    if (t.prerendered)
                        return i();
                    bt.prerender(t, !0),
                    window.setTimeout( () => e(t, i), 10)
                }
                )(t, e))).then( () => new Promise(e => setTimeout(e, 10))).then( () => t.destroy()).then( () => new Promise(e => setTimeout(e, 20))).then(e)
            }
            )
        },
        appLoaded: function() {
            Ot.appLoaded(),
            En.appLoaded()
        },
        appReady: function() {
            const e = {
                debugCanvas: () => be.a.debugCanvas.update(e => !e),
                debugCamera: () => be.a.debugCamera.update(e => !e)
            };
            Rc.add(e, "debugCanvas").name("Canvas Debug"),
            Rc.add(e, "debugCamera").name("Orbit Controls"),
            pa.appReady()
        },
        removeCircle: function() {
            const e = bt.filters.postprocess.uniforms.circleFill;
            $.a.to(e, .9, {
                delay: .15,
                value: .71,
                ease: Xe.f.easeInOut
            })
        }
    }
      , Nc = i(155)
      , Dc = i.n(Nc)
      , Uc = i(152)
      , Bc = i.n(Uc)
      , jc = i(150)
      , Vc = i.n(jc)
      , Gc = i(151)
      , Xc = i.n(Gc)
      , Yc = i(153)
      , Wc = i.n(Yc)
      , qc = i(154)
      , Hc = i.n(qc)
      , Qc = {
        locale: "/:market([a-z]{2})/:language([a-z]{2})",
        marketDomainLocale: "/:language([a-z]{2})",
        demoDomainLocale: "/:language([a-z]{2})",
        views: {
            debug: {
                id: "debug",
                expression: "debug",
                module: Vc.a,
                options: {
                    restricted: !0,
                    silent: !0,
                    standalone: !0
                }
            },
            default: {
                id: "intro",
                expression: ".",
                module: Xc.a,
                options: {
                    silent: !1
                }
            },
            choice: {
                id: "choice",
                expression: "choice",
                module: Bc.a,
                options: {
                    silent: !0
                }
            },
            seed: {
                id: "seed",
                expression: "seed/:id(amandier|cedrat|cerisier|immortelle|karite|lavande|rose|verveine)",
                sampleExpression: "seed/cedrat",
                module: Wc.a,
                options: {
                    silent: !0
                }
            },
            game: {
                id: "game",
                expression: "game/:id(bucket|caterpillars|spiders)",
                sampleExpression: "game/bucket",
                module: Hc.a,
                options: {
                    silent: !0
                }
            },
            confirmation: {
                id: "confirmation",
                expression: "confirmation/:type(optin|optout)",
                sampleExpression: "confirmation/optin",
                module: Dc.a,
                options: {
                    silent: !1,
                    standalone: !0
                }
            }
        }
    }
      , Jc = i(156)
      , Zc = i.n(Jc);
    window.loadVendors();
    new class extends yc {
        constructor({routes: e, styles: t}) {
            super(e, t),
            function() {
                const e = ee.a.resourcesColors.current
                  , t = n.a.colors.current;
                ["sun", "love", "water", "game"].forEach(i => {
                    e[i].normal.set(t[i]),
                    e[i].light.set(t[i + "Light"])
                }
                )
            }(),
            g.init(),
            v.a.init({
                breakpoints: n.a.breakpoints.current
            }),
            U.init(),
            B.a.init(),
            j.a.init(),
            V.a.init(),
            Q.init(),
            ve.a.init(),
            oc.hydratePreloader(),
            this.files = [],
            zc.init({
                parent: document.querySelector('[ref="canvas"]')
            })
        }
        start() {
            this.newPlayerId = Ds.a.checkLoginUrl(),
            this.verveineUnlocked = j.a.checkUnlockableSeedUrl();
            let e = xe.a._check(window.location.pathname);
            e.match || (window.history.replaceState({}, "", xe.a.url("default") + window.location.search),
            e = xe.a._check(window.location.pathname)),
            this.isStandalone = !!e.route.options.standalone,
            this.isStandalone ? super.start() : (this.files = [...this.files, {
                path: "packs/app.pack"
            }, {
                path: "packs/spritesheets.data.pack"
            }, {
                path: "packs/seeds.data.pack"
            }, {
                path: St.a.replacePath("packs/spritesheets.tex.pack")
            }, {
                path: St.a.replacePath("packs/seeds.tex.pack")
            }],
            Promise.resolve().then( () => B.a.load(this.newPlayerId, this.verveineUnlocked)).then( () => j.a.ready()).then( () => this.selectFirstRoute(e)).then( () => super.start()))
        }
        selectFirstRoute(e) {
            be.a.bypassRouteRestriction.current && "seed" === e.route.id && te.a.currentSeed.set(te.a.getSeedById(e.params.id) || te.a.getSeedById("amandier"));
            const t = te.a.getSeedById("verveine");
            if ((this.verveineUnlocked || this.newPlayerId && t.unlocked.current && 0 === t.level.current) && te.a.currentSeed.set(t),
            te.a.currentSeed.set(te.a.currentSeed.get(), !0),
            !be.a.bypassRouteRestriction.current) {
                window.history.replaceState({}, "", xe.a.url("default") + window.location.search);
                const e = te.a.starterChosen.current
                  , t = te.a.getCurrent().id.current;
                e ? xe.a.navigateById("seed", {
                    id: t
                }) : xe.a.navigateById("default")
            }
        }
        beforeLoad() {
            var e;
            if (!this.isStandalone)
                return Promise.all([this.prefetchRoutes(), (e = [{
                    name: "Nickainley",
                    weight: 400
                }, {
                    name: "EB Garamond",
                    weight: 400
                }, {
                    name: "EB Garamond",
                    weight: 500
                }],
                new Promise(t => {
                    let i = 0;
                    for (let n = 0; n < e.length; n++) {
                        const r = e[n];
                        new cc.a(r.name,{
                            weight: r.weight
                        }).load().then( () => {
                            ++i == e.length && t()
                        }
                        ).catch( () => t())
                    }
                }
                ))])
        }
        loadSpine(e, t) {
            const i = e.shift();
            if (!i)
                return t();
            Gi.a.loadFromPack(i),
            window.setTimeout( () => this.loadSpine(e, t), 10)
        }
        afterLoad() {
            if (this.isStandalone)
                return;
            const e = [];
            e.push({
                pack: "seeds.data.pack",
                name: "bag"
            });
            for (const t in te.a.seeds.current)
                for (let i = 1; i < 5; i++)
                    e.push({
                        pack: "seeds.data.pack",
                        name: t + "_lvl" + i
                    });
            return new Promise(t => {
                this.loadSpine(e, t)
            }
            )
        }
        prefetchRoutes() {
            return Promise.all(["default", "choice", "seed", "game"].map(e => new Promise(t => {
                Qc.views[e].module(t)
            }
            )))
        }
        ready() {
            super.ready(),
            Promise.resolve().then( () => !this.isStandalone && zc.appLoaded()).then( () => !this.isStandalone && zc.prerender()).then( () => ve.a.load()).then( () => n.a.appReady.set(!0)).then( () => v.a.update(!0)).then( () => oc.ensurePreloaderComplete()).then( () => !this.isStandalone && B.a.startUpdateTimer()).then( () => !this.isStandalone && zc.appReady()).then( () => !this.isStandalone && oc.mountComponents(this.nodes)).then( () => zc.removeCircle()).then( () => oc.exitPreloader()).then( () => oc.disconnectMessage()).then( () => oc.socialErrorMessage()).catch(e => void 0)
        }
    }
    ({
        routes: Qc,
        styles: Zc.a
    }).start()
}
, function(e, t, i) {
    "use strict";
    var n = i(5)
      , r = i(20)
      , s = i(27)
      , a = i(62);
    const o = {
        low: 0,
        medium: 1,
        high: 2,
        ultra: 3
    }
      , l = {
        ultra: {
            canvasPixelRatios: [2, 2.5]
        },
        high: {
            canvasPixelRatios: [2, 2]
        },
        medium: {
            canvasPixelRatios: [1.3, 1.8]
        },
        low: {
            canvasPixelRatios: [1, 1.5]
        }
    };
    function c() {
        const e = r.a.screenPixelRatio.current
          , t = s.a.canvasSize.current
          , i = Math.max(.75 * e, 1)
          , a = 1000500 / (.9 * (t[0] * t[1] * i))
          , o = s.a.canvasPixelRatios.current[0]
          , l = s.a.canvasPixelRatios.current[1]
          , c = Object(n.clamp)(l * a, o, l);
        s.a.canvasPixelRatio.set(Math.max(1.15, Math.min(e, c)))
    }
    t.a = {
        init: function() {
            const e = r.a.device.current
              , t = a.a.forceQuality.current || e.gpu.quality
              , i = l[t] || l.low;
            for (const e in i)
                s.a[e].set(i[e]);
            if ("android" === e.os && "high" === t && (s.a.canvasPixelRatios.set([1.1, 1.4]),
            e.gpu.series["mali t"] && s.a.canvasPixelRatios.set([1.1, 1.3])),
            "ios" === e.os) {
                const e = Math.max(screen.width, screen.height) < 570;
                "high" === t && e && s.a.canvasPixelRatios.set([1.2, 1.4])
            }
            s.a.canvasSize.subscribe(c),
            r.a.screenPixelRatio.subscribe(c),
            c(),
            s.a.quality.set(t)
        },
        greater: e => o[s.a.quality.current] > o[e],
        greaterEqual: e => o[s.a.quality.current] >= o[e],
        less: e => o[s.a.quality.current] < o[e],
        lessEqual: e => o[s.a.quality.current] <= o[e],
        is: e => o[s.a.quality.current] === o[e]
    }
}
, , , , , , , , , function(e, t, i) {
    "use strict";
    var n = i(12)
      , r = i(34)
      , s = i(157)
      , a = i(50)
      , o = i(19)
      , l = i(13)
      , c = i(61);
    let h = 0
      , u = 0;
    function p() {
        const e = Object(o.a)();
        a.a.update(e),
        s.a.update(e)
    }
    function d(e) {
        (u -= e) < 0 && (p(),
        u = h - Math.abs(u) % h),
        r.a.dateFloat.set(Object(o.a)(!0)),
        r.a.date.set(Object(o.a)())
    }
    t.a = Object.assign({
        init: function() {
            c.a.loadRules()
        },
        load: function(e, t) {
            return new Promise(i => {
                l.a.load(e, t).then(p).then(i)
            }
            )
        },
        startUpdateTimer: function() {
            u = h = r.a.updateDelay.current,
            n.c.add(d)
        },
        update: p
    }, c.a)
}
, function(e, t, i) {
    "use strict";
    var n = i(0)
      , r = i(43)
      , s = i(2)
      , a = i(11)
      , o = i(8)
      , l = i(17)
      , c = i(94)
      , h = i.n(c)
      , u = i(93)
      , p = i(20)
      , d = i(27)
      , f = i(1);
    const m = Object(l.a)("🔈 AUDIO", "black", "#d2e4f1", 1).log
      , g = "audio.pack"
      , v = ".m4a"
      , y = {}
      , b = {}
      , x = {}
      , w = document.createElement("audio");
    w.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
    const _ = {
        volume: 0,
        masterVolume: 1,
        muteVolume: 1
    };
    let T = !1
      , M = null
      , S = !1
      , A = !1
      , P = !1;
    const C = 25
      , L = [];
    function k(e) {
        let t = e ? null : L.pop();
        if (t)
            return t;
        const i = b[U("sprites")];
        return t = new n.c(M).setBuffer(i).setVolume(0).setLoop(!1)
    }
    function E(e) {
        !e || L.length >= C || (e.stop(),
        L.push(e))
    }
    function I() {
        M.volume = _.volume * _.masterVolume * _.muteVolume,
        M.setMasterVolume(M.volume)
    }
    function F(e) {
        e ? (y.fadeinMute.pause(),
        y.fadeoutMute.invalidate().restart()) : (y.fadeoutMute.pause(),
        y.fadeinMute.invalidate().restart())
    }
    function O(e) {
        e ? (y.fadeinOverlay.pause(),
        y.fadeoutOverlay.invalidate().restart()) : (y.fadeoutOverlay.pause(),
        y.fadeinOverlay.invalidate().restart())
    }
    function R(e) {
        _.masterVolume = e ? 1 : 0,
        I()
    }
    function z() {
        if (!P) {
            for (let e = 0; e < C; e++) {
                E(k(!0))
            }
            m("Start playing"),
            y.fadein.invalidate().play();
            for (const e in x) {
                const t = x[e];
                if (!t.pending)
                    return;
                D(t.path, t.sample, t.options)
            }
            P = !0
        }
    }
    function N() {
        if (A)
            return;
        A = !0,
        m("Unlock");
        const e = M.context.createBuffer(1, 1, 22050);
        M.context.resume();
        const t = M.context.createBufferSource();
        t.buffer = e,
        t.connect(M.context.destination),
        void 0 === t.start ? t.noteOn(0) : t.start(0);
        const i = document.createElement("audio");
        i.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
        try {
            Promise.resolve().then( () => i.play()).catch( () => {}
            )
        } catch (e) {}
        A && T && z(),
        document.removeEventListener("touchstart", N, !0),
        document.removeEventListener("touchend", N, !0),
        document.removeEventListener("click", N, !0)
    }
    function D(e, t, i) {
        const a = A && T
          , o = i.loop
          , l = U(o ? e : "sprites")
          , c = b[l];
        if (o && (x[e] || (x[e] = {
            path: e,
            sample: t,
            options: i
        }),
        a || (x[e].pending = !0),
        x[e].playing))
            return;
        const h = t.files.length;
        if (!a || !c || h < 1)
            return;
        const u = o && x[e].audio ? x[e].audio.getVolume() : 0
          , p = o ? x[e].audio || new n.c(M).setBuffer(c) : k();
        if (p.setVolume(i.volume).setLoop(i.loop).setPlaybackRate(i.playbackRate),
        o) {
            const t = x[e];
            t.fade && t.fade.kill();
            const n = {
                volume: u
            };
            t.fade = r.a.to(n, .7, {
                volume: i.volume,
                ease: s.c.easeInOut,
                onUpdate: () => t.audio && t.audio.setVolume(n.volume)
            })
        }
        if (!o) {
            let e = Math.floor(Math.random() * h);
            void 0 !== p._lastid && p._lastid === e && (e = e < h ? e + 1 : 1),
            p.offset = t.files[e][0],
            p.duration = t.files[e][1],
            p.onEnded = () => E(p)
        }
        if (p.play(),
        m("▶ " + l),
        o) {
            const t = x[e];
            t.pending = !1,
            t.playing = !0,
            t.audio = p
        }
    }
    function U(e) {
        return g + "/" + e + v
    }
    t.a = {
        init: function() {
            if (!S) {
                S = !0,
                M = new n.d,
                _.volume = 0,
                I(),
                y.fadein = r.a.to(_, 4, {
                    paused: !0,
                    volume: 1,
                    ease: s.c.easeInOut,
                    onUpdate: () => I()
                }),
                y.fadeinOverlay = r.a.to(_, 1.2, {
                    paused: !0,
                    volume: 1,
                    ease: a.e.easeOut,
                    onUpdate: () => I()
                }),
                y.fadeoutOverlay = r.a.to(_, 1.2, {
                    paused: !0,
                    volume: .57,
                    ease: a.e.easeOut,
                    onUpdate: () => I()
                }),
                y.fadeinMute = r.a.to(_, 1.2, {
                    paused: !0,
                    muteVolume: 1,
                    ease: a.e.easeOut,
                    onUpdate: () => I()
                }),
                y.fadeoutMute = r.a.to(_, 1.8, {
                    paused: !0,
                    muteVolume: 0,
                    ease: a.e.easeOut,
                    onUpdate: () => I()
                }),
                document.addEventListener("touchstart", N, !0),
                document.addEventListener("touchend", N, !0),
                document.addEventListener("click", N, !0),
                p.a.muteSound.subscribe(F),
                p.a.siteVisible.subscribe(R),
                d.a.overlayVisible.subscribe(O),
                window.addEventListener("blur", () => {
                    p.a.muteSound.current || F(!0)
                }
                ),
                window.addEventListener("focus", () => {
                    p.a.muteSound.current || F(!1)
                }
                );
                try {
                    Promise.resolve().then( () => w.play()).then( () => N()).catch( () => {}
                    )
                } catch (e) {}
            }
        },
        load: function() {
            o.a.fileLoader.load([{
                path: "packs/" + g
            }]).then( () => {
                Object.assign(b, o.a.files.get(g)),
                T = !0,
                A && T && z()
            }
            )
        },
        play: function(e, t={}) {
            if (!S)
                return;
            const i = u[e]
              , n = h.a[e];
            if (!i)
                return;
            const r = {
                volume: void 0 !== t.volume ? t.volume : void 0 !== n.volume ? n.volume : 1,
                playbackRate: void 0 !== t.playbackRate ? t.playbackRate : void 0 !== n.playbackRate ? n.playbackRate : 1,
                loop: void 0 !== t.loop ? t.loop : void 0 !== i.loop && i.loop
            }
              , s = n.randomPitch || t.randomPitch;
            s && (r.playbackRate += f.b.randomFloat(s[0], s[1])),
            D(e, i, r)
        },
        stop: function(e) {
            const t = x[e];
            if (!x[e])
                return;
            if (t.playing = !1,
            !t.audio)
                return;
            t.fade && t.fade.kill();
            const i = {
                volume: t.audio.getVolume()
            };
            t.fade = r.a.to(i, 1, {
                volume: 0,
                ease: s.c.easeInOut,
                onUpdate: () => t.audio && t.audio.setVolume(i.volume),
                onComplete: () => {
                    t.audio && t.audio.stop(),
                    t.audio = null
                }
            })
        }
    }
}
]);
